#############################
# EVIO 6.0 SOFTWARE PACKAGE #
#############################

EVIO stands for EVent Input/Output and contains libraries which read & write
data in it own unique format. It was created by the Data Acquisition (DAQ) group
and is now maintained by the Experimental Physics Software and Computing Infrastructure
(EPSCI) group at Thomas Jefferson National Accelerator Facility (Jefferson Lab).
It was originally used in the online DAQ as part of the CODA software,
but is now being used offline and in other applications as well.

There is a C library as well as an independent C++ library which
is a port from the Java version. There are a few utility programs included.
The Java version is a library with an extensive, user-friendly
interface. There is an additional package containing a GUI for looking at
evio format data at the byte level.

If you only plan to run C/C++ applications you can skip the Java
installation. If you only plan to use Java applications you can
you can skip the C/C++ installation.Evio Installation

All code is contained in the github repository,

        https://github.com/JeffersonLab/evio.git

The evio-6.0 branch contains the most recent version of evio.
Documentation is contained in the repository but may also be accessed at:

        https://coda.jlab.org/drupal/content/event-io-evio/

        
##############################################
# C library
##############################################
The C library is called libevio.
It is a library with limited capabilities. In the past, this was acceptable because the evio
format was fairly simple. However, as its complexity has greatly expanded in this version, the C library will
be of very limited usefullness unless one is knowledgeable about all the intricacies of the format.

To compile it, follow the directions below for the C++ compilation which will include the C as well.
The C++ library is much more extensive in scope.
Having said that, the C library and executables can be compiled without any C++. This can be done in 2 ways:

    scons --C
or

    mkdir build
    cd build
    cmake .. –DC_ONLY=1

    
##############################################
# C++ library
##############################################
The C++ library is called libeviocc.
The current C++ evio library is entirely different from the previous version (5.2) as it has been ported from the Java code.
This was done for a number of reasons. First, a much more comprehensive C++ library was desired than was currently existing.
Second, it needed major, new capabilities such as being able to (un)compress data. Third, it had to use a new format
developed from the merging of Java evio version 4 and the Java HIPO library.
Finally, the author and maintainer of the previous code was no longer working at Jefferson Lab.
The simplest solution was to port the well-tested Java code which avoided having to redesign complex software from scratch.
C++ evio is supported on both the MacOS and Linux platforms. C++ version 11 is used, and gcc version 5 or higher is required.



##########################
Prerequisites:


----- Disruptor ------

    Evio depends upon the Disruptor-cpp software package available from a fork of the original package at github at
    
         https://github.com/JeffersonLab/Disruptor-cpp
         
    In terms of functionality, it is an ingenious, ultrafast ring buffer which was initially developed in Java and then ported to C++.
    It’s extremely useful when splitting work among multiple threads and then recombining it. To build it, do this on the Mac:

        1) git clone https://github.com/JeffersonLab/Disruptor-cpp.git
        2) cd Disruptor-cpp
        3) mkdir build
        4) cd build
        5) cmake .. -DCMAKE_BUILD_TYPE=Release
        6) make
        7) setenv DISRUPTOR_CPP_HOME <../>
        
        If using Jefferson Lab’s Redhat Enterprise 7 do:
        
        1) git clone https://github.com/JeffersonLab/Disruptor-cpp.git
        2) cd Disruptor-cpp
        3) mkdir build
        4) cd build
        5) cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER=/apps/gcc/5.3.0/bin/gcc -DCMAKE_CXX_COMPILER=/apps/gcc/5.3.0/bin/g++
        6) make
        7) setenv DISRUPTOR_CPP_HOME <../>
    
    Note that it requires GCC 5.0 / Clang 3.8 / C++14 or newer and boost.
    Its shared library must be installed where evio can find it.
    If not compiling on Jefferson Lab’s RHEL7, either your default compilers must meet this criteria
    or you must specify the proper ones on the cmake command line.

    
----- Boost -----

    Besides the disruptor library, evio requires the boost libraries: boost_system, boost_thread, and boost_chrono.
   
   
------ Lz4 ------

    Finally, evio depends on the lz4 library for compressing data in the lz4 and gzip formats.
    If it isn’t already available on your machine, it can be obtained from the lz4 repository on github:
        1) git clone https://github.com/lz4/lz4.git
        2) cd lz4
        3) make
        4) make install
        
        
        
##########################
Building:

There are 2 different methods to build the C++ library and executables.
The first uses scons, a Python-based build software package which is available at https://scons.org.
The second uses cmake and make. Also, be sure you’ve set the DISRUPTOR_CPP_HOME environmental variable.


----- Scons -----

    To get a listing of all the local options available to the scons command,
    run scons -h in the top-level directory to get this output:
    
        -D                       build from subdirectory of package
        local scons OPTIONS:
        --C                      compile C code only
        --dbg                    compile with debug flag
        --32bits                 compile 32bit libs & executables on 64bit system
        --prefix=<dir>           use base directory <dir> when doing install
        --incdir=<dir>           copy header files to directory <dir> when doing install
        --libdir=<dir>           copy library files to directory <dir> when doing install
        --bindir=<dir>           copy binary files to directory <dir> when doing install 
        install                  install libs, headers, and binaries
        install -c               uninstall libs, headers, and binaries
        doc                      create doxygen and javadoc (in ./doc)
        undoc                    remove doxygen and javadoc (in ./doc)
        tar                      create tar file (in ./tar)
        
        Use scons -H for help about command-line options.


    Although this is fairly self-explanatory, executing:
    
        1) use gcc/5.3.0 # if on CUE system with Redhat 7
        2) cd <evio dir>
        3) scons install
        
    will compile and install all the code. By default, all libraries, executables and includes are installed
    under the directory given by the CODA env variable. If the command line options
    –prefix, --incdir, --libdir, or –bindir are used, they take priority.

    
    To compile a debug version, execute:
    
        scons install --dbg
   
   
----- Cmake -----

    Evio can also be compiled with cmake using the included CMakeLists.txt file.
    To build the C and C++ libraries and executables on the Mac:
    
        1) cd <evio dir>
        2) mkdir build
        3) cd build
        4) cmake .. –DCMAKE_BUILD_TYPE=Release
        5) make
        
        If on redhat 7 linux this will be:
        
        1) cd <evio dir>
        2) mkdir build
        3) cd build
        4) cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER=/apps/gcc/5.3.0/bin/gcc -DCMAKE_CXX_COMPILER=/apps/gcc/5.3.0/bin/g++
        5) make
        
        
    To build only C code, place –DC_ONLY=1 on the cmake command line.
    In order to compile all the examples as well, place –DMAKE_EXAMPLES=1 on the cmake command line.
    The above commands will place everything in the current “build” directory and will keep generated
    files from mixing with the source and config files.
    
    In addition to a having a copy in the build directory, installing the library, binary and include
    files can be done by calling cmake in 2 ways:
    
        1) cmake .. –DCMAKE_BUILD_TYPE=Release –DCODA_INSTALL=<install dir>
        2) make install
        
        or
        
        1) cmake .. –DCMAKE_BUILD_TYPE=Release
        2) make install
 
    The first option explicitly sets the installation directory. The second option installs in the directory
    given in the CODA environmental variable. If cmake was run previously, remove the CMakeCache.txt file so
    new values are generated and used.
    
    To uninstall simply do:
    
        make uninstall
