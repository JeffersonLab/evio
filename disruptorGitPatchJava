diff --git a/src/main/java/com/lmax/disruptor/MultiProducerSequencer.java b/src/main/java/com/lmax/disruptor/MultiProducerSequencer.java
index a34cdd2..a5356bb 100644
--- a/src/main/java/com/lmax/disruptor/MultiProducerSequencer.java
+++ b/src/main/java/com/lmax/disruptor/MultiProducerSequencer.java
@@ -111,9 +111,9 @@ public final class MultiProducerSequencer extends AbstractSequencer
     @Override
     public long next(int n)
     {
-        if (n < 1)
+        if (n < 1 || n > bufferSize)
         {
-            throw new IllegalArgumentException("n must be > 0");
+            throw new IllegalArgumentException("n must be > 0 and < bufferSize");
         }
 
         long current;
@@ -149,6 +149,55 @@ public final class MultiProducerSequencer extends AbstractSequencer
         return next;
     }
 
+    /**
+     * @see Sequencer#nextIntr(int)
+     * @author Carl Timmer
+     */
+    @Override
+    public long nextIntr(int n) throws InterruptedException
+    {
+        if (n < 1 || n > bufferSize)
+        {
+            throw new IllegalArgumentException("n must be > 0 and < bufferSize");
+        }
+
+        long current;
+        long next;
+
+        do
+        {
+            current = cursor.get();
+            next = current + n;
+
+            long wrapPoint = next - bufferSize;
+            long cachedGatingSequence = gatingSequenceCache.get();
+
+            if (wrapPoint > cachedGatingSequence || cachedGatingSequence > current)
+            {
+                long gatingSequence = Util.getMinimumSequence(gatingSequences, current);
+
+                if (wrapPoint > gatingSequence)
+                {
+                    if (Thread.currentThread().isInterrupted())
+                    {
+                        throw new InterruptedException();
+                    }
+                    LockSupport.parkNanos(1);
+                    continue;
+                }
+
+                gatingSequenceCache.set(gatingSequence);
+            }
+            else if (cursor.compareAndSet(current, next))
+            {
+                break;
+            }
+        }
+        while (true);
+
+        return next;
+    }
+
     /**
      * @see Sequencer#tryNext()
      */
diff --git a/src/main/java/com/lmax/disruptor/RingBuffer.java b/src/main/java/com/lmax/disruptor/RingBuffer.java
index e9df321..6d4a2ff 100644
--- a/src/main/java/com/lmax/disruptor/RingBuffer.java
+++ b/src/main/java/com/lmax/disruptor/RingBuffer.java
@@ -50,7 +50,7 @@ abstract class RingBufferFields<E> extends RingBufferPad
         }
         BUFFER_PAD = 128 / scale;
         // Including the buffer pad in the array base offset
-        REF_ARRAY_BASE = UNSAFE.arrayBaseOffset(Object[].class) + (BUFFER_PAD << REF_ELEMENT_SHIFT);
+        REF_ARRAY_BASE = UNSAFE.arrayBaseOffset(Object[].class) + 128;
     }
 
     private final long indexMask;
@@ -137,7 +137,7 @@ public final class RingBuffer<E> extends RingBufferFields<E> implements Cursored
     {
         MultiProducerSequencer sequencer = new MultiProducerSequencer(bufferSize, waitStrategy);
 
-        return new RingBuffer<E>(factory, sequencer);
+        return new RingBuffer<>(factory, sequencer);
     }
 
     /**
@@ -147,7 +147,7 @@ public final class RingBuffer<E> extends RingBufferFields<E> implements Cursored
      * @param factory    used to create the events within the ring buffer.
      * @param bufferSize number of elements to create within the ring buffer.
      * @return a constructed ring buffer.
-     * @throws IllegalArgumentException if <tt>bufferSize</tt> is less than 1 or not a power of 2
+     * @throws IllegalArgumentException if <code>bufferSize</code> is less than 1 or not a power of 2
      * @see MultiProducerSequencer
      */
     public static <E> RingBuffer<E> createMultiProducer(EventFactory<E> factory, int bufferSize)
@@ -173,7 +173,7 @@ public final class RingBuffer<E> extends RingBufferFields<E> implements Cursored
     {
         SingleProducerSequencer sequencer = new SingleProducerSequencer(bufferSize, waitStrategy);
 
-        return new RingBuffer<E>(factory, sequencer);
+        return new RingBuffer<>(factory, sequencer);
     }
 
     /**
@@ -183,7 +183,7 @@ public final class RingBuffer<E> extends RingBufferFields<E> implements Cursored
      * @param factory    used to create the events within the ring buffer.
      * @param bufferSize number of elements to create within the ring buffer.
      * @return a constructed ring buffer.
-     * @throws IllegalArgumentException if <tt>bufferSize</tt> is less than 1 or not a power of 2
+     * @throws IllegalArgumentException if <code>bufferSize</code> is less than 1 or not a power of 2
      * @see MultiProducerSequencer
      */
     public static <E> RingBuffer<E> createSingleProducer(EventFactory<E> factory, int bufferSize)
@@ -277,6 +277,23 @@ public final class RingBuffer<E> extends RingBufferFields<E> implements Cursored
         return sequencer.next(n);
     }
 
+    /**
+     * The same functionality as {@link RingBuffer#next(int)}.
+     * This method throws an InterruptedException if the thread
+     * which calls it is interrupted.
+     *
+     * @author Carl Timmer
+     * @see Sequencer#next(int)
+     * @param n number of slots to claim
+     * @return sequence number of the highest slot claimed
+     * @throws InterruptedException if thread is interrupted
+     */
+    @Override
+    public long nextIntr(int n) throws InterruptedException
+    {
+        return sequencer.nextIntr(n);
+    }
+
     /**
      * <p>Increment and return the next sequence for the ring buffer.  Calls of this
      * method should ensure that they always publish the sequence afterward.  E.g.</p>
@@ -388,7 +405,7 @@ public final class RingBuffer<E> extends RingBufferFields<E> implements Cursored
      * Remove the specified sequence from this ringBuffer.
      *
      * @param sequence to be removed.
-     * @return <tt>true</tt> if this sequence was found, <tt>false</tt> otherwise.
+     * @return <code>true</code> if this sequence was found, <code>false</code> otherwise.
      */
     public boolean removeGatingSequence(Sequence sequence)
     {
@@ -441,14 +458,14 @@ public final class RingBuffer<E> extends RingBufferFields<E> implements Cursored
     }
 
     /**
-     * Given specified <tt>requiredCapacity</tt> determines if that amount of space
-     * is available.  Note, you can not assume that if this method returns <tt>true</tt>
+     * Given specified <code>requiredCapacity</code> determines if that amount of space
+     * is available.  Note, you can not assume that if this method returns <code>true</code>
      * that a call to {@link RingBuffer#next()} will not block.  Especially true if this
      * ring buffer is set up to handle multiple producers.
      *
      * @param requiredCapacity The capacity to check for.
-     * @return <tt>true</tt> If the specified <tt>requiredCapacity</tt> is available
-     * <tt>false</tt> if not.
+     * @return <code>true</code> If the specified <code>requiredCapacity</code> is available
+     * <code>false</code> if not.
      */
     public boolean hasAvailableCapacity(int requiredCapacity)
     {
diff --git a/src/main/java/com/lmax/disruptor/Sequenced.java b/src/main/java/com/lmax/disruptor/Sequenced.java
index 3c8ba69..89e4770 100644
--- a/src/main/java/com/lmax/disruptor/Sequenced.java
+++ b/src/main/java/com/lmax/disruptor/Sequenced.java
@@ -50,6 +50,18 @@ public interface Sequenced
      */
     long next(int n);
 
+    /**
+     * Claim the next n events in sequence for publishing.
+     * This method is interruptible and will throw an
+     * InterruptedException if it is.
+     *
+     * @author Carl Timmer
+     * @param n the number of sequences to claim
+     * @return the highest claimed sequence value
+     * @throws InterruptedException if interrupted
+     */
+    long nextIntr(int n) throws InterruptedException;
+
     /**
      * Attempt to claim the next event in sequence for publishing.  Will return the
      * number of the slot if there is at least <code>requiredCapacity</code> slots
diff --git a/src/main/java/com/lmax/disruptor/SingleProducerSequencer.java b/src/main/java/com/lmax/disruptor/SingleProducerSequencer.java
index 32e1942..678388a 100644
--- a/src/main/java/com/lmax/disruptor/SingleProducerSequencer.java
+++ b/src/main/java/com/lmax/disruptor/SingleProducerSequencer.java
@@ -116,9 +116,9 @@ public final class SingleProducerSequencer extends SingleProducerSequencerFields
     @Override
     public long next(int n)
     {
-        if (n < 1)
+        if (n < 1 || n > bufferSize)
         {
-            throw new IllegalArgumentException("n must be > 0");
+            throw new IllegalArgumentException("n must be > 0 and < bufferSize");
         }
 
         long nextValue = this.nextValue;
@@ -145,6 +145,44 @@ public final class SingleProducerSequencer extends SingleProducerSequencerFields
         return nextSequence;
     }
 
+    /**
+     * @see Sequencer#nextIntr(int)
+     * @author Carl Timmer
+     */
+    @Override
+    public long nextIntr(int n) throws InterruptedException
+    {
+        if (n < 1 || n > bufferSize)
+        {
+            throw new IllegalArgumentException("n must be > 0 and < bufferSize");
+        }
+
+        long nextValue = this.nextValue;
+
+        long nextSequence = nextValue + n;
+        long wrapPoint = nextSequence - bufferSize;
+        long cachedGatingSequence = this.cachedValue;
+
+        if (wrapPoint > cachedGatingSequence || cachedGatingSequence > nextValue)
+        {
+            long minSequence;
+            while (wrapPoint > (minSequence = Util.getMinimumSequence(gatingSequences, nextValue)))
+            {
+                if (Thread.currentThread().isInterrupted())
+                {
+                    throw new InterruptedException();
+                }
+                LockSupport.parkNanos(1L);
+            }
+
+            this.cachedValue = minSequence;
+        }
+
+        this.nextValue = nextSequence;
+
+        return nextSequence;
+    }
+
     /**
      * @see Sequencer#tryNext()
      */
diff --git a/src/main/java/com/lmax/disruptor/YieldingWaitStrategy.java b/src/main/java/com/lmax/disruptor/YieldingWaitStrategy.java
index ba357ac..f8c4546 100644
--- a/src/main/java/com/lmax/disruptor/YieldingWaitStrategy.java
+++ b/src/main/java/com/lmax/disruptor/YieldingWaitStrategy.java
@@ -49,13 +49,18 @@ public final class YieldingWaitStrategy implements WaitStrategy
     }
 
     private int applyWaitMethod(final SequenceBarrier barrier, int counter)
-        throws AlertException
+        throws AlertException, InterruptedException // InterruptedException added by Carl Timmer
     {
         barrier.checkAlert();
 
         if (0 == counter)
         {
             Thread.yield();
+            // Next 3 lines added by Carl Timmer to make it interruptible
+            if (Thread.interrupted())
+            {
+                throw new InterruptedException();
+            }
         }
         else
         {
diff --git a/src/perftest/java/com/lmax/disruptor/AbstractPerfTestDisruptor.java b/src/perftest/java/com/lmax/disruptor/AbstractPerfTestDisruptor.java
deleted file mode 100644
index 7b71ab6..0000000
--- a/src/perftest/java/com/lmax/disruptor/AbstractPerfTestDisruptor.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor;
-
-
-public abstract class AbstractPerfTestDisruptor
-{
-    public static final int RUNS = 7;
-
-    protected void testImplementations()
-        throws Exception
-    {
-        final int availableProcessors = Runtime.getRuntime().availableProcessors();
-        if (getRequiredProcessorCount() > availableProcessors)
-        {
-            System.out.print("*** Warning ***: your system has insufficient processors to execute the test efficiently. ");
-            System.out.println("Processors required = " + getRequiredProcessorCount() + " available = " + availableProcessors);
-        }
-
-        long[] disruptorOps = new long[RUNS];
-
-        System.out.println("Starting Disruptor tests");
-        for (int i = 0; i < RUNS; i++)
-        {
-            System.gc();
-            disruptorOps[i] = runDisruptorPass();
-            System.out.format("Run %d, Disruptor=%,d ops/sec%n", i, Long.valueOf(disruptorOps[i]));
-        }
-    }
-
-    public static void printResults(final String className, final long[] disruptorOps, final long[] queueOps)
-    {
-        for (int i = 0; i < RUNS; i++)
-        {
-            System.out.format("%s run %d: BlockingQueue=%,d Disruptor=%,d ops/sec\n",
-                              className, Integer.valueOf(i), Long.valueOf(queueOps[i]), Long.valueOf(disruptorOps[i]));
-        }
-    }
-
-    protected abstract int getRequiredProcessorCount();
-
-    protected abstract long runDisruptorPass() throws Exception;
-}
diff --git a/src/perftest/java/com/lmax/disruptor/AbstractPerfTestQueue.java b/src/perftest/java/com/lmax/disruptor/AbstractPerfTestQueue.java
deleted file mode 100644
index 1d16661..0000000
--- a/src/perftest/java/com/lmax/disruptor/AbstractPerfTestQueue.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor;
-
-
-public abstract class AbstractPerfTestQueue
-{
-    public static final int RUNS = 7;
-
-    protected void testImplementations()
-        throws Exception
-    {
-        final int availableProcessors = Runtime.getRuntime().availableProcessors();
-        if (getRequiredProcessorCount() > availableProcessors)
-        {
-            System.out.print(
-                "*** Warning ***: your system has insufficient processors to execute the test efficiently. ");
-            System.out.println(
-                "Processors required = " + getRequiredProcessorCount() + " available = " + availableProcessors);
-        }
-
-        long[] queueOps = new long[RUNS];
-
-        System.out.println("Starting Queue tests");
-        for (int i = 0; i < RUNS; i++)
-        {
-            System.gc();
-            queueOps[i] = runQueuePass();
-            System.out.format("Run %d, BlockingQueue=%,d ops/sec%n", i, Long.valueOf(queueOps[i]));
-        }
-    }
-
-    public static void printResults(final String className, final long[] disruptorOps, final long[] queueOps)
-    {
-        for (int i = 0; i < RUNS; i++)
-        {
-            System.out.format(
-                "%s run %d: BlockingQueue=%,d Disruptor=%,d ops/sec\n",
-                className, Integer.valueOf(i), Long.valueOf(queueOps[i]), Long.valueOf(disruptorOps[i]));
-        }
-    }
-
-    protected abstract int getRequiredProcessorCount();
-
-    protected abstract long runQueuePass() throws Exception;
-}
diff --git a/src/perftest/java/com/lmax/disruptor/immutable/Constants.java b/src/perftest/java/com/lmax/disruptor/immutable/Constants.java
deleted file mode 100644
index 7c55258..0000000
--- a/src/perftest/java/com/lmax/disruptor/immutable/Constants.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package com.lmax.disruptor.immutable;
-
-public class Constants
-{
-    public static final long ITERATIONS = 1000 * 1000 * 100L;
-    public static final int SIZE = 1 << 20;
-}
diff --git a/src/perftest/java/com/lmax/disruptor/immutable/CustomPerformanceTest.java b/src/perftest/java/com/lmax/disruptor/immutable/CustomPerformanceTest.java
deleted file mode 100644
index fc1a9b8..0000000
--- a/src/perftest/java/com/lmax/disruptor/immutable/CustomPerformanceTest.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package com.lmax.disruptor.immutable;
-
-import java.util.concurrent.locks.LockSupport;
-
-import com.lmax.disruptor.BatchEventProcessor;
-import com.lmax.disruptor.SingleProducerSequencer;
-import com.lmax.disruptor.YieldingWaitStrategy;
-
-public class CustomPerformanceTest
-{
-    private final CustomRingBuffer<SimpleEvent> ringBuffer;
-
-    public CustomPerformanceTest()
-    {
-        ringBuffer =
-            new CustomRingBuffer<SimpleEvent>(new SingleProducerSequencer(Constants.SIZE, new YieldingWaitStrategy()));
-    }
-
-    public void run()
-    {
-        try
-        {
-            doRun();
-        }
-        catch (InterruptedException e)
-        {
-            e.printStackTrace();
-        }
-    }
-
-    private void doRun() throws InterruptedException
-    {
-        BatchEventProcessor<?> batchEventProcessor = ringBuffer.createHandler(new SimpleEventHandler());
-
-        Thread t = new Thread(batchEventProcessor);
-        t.start();
-
-        long iterations = Constants.ITERATIONS;
-        for (long l = 0; l < iterations; l++)
-        {
-            SimpleEvent e = new SimpleEvent(l, l, l, l);
-            ringBuffer.put(e);
-        }
-
-        while (batchEventProcessor.getSequence().get() != iterations - 1)
-        {
-            LockSupport.parkNanos(1);
-        }
-
-        batchEventProcessor.halt();
-        t.join();
-    }
-
-    public static void main(String[] args)
-    {
-        new CustomPerformanceTest().run();
-    }
-
-}
diff --git a/src/perftest/java/com/lmax/disruptor/immutable/CustomRingBuffer.java b/src/perftest/java/com/lmax/disruptor/immutable/CustomRingBuffer.java
deleted file mode 100644
index c575f82..0000000
--- a/src/perftest/java/com/lmax/disruptor/immutable/CustomRingBuffer.java
+++ /dev/null
@@ -1,99 +0,0 @@
-package com.lmax.disruptor.immutable;
-
-import com.lmax.disruptor.BatchEventProcessor;
-import com.lmax.disruptor.DataProvider;
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.LifecycleAware;
-import com.lmax.disruptor.Sequencer;
-
-public class CustomRingBuffer<T> implements DataProvider<EventAccessor<T>>, EventAccessor<T>
-{
-    private static final class AccessorEventHandler<T> implements EventHandler<EventAccessor<T>>, LifecycleAware
-    {
-        private final EventHandler<T> handler;
-        private final LifecycleAware lifecycle;
-
-        private AccessorEventHandler(EventHandler<T> handler)
-        {
-            this.handler = handler;
-            lifecycle = handler instanceof LifecycleAware ? (LifecycleAware) handler : null;
-        }
-
-        @Override
-        public void onEvent(EventAccessor<T> accessor, long sequence, boolean endOfBatch) throws Exception
-        {
-            this.handler.onEvent(accessor.take(sequence), sequence, endOfBatch);
-        }
-
-        @Override
-        public void onShutdown()
-        {
-            if (null != lifecycle)
-            {
-                lifecycle.onShutdown();
-            }
-        }
-
-        @Override
-        public void onStart()
-        {
-            if (null != lifecycle)
-            {
-                lifecycle.onStart();
-            }
-        }
-    }
-
-    private final Sequencer sequencer;
-    private final Object[] buffer;
-    private final int mask;
-
-    public CustomRingBuffer(Sequencer sequencer)
-    {
-        this.sequencer = sequencer;
-        buffer = new Object[sequencer.getBufferSize()];
-        mask = sequencer.getBufferSize() - 1;
-    }
-
-    private int index(long sequence)
-    {
-        return (int) sequence & mask;
-    }
-
-    public void put(T e)
-    {
-        long next = sequencer.next();
-        buffer[index(next)] = e;
-        sequencer.publish(next);
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public T take(long sequence)
-    {
-        int index = index(sequence);
-
-        T t = (T) buffer[index];
-        buffer[index] = null;
-
-        return t;
-    }
-
-    @Override
-    public EventAccessor<T> get(long sequence)
-    {
-        return this;
-    }
-
-    public BatchEventProcessor<EventAccessor<T>> createHandler(final EventHandler<T> handler)
-    {
-        BatchEventProcessor<EventAccessor<T>> processor =
-            new BatchEventProcessor<EventAccessor<T>>(
-                this,
-                sequencer.newBarrier(),
-                new AccessorEventHandler<T>(handler));
-        sequencer.addGatingSequences(processor.getSequence());
-
-        return processor;
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/immutable/EventAccessor.java b/src/perftest/java/com/lmax/disruptor/immutable/EventAccessor.java
deleted file mode 100644
index 2f0fe86..0000000
--- a/src/perftest/java/com/lmax/disruptor/immutable/EventAccessor.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package com.lmax.disruptor.immutable;
-
-public interface EventAccessor<T>
-{
-    T take(long sequence);
-}
diff --git a/src/perftest/java/com/lmax/disruptor/immutable/EventHolder.java b/src/perftest/java/com/lmax/disruptor/immutable/EventHolder.java
deleted file mode 100644
index 515310b..0000000
--- a/src/perftest/java/com/lmax/disruptor/immutable/EventHolder.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package com.lmax.disruptor.immutable;
-
-import com.lmax.disruptor.EventFactory;
-
-public class EventHolder
-{
-
-    public static final EventFactory<EventHolder> FACTORY = new EventFactory<EventHolder>()
-    {
-        @Override
-        public EventHolder newInstance()
-        {
-            return new EventHolder();
-        }
-    };
-
-    public SimpleEvent event;
-}
diff --git a/src/perftest/java/com/lmax/disruptor/immutable/EventHolderHandler.java b/src/perftest/java/com/lmax/disruptor/immutable/EventHolderHandler.java
deleted file mode 100644
index f597187..0000000
--- a/src/perftest/java/com/lmax/disruptor/immutable/EventHolderHandler.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package com.lmax.disruptor.immutable;
-
-import com.lmax.disruptor.EventHandler;
-
-public class EventHolderHandler implements EventHandler<EventHolder>
-{
-    private final EventHandler<SimpleEvent> delegate;
-
-    public EventHolderHandler(EventHandler<SimpleEvent> delegate)
-    {
-        this.delegate = delegate;
-    }
-
-    @Override
-    public void onEvent(EventHolder holder, long sequence, boolean endOfBatch) throws Exception
-    {
-        delegate.onEvent(holder.event, sequence, endOfBatch);
-        holder.event = null;
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/immutable/SimpleEvent.java b/src/perftest/java/com/lmax/disruptor/immutable/SimpleEvent.java
deleted file mode 100644
index 2614c24..0000000
--- a/src/perftest/java/com/lmax/disruptor/immutable/SimpleEvent.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package com.lmax.disruptor.immutable;
-
-public class SimpleEvent
-{
-    private final long id;
-    private final long v1;
-    private final long v2;
-    private final long v3;
-
-    public SimpleEvent(long id, long v1, long v2, long v3)
-    {
-        this.id = id;
-        this.v1 = v1;
-        this.v2 = v2;
-        this.v3 = v3;
-    }
-
-    public long getCounter()
-    {
-        return v1;
-    }
-
-    @Override
-    public String toString()
-    {
-        return "SimpleEvent [id=" + id + ", v1=" + v1 + ", v2=" + v2 + ", v3=" + v3 + "]";
-    }
-}
\ No newline at end of file
diff --git a/src/perftest/java/com/lmax/disruptor/immutable/SimpleEventHandler.java b/src/perftest/java/com/lmax/disruptor/immutable/SimpleEventHandler.java
deleted file mode 100644
index cc4560f..0000000
--- a/src/perftest/java/com/lmax/disruptor/immutable/SimpleEventHandler.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package com.lmax.disruptor.immutable;
-
-import com.lmax.disruptor.EventHandler;
-
-public class SimpleEventHandler implements EventHandler<SimpleEvent>
-{
-    public long counter;
-
-    @Override
-    public void onEvent(SimpleEvent arg0, long arg1, boolean arg2) throws Exception
-    {
-        counter += arg0.getCounter();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/immutable/SimplePerformanceTest.java b/src/perftest/java/com/lmax/disruptor/immutable/SimplePerformanceTest.java
deleted file mode 100644
index 074578a..0000000
--- a/src/perftest/java/com/lmax/disruptor/immutable/SimplePerformanceTest.java
+++ /dev/null
@@ -1,75 +0,0 @@
-package com.lmax.disruptor.immutable;
-
-import java.util.concurrent.locks.LockSupport;
-
-import com.lmax.disruptor.BatchEventProcessor;
-import com.lmax.disruptor.EventTranslatorOneArg;
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.YieldingWaitStrategy;
-
-public class SimplePerformanceTest
-{
-    private final RingBuffer<EventHolder> ringBuffer;
-    private final EventHolderHandler eventHolderHandler;
-
-    public SimplePerformanceTest()
-    {
-        ringBuffer = RingBuffer.createSingleProducer(EventHolder.FACTORY, Constants.SIZE, new YieldingWaitStrategy());
-        eventHolderHandler = new EventHolderHandler(new SimpleEventHandler());
-    }
-
-    public void run()
-    {
-        try
-        {
-            doRun();
-        }
-        catch (InterruptedException e)
-        {
-            e.printStackTrace();
-        }
-    }
-
-    private void doRun() throws InterruptedException
-    {
-        BatchEventProcessor<EventHolder> batchEventProcessor =
-            new BatchEventProcessor<EventHolder>(
-                ringBuffer,
-                ringBuffer.newBarrier(),
-                eventHolderHandler);
-        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());
-
-        Thread t = new Thread(batchEventProcessor);
-        t.start();
-
-        long iterations = Constants.ITERATIONS;
-        for (long l = 0; l < iterations; l++)
-        {
-            SimpleEvent e = new SimpleEvent(l, l, l, l);
-            ringBuffer.publishEvent(TRANSLATOR, e);
-        }
-
-        while (batchEventProcessor.getSequence().get() != iterations - 1)
-        {
-            LockSupport.parkNanos(1);
-        }
-
-        batchEventProcessor.halt();
-        t.join();
-    }
-
-    private static final EventTranslatorOneArg<EventHolder, SimpleEvent> TRANSLATOR =
-        new EventTranslatorOneArg<EventHolder, SimpleEvent>()
-        {
-            @Override
-            public void translateTo(EventHolder holder, long arg1, SimpleEvent event)
-            {
-                holder.event = event;
-            }
-        };
-
-    public static void main(String[] args)
-    {
-        new SimplePerformanceTest().run();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/offheap/OneToOneOffHeapThroughputTest.java b/src/perftest/java/com/lmax/disruptor/offheap/OneToOneOffHeapThroughputTest.java
deleted file mode 100644
index 0368eae..0000000
--- a/src/perftest/java/com/lmax/disruptor/offheap/OneToOneOffHeapThroughputTest.java
+++ /dev/null
@@ -1,183 +0,0 @@
-package com.lmax.disruptor.offheap;
-
-import com.lmax.disruptor.*;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.util.Random;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-import java.util.concurrent.locks.LockSupport;
-
-public class OneToOneOffHeapThroughputTest extends AbstractPerfTestDisruptor
-{
-    private static final int BLOCK_SIZE = 256;
-    private static final int BUFFER_SIZE = 1024 * 1024;
-    private static final long ITERATIONS = 1000 * 1000 * 10L;
-
-    private final Executor executor = Executors.newFixedThreadPool(1, DaemonThreadFactory.INSTANCE);
-    private final WaitStrategy waitStrategy = new YieldingWaitStrategy();
-    private final OffHeapRingBuffer buffer =
-        new OffHeapRingBuffer(new SingleProducerSequencer(BUFFER_SIZE, waitStrategy), BLOCK_SIZE);
-    private final ByteBufferHandler handler = new ByteBufferHandler();
-    private final BatchEventProcessor<ByteBuffer> processor =
-        new BatchEventProcessor<ByteBuffer>(buffer, buffer.newBarrier(), handler);
-
-    {
-        buffer.addGatingSequences(processor.getSequence());
-    }
-
-    private final Random r = new Random(1);
-    private final byte[] data = new byte[BLOCK_SIZE];
-
-    public OneToOneOffHeapThroughputTest()
-    {
-        r.nextBytes(data);
-    }
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 2;
-    }
-
-    @Override
-    protected long runDisruptorPass() throws Exception
-    {
-        byte[] data = this.data;
-
-        final CountDownLatch latch = new CountDownLatch(1);
-        long expectedCount = processor.getSequence().get() + ITERATIONS;
-        handler.reset(latch, ITERATIONS);
-        executor.execute(processor);
-        long start = System.currentTimeMillis();
-
-        final OffHeapRingBuffer rb = buffer;
-
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            rb.put(data);
-        }
-
-        latch.await();
-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-        waitForEventProcessorSequence(expectedCount);
-        processor.halt();
-
-        return opsPerSecond;
-    }
-
-    private void waitForEventProcessorSequence(long expectedCount)
-    {
-        while (processor.getSequence().get() < expectedCount)
-        {
-            LockSupport.parkNanos(1);
-        }
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        new OneToOneOffHeapThroughputTest().testImplementations();
-    }
-
-    public static class ByteBufferHandler implements EventHandler<ByteBuffer>
-    {
-        private long total = 0;
-        private long expectedCount;
-        private CountDownLatch latch;
-
-        @Override
-        public void onEvent(ByteBuffer event, long sequence, boolean endOfBatch) throws Exception
-        {
-            final int start = event.position();
-            for (int i = start, size = start + BLOCK_SIZE; i < size; i += 8)
-            {
-                total += event.getLong(i);
-            }
-
-            if (--expectedCount == 0)
-            {
-                latch.countDown();
-            }
-        }
-
-        public long getTotal()
-        {
-            return total;
-        }
-
-        public void reset(CountDownLatch latch, long expectedCount)
-        {
-            this.latch = latch;
-            this.expectedCount = expectedCount;
-        }
-    }
-
-    public static class OffHeapRingBuffer implements DataProvider<ByteBuffer>
-    {
-        private final Sequencer sequencer;
-        private final int entrySize;
-        private final ByteBuffer buffer;
-        private final int mask;
-
-        private final ThreadLocal<ByteBuffer> perThreadBuffer = new ThreadLocal<ByteBuffer>()
-        {
-            @Override
-            protected ByteBuffer initialValue()
-            {
-                return buffer.duplicate().order(ByteOrder.nativeOrder());
-            }
-        };
-
-        public OffHeapRingBuffer(Sequencer sequencer, int entrySize)
-        {
-            this.sequencer = sequencer;
-            this.entrySize = entrySize;
-            this.mask = sequencer.getBufferSize() - 1;
-            buffer = ByteBuffer.allocateDirect(sequencer.getBufferSize() * entrySize).order(ByteOrder.nativeOrder());
-        }
-
-        public void addGatingSequences(Sequence sequence)
-        {
-            sequencer.addGatingSequences(sequence);
-        }
-
-        public SequenceBarrier newBarrier()
-        {
-            return sequencer.newBarrier();
-        }
-
-        @Override
-        public ByteBuffer get(long sequence)
-        {
-            int index = index(sequence);
-            int position = index * entrySize;
-            int limit = position + entrySize;
-
-            ByteBuffer byteBuffer = perThreadBuffer.get();
-            byteBuffer.position(position).limit(limit);
-
-            return byteBuffer;
-        }
-
-        public void put(byte[] data)
-        {
-            long next = sequencer.next();
-            try
-            {
-                get(next).put(data);
-            }
-            finally
-            {
-                sequencer.publish(next);
-            }
-        }
-
-        private int index(long next)
-        {
-            return (int) (next & mask);
-        }
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/offheap/OneToOneOnHeapThroughputTest.java b/src/perftest/java/com/lmax/disruptor/offheap/OneToOneOnHeapThroughputTest.java
deleted file mode 100644
index 9a6e527..0000000
--- a/src/perftest/java/com/lmax/disruptor/offheap/OneToOneOnHeapThroughputTest.java
+++ /dev/null
@@ -1,207 +0,0 @@
-package com.lmax.disruptor.offheap;
-
-import com.lmax.disruptor.*;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.util.Random;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-import java.util.concurrent.locks.LockSupport;
-
-public class OneToOneOnHeapThroughputTest extends AbstractPerfTestDisruptor
-{
-    private static final int BLOCK_SIZE = 256;
-    private static final int BUFFER_SIZE = 1024 * 1024;
-    private static final long ITERATIONS = 1000 * 1000 * 10L;
-
-    private static final boolean SLICED_BUFFER = Boolean.getBoolean("sliced");
-    private final Executor executor = Executors.newFixedThreadPool(1, DaemonThreadFactory.INSTANCE);
-    private final WaitStrategy waitStrategy = new YieldingWaitStrategy();
-    private final RingBuffer<ByteBuffer> buffer =
-        RingBuffer.createSingleProducer(
-            SLICED_BUFFER ? SlicedBufferFactory.direct(BLOCK_SIZE, BUFFER_SIZE) : BufferFactory.direct(BLOCK_SIZE),
-            BUFFER_SIZE, waitStrategy);
-        private final ByteBufferHandler handler = new ByteBufferHandler();
-    private final BatchEventProcessor<ByteBuffer> processor =
-        new BatchEventProcessor<ByteBuffer>(buffer, buffer.newBarrier(), handler);
-
-    {
-        buffer.addGatingSequences(processor.getSequence());
-    }
-
-    private final Random r = new Random(1);
-    private final byte[] data = new byte[BLOCK_SIZE];
-
-    public OneToOneOnHeapThroughputTest()
-    {
-        r.nextBytes(data);
-    }
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 2;
-    }
-
-    @Override
-    protected long runDisruptorPass() throws Exception
-    {
-        byte[] data = this.data;
-
-        final CountDownLatch latch = new CountDownLatch(1);
-        long expectedCount = processor.getSequence().get() + ITERATIONS;
-        handler.reset(latch, ITERATIONS);
-        executor.execute(processor);
-        long start = System.currentTimeMillis();
-
-        final RingBuffer<ByteBuffer> rb = buffer;
-
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            long next = rb.next();
-            ByteBuffer event = rb.get(next);
-            event.clear();
-            event.put(data);
-            event.flip();
-            rb.publish(next);
-        }
-
-        latch.await();
-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-        waitForEventProcessorSequence(expectedCount);
-        processor.halt();
-
-        return opsPerSecond;
-    }
-
-    private void waitForEventProcessorSequence(long expectedCount)
-    {
-        while (processor.getSequence().get() < expectedCount)
-        {
-            LockSupport.parkNanos(1);
-        }
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        new OneToOneOnHeapThroughputTest().testImplementations();
-    }
-
-    public static class ByteBufferHandler implements EventHandler<ByteBuffer>
-    {
-        private long total = 0;
-        private long expectedCount;
-        private CountDownLatch latch;
-
-        @Override
-        public void onEvent(ByteBuffer event, long sequence, boolean endOfBatch) throws Exception
-        {
-            for (int i = 0; i < BLOCK_SIZE; i += 8)
-            {
-                total += event.getLong(i);
-            }
-
-            if (--expectedCount == 0)
-            {
-                latch.countDown();
-            }
-        }
-
-        public long getTotal()
-        {
-            return total;
-        }
-
-        public void reset(CountDownLatch latch, long expectedCount)
-        {
-            this.latch = latch;
-            this.expectedCount = expectedCount;
-        }
-    }
-
-    private static final class BufferFactory implements EventFactory<ByteBuffer>
-    {
-        private final boolean isDirect;
-        private final int size;
-
-        private BufferFactory(boolean isDirect, int size)
-        {
-            this.isDirect = isDirect;
-            this.size = size;
-        }
-
-        @Override
-        public ByteBuffer newInstance()
-        {
-            if (isDirect)
-            {
-                return ByteBuffer.allocateDirect(size).order(ByteOrder.nativeOrder());
-            }
-            else
-            {
-                return ByteBuffer.allocate(size).order(ByteOrder.nativeOrder());
-            }
-        }
-
-        public static BufferFactory direct(int size)
-        {
-            return new BufferFactory(true, size);
-        }
-
-        @SuppressWarnings("unused")
-        public static BufferFactory heap(int size)
-        {
-            return new BufferFactory(false, size);
-        }
-    }
-
-    private static final class SlicedBufferFactory implements EventFactory<ByteBuffer>
-    {
-        private final boolean isDirect;
-        private final int size;
-        private final int total;
-        private ByteBuffer buffer;
-
-        private SlicedBufferFactory(boolean isDirect, int size, int total)
-        {
-            this.isDirect = isDirect;
-            this.size = size;
-            this.total = total;
-            this.buffer =
-                (isDirect ? ByteBuffer.allocateDirect(size * total) : ByteBuffer.allocate(size * total))
-                    .order(ByteOrder.nativeOrder());
-            this.buffer.limit(0);
-        }
-
-        @Override
-        public ByteBuffer newInstance()
-        {
-            if (this.buffer.limit() == this.buffer.capacity())
-            {
-                this.buffer =
-                    (isDirect ? ByteBuffer.allocateDirect(size * total) : ByteBuffer.allocate(size * total))
-                        .order(ByteOrder.nativeOrder());
-                this.buffer.limit(0);
-            }
-            final int limit = this.buffer.limit();
-            this.buffer.limit(limit + size);
-            this.buffer.position(limit);
-            final ByteBuffer slice = this.buffer.slice().order(ByteOrder.nativeOrder());
-            return slice;
-        }
-
-        public static SlicedBufferFactory direct(int size, int total)
-        {
-            return new SlicedBufferFactory(true, size, total);
-        }
-
-        @SuppressWarnings("unused")
-        public static SlicedBufferFactory heap(int size, int total)
-        {
-            return new SlicedBufferFactory(false, size, total);
-        }
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/primitive/LongRingBuffer.java b/src/perftest/java/com/lmax/disruptor/primitive/LongRingBuffer.java
deleted file mode 100644
index a14ae39..0000000
--- a/src/perftest/java/com/lmax/disruptor/primitive/LongRingBuffer.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package com.lmax.disruptor.primitive;
-
-import com.lmax.disruptor.BatchEventProcessor;
-import com.lmax.disruptor.DataProvider;
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.Sequencer;
-
-public class LongRingBuffer
-{
-    private final Sequencer sequencer;
-    private final long[] buffer;
-    private final int mask;
-
-    public LongRingBuffer(final Sequencer sequencer)
-    {
-        this.sequencer = sequencer;
-        this.buffer = new long[sequencer.getBufferSize()];
-        this.mask = sequencer.getBufferSize() - 1;
-    }
-
-    private int index(final long sequence)
-    {
-        return (int) sequence & mask;
-    }
-
-    public void put(final long e)
-    {
-        final long next = sequencer.next();
-        buffer[index(next)] = e;
-        sequencer.publish(next);
-    }
-
-    public interface LongHandler
-    {
-        void onEvent(long value, long sequence, boolean endOfBatch);
-    }
-
-    private class LongEvent implements DataProvider<LongEvent>
-    {
-        private long sequence;
-
-        public long get()
-        {
-            return buffer[index(sequence)];
-        }
-
-        @Override
-        public LongEvent get(final long sequence)
-        {
-            this.sequence = sequence;
-            return this;
-        }
-    }
-
-    public BatchEventProcessor<LongEvent> createProcessor(final LongHandler handler)
-    {
-        return new BatchEventProcessor<LongEvent>(
-            new LongEvent(),
-            sequencer.newBarrier(),
-            new EventHandler<LongEvent>()
-            {
-                @Override
-                public void onEvent(final LongEvent event, final long sequence, final boolean endOfBatch)
-                    throws Exception
-                {
-                    handler.onEvent(event.get(), sequence, endOfBatch);
-                }
-            });
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/queue/OneToOneQueueBatchedThroughputTest.java b/src/perftest/java/com/lmax/disruptor/queue/OneToOneQueueBatchedThroughputTest.java
deleted file mode 100644
index c2ca1f9..0000000
--- a/src/perftest/java/com/lmax/disruptor/queue/OneToOneQueueBatchedThroughputTest.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.queue;
-
-import com.lmax.disruptor.AbstractPerfTestQueue;
-import com.lmax.disruptor.support.ValueAdditionBatchQueueProcessor;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-import java.util.concurrent.*;
-
-import static com.lmax.disruptor.support.PerfTestUtil.failIf;
-
-/**
- * <pre>
- * UniCast a series of items between 1 publisher and 1 event processor.
- *
- * +----+    +-----+
- * | P1 |--->| EP1 |
- * +----+    +-----+
- *
- * Queue Based:
- * ============
- *
- *        put      take
- * +----+    +====+    +-----+
- * | P1 |--->| Q1 |<---| EP1 |
- * +----+    +====+    +-----+
- *
- * P1  - Publisher 1
- * Q1  - Queue 1
- * EP1 - EventProcessor 1
- *
- * </pre>
- */
-public final class OneToOneQueueBatchedThroughputTest extends AbstractPerfTestQueue
-{
-    private static final int BUFFER_SIZE = 1024 * 64;
-    private static final long ITERATIONS = 1000L * 1000L * 10L;
-    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);
-    private final long expectedResult = ITERATIONS * 3L;
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final BlockingQueue<Long> blockingQueue = new LinkedBlockingQueue<Long>(BUFFER_SIZE);
-    private final ValueAdditionBatchQueueProcessor queueProcessor =
-        new ValueAdditionBatchQueueProcessor(blockingQueue, ITERATIONS);
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 2;
-    }
-
-    @Override
-    protected long runQueuePass() throws InterruptedException
-    {
-        final CountDownLatch latch = new CountDownLatch(1);
-        queueProcessor.reset(latch);
-        Future<?> future = executor.submit(queueProcessor);
-        long start = System.currentTimeMillis();
-
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            blockingQueue.put(3L);
-        }
-
-        latch.await();
-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-        queueProcessor.halt();
-        future.cancel(true);
-
-        failIf(expectedResult, 0);
-
-        return opsPerSecond;
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        OneToOneQueueBatchedThroughputTest test = new OneToOneQueueBatchedThroughputTest();
-        test.testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/queue/OneToOneQueueThroughputTest.java b/src/perftest/java/com/lmax/disruptor/queue/OneToOneQueueThroughputTest.java
deleted file mode 100644
index 99fb772..0000000
--- a/src/perftest/java/com/lmax/disruptor/queue/OneToOneQueueThroughputTest.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.queue;
-
-import com.lmax.disruptor.AbstractPerfTestQueue;
-import com.lmax.disruptor.support.ValueAdditionQueueProcessor;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-import java.util.concurrent.*;
-
-import static com.lmax.disruptor.support.PerfTestUtil.failIf;
-
-/**
- * <pre>
- * UniCast a series of items between 1 publisher and 1 event processor.
- *
- * +----+    +-----+
- * | P1 |--->| EP1 |
- * +----+    +-----+
- *
- * Queue Based:
- * ============
- *
- *        put      take
- * +----+    +====+    +-----+
- * | P1 |--->| Q1 |<---| EP1 |
- * +----+    +====+    +-----+
- *
- * P1  - Publisher 1
- * Q1  - Queue 1
- * EP1 - EventProcessor 1
- *
- * </pre>
- */
-public final class OneToOneQueueThroughputTest extends AbstractPerfTestQueue
-{
-    private static final int BUFFER_SIZE = 1024 * 64;
-    private static final long ITERATIONS = 1000L * 1000L * 10L;
-    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);
-    private final long expectedResult = ITERATIONS * 3L;
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final BlockingQueue<Long> blockingQueue = new LinkedBlockingQueue<Long>(BUFFER_SIZE);
-    private final ValueAdditionQueueProcessor queueProcessor =
-        new ValueAdditionQueueProcessor(blockingQueue, ITERATIONS - 1);
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 2;
-    }
-
-    @Override
-    protected long runQueuePass() throws InterruptedException
-    {
-        final CountDownLatch latch = new CountDownLatch(1);
-        queueProcessor.reset(latch);
-        Future<?> future = executor.submit(queueProcessor);
-        long start = System.currentTimeMillis();
-
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            blockingQueue.put(3L);
-        }
-
-        latch.await();
-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-        queueProcessor.halt();
-        future.cancel(true);
-
-        failIf(expectedResult, 0);
-
-        return opsPerSecond;
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        OneToOneQueueThroughputTest test = new OneToOneQueueThroughputTest();
-        test.testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/queue/OneToThreeDiamondQueueThroughputTest.java b/src/perftest/java/com/lmax/disruptor/queue/OneToThreeDiamondQueueThroughputTest.java
deleted file mode 100644
index 1c6e106..0000000
--- a/src/perftest/java/com/lmax/disruptor/queue/OneToThreeDiamondQueueThroughputTest.java
+++ /dev/null
@@ -1,190 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.queue;
-
-import static com.lmax.disruptor.support.PerfTestUtil.failIf;
-
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.LinkedBlockingQueue;
-
-import com.lmax.disruptor.AbstractPerfTestQueue;
-import com.lmax.disruptor.support.FizzBuzzQueueProcessor;
-import com.lmax.disruptor.support.FizzBuzzStep;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-/**
- * <pre>
- * Produce an event replicated to two event processors and fold back to a single third event processor.
- *
- *           +-----+
- *    +----->| EP1 |------+
- *    |      +-----+      |
- *    |                   v
- * +----+              +-----+
- * | P1 |              | EP3 |
- * +----+              +-----+
- *    |                   ^
- *    |      +-----+      |
- *    +----->| EP2 |------+
- *           +-----+
- *
- *
- * Queue Based:
- * ============
- *                 take       put
- *     put   +====+    +-----+    +====+  take
- *    +----->| Q1 |<---| EP1 |--->| Q3 |<------+
- *    |      +====+    +-----+    +====+       |
- *    |                                        |
- * +----+    +====+    +-----+    +====+    +-----+
- * | P1 |--->| Q2 |<---| EP2 |--->| Q4 |<---| EP3 |
- * +----+    +====+    +-----+    +====+    +-----+
- *
- * P1  - Publisher 1
- * Q1  - Queue 1
- * Q2  - Queue 2
- * Q3  - Queue 3
- * Q4  - Queue 4
- * EP1 - EventProcessor 1
- * EP2 - EventProcessor 2
- * EP3 - EventProcessor 3
- *
- *
- * Disruptor:
- * ==========
- *                    track to prevent wrap
- *              +-------------------------------+
- *              |                               |
- *              |                               v
- * +----+    +====+               +=====+    +-----+
- * | P1 |--->| RB |<--------------| SB2 |<---| EP3 |
- * +----+    +====+               +=====+    +-----+
- *      claim   ^  get               |   waitFor
- *              |                    |
- *           +=====+    +-----+      |
- *           | SB1 |<---| EP1 |<-----+
- *           +=====+    +-----+      |
- *              ^                    |
- *              |       +-----+      |
- *              +-------| EP2 |<-----+
- *             waitFor  +-----+
- *
- * P1  - Publisher 1
- * RB  - RingBuffer
- * SB1 - SequenceBarrier 1
- * EP1 - EventProcessor 1
- * EP2 - EventProcessor 2
- * SB2 - SequenceBarrier 2
- * EP3 - EventProcessor 3
- *
- * </pre>
- */
-public final class OneToThreeDiamondQueueThroughputTest extends AbstractPerfTestQueue
-{
-    private static final int NUM_EVENT_PROCESSORS = 3;
-    private static final int BUFFER_SIZE = 1024 * 8;
-    private static final long ITERATIONS = 1000L * 1000L * 100L;
-    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_EVENT_PROCESSORS, DaemonThreadFactory.INSTANCE);
-
-    private final long expectedResult;
-
-    {
-        long temp = 0L;
-
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            boolean fizz = 0 == (i % 3L);
-            boolean buzz = 0 == (i % 5L);
-
-            if (fizz && buzz)
-            {
-                ++temp;
-            }
-        }
-
-        expectedResult = temp;
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final BlockingQueue<Long> fizzInputQueue = new LinkedBlockingQueue<Long>(BUFFER_SIZE);
-    private final BlockingQueue<Long> buzzInputQueue = new LinkedBlockingQueue<Long>(BUFFER_SIZE);
-    private final BlockingQueue<Boolean> fizzOutputQueue = new LinkedBlockingQueue<Boolean>(BUFFER_SIZE);
-    private final BlockingQueue<Boolean> buzzOutputQueue = new LinkedBlockingQueue<Boolean>(BUFFER_SIZE);
-
-    private final FizzBuzzQueueProcessor fizzQueueProcessor =
-        new FizzBuzzQueueProcessor(FizzBuzzStep.FIZZ, fizzInputQueue, buzzInputQueue, fizzOutputQueue, buzzOutputQueue, ITERATIONS - 1);
-
-    private final FizzBuzzQueueProcessor buzzQueueProcessor =
-        new FizzBuzzQueueProcessor(FizzBuzzStep.BUZZ, fizzInputQueue, buzzInputQueue, fizzOutputQueue, buzzOutputQueue, ITERATIONS - 1);
-
-    private final FizzBuzzQueueProcessor fizzBuzzQueueProcessor =
-        new FizzBuzzQueueProcessor(FizzBuzzStep.FIZZ_BUZZ, fizzInputQueue, buzzInputQueue, fizzOutputQueue, buzzOutputQueue, ITERATIONS - 1);
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 4;
-    }
-
-    @Override
-    protected long runQueuePass() throws Exception
-    {
-        final CountDownLatch latch = new CountDownLatch(1);
-        fizzBuzzQueueProcessor.reset(latch);
-
-        Future<?>[] futures = new Future[NUM_EVENT_PROCESSORS];
-        futures[0] = executor.submit(fizzQueueProcessor);
-        futures[1] = executor.submit(buzzQueueProcessor);
-        futures[2] = executor.submit(fizzBuzzQueueProcessor);
-
-        long start = System.currentTimeMillis();
-
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            Long value = Long.valueOf(i);
-            fizzInputQueue.put(value);
-            buzzInputQueue.put(value);
-        }
-
-        latch.await();
-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-
-        fizzQueueProcessor.halt();
-        buzzQueueProcessor.halt();
-        fizzBuzzQueueProcessor.halt();
-
-        for (Future<?> future : futures)
-        {
-            future.cancel(true);
-        }
-
-        failIf(expectedResult, 0);
-
-        return opsPerSecond;
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        new OneToThreeDiamondQueueThroughputTest().testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/queue/OneToThreePipelineQueueThroughputTest.java b/src/perftest/java/com/lmax/disruptor/queue/OneToThreePipelineQueueThroughputTest.java
deleted file mode 100644
index 90342ce..0000000
--- a/src/perftest/java/com/lmax/disruptor/queue/OneToThreePipelineQueueThroughputTest.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.queue;
-
-import static com.lmax.disruptor.support.PerfTestUtil.failIf;
-
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.LinkedBlockingQueue;
-
-import com.lmax.disruptor.AbstractPerfTestQueue;
-import com.lmax.disruptor.support.FunctionQueueProcessor;
-import com.lmax.disruptor.support.FunctionStep;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-/**
- * <pre>
- *
- * Pipeline a series of stages from a publisher to ultimate event processor.
- * Each event processor depends on the output of the event processor.
- *
- * +----+    +-----+    +-----+    +-----+
- * | P1 |--->| EP1 |--->| EP2 |--->| EP3 |
- * +----+    +-----+    +-----+    +-----+
- *
- *
- * Queue Based:
- * ============
- *
- *        put      take        put      take        put      take
- * +----+    +====+    +-----+    +====+    +-----+    +====+    +-----+
- * | P1 |--->| Q1 |<---| EP1 |--->| Q2 |<---| EP2 |--->| Q3 |<---| EP3 |
- * +----+    +====+    +-----+    +====+    +-----+    +====+    +-----+
- *
- * P1  - Publisher 1
- * Q1  - Queue 1
- * EP1 - EventProcessor 1
- * Q2  - Queue 2
- * EP2 - EventProcessor 2
- * Q3  - Queue 3
- * EP3 - EventProcessor 3
- *
- * </pre>
- */
-public final class OneToThreePipelineQueueThroughputTest extends AbstractPerfTestQueue
-{
-    private static final int NUM_EVENT_PROCESSORS = 3;
-    private static final int BUFFER_SIZE = 1024 * 8;
-    private static final long ITERATIONS = 1000L * 1000L * 10L;
-    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_EVENT_PROCESSORS, DaemonThreadFactory.INSTANCE);
-
-    private static final long OPERAND_TWO_INITIAL_VALUE = 777L;
-    private final long expectedResult;
-
-    {
-        long temp = 0L;
-        long operandTwo = OPERAND_TWO_INITIAL_VALUE;
-
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            long stepOneResult = i + operandTwo--;
-            long stepTwoResult = stepOneResult + 3;
-
-            if ((stepTwoResult & 4L) == 4L)
-            {
-                ++temp;
-            }
-        }
-
-        expectedResult = temp;
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final BlockingQueue<long[]> stepOneQueue = new LinkedBlockingQueue<long[]>(BUFFER_SIZE);
-    private final BlockingQueue<Long> stepTwoQueue = new LinkedBlockingQueue<Long>(BUFFER_SIZE);
-    private final BlockingQueue<Long> stepThreeQueue = new LinkedBlockingQueue<Long>(BUFFER_SIZE);
-
-    private final FunctionQueueProcessor stepOneQueueProcessor =
-        new FunctionQueueProcessor(FunctionStep.ONE, stepOneQueue, stepTwoQueue, stepThreeQueue, ITERATIONS - 1);
-    private final FunctionQueueProcessor stepTwoQueueProcessor =
-        new FunctionQueueProcessor(FunctionStep.TWO, stepOneQueue, stepTwoQueue, stepThreeQueue, ITERATIONS - 1);
-    private final FunctionQueueProcessor stepThreeQueueProcessor =
-        new FunctionQueueProcessor(FunctionStep.THREE, stepOneQueue, stepTwoQueue, stepThreeQueue, ITERATIONS - 1);
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 4;
-    }
-
-    @Override
-    protected long runQueuePass() throws Exception
-    {
-        CountDownLatch latch = new CountDownLatch(1);
-        stepThreeQueueProcessor.reset(latch);
-
-        Future<?>[] futures = new Future[NUM_EVENT_PROCESSORS];
-        futures[0] = executor.submit(stepOneQueueProcessor);
-        futures[1] = executor.submit(stepTwoQueueProcessor);
-        futures[2] = executor.submit(stepThreeQueueProcessor);
-
-        long start = System.currentTimeMillis();
-
-        long operandTwo = OPERAND_TWO_INITIAL_VALUE;
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            long[] values = new long[2];
-            values[0] = i;
-            values[1] = operandTwo--;
-            stepOneQueue.put(values);
-        }
-
-        latch.await();
-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-
-        stepOneQueueProcessor.halt();
-        stepTwoQueueProcessor.halt();
-        stepThreeQueueProcessor.halt();
-
-        for (Future<?> future : futures)
-        {
-            future.cancel(true);
-        }
-
-        failIf(expectedResult, 0);
-
-        return opsPerSecond;
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        new OneToThreePipelineQueueThroughputTest().testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/queue/OneToThreeQueueThroughputTest.java b/src/perftest/java/com/lmax/disruptor/queue/OneToThreeQueueThroughputTest.java
deleted file mode 100644
index ce3be04..0000000
--- a/src/perftest/java/com/lmax/disruptor/queue/OneToThreeQueueThroughputTest.java
+++ /dev/null
@@ -1,158 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.queue;
-
-import static com.lmax.disruptor.support.PerfTestUtil.failIf;
-
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.LinkedBlockingQueue;
-
-import com.lmax.disruptor.AbstractPerfTestQueue;
-import com.lmax.disruptor.support.Operation;
-import com.lmax.disruptor.support.ValueMutationQueueProcessor;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-/**
- * <pre>
- *
- * MultiCast a series of items between 1 publisher and 3 event processors.
- *
- *           +-----+
- *    +----->| EP1 |
- *    |      +-----+
- *    |
- * +----+    +-----+
- * | P1 |--->| EP2 |
- * +----+    +-----+
- *    |
- *    |      +-----+
- *    +----->| EP3 |
- *           +-----+
- *
- *
- * Queue Based:
- * ============
- *                 take
- *   put     +====+    +-----+
- *    +----->| Q1 |<---| EP1 |
- *    |      +====+    +-----+
- *    |
- * +----+    +====+    +-----+
- * | P1 |--->| Q2 |<---| EP2 |
- * +----+    +====+    +-----+
- *    |
- *    |      +====+    +-----+
- *    +----->| Q3 |<---| EP3 |
- *           +====+    +-----+
- *
- * P1  - Publisher 1
- * Q1  - Queue 1
- * Q2  - Queue 2
- * Q3  - Queue 3
- * EP1 - EventProcessor 1
- * EP2 - EventProcessor 2
- * EP3 - EventProcessor 3
- *
- * </pre>
- */
-public final class OneToThreeQueueThroughputTest extends AbstractPerfTestQueue
-{
-    private static final int NUM_EVENT_PROCESSORS = 3;
-    private static final int BUFFER_SIZE = 1024 * 8;
-    private static final long ITERATIONS = 1000L * 1000L * 1L;
-    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_EVENT_PROCESSORS, DaemonThreadFactory.INSTANCE);
-
-    private final long[] results = new long[NUM_EVENT_PROCESSORS];
-
-    {
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            results[0] = Operation.ADDITION.op(results[0], i);
-            results[1] = Operation.SUBTRACTION.op(results[1], i);
-            results[2] = Operation.AND.op(results[2], i);
-        }
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @SuppressWarnings("unchecked")
-    private final BlockingQueue<Long>[] blockingQueues = new BlockingQueue[NUM_EVENT_PROCESSORS];
-
-    {
-        blockingQueues[0] = new LinkedBlockingQueue<Long>(BUFFER_SIZE);
-        blockingQueues[1] = new LinkedBlockingQueue<Long>(BUFFER_SIZE);
-        blockingQueues[2] = new LinkedBlockingQueue<Long>(BUFFER_SIZE);
-    }
-
-    private final ValueMutationQueueProcessor[] queueProcessors = new ValueMutationQueueProcessor[NUM_EVENT_PROCESSORS];
-
-    {
-        queueProcessors[0] = new ValueMutationQueueProcessor(blockingQueues[0], Operation.ADDITION, ITERATIONS - 1);
-        queueProcessors[1] = new ValueMutationQueueProcessor(blockingQueues[1], Operation.SUBTRACTION, ITERATIONS - 1);
-        queueProcessors[2] = new ValueMutationQueueProcessor(blockingQueues[2], Operation.AND, ITERATIONS - 1);
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 4;
-    }
-
-    @Override
-    protected long runQueuePass() throws InterruptedException
-    {
-        CountDownLatch latch = new CountDownLatch(NUM_EVENT_PROCESSORS);
-        Future<?>[] futures = new Future[NUM_EVENT_PROCESSORS];
-        for (int i = 0; i < NUM_EVENT_PROCESSORS; i++)
-        {
-            queueProcessors[i].reset(latch);
-            futures[i] = executor.submit(queueProcessors[i]);
-        }
-
-        long start = System.currentTimeMillis();
-
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            final Long value = Long.valueOf(i);
-            for (BlockingQueue<Long> queue : blockingQueues)
-            {
-                queue.put(value);
-            }
-        }
-
-        latch.await();
-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-        for (int i = 0; i < NUM_EVENT_PROCESSORS; i++)
-        {
-            queueProcessors[i].halt();
-            futures[i].cancel(true);
-            failIf(queueProcessors[i].getValue(), -1);
-        }
-
-        return opsPerSecond;
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        new OneToThreeQueueThroughputTest().testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/queue/PingPongQueueLatencyTest.java b/src/perftest/java/com/lmax/disruptor/queue/PingPongQueueLatencyTest.java
deleted file mode 100644
index ff2dab8..0000000
--- a/src/perftest/java/com/lmax/disruptor/queue/PingPongQueueLatencyTest.java
+++ /dev/null
@@ -1,226 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.queue;
-
-import java.io.PrintStream;
-import java.util.concurrent.*;
-
-import org.HdrHistogram.Histogram;
-
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-/**
- * <pre>
- *
- * Ping pongs between 2 event handlers and measures the latency of
- * a round trip.
- *
- * Queue Based:
- * ============
- *               +---take---+
- *               |          |
- *               |          V
- *            +====+      +====+
- *    +------>| Q1 |      | P2 |-------+
- *    |       +====+      +====+       |
- *   put                              put
- *    |       +====+      +====+       |
- *    +-------| P1 |      | Q2 |<------+
- *            +====+      +====+
- *               ^          |
- *               |          |
- *               +---take---+
- *
- * P1 - QueuePinger
- * P2 - QueuePonger
- * Q1 - PingQueue
- * Q2 - PongQueue
- *
- * </pre>
- * <p>
- * Note: <b>This test is only useful on a system using an invariant TSC in user space from the System.nanoTime() call.</b>
- */
-public final class PingPongQueueLatencyTest
-{
-    private static final int BUFFER_SIZE = 1024;
-    private static final long ITERATIONS = 100L * 1000L * 30L;
-    private static final long PAUSE_NANOS = 1000L;
-    private final ExecutorService executor = Executors.newCachedThreadPool(DaemonThreadFactory.INSTANCE);
-
-    private final Histogram histogram = new Histogram(10000000000L, 4);
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final BlockingQueue<Long> pingQueue = new ArrayBlockingQueue<Long>(BUFFER_SIZE);
-    private final BlockingQueue<Long> pongQueue = new ArrayBlockingQueue<Long>(BUFFER_SIZE);
-    private final QueuePinger qPinger = new QueuePinger(pingQueue, pongQueue, ITERATIONS, PAUSE_NANOS);
-    private final QueuePonger qPonger = new QueuePonger(pingQueue, pongQueue);
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    public void testImplementation() throws Exception
-    {
-        final int runs = 3;
-
-        for (int i = 0; i < runs; i++)
-        {
-            System.gc();
-            histogram.reset();
-
-            runQueuePass();
-
-            System.out.format("%s run %d BlockingQueue %s\n", getClass().getSimpleName(), Long.valueOf(i), histogram);
-            dumpHistogram(histogram, System.out);
-        }
-    }
-
-    private static void dumpHistogram(final Histogram histogram, final PrintStream out)
-    {
-        histogram.outputPercentileDistribution(out, 1, 1000.0);
-    }
-
-    private void runQueuePass() throws Exception
-    {
-        final CountDownLatch latch = new CountDownLatch(1);
-        final CyclicBarrier barrier = new CyclicBarrier(3);
-        qPinger.reset(barrier, latch, histogram);
-        qPonger.reset(barrier);
-
-        final Future<?> pingFuture = executor.submit(qPinger);
-        final Future<?> pongFuture = executor.submit(qPonger);
-
-        barrier.await();
-        latch.await();
-
-        pingFuture.cancel(true);
-        pongFuture.cancel(true);
-    }
-
-    public static void main(final String[] args) throws Exception
-    {
-        final PingPongQueueLatencyTest test = new PingPongQueueLatencyTest();
-        test.testImplementation();
-    }
-
-    private static class QueuePinger implements Runnable
-    {
-        private final BlockingQueue<Long> pingQueue;
-        private final BlockingQueue<Long> pongQueue;
-        private final long pauseTimeNs;
-
-        private Histogram histogram;
-        private CyclicBarrier barrier;
-        private CountDownLatch latch;
-        private long counter;
-        private final long maxEvents;
-
-        QueuePinger(
-            final BlockingQueue<Long> pingQueue, final BlockingQueue<Long> pongQueue, final long maxEvents,
-            final long pauseTimeNs)
-        {
-            this.pingQueue = pingQueue;
-            this.pongQueue = pongQueue;
-            this.maxEvents = maxEvents;
-            this.pauseTimeNs = pauseTimeNs;
-        }
-
-        @Override
-        public void run()
-        {
-            try
-            {
-                barrier.await();
-
-                Thread.sleep(1000);
-
-                long counter = 0;
-
-                while (counter < maxEvents)
-                {
-                    final long t0 = System.nanoTime();
-                    pingQueue.put(1L);
-                    counter += pongQueue.take();
-                    final long t1 = System.nanoTime();
-
-                    histogram.recordValueWithExpectedInterval(t1 - t0, pauseTimeNs);
-
-                    while (pauseTimeNs > (System.nanoTime() - t1))
-                    {
-                        Thread.yield();
-                    }
-                }
-
-                latch.countDown();
-            }
-            catch (final Exception e)
-            {
-                e.printStackTrace();
-                return;
-            }
-        }
-
-        public void reset(final CyclicBarrier barrier, final CountDownLatch latch, final Histogram histogram)
-        {
-            this.histogram = histogram;
-            this.barrier = barrier;
-            this.latch = latch;
-
-            counter = 0;
-        }
-    }
-
-    private static class QueuePonger implements Runnable
-    {
-        private final BlockingQueue<Long> pingQueue;
-        private final BlockingQueue<Long> pongQueue;
-        private CyclicBarrier barrier;
-
-        QueuePonger(final BlockingQueue<Long> pingQueue, final BlockingQueue<Long> pongQueue)
-        {
-            this.pingQueue = pingQueue;
-            this.pongQueue = pongQueue;
-        }
-
-        @Override
-        public void run()
-        {
-            final Thread thread = Thread.currentThread();
-            try
-            {
-                barrier.await();
-
-                while (!thread.isInterrupted())
-                {
-                    final Long value = pingQueue.take();
-                    pongQueue.put(value);
-                }
-            }
-            catch (final InterruptedException e)
-            {
-                // do-nothing.
-            }
-            catch (final Exception e)
-            {
-                e.printStackTrace();
-            }
-        }
-
-        public void reset(final CyclicBarrier barrier)
-        {
-            this.barrier = barrier;
-        }
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/queue/ThreeToOneQueueThroughputTest.java b/src/perftest/java/com/lmax/disruptor/queue/ThreeToOneQueueThroughputTest.java
deleted file mode 100644
index 48c40f5..0000000
--- a/src/perftest/java/com/lmax/disruptor/queue/ThreeToOneQueueThroughputTest.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.queue;
-
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.CyclicBarrier;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.LinkedBlockingQueue;
-
-import com.lmax.disruptor.AbstractPerfTestQueue;
-import com.lmax.disruptor.support.ValueAdditionQueueProcessor;
-import com.lmax.disruptor.support.ValueQueuePublisher;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-/**
- * <pre>
- *
- * Sequence a series of events from multiple publishers going to one event processor.
- *
- * +----+
- * | P1 |------+
- * +----+      |
- *             v
- * +----+    +-----+
- * | P1 |--->| EP1 |
- * +----+    +-----+
- *             ^
- * +----+      |
- * | P3 |------+
- * +----+
- *
- *
- * Queue Based:
- * ============
- *
- * +----+  put
- * | P1 |------+
- * +----+      |
- *             v   take
- * +----+    +====+    +-----+
- * | P2 |--->| Q1 |<---| EP1 |
- * +----+    +====+    +-----+
- *             ^
- * +----+      |
- * | P3 |------+
- * +----+
- *
- * P1  - Publisher 1
- * P2  - Publisher 2
- * P3  - Publisher 3
- * Q1  - Queue 1
- * EP1 - EventProcessor 1
- *
- * </pre>
- */
-public final class ThreeToOneQueueThroughputTest extends AbstractPerfTestQueue
-{
-    private static final int NUM_PUBLISHERS = 3;
-    private static final int BUFFER_SIZE = 1024 * 64;
-    private static final long ITERATIONS = 1000L * 1000L * 20L;
-    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_PUBLISHERS + 1, DaemonThreadFactory.INSTANCE);
-    private final CyclicBarrier cyclicBarrier = new CyclicBarrier(NUM_PUBLISHERS + 1);
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final BlockingQueue<Long> blockingQueue = new LinkedBlockingQueue<Long>(BUFFER_SIZE);
-    private final ValueAdditionQueueProcessor queueProcessor =
-        new ValueAdditionQueueProcessor(blockingQueue, ((ITERATIONS / NUM_PUBLISHERS) * NUM_PUBLISHERS) - 1L);
-    private final ValueQueuePublisher[] valueQueuePublishers = new ValueQueuePublisher[NUM_PUBLISHERS];
-
-    {
-        for (int i = 0; i < NUM_PUBLISHERS; i++)
-        {
-            valueQueuePublishers[i] =
-                new ValueQueuePublisher(cyclicBarrier, blockingQueue, ITERATIONS / NUM_PUBLISHERS);
-        }
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 4;
-    }
-
-    @Override
-    protected long runQueuePass() throws Exception
-    {
-        final CountDownLatch latch = new CountDownLatch(1);
-        queueProcessor.reset(latch);
-
-        Future<?>[] futures = new Future[NUM_PUBLISHERS];
-        for (int i = 0; i < NUM_PUBLISHERS; i++)
-        {
-            futures[i] = executor.submit(valueQueuePublishers[i]);
-        }
-        Future<?> processorFuture = executor.submit(queueProcessor);
-
-        long start = System.currentTimeMillis();
-        cyclicBarrier.await();
-
-        for (int i = 0; i < NUM_PUBLISHERS; i++)
-        {
-            futures[i].get();
-        }
-
-        latch.await();
-
-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-        queueProcessor.halt();
-        processorFuture.cancel(true);
-
-        return opsPerSecond;
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        new ThreeToOneQueueThroughputTest().testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/raw/OneToOneRawBatchThroughputTest.java b/src/perftest/java/com/lmax/disruptor/raw/OneToOneRawBatchThroughputTest.java
deleted file mode 100644
index 0306784..0000000
--- a/src/perftest/java/com/lmax/disruptor/raw/OneToOneRawBatchThroughputTest.java
+++ /dev/null
@@ -1,179 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.raw;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
-import com.lmax.disruptor.AbstractPerfTestDisruptor;
-import com.lmax.disruptor.Sequence;
-import com.lmax.disruptor.SequenceBarrier;
-import com.lmax.disruptor.Sequenced;
-import com.lmax.disruptor.Sequencer;
-import com.lmax.disruptor.SingleProducerSequencer;
-import com.lmax.disruptor.YieldingWaitStrategy;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-/**
- * <pre>
- * UniCast a series of items between 1 publisher and 1 event processor.
- *
- * +----+    +-----+
- * | P1 |--->| EP1 |
- * +----+    +-----+
- *
- *
- * Queue Based:
- * ============
- *
- *        put      take
- * +----+    +====+    +-----+
- * | P1 |--->| Q1 |<---| EP1 |
- * +----+    +====+    +-----+
- *
- * P1  - Publisher 1
- * Q1  - Queue 1
- * EP1 - EventProcessor 1
- *
- *
- * Disruptor:
- * ==========
- *              track to prevent wrap
- *              +------------------+
- *              |                  |
- *              |                  v
- * +----+    +====+    +====+   +-----+
- * | P1 |--->| RB |<---| SB |   | EP1 |
- * +----+    +====+    +====+   +-----+
- *      claim      get    ^        |
- *                        |        |
- *                        +--------+
- *                          waitFor
- *
- * P1  - Publisher 1
- * RB  - RingBuffer
- * SB  - SequenceBarrier
- * EP1 - EventProcessor 1
- *
- * </pre>
- */
-public final class OneToOneRawBatchThroughputTest extends AbstractPerfTestDisruptor
-{
-    private static final int BUFFER_SIZE = 1024 * 64;
-    private static final long ITERATIONS = 1000L * 1000L * 200L;
-    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final Sequencer sequencer = new SingleProducerSequencer(BUFFER_SIZE, new YieldingWaitStrategy());
-    private final MyRunnable myRunnable = new MyRunnable(sequencer);
-
-    {
-        sequencer.addGatingSequences(myRunnable.sequence);
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 2;
-    }
-
-    @Override
-    protected long runDisruptorPass() throws InterruptedException
-    {
-        int batchSize = 10;
-        final CountDownLatch latch = new CountDownLatch(1);
-        long expectedCount = myRunnable.sequence.get() + (ITERATIONS * batchSize);
-        myRunnable.reset(latch, expectedCount);
-        executor.submit(myRunnable);
-        long start = System.currentTimeMillis();
-
-        final Sequenced sequencer = this.sequencer;
-
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            long next = sequencer.next(batchSize);
-            sequencer.publish((next - (batchSize - 1)), next);
-        }
-
-        latch.await();
-        long end = System.currentTimeMillis();
-        long opsPerSecond = (ITERATIONS * 1000L * batchSize) / (end - start);
-        waitForEventProcessorSequence(expectedCount);
-
-        return opsPerSecond;
-    }
-
-    private void waitForEventProcessorSequence(long expectedCount) throws InterruptedException
-    {
-        while (myRunnable.sequence.get() != expectedCount)
-        {
-            Thread.sleep(1);
-        }
-    }
-
-    private static class MyRunnable implements Runnable
-    {
-        private CountDownLatch latch;
-        private long expectedCount;
-        Sequence sequence = new Sequence(-1);
-        private final SequenceBarrier barrier;
-
-        MyRunnable(Sequencer sequencer)
-        {
-            this.barrier = sequencer.newBarrier();
-        }
-
-        public void reset(CountDownLatch latch, long expectedCount)
-        {
-            this.latch = latch;
-            this.expectedCount = expectedCount;
-        }
-
-        @Override
-        public void run()
-        {
-            long expected = expectedCount;
-            long processed = -1;
-
-            try
-            {
-                do
-                {
-                    processed = barrier.waitFor(sequence.get() + 1);
-                    sequence.set(processed);
-                }
-                while (processed < expected);
-
-                latch.countDown();
-                sequence.set(processed);
-            }
-            catch (Exception e)
-            {
-                e.printStackTrace();
-            }
-        }
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        OneToOneRawBatchThroughputTest test = new OneToOneRawBatchThroughputTest();
-        test.testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/raw/OneToOneRawThroughputTest.java b/src/perftest/java/com/lmax/disruptor/raw/OneToOneRawThroughputTest.java
deleted file mode 100644
index af8e1eb..0000000
--- a/src/perftest/java/com/lmax/disruptor/raw/OneToOneRawThroughputTest.java
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.raw;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
-import com.lmax.disruptor.AbstractPerfTestDisruptor;
-import com.lmax.disruptor.Sequence;
-import com.lmax.disruptor.SequenceBarrier;
-import com.lmax.disruptor.Sequenced;
-import com.lmax.disruptor.Sequencer;
-import com.lmax.disruptor.SingleProducerSequencer;
-import com.lmax.disruptor.YieldingWaitStrategy;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-/**
- * <pre>
- * UniCast a series of items between 1 publisher and 1 event processor.
- *
- * +----+    +-----+
- * | P1 |--->| EP1 |
- * +----+    +-----+
- *
- *
- * Queue Based:
- * ============
- *
- *        put      take
- * +----+    +====+    +-----+
- * | P1 |--->| Q1 |<---| EP1 |
- * +----+    +====+    +-----+
- *
- * P1  - Publisher 1
- * Q1  - Queue 1
- * EP1 - EventProcessor 1
- *
- *
- * Disruptor:
- * ==========
- *              track to prevent wrap
- *              +------------------+
- *              |                  |
- *              |                  v
- * +----+    +====+    +====+   +-----+
- * | P1 |--->| RB |<---| SB |   | EP1 |
- * +----+    +====+    +====+   +-----+
- *      claim      get    ^        |
- *                        |        |
- *                        +--------+
- *                          waitFor
- *
- * P1  - Publisher 1
- * RB  - RingBuffer
- * SB  - SequenceBarrier
- * EP1 - EventProcessor 1
- *
- * </pre>
- */
-public final class OneToOneRawThroughputTest extends AbstractPerfTestDisruptor
-{
-    private static final int BUFFER_SIZE = 1024 * 64;
-    private static final long ITERATIONS = 1000L * 1000L * 200L;
-    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final Sequencer sequencer = new SingleProducerSequencer(BUFFER_SIZE, new YieldingWaitStrategy());
-    private final MyRunnable myRunnable = new MyRunnable(sequencer);
-
-    {
-        sequencer.addGatingSequences(myRunnable.sequence);
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 2;
-    }
-
-    @Override
-    protected long runDisruptorPass() throws InterruptedException
-    {
-        final CountDownLatch latch = new CountDownLatch(1);
-        long expectedCount = myRunnable.sequence.get() + ITERATIONS;
-        myRunnable.reset(latch, expectedCount);
-        executor.submit(myRunnable);
-        long start = System.currentTimeMillis();
-
-        final Sequenced sequencer = this.sequencer;
-
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            long next = sequencer.next();
-            sequencer.publish(next);
-        }
-
-        latch.await();
-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-        waitForEventProcessorSequence(expectedCount);
-
-        return opsPerSecond;
-    }
-
-    private void waitForEventProcessorSequence(long expectedCount) throws InterruptedException
-    {
-        while (myRunnable.sequence.get() != expectedCount)
-        {
-            Thread.sleep(1);
-        }
-    }
-
-    private static class MyRunnable implements Runnable
-    {
-        private CountDownLatch latch;
-        private long expectedCount;
-        Sequence sequence = new Sequence(-1);
-        private final SequenceBarrier barrier;
-
-        MyRunnable(Sequencer sequencer)
-        {
-            this.barrier = sequencer.newBarrier();
-        }
-
-        public void reset(CountDownLatch latch, long expectedCount)
-        {
-            this.latch = latch;
-            this.expectedCount = expectedCount;
-        }
-
-        @Override
-        public void run()
-        {
-            long expected = expectedCount;
-            long processed = -1;
-
-            try
-            {
-                do
-                {
-                    processed = barrier.waitFor(sequence.get() + 1);
-                    sequence.set(processed);
-                }
-                while (processed < expected);
-
-                latch.countDown();
-                sequence.setVolatile(processed);
-            }
-            catch (Exception e)
-            {
-                e.printStackTrace();
-            }
-        }
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        OneToOneRawThroughputTest test = new OneToOneRawThroughputTest();
-        test.testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedBatchThroughputTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedBatchThroughputTest.java
deleted file mode 100644
index 8fd0d63..0000000
--- a/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedBatchThroughputTest.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.sequenced;
-
-import static com.lmax.disruptor.RingBuffer.createSingleProducer;
-import static com.lmax.disruptor.support.PerfTestUtil.failIfNot;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
-import com.lmax.disruptor.AbstractPerfTestDisruptor;
-import com.lmax.disruptor.BatchEventProcessor;
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.SequenceBarrier;
-import com.lmax.disruptor.YieldingWaitStrategy;
-import com.lmax.disruptor.support.PerfTestUtil;
-import com.lmax.disruptor.support.ValueAdditionEventHandler;
-import com.lmax.disruptor.support.ValueEvent;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-/**
- * <pre>
- * UniCast a series of items between 1 publisher and 1 event processor.
- *
- * +----+    +-----+
- * | P1 |--->| EP1 |
- * +----+    +-----+
- *
- * Disruptor:
- * ==========
- *              track to prevent wrap
- *              +------------------+
- *              |                  |
- *              |                  v
- * +----+    +====+    +====+   +-----+
- * | P1 |--->| RB |<---| SB |   | EP1 |
- * +----+    +====+    +====+   +-----+
- *      claim      get    ^        |
- *                        |        |
- *                        +--------+
- *                          waitFor
- *
- * P1  - Publisher 1
- * RB  - RingBuffer
- * SB  - SequenceBarrier
- * EP1 - EventProcessor 1
- *
- * </pre>
- */
-public final class OneToOneSequencedBatchThroughputTest extends AbstractPerfTestDisruptor
-{
-    public static final int BATCH_SIZE = 10;
-    private static final int BUFFER_SIZE = 1024 * 64;
-    private static final long ITERATIONS = 1000L * 1000L * 100L;
-    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);
-    private final long expectedResult = PerfTestUtil.accumulatedAddition(ITERATIONS) * BATCH_SIZE;
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final RingBuffer<ValueEvent> ringBuffer =
-        createSingleProducer(ValueEvent.EVENT_FACTORY, BUFFER_SIZE, new YieldingWaitStrategy());
-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();
-    private final ValueAdditionEventHandler handler = new ValueAdditionEventHandler();
-    private final BatchEventProcessor<ValueEvent> batchEventProcessor =
-        new BatchEventProcessor<ValueEvent>(ringBuffer, sequenceBarrier, handler);
-
-    {
-        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 2;
-    }
-
-    @Override
-    protected long runDisruptorPass() throws InterruptedException
-    {
-        final CountDownLatch latch = new CountDownLatch(1);
-        long expectedCount = batchEventProcessor.getSequence().get() + ITERATIONS * BATCH_SIZE;
-        handler.reset(latch, expectedCount);
-        executor.submit(batchEventProcessor);
-        long start = System.currentTimeMillis();
-
-        final RingBuffer<ValueEvent> rb = ringBuffer;
-
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            long hi = rb.next(BATCH_SIZE);
-            long lo = hi - (BATCH_SIZE - 1);
-            for (long l = lo; l <= hi; l++)
-            {
-                rb.get(l).setValue(i);
-            }
-            rb.publish(lo, hi);
-        }
-
-        latch.await();
-        long opsPerSecond = (BATCH_SIZE * ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-        waitForEventProcessorSequence(expectedCount);
-        batchEventProcessor.halt();
-
-        failIfNot(expectedResult, handler.getValue());
-
-        return opsPerSecond;
-    }
-
-    private void waitForEventProcessorSequence(long expectedCount) throws InterruptedException
-    {
-        while (batchEventProcessor.getSequence().get() != expectedCount)
-        {
-            Thread.sleep(1);
-        }
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        OneToOneSequencedBatchThroughputTest test = new OneToOneSequencedBatchThroughputTest();
-        test.testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedLongArrayThroughputTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedLongArrayThroughputTest.java
deleted file mode 100644
index 404cdc1..0000000
--- a/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedLongArrayThroughputTest.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.sequenced;
-
-import static com.lmax.disruptor.RingBuffer.createSingleProducer;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
-import com.lmax.disruptor.AbstractPerfTestDisruptor;
-import com.lmax.disruptor.BatchEventProcessor;
-import com.lmax.disruptor.EventFactory;
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.SequenceBarrier;
-import com.lmax.disruptor.YieldingWaitStrategy;
-import com.lmax.disruptor.support.LongArrayEventHandler;
-import com.lmax.disruptor.support.PerfTestUtil;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-/**
- * <pre>
- * UniCast a series of items between 1 publisher and 1 event processor.
- *
- * +----+    +-----+
- * | P1 |--->| EP1 |
- * +----+    +-----+
- *
- * Disruptor:
- * ==========
- *              track to prevent wrap
- *              +------------------+
- *              |                  |
- *              |                  v
- * +----+    +====+    +====+   +-----+
- * | P1 |--->| RB |<---| SB |   | EP1 |
- * +----+    +====+    +====+   +-----+
- *      claim      get    ^        |
- *                        |        |
- *                        +--------+
- *                          waitFor
- *
- * P1  - Publisher 1
- * RB  - RingBuffer
- * SB  - SequenceBarrier
- * EP1 - EventProcessor 1
- *
- * </pre>
- */
-public final class OneToOneSequencedLongArrayThroughputTest extends AbstractPerfTestDisruptor
-{
-    private static final int BUFFER_SIZE = 1024 * 1;
-    private static final long ITERATIONS = 1000L * 1000L * 1L;
-    private static final int ARRAY_SIZE = 2 * 1024;
-    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);
-
-    private static final EventFactory<long[]> FACTORY = new EventFactory<long[]>()
-    {
-        @Override
-        public long[] newInstance()
-        {
-            return new long[ARRAY_SIZE];
-        }
-    };
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final RingBuffer<long[]> ringBuffer =
-        createSingleProducer(FACTORY, BUFFER_SIZE, new YieldingWaitStrategy());
-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();
-    private final LongArrayEventHandler handler = new LongArrayEventHandler();
-    private final BatchEventProcessor<long[]> batchEventProcessor =
-        new BatchEventProcessor<long[]>(ringBuffer, sequenceBarrier, handler);
-
-    {
-        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 2;
-    }
-
-    @Override
-    protected long runDisruptorPass() throws InterruptedException
-    {
-        final CountDownLatch latch = new CountDownLatch(1);
-        long expectedCount = batchEventProcessor.getSequence().get() + ITERATIONS;
-        handler.reset(latch, ITERATIONS);
-        executor.submit(batchEventProcessor);
-        long start = System.currentTimeMillis();
-
-        final RingBuffer<long[]> rb = ringBuffer;
-
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            long next = rb.next();
-            long[] event = rb.get(next);
-            for (int j = 0; j < event.length; j++)
-            {
-                event[j] = i;
-            }
-            rb.publish(next);
-        }
-
-        latch.await();
-        long opsPerSecond = (ITERATIONS * ARRAY_SIZE * 1000L) / (System.currentTimeMillis() - start);
-        waitForEventProcessorSequence(expectedCount);
-        batchEventProcessor.halt();
-
-        PerfTestUtil.failIf(0, handler.getValue());
-
-        return opsPerSecond;
-    }
-
-    private void waitForEventProcessorSequence(long expectedCount) throws InterruptedException
-    {
-        while (batchEventProcessor.getSequence().get() != expectedCount)
-        {
-            Thread.sleep(1);
-        }
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        OneToOneSequencedLongArrayThroughputTest test = new OneToOneSequencedLongArrayThroughputTest();
-        test.testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedPollerThroughputTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedPollerThroughputTest.java
deleted file mode 100644
index 6f43484..0000000
--- a/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedPollerThroughputTest.java
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.sequenced;
-
-import static com.lmax.disruptor.RingBuffer.createSingleProducer;
-import static com.lmax.disruptor.support.PerfTestUtil.failIfNot;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
-import com.lmax.disruptor.AbstractPerfTestDisruptor;
-import com.lmax.disruptor.EventPoller;
-import com.lmax.disruptor.EventPoller.PollState;
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.YieldingWaitStrategy;
-import com.lmax.disruptor.support.PerfTestUtil;
-import com.lmax.disruptor.support.ValueEvent;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-import com.lmax.disruptor.util.PaddedLong;
-
-/**
- * <pre>
- * UniCast a series of items between 1 publisher and 1 event processor.
- *
- * +----+    +-----+
- * | P1 |--->| EP1 |
- * +----+    +-----+
- *
- * Disruptor:
- * ==========
- *              track to prevent wrap
- *              +------------------+
- *              |                  |
- *              |                  v
- * +----+    +====+    +====+   +-----+
- * | P1 |--->| RB |<---| SB |   | EP1 |
- * +----+    +====+    +====+   +-----+
- *      claim      get    ^        |
- *                        |        |
- *                        +--------+
- *                          waitFor
- *
- * P1  - Publisher 1
- * RB  - RingBuffer
- * SB  - SequenceBarrier
- * EP1 - EventProcessor 1
- *
- * </pre>
- */
-public final class OneToOneSequencedPollerThroughputTest extends AbstractPerfTestDisruptor
-{
-    private static final int BUFFER_SIZE = 1024 * 64;
-    private static final long ITERATIONS = 1000L * 1000L * 100L;
-    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);
-    private final long expectedResult = PerfTestUtil.accumulatedAddition(ITERATIONS);
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final RingBuffer<ValueEvent> ringBuffer =
-        createSingleProducer(ValueEvent.EVENT_FACTORY, BUFFER_SIZE, new YieldingWaitStrategy());
-
-    private final EventPoller<ValueEvent> poller = ringBuffer.newPoller();
-    private final PollRunnable pollRunnable = new PollRunnable(poller);
-
-    {
-        ringBuffer.addGatingSequences(poller.getSequence());
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 2;
-    }
-
-    private static class PollRunnable implements Runnable, EventPoller.Handler<ValueEvent>
-    {
-        private final EventPoller<ValueEvent> poller;
-        private volatile boolean running = true;
-        private final PaddedLong value = new PaddedLong();
-        private CountDownLatch latch;
-        private long count;
-
-        PollRunnable(EventPoller<ValueEvent> poller)
-        {
-            this.poller = poller;
-        }
-
-        @Override
-        public void run()
-        {
-            try
-            {
-                while (running)
-                {
-                    if (PollState.PROCESSING != poller.poll(this))
-                    {
-                        Thread.yield();
-                    }
-                }
-            }
-            catch (Exception e)
-            {
-                e.printStackTrace();
-            }
-        }
-
-        @Override
-        public boolean onEvent(ValueEvent event, long sequence, boolean endOfBatch)
-        {
-            value.set(value.get() + event.getValue());
-
-            if (count == sequence)
-            {
-                latch.countDown();
-            }
-
-            return true;
-        }
-
-        public void halt()
-        {
-            running = false;
-        }
-
-        public void reset(final CountDownLatch latch, final long expectedCount)
-        {
-            value.set(0L);
-            this.latch = latch;
-            count = expectedCount;
-            running = true;
-        }
-
-        public long getValue()
-        {
-            return value.get();
-        }
-    }
-
-    @Override
-    protected long runDisruptorPass() throws InterruptedException
-    {
-        final CountDownLatch latch = new CountDownLatch(1);
-        long expectedCount = poller.getSequence().get() + ITERATIONS;
-        pollRunnable.reset(latch, expectedCount);
-        executor.submit(pollRunnable);
-        long start = System.currentTimeMillis();
-
-        final RingBuffer<ValueEvent> rb = ringBuffer;
-
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            long next = rb.next();
-            rb.get(next).setValue(i);
-            rb.publish(next);
-        }
-
-        latch.await();
-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-        waitForEventProcessorSequence(expectedCount);
-        pollRunnable.halt();
-
-        failIfNot(expectedResult, pollRunnable.getValue());
-
-        return opsPerSecond;
-    }
-
-    private void waitForEventProcessorSequence(long expectedCount) throws InterruptedException
-    {
-        while (poller.getSequence().get() != expectedCount)
-        {
-            Thread.sleep(1);
-        }
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        OneToOneSequencedPollerThroughputTest test = new OneToOneSequencedPollerThroughputTest();
-        test.testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedThroughputTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedThroughputTest.java
deleted file mode 100644
index daa1b7c..0000000
--- a/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedThroughputTest.java
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.sequenced;
-
-import static com.lmax.disruptor.RingBuffer.createSingleProducer;
-import static com.lmax.disruptor.support.PerfTestUtil.failIfNot;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
-import com.lmax.disruptor.AbstractPerfTestDisruptor;
-import com.lmax.disruptor.BatchEventProcessor;
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.SequenceBarrier;
-import com.lmax.disruptor.YieldingWaitStrategy;
-import com.lmax.disruptor.support.PerfTestUtil;
-import com.lmax.disruptor.support.ValueAdditionEventHandler;
-import com.lmax.disruptor.support.ValueEvent;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-/**
- * <pre>
- * UniCast a series of items between 1 publisher and 1 event processor.
- *
- * +----+    +-----+
- * | P1 |--->| EP1 |
- * +----+    +-----+
- *
- * Disruptor:
- * ==========
- *              track to prevent wrap
- *              +------------------+
- *              |                  |
- *              |                  v
- * +----+    +====+    +====+   +-----+
- * | P1 |--->| RB |<---| SB |   | EP1 |
- * +----+    +====+    +====+   +-----+
- *      claim      get    ^        |
- *                        |        |
- *                        +--------+
- *                          waitFor
- *
- * P1  - Publisher 1
- * RB  - RingBuffer
- * SB  - SequenceBarrier
- * EP1 - EventProcessor 1
- *
- * </pre>
- */
-public final class OneToOneSequencedThroughputTest extends AbstractPerfTestDisruptor
-{
-    private static final int BUFFER_SIZE = 1024 * 64;
-    private static final long ITERATIONS = 1000L * 1000L * 100L;
-    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);
-    private final long expectedResult = PerfTestUtil.accumulatedAddition(ITERATIONS);
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final RingBuffer<ValueEvent> ringBuffer =
-        createSingleProducer(ValueEvent.EVENT_FACTORY, BUFFER_SIZE, new YieldingWaitStrategy());
-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();
-    private final ValueAdditionEventHandler handler = new ValueAdditionEventHandler();
-    private final BatchEventProcessor<ValueEvent> batchEventProcessor =
-        new BatchEventProcessor<ValueEvent>(ringBuffer, sequenceBarrier, handler);
-
-    {
-        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 2;
-    }
-
-    @Override
-    protected long runDisruptorPass() throws InterruptedException
-    {
-        final CountDownLatch latch = new CountDownLatch(1);
-        long expectedCount = batchEventProcessor.getSequence().get() + ITERATIONS;
-        handler.reset(latch, expectedCount);
-        executor.submit(batchEventProcessor);
-        long start = System.currentTimeMillis();
-
-        final RingBuffer<ValueEvent> rb = ringBuffer;
-
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            long next = rb.next();
-            rb.get(next).setValue(i);
-            rb.publish(next);
-        }
-
-        latch.await();
-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-        waitForEventProcessorSequence(expectedCount);
-        batchEventProcessor.halt();
-
-        failIfNot(expectedResult, handler.getValue());
-
-        return opsPerSecond;
-    }
-
-    private void waitForEventProcessorSequence(long expectedCount) throws InterruptedException
-    {
-        while (batchEventProcessor.getSequence().get() != expectedCount)
-        {
-            Thread.sleep(1);
-        }
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        OneToOneSequencedThroughputTest test = new OneToOneSequencedThroughputTest();
-        test.testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/sequenced/OneToThreeDiamondSequencedThroughputTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/OneToThreeDiamondSequencedThroughputTest.java
deleted file mode 100644
index cd4268a..0000000
--- a/src/perftest/java/com/lmax/disruptor/sequenced/OneToThreeDiamondSequencedThroughputTest.java
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.sequenced;
-
-import static com.lmax.disruptor.RingBuffer.createSingleProducer;
-import static com.lmax.disruptor.support.PerfTestUtil.failIfNot;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
-import com.lmax.disruptor.AbstractPerfTestDisruptor;
-import com.lmax.disruptor.BatchEventProcessor;
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.SequenceBarrier;
-import com.lmax.disruptor.YieldingWaitStrategy;
-import com.lmax.disruptor.support.FizzBuzzEvent;
-import com.lmax.disruptor.support.FizzBuzzEventHandler;
-import com.lmax.disruptor.support.FizzBuzzStep;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-/**
- * <pre>
- * Produce an event replicated to two event processors and fold back to a single third event processor.
- *
- *           +-----+
- *    +----->| EP1 |------+
- *    |      +-----+      |
- *    |                   v
- * +----+              +-----+
- * | P1 |              | EP3 |
- * +----+              +-----+
- *    |                   ^
- *    |      +-----+      |
- *    +----->| EP2 |------+
- *           +-----+
- *
- * Disruptor:
- * ==========
- *                    track to prevent wrap
- *              +-------------------------------+
- *              |                               |
- *              |                               v
- * +----+    +====+               +=====+    +-----+
- * | P1 |--->| RB |<--------------| SB2 |<---| EP3 |
- * +----+    +====+               +=====+    +-----+
- *      claim   ^  get               |   waitFor
- *              |                    |
- *           +=====+    +-----+      |
- *           | SB1 |<---| EP1 |<-----+
- *           +=====+    +-----+      |
- *              ^                    |
- *              |       +-----+      |
- *              +-------| EP2 |<-----+
- *             waitFor  +-----+
- *
- * P1  - Publisher 1
- * RB  - RingBuffer
- * SB1 - SequenceBarrier 1
- * EP1 - EventProcessor 1
- * EP2 - EventProcessor 2
- * SB2 - SequenceBarrier 2
- * EP3 - EventProcessor 3
- *
- * </pre>
- */
-public final class OneToThreeDiamondSequencedThroughputTest extends AbstractPerfTestDisruptor
-{
-    private static final int NUM_EVENT_PROCESSORS = 3;
-    private static final int BUFFER_SIZE = 1024 * 8;
-    private static final long ITERATIONS = 1000L * 1000L * 100L;
-    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_EVENT_PROCESSORS, DaemonThreadFactory.INSTANCE);
-
-    private final long expectedResult;
-
-    {
-        long temp = 0L;
-
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            boolean fizz = 0 == (i % 3L);
-            boolean buzz = 0 == (i % 5L);
-
-            if (fizz && buzz)
-            {
-                ++temp;
-            }
-        }
-
-        expectedResult = temp;
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final RingBuffer<FizzBuzzEvent> ringBuffer =
-        createSingleProducer(FizzBuzzEvent.EVENT_FACTORY, BUFFER_SIZE, new YieldingWaitStrategy());
-
-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();
-
-    private final FizzBuzzEventHandler fizzHandler = new FizzBuzzEventHandler(FizzBuzzStep.FIZZ);
-    private final BatchEventProcessor<FizzBuzzEvent> batchProcessorFizz =
-        new BatchEventProcessor<FizzBuzzEvent>(ringBuffer, sequenceBarrier, fizzHandler);
-
-    private final FizzBuzzEventHandler buzzHandler = new FizzBuzzEventHandler(FizzBuzzStep.BUZZ);
-    private final BatchEventProcessor<FizzBuzzEvent> batchProcessorBuzz =
-        new BatchEventProcessor<FizzBuzzEvent>(ringBuffer, sequenceBarrier, buzzHandler);
-
-    private final SequenceBarrier sequenceBarrierFizzBuzz =
-        ringBuffer.newBarrier(batchProcessorFizz.getSequence(), batchProcessorBuzz.getSequence());
-
-    private final FizzBuzzEventHandler fizzBuzzHandler = new FizzBuzzEventHandler(FizzBuzzStep.FIZZ_BUZZ);
-    private final BatchEventProcessor<FizzBuzzEvent> batchProcessorFizzBuzz =
-        new BatchEventProcessor<FizzBuzzEvent>(ringBuffer, sequenceBarrierFizzBuzz, fizzBuzzHandler);
-
-    {
-        ringBuffer.addGatingSequences(batchProcessorFizzBuzz.getSequence());
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 4;
-    }
-
-    @Override
-    protected long runDisruptorPass() throws Exception
-    {
-        CountDownLatch latch = new CountDownLatch(1);
-        fizzBuzzHandler.reset(latch, batchProcessorFizzBuzz.getSequence().get() + ITERATIONS);
-
-        executor.submit(batchProcessorFizz);
-        executor.submit(batchProcessorBuzz);
-        executor.submit(batchProcessorFizzBuzz);
-
-        long start = System.currentTimeMillis();
-
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            long sequence = ringBuffer.next();
-            ringBuffer.get(sequence).setValue(i);
-            ringBuffer.publish(sequence);
-        }
-
-        latch.await();
-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-
-        batchProcessorFizz.halt();
-        batchProcessorBuzz.halt();
-        batchProcessorFizzBuzz.halt();
-
-        failIfNot(expectedResult, fizzBuzzHandler.getFizzBuzzCounter());
-
-        return opsPerSecond;
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        new OneToThreeDiamondSequencedThroughputTest().testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/sequenced/OneToThreePipelineSequencedThroughputTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/OneToThreePipelineSequencedThroughputTest.java
deleted file mode 100644
index d136eab..0000000
--- a/src/perftest/java/com/lmax/disruptor/sequenced/OneToThreePipelineSequencedThroughputTest.java
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.sequenced;
-
-import static com.lmax.disruptor.RingBuffer.createSingleProducer;
-import static com.lmax.disruptor.support.PerfTestUtil.failIfNot;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
-import com.lmax.disruptor.AbstractPerfTestDisruptor;
-import com.lmax.disruptor.BatchEventProcessor;
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.SequenceBarrier;
-import com.lmax.disruptor.YieldingWaitStrategy;
-import com.lmax.disruptor.support.FunctionEvent;
-import com.lmax.disruptor.support.FunctionEventHandler;
-import com.lmax.disruptor.support.FunctionStep;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-/**
- * <pre>
- *
- * Pipeline a series of stages from a publisher to ultimate event processor.
- * Each event processor depends on the output of the event processor.
- *
- * +----+    +-----+    +-----+    +-----+
- * | P1 |--->| EP1 |--->| EP2 |--->| EP3 |
- * +----+    +-----+    +-----+    +-----+
- *
- *
- * Disruptor:
- * ==========
- *                           track to prevent wrap
- *              +----------------------------------------------------------------+
- *              |                                                                |
- *              |                                                                v
- * +----+    +====+    +=====+    +-----+    +=====+    +-----+    +=====+    +-----+
- * | P1 |--->| RB |    | SB1 |<---| EP1 |<---| SB2 |<---| EP2 |<---| SB3 |<---| EP3 |
- * +----+    +====+    +=====+    +-----+    +=====+    +-----+    +=====+    +-----+
- *      claim   ^  get    |   waitFor           |   waitFor           |  waitFor
- *              |         |                     |                     |
- *              +---------+---------------------+---------------------+
- *        </pre>
- *
- * P1  - Publisher 1
- * RB  - RingBuffer
- * SB1 - SequenceBarrier 1
- * EP1 - EventProcessor 1
- * SB2 - SequenceBarrier 2
- * EP2 - EventProcessor 2
- * SB3 - SequenceBarrier 3
- * EP3 - EventProcessor 3
- *
- * </pre>
- */
-public final class OneToThreePipelineSequencedThroughputTest extends AbstractPerfTestDisruptor
-{
-    private static final int NUM_EVENT_PROCESSORS = 3;
-    private static final int BUFFER_SIZE = 1024 * 8;
-    private static final long ITERATIONS = 1000L * 1000L * 100L;
-    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_EVENT_PROCESSORS, DaemonThreadFactory.INSTANCE);
-
-    private static final long OPERAND_TWO_INITIAL_VALUE = 777L;
-    private final long expectedResult;
-
-    {
-        long temp = 0L;
-        long operandTwo = OPERAND_TWO_INITIAL_VALUE;
-
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            long stepOneResult = i + operandTwo--;
-            long stepTwoResult = stepOneResult + 3;
-
-            if ((stepTwoResult & 4L) == 4L)
-            {
-                ++temp;
-            }
-        }
-
-        expectedResult = temp;
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final RingBuffer<FunctionEvent> ringBuffer =
-        createSingleProducer(FunctionEvent.EVENT_FACTORY, BUFFER_SIZE, new YieldingWaitStrategy());
-
-    private final SequenceBarrier stepOneSequenceBarrier = ringBuffer.newBarrier();
-    private final FunctionEventHandler stepOneFunctionHandler = new FunctionEventHandler(FunctionStep.ONE);
-    private final BatchEventProcessor<FunctionEvent> stepOneBatchProcessor =
-        new BatchEventProcessor<FunctionEvent>(ringBuffer, stepOneSequenceBarrier, stepOneFunctionHandler);
-
-    private final SequenceBarrier stepTwoSequenceBarrier = ringBuffer.newBarrier(stepOneBatchProcessor.getSequence());
-    private final FunctionEventHandler stepTwoFunctionHandler = new FunctionEventHandler(FunctionStep.TWO);
-    private final BatchEventProcessor<FunctionEvent> stepTwoBatchProcessor =
-        new BatchEventProcessor<FunctionEvent>(ringBuffer, stepTwoSequenceBarrier, stepTwoFunctionHandler);
-
-    private final SequenceBarrier stepThreeSequenceBarrier = ringBuffer.newBarrier(stepTwoBatchProcessor.getSequence());
-    private final FunctionEventHandler stepThreeFunctionHandler = new FunctionEventHandler(FunctionStep.THREE);
-    private final BatchEventProcessor<FunctionEvent> stepThreeBatchProcessor =
-        new BatchEventProcessor<FunctionEvent>(ringBuffer, stepThreeSequenceBarrier, stepThreeFunctionHandler);
-
-    {
-        ringBuffer.addGatingSequences(stepThreeBatchProcessor.getSequence());
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 4;
-    }
-
-    @Override
-    protected long runDisruptorPass() throws InterruptedException
-    {
-        CountDownLatch latch = new CountDownLatch(1);
-        stepThreeFunctionHandler.reset(latch, stepThreeBatchProcessor.getSequence().get() + ITERATIONS);
-
-        executor.submit(stepOneBatchProcessor);
-        executor.submit(stepTwoBatchProcessor);
-        executor.submit(stepThreeBatchProcessor);
-
-        long start = System.currentTimeMillis();
-
-        long operandTwo = OPERAND_TWO_INITIAL_VALUE;
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            long sequence = ringBuffer.next();
-            FunctionEvent event = ringBuffer.get(sequence);
-            event.setOperandOne(i);
-            event.setOperandTwo(operandTwo--);
-            ringBuffer.publish(sequence);
-        }
-
-        latch.await();
-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-
-        stepOneBatchProcessor.halt();
-        stepTwoBatchProcessor.halt();
-        stepThreeBatchProcessor.halt();
-
-        failIfNot(expectedResult, stepThreeFunctionHandler.getStepThreeCounter());
-
-        return opsPerSecond;
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        new OneToThreePipelineSequencedThroughputTest().testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/sequenced/OneToThreeSequencedThroughputTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/OneToThreeSequencedThroughputTest.java
deleted file mode 100644
index 6803a97..0000000
--- a/src/perftest/java/com/lmax/disruptor/sequenced/OneToThreeSequencedThroughputTest.java
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.sequenced;
-
-import static com.lmax.disruptor.RingBuffer.createSingleProducer;
-import static com.lmax.disruptor.support.PerfTestUtil.failIfNot;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
-import com.lmax.disruptor.AbstractPerfTestDisruptor;
-import com.lmax.disruptor.BatchEventProcessor;
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.SequenceBarrier;
-import com.lmax.disruptor.YieldingWaitStrategy;
-import com.lmax.disruptor.support.Operation;
-import com.lmax.disruptor.support.ValueEvent;
-import com.lmax.disruptor.support.ValueMutationEventHandler;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-/**
- * <pre>
- *
- * MultiCast a series of items between 1 publisher and 3 event processors.
- *
- *           +-----+
- *    +----->| EP1 |
- *    |      +-----+
- *    |
- * +----+    +-----+
- * | P1 |--->| EP2 |
- * +----+    +-----+
- *    |
- *    |      +-----+
- *    +----->| EP3 |
- *           +-----+
- *
- * Disruptor:
- * ==========
- *                             track to prevent wrap
- *             +--------------------+----------+----------+
- *             |                    |          |          |
- *             |                    v          v          v
- * +----+    +====+    +====+    +-----+    +-----+    +-----+
- * | P1 |--->| RB |<---| SB |    | EP1 |    | EP2 |    | EP3 |
- * +----+    +====+    +====+    +-----+    +-----+    +-----+
- *      claim      get    ^         |          |          |
- *                        |         |          |          |
- *                        +---------+----------+----------+
- *                                      waitFor
- *
- * P1  - Publisher 1
- * RB  - RingBuffer
- * SB  - SequenceBarrier
- * EP1 - EventProcessor 1
- * EP2 - EventProcessor 2
- * EP3 - EventProcessor 3
- *
- * </pre>
- */
-public final class OneToThreeSequencedThroughputTest extends AbstractPerfTestDisruptor
-{
-    private static final int NUM_EVENT_PROCESSORS = 3;
-    private static final int BUFFER_SIZE = 1024 * 8;
-    private static final long ITERATIONS = 1000L * 1000L * 100L;
-    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_EVENT_PROCESSORS, DaemonThreadFactory.INSTANCE);
-
-    private final long[] results = new long[NUM_EVENT_PROCESSORS];
-
-    {
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            results[0] = Operation.ADDITION.op(results[0], i);
-            results[1] = Operation.SUBTRACTION.op(results[1], i);
-            results[2] = Operation.AND.op(results[2], i);
-        }
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final RingBuffer<ValueEvent> ringBuffer =
-        createSingleProducer(ValueEvent.EVENT_FACTORY, BUFFER_SIZE, new YieldingWaitStrategy());
-
-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();
-
-    private final ValueMutationEventHandler[] handlers = new ValueMutationEventHandler[NUM_EVENT_PROCESSORS];
-
-    {
-        handlers[0] = new ValueMutationEventHandler(Operation.ADDITION);
-        handlers[1] = new ValueMutationEventHandler(Operation.SUBTRACTION);
-        handlers[2] = new ValueMutationEventHandler(Operation.AND);
-    }
-
-    private final BatchEventProcessor<?>[] batchEventProcessors = new BatchEventProcessor[NUM_EVENT_PROCESSORS];
-
-    {
-        batchEventProcessors[0] = new BatchEventProcessor<ValueEvent>(ringBuffer, sequenceBarrier, handlers[0]);
-        batchEventProcessors[1] = new BatchEventProcessor<ValueEvent>(ringBuffer, sequenceBarrier, handlers[1]);
-        batchEventProcessors[2] = new BatchEventProcessor<ValueEvent>(ringBuffer, sequenceBarrier, handlers[2]);
-
-        ringBuffer.addGatingSequences(
-            batchEventProcessors[0].getSequence(),
-            batchEventProcessors[1].getSequence(),
-            batchEventProcessors[2].getSequence());
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 4;
-    }
-
-    @Override
-    protected long runDisruptorPass() throws InterruptedException
-    {
-        CountDownLatch latch = new CountDownLatch(NUM_EVENT_PROCESSORS);
-        for (int i = 0; i < NUM_EVENT_PROCESSORS; i++)
-        {
-            handlers[i].reset(latch, batchEventProcessors[i].getSequence().get() + ITERATIONS);
-            executor.submit(batchEventProcessors[i]);
-        }
-
-        long start = System.currentTimeMillis();
-
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            long sequence = ringBuffer.next();
-            ringBuffer.get(sequence).setValue(i);
-            ringBuffer.publish(sequence);
-        }
-
-        latch.await();
-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-        for (int i = 0; i < NUM_EVENT_PROCESSORS; i++)
-        {
-            batchEventProcessors[i].halt();
-            failIfNot(results[i], handlers[i].getValue());
-        }
-
-        return opsPerSecond;
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        new OneToThreeSequencedThroughputTest().testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/sequenced/PingPongSequencedLatencyTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/PingPongSequencedLatencyTest.java
deleted file mode 100644
index 6cb598f..0000000
--- a/src/perftest/java/com/lmax/disruptor/sequenced/PingPongSequencedLatencyTest.java
+++ /dev/null
@@ -1,267 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.sequenced;
-
-import static com.lmax.disruptor.RingBuffer.createSingleProducer;
-
-import java.io.PrintStream;
-import java.util.concurrent.BrokenBarrierException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.CyclicBarrier;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
-import com.lmax.disruptor.*;
-import org.HdrHistogram.Histogram;
-
-import com.lmax.disruptor.support.ValueEvent;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-/**
- * <pre>
- *
- * Ping pongs between 2 event handlers and measures the latency of
- * a round trip.
- *
- * Disruptor:
- * ==========
- *               +----------+
- *               |          |
- *               |   get    V
- *  waitFor   +=====+    +=====+  claim
- *    +------>| SB2 |    | RB2 |<------+
- *    |       +=====+    +=====+       |
- *    |                                |
- * +-----+    +=====+    +=====+    +-----+
- * | EP1 |--->| RB1 |    | SB1 |<---| EP2 |
- * +-----+    +=====+    +=====+    +-----+
- *       claim   ^   get    |  waitFor
- *               |          |
- *               +----------+
- *
- * EP1 - Pinger
- * EP2 - Ponger
- * RB1 - PingBuffer
- * SB1 - PingBarrier
- * RB2 - PongBuffer
- * SB2 - PongBarrier
- *
- * </pre>
- * <p>
- * Note: <b>This test is only useful on a system using an invariant TSC in user space from the System.nanoTime() call.</b>
- */
-public final class PingPongSequencedLatencyTest
-{
-    private static final int BUFFER_SIZE = 1024;
-    private static final long ITERATIONS = 100L * 1000L * 30L;
-    private static final long PAUSE_NANOS = 1000L;
-    private final ExecutorService executor = Executors.newCachedThreadPool(DaemonThreadFactory.INSTANCE);
-
-    private final Histogram histogram = new Histogram(10000000000L, 4);
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final RingBuffer<ValueEvent> pingBuffer =
-        createSingleProducer(ValueEvent.EVENT_FACTORY, BUFFER_SIZE, new BlockingWaitStrategy());
-    private final RingBuffer<ValueEvent> pongBuffer =
-        createSingleProducer(ValueEvent.EVENT_FACTORY, BUFFER_SIZE, new BlockingWaitStrategy());
-
-    private final SequenceBarrier pongBarrier = pongBuffer.newBarrier();
-    private final Pinger pinger = new Pinger(pingBuffer, ITERATIONS, PAUSE_NANOS);
-    private final BatchEventProcessor<ValueEvent> pingProcessor =
-        new BatchEventProcessor<ValueEvent>(pongBuffer, pongBarrier, pinger);
-
-    private final SequenceBarrier pingBarrier = pingBuffer.newBarrier();
-    private final Ponger ponger = new Ponger(pongBuffer);
-    private final BatchEventProcessor<ValueEvent> pongProcessor =
-        new BatchEventProcessor<ValueEvent>(pingBuffer, pingBarrier, ponger);
-
-    {
-        pingBuffer.addGatingSequences(pongProcessor.getSequence());
-        pongBuffer.addGatingSequences(pingProcessor.getSequence());
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    public void shouldCompareDisruptorVsQueues() throws Exception
-    {
-        final int runs = 3;
-
-        for (int i = 0; i < runs; i++)
-        {
-            System.gc();
-            histogram.reset();
-
-            runDisruptorPass();
-
-            System.out.format("%s run %d Disruptor %s\n", getClass().getSimpleName(), Long.valueOf(i), histogram);
-            dumpHistogram(histogram, System.out);
-        }
-    }
-
-    private static void dumpHistogram(final Histogram histogram, final PrintStream out)
-    {
-        histogram.outputPercentileDistribution(out, 1, 1000.0);
-    }
-
-    private void runDisruptorPass() throws InterruptedException, BrokenBarrierException
-    {
-        final CountDownLatch latch = new CountDownLatch(1);
-        final CyclicBarrier barrier = new CyclicBarrier(3);
-        pinger.reset(barrier, latch, histogram);
-        ponger.reset(barrier);
-
-        executor.submit(pongProcessor);
-        executor.submit(pingProcessor);
-
-        barrier.await();
-        latch.await();
-
-        pingProcessor.halt();
-        pongProcessor.halt();
-    }
-
-    public static void main(final String[] args) throws Exception
-    {
-        final PingPongSequencedLatencyTest test = new PingPongSequencedLatencyTest();
-        test.shouldCompareDisruptorVsQueues();
-    }
-
-    private static class Pinger implements EventHandler<ValueEvent>, LifecycleAware
-    {
-        private final RingBuffer<ValueEvent> buffer;
-        private final long maxEvents;
-        private final long pauseTimeNs;
-
-        private long counter = 0;
-        private CyclicBarrier barrier;
-        private CountDownLatch latch;
-        private Histogram histogram;
-        private long t0;
-
-        Pinger(final RingBuffer<ValueEvent> buffer, final long maxEvents, final long pauseTimeNs)
-        {
-            this.buffer = buffer;
-            this.maxEvents = maxEvents;
-            this.pauseTimeNs = pauseTimeNs;
-        }
-
-        @Override
-        public void onEvent(final ValueEvent event, final long sequence, final boolean endOfBatch) throws Exception
-        {
-            final long t1 = System.nanoTime();
-
-            histogram.recordValueWithExpectedInterval(t1 - t0, pauseTimeNs);
-
-            if (event.getValue() < maxEvents)
-            {
-                while (pauseTimeNs > (System.nanoTime() - t1))
-                {
-                    Thread.yield();
-                }
-
-                send();
-            }
-            else
-            {
-                latch.countDown();
-            }
-        }
-
-        private void send()
-        {
-            t0 = System.nanoTime();
-            final long next = buffer.next();
-            buffer.get(next).setValue(counter);
-            buffer.publish(next);
-
-            counter++;
-        }
-
-        @Override
-        public void onStart()
-        {
-            try
-            {
-                barrier.await();
-
-                Thread.sleep(1000);
-                send();
-            }
-            catch (final Exception e)
-            {
-                throw new RuntimeException(e);
-            }
-        }
-
-        @Override
-        public void onShutdown()
-        {
-        }
-
-        public void reset(final CyclicBarrier barrier, final CountDownLatch latch, final Histogram histogram)
-        {
-            this.histogram = histogram;
-            this.barrier = barrier;
-            this.latch = latch;
-
-            counter = 0;
-        }
-    }
-
-    private static class Ponger implements EventHandler<ValueEvent>, LifecycleAware
-    {
-        private final RingBuffer<ValueEvent> buffer;
-
-        private CyclicBarrier barrier;
-
-        Ponger(final RingBuffer<ValueEvent> buffer)
-        {
-            this.buffer = buffer;
-        }
-
-        @Override
-        public void onEvent(final ValueEvent event, final long sequence, final boolean endOfBatch) throws Exception
-        {
-            final long next = buffer.next();
-            buffer.get(next).setValue(event.getValue());
-            buffer.publish(next);
-        }
-
-        @Override
-        public void onStart()
-        {
-            try
-            {
-                barrier.await();
-            }
-            catch (final Exception e)
-            {
-                throw new RuntimeException(e);
-            }
-        }
-
-        @Override
-        public void onShutdown()
-        {
-        }
-
-        public void reset(final CyclicBarrier barrier)
-        {
-            this.barrier = barrier;
-        }
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/sequenced/ThreeToOneSequencedBatchThroughputTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/ThreeToOneSequencedBatchThroughputTest.java
deleted file mode 100644
index a09fa53..0000000
--- a/src/perftest/java/com/lmax/disruptor/sequenced/ThreeToOneSequencedBatchThroughputTest.java
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.sequenced;
-
-import static com.lmax.disruptor.RingBuffer.createMultiProducer;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.CyclicBarrier;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-
-import com.lmax.disruptor.AbstractPerfTestDisruptor;
-import com.lmax.disruptor.BatchEventProcessor;
-import com.lmax.disruptor.BusySpinWaitStrategy;
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.SequenceBarrier;
-import com.lmax.disruptor.support.ValueAdditionEventHandler;
-import com.lmax.disruptor.support.ValueBatchPublisher;
-import com.lmax.disruptor.support.ValueEvent;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-/**
- * <pre>
- *
- * Sequence a series of events from multiple publishers going to one event processor.
- *
- * +----+
- * | P1 |------+
- * +----+      |
- *             v
- * +----+    +-----+
- * | P1 |--->| EP1 |
- * +----+    +-----+
- *             ^
- * +----+      |
- * | P3 |------+
- * +----+
- *
- * Disruptor:
- * ==========
- *             track to prevent wrap
- *             +--------------------+
- *             |                    |
- *             |                    v
- * +----+    +====+    +====+    +-----+
- * | P1 |--->| RB |<---| SB |    | EP1 |
- * +----+    +====+    +====+    +-----+
- *             ^   get    ^         |
- * +----+      |          |         |
- * | P2 |------+          +---------+
- * +----+      |            waitFor
- *             |
- * +----+      |
- * | P3 |------+
- * +----+
- *
- * P1  - Publisher 1
- * P2  - Publisher 2
- * P3  - Publisher 3
- * RB  - RingBuffer
- * SB  - SequenceBarrier
- * EP1 - EventProcessor 1
- *
- * </pre>
- *
- * @author mikeb01
- */
-public final class ThreeToOneSequencedBatchThroughputTest extends AbstractPerfTestDisruptor
-{
-    private static final int NUM_PUBLISHERS = 3;
-    private static final int BUFFER_SIZE = 1024 * 64;
-    private static final long ITERATIONS = 1000L * 1000L * 100L;
-    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_PUBLISHERS + 1, DaemonThreadFactory.INSTANCE);
-    private final CyclicBarrier cyclicBarrier = new CyclicBarrier(NUM_PUBLISHERS + 1);
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final RingBuffer<ValueEvent> ringBuffer =
-        createMultiProducer(ValueEvent.EVENT_FACTORY, BUFFER_SIZE, new BusySpinWaitStrategy());
-
-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();
-    private final ValueAdditionEventHandler handler = new ValueAdditionEventHandler();
-    private final BatchEventProcessor<ValueEvent> batchEventProcessor =
-        new BatchEventProcessor<ValueEvent>(ringBuffer, sequenceBarrier, handler);
-    private final ValueBatchPublisher[] valuePublishers = new ValueBatchPublisher[NUM_PUBLISHERS];
-
-    {
-        for (int i = 0; i < NUM_PUBLISHERS; i++)
-        {
-            valuePublishers[i] = new ValueBatchPublisher(cyclicBarrier, ringBuffer, ITERATIONS / NUM_PUBLISHERS, 10);
-        }
-
-        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 4;
-    }
-
-    @Override
-    protected long runDisruptorPass() throws Exception
-    {
-        final CountDownLatch latch = new CountDownLatch(1);
-        handler
-            .reset(latch, batchEventProcessor.getSequence().get() + ((ITERATIONS / NUM_PUBLISHERS) * NUM_PUBLISHERS));
-
-        Future<?>[] futures = new Future[NUM_PUBLISHERS];
-        for (int i = 0; i < NUM_PUBLISHERS; i++)
-        {
-            futures[i] = executor.submit(valuePublishers[i]);
-        }
-        executor.submit(batchEventProcessor);
-
-        long start = System.currentTimeMillis();
-        cyclicBarrier.await();
-
-        for (int i = 0; i < NUM_PUBLISHERS; i++)
-        {
-            futures[i].get();
-        }
-
-        latch.await();
-
-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-        batchEventProcessor.halt();
-
-        return opsPerSecond;
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        new ThreeToOneSequencedBatchThroughputTest().testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/sequenced/ThreeToOneSequencedThroughputTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/ThreeToOneSequencedThroughputTest.java
deleted file mode 100644
index a3aac27..0000000
--- a/src/perftest/java/com/lmax/disruptor/sequenced/ThreeToOneSequencedThroughputTest.java
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.sequenced;
-
-import static com.lmax.disruptor.RingBuffer.createMultiProducer;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.CyclicBarrier;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-
-import com.lmax.disruptor.AbstractPerfTestDisruptor;
-import com.lmax.disruptor.BatchEventProcessor;
-import com.lmax.disruptor.BusySpinWaitStrategy;
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.SequenceBarrier;
-import com.lmax.disruptor.support.ValueAdditionEventHandler;
-import com.lmax.disruptor.support.ValueEvent;
-import com.lmax.disruptor.support.ValuePublisher;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-/**
- * <pre>
- *
- * Sequence a series of events from multiple publishers going to one event processor.
- *
- * +----+
- * | P1 |------+
- * +----+      |
- *             v
- * +----+    +-----+
- * | P1 |--->| EP1 |
- * +----+    +-----+
- *             ^
- * +----+      |
- * | P3 |------+
- * +----+
- *
- *
- * Disruptor:
- * ==========
- *             track to prevent wrap
- *             +--------------------+
- *             |                    |
- *             |                    v
- * +----+    +====+    +====+    +-----+
- * | P1 |--->| RB |<---| SB |    | EP1 |
- * +----+    +====+    +====+    +-----+
- *             ^   get    ^         |
- * +----+      |          |         |
- * | P2 |------+          +---------+
- * +----+      |            waitFor
- *             |
- * +----+      |
- * | P3 |------+
- * +----+
- *
- * P1  - Publisher 1
- * P2  - Publisher 2
- * P3  - Publisher 3
- * RB  - RingBuffer
- * SB  - SequenceBarrier
- * EP1 - EventProcessor 1
- *
- * </pre>
- */
-public final class ThreeToOneSequencedThroughputTest extends AbstractPerfTestDisruptor
-{
-    private static final int NUM_PUBLISHERS = 3;
-    private static final int BUFFER_SIZE = 1024 * 64;
-    private static final long ITERATIONS = 1000L * 1000L * 20L;
-    private final ExecutorService executor =
-        Executors.newFixedThreadPool(NUM_PUBLISHERS + 1, DaemonThreadFactory.INSTANCE);
-    private final CyclicBarrier cyclicBarrier = new CyclicBarrier(NUM_PUBLISHERS + 1);
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final RingBuffer<ValueEvent> ringBuffer =
-        createMultiProducer(ValueEvent.EVENT_FACTORY, BUFFER_SIZE, new BusySpinWaitStrategy());
-
-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();
-    private final ValueAdditionEventHandler handler = new ValueAdditionEventHandler();
-    private final BatchEventProcessor<ValueEvent> batchEventProcessor =
-        new BatchEventProcessor<ValueEvent>(ringBuffer, sequenceBarrier, handler);
-    private final ValuePublisher[] valuePublishers = new ValuePublisher[NUM_PUBLISHERS];
-
-    {
-        for (int i = 0; i < NUM_PUBLISHERS; i++)
-        {
-            valuePublishers[i] = new ValuePublisher(cyclicBarrier, ringBuffer, ITERATIONS / NUM_PUBLISHERS);
-        }
-
-        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 4;
-    }
-
-    @Override
-    protected long runDisruptorPass() throws Exception
-    {
-        final CountDownLatch latch = new CountDownLatch(1);
-        handler
-            .reset(latch, batchEventProcessor.getSequence().get() + ((ITERATIONS / NUM_PUBLISHERS) * NUM_PUBLISHERS));
-
-        Future<?>[] futures = new Future[NUM_PUBLISHERS];
-        for (int i = 0; i < NUM_PUBLISHERS; i++)
-        {
-            futures[i] = executor.submit(valuePublishers[i]);
-        }
-        executor.submit(batchEventProcessor);
-
-        long start = System.currentTimeMillis();
-        cyclicBarrier.await();
-
-        for (int i = 0; i < NUM_PUBLISHERS; i++)
-        {
-            futures[i].get();
-        }
-
-        latch.await();
-
-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-        batchEventProcessor.halt();
-
-        return opsPerSecond;
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        new ThreeToOneSequencedThroughputTest().testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/sequenced/ThreeToThreeSequencedThroughputTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/ThreeToThreeSequencedThroughputTest.java
deleted file mode 100644
index 16aaae3..0000000
--- a/src/perftest/java/com/lmax/disruptor/sequenced/ThreeToThreeSequencedThroughputTest.java
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.sequenced;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.CyclicBarrier;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-
-import com.lmax.disruptor.AbstractPerfTestDisruptor;
-import com.lmax.disruptor.EventFactory;
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.SequenceBarrier;
-import com.lmax.disruptor.YieldingWaitStrategy;
-import com.lmax.disruptor.support.LongArrayEventHandler;
-import com.lmax.disruptor.support.LongArrayPublisher;
-import com.lmax.disruptor.support.MultiBufferBatchEventProcessor;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-/**
- * <pre>
- *
- * Sequence a series of events from multiple publishers going to one event processor.
- *
- * Disruptor:
- * ==========
- *             track to prevent wrap
- *             +--------------------+
- *             |                    |
- *             |                    |
- * +----+    +====+    +====+       |
- * | P1 |--->| RB |--->| SB |--+    |
- * +----+    +====+    +====+  |    |
- *                             |    v
- * +----+    +====+    +====+  | +----+
- * | P2 |--->| RB |--->| SB |--+>| EP |
- * +----+    +====+    +====+  | +----+
- *                             |
- * +----+    +====+    +====+  |
- * | P3 |--->| RB |--->| SB |--+
- * +----+    +====+    +====+
- *
- * P1 - Publisher 1
- * P2 - Publisher 2
- * P3 - Publisher 3
- * RB - RingBuffer
- * SB - SequenceBarrier
- * EP - EventProcessor
- *
- * </pre>
- */
-public final class ThreeToThreeSequencedThroughputTest extends AbstractPerfTestDisruptor
-{
-    private static final int NUM_PUBLISHERS = 3;
-    private static final int ARRAY_SIZE = 3;
-    private static final int BUFFER_SIZE = 1024 * 64;
-    private static final long ITERATIONS = 1000L * 1000L * 180L;
-    private final ExecutorService executor =
-        Executors.newFixedThreadPool(NUM_PUBLISHERS + 1, DaemonThreadFactory.INSTANCE);
-    private final CyclicBarrier cyclicBarrier = new CyclicBarrier(NUM_PUBLISHERS + 1);
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @SuppressWarnings("unchecked")
-    private final RingBuffer<long[]>[] buffers = new RingBuffer[NUM_PUBLISHERS];
-    private final SequenceBarrier[] barriers = new SequenceBarrier[NUM_PUBLISHERS];
-    private final LongArrayPublisher[] valuePublishers = new LongArrayPublisher[NUM_PUBLISHERS];
-
-    private final LongArrayEventHandler handler = new LongArrayEventHandler();
-    private final MultiBufferBatchEventProcessor<long[]> batchEventProcessor;
-
-    private static final EventFactory<long[]> FACTORY = new EventFactory<long[]>()
-    {
-        @Override
-        public long[] newInstance()
-        {
-            return new long[ARRAY_SIZE];
-        }
-    };
-
-    {
-        for (int i = 0; i < NUM_PUBLISHERS; i++)
-        {
-            buffers[i] = RingBuffer.createSingleProducer(FACTORY, BUFFER_SIZE, new YieldingWaitStrategy());
-            barriers[i] = buffers[i].newBarrier();
-            valuePublishers[i] = new LongArrayPublisher(
-                cyclicBarrier,
-                buffers[i],
-                ITERATIONS / NUM_PUBLISHERS,
-                ARRAY_SIZE);
-        }
-
-        batchEventProcessor = new MultiBufferBatchEventProcessor<long[]>(buffers, barriers, handler);
-
-        for (int i = 0; i < NUM_PUBLISHERS; i++)
-        {
-            buffers[i].addGatingSequences(batchEventProcessor.getSequences()[i]);
-        }
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 4;
-    }
-
-    @Override
-    protected long runDisruptorPass() throws Exception
-    {
-        final CountDownLatch latch = new CountDownLatch(1);
-        handler.reset(latch, ITERATIONS);
-
-        Future<?>[] futures = new Future[NUM_PUBLISHERS];
-        for (int i = 0; i < NUM_PUBLISHERS; i++)
-        {
-            futures[i] = executor.submit(valuePublishers[i]);
-        }
-        executor.submit(batchEventProcessor);
-
-        long start = System.currentTimeMillis();
-        cyclicBarrier.await();
-
-        for (int i = 0; i < NUM_PUBLISHERS; i++)
-        {
-            futures[i].get();
-        }
-
-        latch.await();
-
-        long opsPerSecond = (ITERATIONS * 1000L * ARRAY_SIZE) / (System.currentTimeMillis() - start);
-        batchEventProcessor.halt();
-
-        return opsPerSecond;
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        new ThreeToThreeSequencedThroughputTest().testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/EventCountingAndReleasingWorkHandler.java b/src/perftest/java/com/lmax/disruptor/support/EventCountingAndReleasingWorkHandler.java
deleted file mode 100644
index 103133c..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/EventCountingAndReleasingWorkHandler.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import com.lmax.disruptor.EventReleaseAware;
-import com.lmax.disruptor.EventReleaser;
-import com.lmax.disruptor.WorkHandler;
-import com.lmax.disruptor.util.PaddedLong;
-
-public final class EventCountingAndReleasingWorkHandler
-    implements WorkHandler<ValueEvent>, EventReleaseAware
-{
-    private final PaddedLong[] counters;
-    private final int index;
-    private EventReleaser eventReleaser;
-
-    public EventCountingAndReleasingWorkHandler(final PaddedLong[] counters, final int index)
-    {
-        this.counters = counters;
-        this.index = index;
-    }
-
-    @Override
-    public void onEvent(final ValueEvent event) throws Exception
-    {
-        eventReleaser.release();
-        counters[index].set(counters[index].get() + 1L);
-    }
-
-    @Override
-    public void setEventReleaser(final EventReleaser eventReleaser)
-    {
-        this.eventReleaser = eventReleaser;
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/EventCountingQueueProcessor.java b/src/perftest/java/com/lmax/disruptor/support/EventCountingQueueProcessor.java
deleted file mode 100644
index 091348d..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/EventCountingQueueProcessor.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import com.lmax.disruptor.util.PaddedLong;
-
-import java.util.concurrent.BlockingQueue;
-
-public final class EventCountingQueueProcessor implements Runnable
-{
-    private volatile boolean running;
-    private final BlockingQueue<Long> blockingQueue;
-    private final PaddedLong[] counters;
-    private final int index;
-
-    public EventCountingQueueProcessor(
-        final BlockingQueue<Long> blockingQueue, final PaddedLong[] counters, final int index)
-    {
-        this.blockingQueue = blockingQueue;
-        this.counters = counters;
-        this.index = index;
-    }
-
-    public void halt()
-    {
-        running = false;
-    }
-
-    @Override
-    public void run()
-    {
-        running = true;
-        while (running)
-        {
-            try
-            {
-                blockingQueue.take();
-                counters[index].set(counters[index].get() + 1L);
-            }
-            catch (InterruptedException ex)
-            {
-                break;
-            }
-        }
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/EventCountingWorkHandler.java b/src/perftest/java/com/lmax/disruptor/support/EventCountingWorkHandler.java
deleted file mode 100644
index 5bac8f1..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/EventCountingWorkHandler.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import com.lmax.disruptor.WorkHandler;
-import com.lmax.disruptor.util.PaddedLong;
-
-public final class EventCountingWorkHandler
-    implements WorkHandler<ValueEvent>
-{
-    private final PaddedLong[] counters;
-    private final int index;
-
-    public EventCountingWorkHandler(final PaddedLong[] counters, final int index)
-    {
-        this.counters = counters;
-        this.index = index;
-    }
-
-    @Override
-    public void onEvent(final ValueEvent event) throws Exception
-    {
-        counters[index].set(counters[index].get() + 1L);
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/FizzBuzzEvent.java b/src/perftest/java/com/lmax/disruptor/support/FizzBuzzEvent.java
deleted file mode 100644
index 81755bc..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/FizzBuzzEvent.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import com.lmax.disruptor.EventFactory;
-
-public final class FizzBuzzEvent
-{
-    private boolean fizz = false;
-    private boolean buzz = false;
-    private long value = 0;
-
-    public long getValue()
-    {
-        return value;
-    }
-
-    public void setValue(final long value)
-    {
-        fizz = false;
-        buzz = false;
-        this.value = value;
-    }
-
-    public boolean isFizz()
-    {
-        return fizz;
-    }
-
-    public void setFizz(final boolean fizz)
-    {
-        this.fizz = fizz;
-    }
-
-    public boolean isBuzz()
-    {
-        return buzz;
-    }
-
-    public void setBuzz(final boolean buzz)
-    {
-        this.buzz = buzz;
-    }
-
-    public static final EventFactory<FizzBuzzEvent> EVENT_FACTORY = new EventFactory<FizzBuzzEvent>()
-    {
-        public FizzBuzzEvent newInstance()
-        {
-            return new FizzBuzzEvent();
-        }
-    };
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/FizzBuzzEventHandler.java b/src/perftest/java/com/lmax/disruptor/support/FizzBuzzEventHandler.java
deleted file mode 100644
index cb0bdeb..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/FizzBuzzEventHandler.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.util.PaddedLong;
-
-import java.util.concurrent.CountDownLatch;
-
-public final class FizzBuzzEventHandler implements EventHandler<FizzBuzzEvent>
-{
-    private final FizzBuzzStep fizzBuzzStep;
-    private final PaddedLong fizzBuzzCounter = new PaddedLong();
-    private long count;
-    private CountDownLatch latch;
-
-    public FizzBuzzEventHandler(final FizzBuzzStep fizzBuzzStep)
-    {
-        this.fizzBuzzStep = fizzBuzzStep;
-    }
-
-    public void reset(final CountDownLatch latch, final long expectedCount)
-    {
-        fizzBuzzCounter.set(0L);
-        this.latch = latch;
-        count = expectedCount;
-    }
-
-    public long getFizzBuzzCounter()
-    {
-        return fizzBuzzCounter.get();
-    }
-
-    @Override
-    public void onEvent(final FizzBuzzEvent event, final long sequence, final boolean endOfBatch) throws Exception
-    {
-        switch (fizzBuzzStep)
-        {
-            case FIZZ:
-                if (0 == (event.getValue() % 3))
-                {
-                    event.setFizz(true);
-                }
-                break;
-
-            case BUZZ:
-                if (0 == (event.getValue() % 5))
-                {
-                    event.setBuzz(true);
-                }
-                break;
-
-            case FIZZ_BUZZ:
-                if (event.isFizz() && event.isBuzz())
-                {
-                    fizzBuzzCounter.set(fizzBuzzCounter.get() + 1L);
-                }
-                break;
-        }
-
-        if (latch != null && count == sequence)
-        {
-            latch.countDown();
-        }
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/FizzBuzzQueueProcessor.java b/src/perftest/java/com/lmax/disruptor/support/FizzBuzzQueueProcessor.java
deleted file mode 100644
index 06ec3f7..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/FizzBuzzQueueProcessor.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.CountDownLatch;
-
-public final class FizzBuzzQueueProcessor implements Runnable
-{
-    private final FizzBuzzStep fizzBuzzStep;
-    private final BlockingQueue<Long> fizzInputQueue;
-    private final BlockingQueue<Long> buzzInputQueue;
-    private final BlockingQueue<Boolean> fizzOutputQueue;
-    private final BlockingQueue<Boolean> buzzOutputQueue;
-    private final long count;
-
-    private volatile boolean running;
-    private long fizzBuzzCounter = 0;
-    private long sequence;
-    private CountDownLatch latch = null;
-
-    public FizzBuzzQueueProcessor(
-        final FizzBuzzStep fizzBuzzStep,
-        final BlockingQueue<Long> fizzInputQueue,
-        final BlockingQueue<Long> buzzInputQueue,
-        final BlockingQueue<Boolean> fizzOutputQueue,
-        final BlockingQueue<Boolean> buzzOutputQueue, final long count)
-    {
-        this.fizzBuzzStep = fizzBuzzStep;
-
-        this.fizzInputQueue = fizzInputQueue;
-        this.buzzInputQueue = buzzInputQueue;
-        this.fizzOutputQueue = fizzOutputQueue;
-        this.buzzOutputQueue = buzzOutputQueue;
-        this.count = count;
-    }
-
-    public long getFizzBuzzCounter()
-    {
-        return fizzBuzzCounter;
-    }
-
-    public void reset(final CountDownLatch latch)
-    {
-        fizzBuzzCounter = 0L;
-        sequence = 0L;
-        this.latch = latch;
-    }
-
-    public void halt()
-    {
-        running = false;
-    }
-
-    @Override
-    public void run()
-    {
-        running = true;
-        while (true)
-        {
-            try
-            {
-                switch (fizzBuzzStep)
-                {
-                    case FIZZ:
-                    {
-                        Long value = fizzInputQueue.take();
-                        fizzOutputQueue.put(Boolean.valueOf(0 == (value.longValue() % 3)));
-                        break;
-                    }
-
-                    case BUZZ:
-                    {
-                        Long value = buzzInputQueue.take();
-                        buzzOutputQueue.put(Boolean.valueOf(0 == (value.longValue() % 5)));
-                        break;
-                    }
-
-                    case FIZZ_BUZZ:
-                    {
-                        final boolean fizz = fizzOutputQueue.take().booleanValue();
-                        final boolean buzz = buzzOutputQueue.take().booleanValue();
-                        if (fizz && buzz)
-                        {
-                            ++fizzBuzzCounter;
-                        }
-                        break;
-                    }
-                }
-
-                if (null != latch && sequence++ == count)
-                {
-                    latch.countDown();
-                }
-            }
-            catch (InterruptedException ex)
-            {
-                if (!running)
-                {
-                    break;
-                }
-            }
-        }
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/FizzBuzzStep.java b/src/perftest/java/com/lmax/disruptor/support/FizzBuzzStep.java
deleted file mode 100644
index 04ce65a..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/FizzBuzzStep.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-public enum FizzBuzzStep
-{
-    FIZZ,
-    BUZZ,
-    FIZZ_BUZZ,
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/FunctionEvent.java b/src/perftest/java/com/lmax/disruptor/support/FunctionEvent.java
deleted file mode 100644
index 92492cb..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/FunctionEvent.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import com.lmax.disruptor.EventFactory;
-
-public final class FunctionEvent
-{
-    private long operandOne;
-    private long operandTwo;
-    private long stepOneResult;
-    private long stepTwoResult;
-
-    public long getOperandOne()
-    {
-        return operandOne;
-    }
-
-    public void setOperandOne(final long operandOne)
-    {
-        this.operandOne = operandOne;
-    }
-
-    public long getOperandTwo()
-    {
-        return operandTwo;
-    }
-
-    public void setOperandTwo(final long operandTwo)
-    {
-        this.operandTwo = operandTwo;
-    }
-
-    public long getStepOneResult()
-    {
-        return stepOneResult;
-    }
-
-    public void setStepOneResult(final long stepOneResult)
-    {
-        this.stepOneResult = stepOneResult;
-    }
-
-    public long getStepTwoResult()
-    {
-        return stepTwoResult;
-    }
-
-    public void setStepTwoResult(final long stepTwoResult)
-    {
-        this.stepTwoResult = stepTwoResult;
-    }
-
-    public static final EventFactory<FunctionEvent> EVENT_FACTORY = new EventFactory<FunctionEvent>()
-    {
-        public FunctionEvent newInstance()
-        {
-            return new FunctionEvent();
-        }
-    };
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/FunctionEventHandler.java b/src/perftest/java/com/lmax/disruptor/support/FunctionEventHandler.java
deleted file mode 100644
index 0d636cf..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/FunctionEventHandler.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.util.PaddedLong;
-
-import java.util.concurrent.CountDownLatch;
-
-public final class FunctionEventHandler implements EventHandler<FunctionEvent>
-{
-    private final FunctionStep functionStep;
-    private final PaddedLong stepThreeCounter = new PaddedLong();
-    private long count;
-    private CountDownLatch latch;
-
-    public FunctionEventHandler(final FunctionStep functionStep)
-    {
-        this.functionStep = functionStep;
-    }
-
-    public long getStepThreeCounter()
-    {
-        return stepThreeCounter.get();
-    }
-
-    public void reset(final CountDownLatch latch, final long expectedCount)
-    {
-        stepThreeCounter.set(0L);
-        this.latch = latch;
-        count = expectedCount;
-    }
-
-    @Override
-    public void onEvent(final FunctionEvent event, final long sequence, final boolean endOfBatch) throws Exception
-    {
-        switch (functionStep)
-        {
-            case ONE:
-                event.setStepOneResult(event.getOperandOne() + event.getOperandTwo());
-                break;
-
-            case TWO:
-                event.setStepTwoResult(event.getStepOneResult() + 3L);
-                break;
-
-            case THREE:
-                if ((event.getStepTwoResult() & 4L) == 4L)
-                {
-                    stepThreeCounter.set(stepThreeCounter.get() + 1L);
-                }
-                break;
-        }
-
-        if (latch != null && count == sequence)
-        {
-            latch.countDown();
-        }
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/FunctionQueueProcessor.java b/src/perftest/java/com/lmax/disruptor/support/FunctionQueueProcessor.java
deleted file mode 100644
index e6af4d7..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/FunctionQueueProcessor.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.CountDownLatch;
-
-public final class FunctionQueueProcessor implements Runnable
-{
-    private final FunctionStep functionStep;
-    private final BlockingQueue<long[]> stepOneQueue;
-    private final BlockingQueue<Long> stepTwoQueue;
-    private final BlockingQueue<Long> stepThreeQueue;
-    private final long count;
-
-    private volatile boolean running;
-    private long stepThreeCounter;
-    private long sequence;
-    private CountDownLatch latch;
-
-    public FunctionQueueProcessor(
-        final FunctionStep functionStep,
-        final BlockingQueue<long[]> stepOneQueue,
-        final BlockingQueue<Long> stepTwoQueue,
-        final BlockingQueue<Long> stepThreeQueue,
-        final long count)
-    {
-        this.functionStep = functionStep;
-        this.stepOneQueue = stepOneQueue;
-        this.stepTwoQueue = stepTwoQueue;
-        this.stepThreeQueue = stepThreeQueue;
-        this.count = count;
-    }
-
-    public long getStepThreeCounter()
-    {
-        return stepThreeCounter;
-    }
-
-    public void reset(final CountDownLatch latch)
-    {
-        stepThreeCounter = 0L;
-        sequence = 0L;
-        this.latch = latch;
-    }
-
-    public void halt()
-    {
-        running = false;
-    }
-
-    @Override
-    public void run()
-    {
-        running = true;
-        while (true)
-        {
-            try
-            {
-                switch (functionStep)
-                {
-                    case ONE:
-                    {
-                        long[] values = stepOneQueue.take();
-                        stepTwoQueue.put(Long.valueOf(values[0] + values[1]));
-                        break;
-                    }
-
-                    case TWO:
-                    {
-                        Long value = stepTwoQueue.take();
-                        stepThreeQueue.put(Long.valueOf(value.longValue() + 3));
-                        break;
-                    }
-
-                    case THREE:
-                    {
-                        Long value = stepThreeQueue.take();
-                        long testValue = value.longValue();
-                        if ((testValue & 4L) == 4L)
-                        {
-                            ++stepThreeCounter;
-                        }
-                        break;
-                    }
-                }
-
-                if (null != latch && sequence++ == count)
-                {
-                    latch.countDown();
-                }
-            }
-            catch (InterruptedException ex)
-            {
-                if (!running)
-                {
-                    break;
-                }
-            }
-        }
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/FunctionStep.java b/src/perftest/java/com/lmax/disruptor/support/FunctionStep.java
deleted file mode 100644
index 3822172..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/FunctionStep.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-public enum FunctionStep
-{
-    ONE,
-    TWO,
-    THREE
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/LongArrayEventHandler.java b/src/perftest/java/com/lmax/disruptor/support/LongArrayEventHandler.java
deleted file mode 100644
index 2691047..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/LongArrayEventHandler.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import java.util.concurrent.CountDownLatch;
-
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.util.PaddedLong;
-
-public final class LongArrayEventHandler implements EventHandler<long[]>
-{
-    private final PaddedLong value = new PaddedLong();
-    private long count;
-    private CountDownLatch latch;
-
-    public long getValue()
-    {
-        return value.get();
-    }
-
-    public void reset(final CountDownLatch latch, final long expectedCount)
-    {
-        value.set(0L);
-        this.latch = latch;
-        count = expectedCount;
-    }
-
-    @Override
-    public void onEvent(final long[] event, final long sequence, final boolean endOfBatch) throws Exception
-    {
-        for (int i = 0; i < event.length; i++)
-        {
-            value.set(value.get() + event[i]);
-        }
-
-        if (--count == 0)
-        {
-            latch.countDown();
-        }
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/LongArrayPublisher.java b/src/perftest/java/com/lmax/disruptor/support/LongArrayPublisher.java
deleted file mode 100644
index 85cc66b..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/LongArrayPublisher.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import java.util.concurrent.CyclicBarrier;
-
-import com.lmax.disruptor.RingBuffer;
-
-public final class LongArrayPublisher implements Runnable
-{
-    private final CyclicBarrier cyclicBarrier;
-    private final RingBuffer<long[]> ringBuffer;
-    private final long iterations;
-    private final long arraySize;
-
-    public LongArrayPublisher(
-        final CyclicBarrier cyclicBarrier,
-        final RingBuffer<long[]> ringBuffer,
-        final long iterations,
-        final long arraySize)
-    {
-        this.cyclicBarrier = cyclicBarrier;
-        this.ringBuffer = ringBuffer;
-        this.iterations = iterations;
-        this.arraySize = arraySize;
-    }
-
-    @Override
-    public void run()
-    {
-        try
-        {
-            cyclicBarrier.await();
-
-            for (long i = 0; i < iterations; i++)
-            {
-                long sequence = ringBuffer.next();
-                long[] event = ringBuffer.get(sequence);
-                for (int j = 0; j < arraySize; j++)
-                {
-                    event[j] = i + j;
-                }
-                ringBuffer.publish(sequence);
-            }
-        }
-        catch (Exception ex)
-        {
-            throw new RuntimeException(ex);
-        }
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/MultiBufferBatchEventProcessor.java b/src/perftest/java/com/lmax/disruptor/support/MultiBufferBatchEventProcessor.java
deleted file mode 100644
index cc87eb2..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/MultiBufferBatchEventProcessor.java
+++ /dev/null
@@ -1,127 +0,0 @@
-package com.lmax.disruptor.support;
-
-import com.lmax.disruptor.*;
-
-import java.util.concurrent.atomic.AtomicBoolean;
-
-public class MultiBufferBatchEventProcessor<T>
-    implements EventProcessor
-{
-    private final AtomicBoolean isRunning = new AtomicBoolean(false);
-    private final DataProvider<T>[] providers;
-    private final SequenceBarrier[] barriers;
-    private final EventHandler<T> handler;
-    private final Sequence[] sequences;
-    private long count;
-
-    public MultiBufferBatchEventProcessor(
-        DataProvider<T>[] providers,
-        SequenceBarrier[] barriers,
-        EventHandler<T> handler)
-    {
-        if (providers.length != barriers.length)
-        {
-            throw new IllegalArgumentException();
-        }
-
-        this.providers = providers;
-        this.barriers = barriers;
-        this.handler = handler;
-
-        this.sequences = new Sequence[providers.length];
-        for (int i = 0; i < sequences.length; i++)
-        {
-            sequences[i] = new Sequence(-1);
-        }
-    }
-
-    @Override
-    public void run()
-    {
-        if (!isRunning.compareAndSet(false, true))
-        {
-            throw new RuntimeException("Already running");
-        }
-
-        for (SequenceBarrier barrier : barriers)
-        {
-            barrier.clearAlert();
-        }
-
-        final int barrierLength = barriers.length;
-
-        while (true)
-        {
-            try
-            {
-                for (int i = 0; i < barrierLength; i++)
-                {
-                    long available = barriers[i].waitFor(-1);
-                    Sequence sequence = sequences[i];
-
-                    long nextSequence = sequence.get() + 1;
-
-                    for (long l = nextSequence; l <= available; l++)
-                    {
-                        handler.onEvent(providers[i].get(l), l, nextSequence == available);
-                    }
-
-                    sequence.set(available);
-
-                    count += available - nextSequence + 1;
-                }
-
-                Thread.yield();
-            }
-            catch (AlertException e)
-            {
-                if (!isRunning())
-                {
-                    break;
-                }
-            }
-            catch (InterruptedException e)
-            {
-                e.printStackTrace();
-            }
-            catch (TimeoutException e)
-            {
-                e.printStackTrace();
-            }
-            catch (Exception e)
-            {
-                e.printStackTrace();
-                break;
-            }
-        }
-    }
-
-    @Override
-    public Sequence getSequence()
-    {
-        throw new UnsupportedOperationException();
-    }
-
-    public long getCount()
-    {
-        return count;
-    }
-
-    public Sequence[] getSequences()
-    {
-        return sequences;
-    }
-
-    @Override
-    public void halt()
-    {
-        isRunning.set(false);
-        barriers[0].alert();
-    }
-
-    @Override
-    public boolean isRunning()
-    {
-        return isRunning.get();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/Operation.java b/src/perftest/java/com/lmax/disruptor/support/Operation.java
deleted file mode 100644
index 5a9da99..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/Operation.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-public enum Operation
-{
-    ADDITION
-        {
-            @Override
-            public long op(final long lhs, final long rhs)
-            {
-                return lhs + rhs;
-            }
-        },
-
-    SUBTRACTION
-        {
-            @Override
-            public long op(final long lhs, final long rhs)
-            {
-                return lhs - rhs;
-            }
-        },
-
-    AND
-        {
-            @Override
-            public long op(final long lhs, final long rhs)
-            {
-                return lhs & rhs;
-            }
-        };
-
-    public abstract long op(long lhs, long rhs);
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/PerfTestUtil.java b/src/perftest/java/com/lmax/disruptor/support/PerfTestUtil.java
deleted file mode 100644
index d78472f..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/PerfTestUtil.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-public final class PerfTestUtil
-{
-    public static long accumulatedAddition(final long iterations)
-    {
-        long temp = 0L;
-        for (long i = 0L; i < iterations; i++)
-        {
-            temp += i;
-        }
-
-        return temp;
-    }
-
-    public static void failIf(long a, long b)
-    {
-        if (a == b)
-        {
-            throw new RuntimeException();
-        }
-    }
-
-    public static void failIfNot(long a, long b)
-    {
-        if (a != b)
-        {
-            throw new RuntimeException();
-        }
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/ValueAdditionBatchQueueProcessor.java b/src/perftest/java/com/lmax/disruptor/support/ValueAdditionBatchQueueProcessor.java
deleted file mode 100644
index abaf4bc..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/ValueAdditionBatchQueueProcessor.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import java.util.ArrayList;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.CountDownLatch;
-
-public final class ValueAdditionBatchQueueProcessor implements Runnable
-{
-    private volatile boolean running;
-    private long value;
-    private long sequence;
-    private CountDownLatch latch;
-
-    private final BlockingQueue<Long> blockingQueue;
-    private final ArrayList<Long> batch = new ArrayList<Long>(100);
-    private final long count;
-
-    public ValueAdditionBatchQueueProcessor(final BlockingQueue<Long> blockingQueue, final long count)
-    {
-        this.blockingQueue = blockingQueue;
-        this.count = count;
-    }
-
-    public long getValue()
-    {
-        return value;
-    }
-
-    public void reset(final CountDownLatch latch)
-    {
-        value = 0L;
-        sequence = 0L;
-        this.latch = latch;
-    }
-
-    public void halt()
-    {
-        running = false;
-    }
-
-    @Override
-    public void run()
-    {
-        running = true;
-        while (true)
-        {
-            try
-            {
-                long v = blockingQueue.take();
-                sequence++;
-
-                this.value += v;
-
-                int c = blockingQueue.drainTo(batch, 100);
-                sequence += c;
-
-                v = 0;
-                for (int i = 0, n = batch.size(); i < n; i++)
-                {
-                    v += batch.get(i);
-                }
-
-                this.value += v;
-
-                batch.clear();
-
-                if (sequence == count)
-                {
-                    latch.countDown();
-                }
-            }
-            catch (InterruptedException ex)
-            {
-                if (!running)
-                {
-                    break;
-                }
-            }
-        }
-    }
-
-    @Override
-    public String toString()
-    {
-        return "ValueAdditionBatchQueueProcessor{" +
-            "value=" + value +
-            ", sequence=" + sequence +
-            ", count=" + count +
-            '}';
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/ValueAdditionEventHandler.java b/src/perftest/java/com/lmax/disruptor/support/ValueAdditionEventHandler.java
deleted file mode 100644
index 149fcad..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/ValueAdditionEventHandler.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import java.util.concurrent.CountDownLatch;
-
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.util.PaddedLong;
-
-public final class ValueAdditionEventHandler implements EventHandler<ValueEvent>
-{
-    private final PaddedLong value = new PaddedLong();
-    private long count;
-    private CountDownLatch latch;
-
-    public long getValue()
-    {
-        return value.get();
-    }
-
-    public void reset(final CountDownLatch latch, final long expectedCount)
-    {
-        value.set(0L);
-        this.latch = latch;
-        count = expectedCount;
-    }
-
-    @Override
-    public void onEvent(final ValueEvent event, final long sequence, final boolean endOfBatch) throws Exception
-    {
-        value.set(value.get() + event.getValue());
-
-        if (count == sequence)
-        {
-            latch.countDown();
-        }
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/ValueAdditionQueueProcessor.java b/src/perftest/java/com/lmax/disruptor/support/ValueAdditionQueueProcessor.java
deleted file mode 100644
index 1a99505..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/ValueAdditionQueueProcessor.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.CountDownLatch;
-
-public final class ValueAdditionQueueProcessor implements Runnable
-{
-    private volatile boolean running;
-    private long value;
-    private long sequence;
-    private CountDownLatch latch;
-
-    private final BlockingQueue<Long> blockingQueue;
-    private final long count;
-
-    public ValueAdditionQueueProcessor(final BlockingQueue<Long> blockingQueue, final long count)
-    {
-        this.blockingQueue = blockingQueue;
-        this.count = count;
-    }
-
-    public long getValue()
-    {
-        return value;
-    }
-
-    public void reset(final CountDownLatch latch)
-    {
-        value = 0L;
-        sequence = 0L;
-        this.latch = latch;
-    }
-
-    public void halt()
-    {
-        running = false;
-    }
-
-    @Override
-    public void run()
-    {
-        running = true;
-        while (true)
-        {
-            try
-            {
-                long value = blockingQueue.take().longValue();
-                this.value += value;
-
-                if (sequence++ == count)
-                {
-                    latch.countDown();
-                }
-            }
-            catch (InterruptedException ex)
-            {
-                if (!running)
-                {
-                    break;
-                }
-            }
-        }
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/ValueAdditionWorkHandler.java b/src/perftest/java/com/lmax/disruptor/support/ValueAdditionWorkHandler.java
deleted file mode 100644
index 3f2b93b..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/ValueAdditionWorkHandler.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright 2012 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import com.lmax.disruptor.WorkHandler;
-
-public class ValueAdditionWorkHandler implements WorkHandler<ValueEvent>
-{
-    private long total;
-
-    @Override
-    public void onEvent(ValueEvent event) throws Exception
-    {
-        long value = event.getValue();
-        total += value;
-    }
-
-    public long getTotal()
-    {
-        return total;
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/ValueBatchPublisher.java b/src/perftest/java/com/lmax/disruptor/support/ValueBatchPublisher.java
deleted file mode 100644
index 1a06d76..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/ValueBatchPublisher.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import java.util.concurrent.CyclicBarrier;
-
-import com.lmax.disruptor.RingBuffer;
-
-public final class ValueBatchPublisher implements Runnable
-{
-    private final CyclicBarrier cyclicBarrier;
-    private final RingBuffer<ValueEvent> ringBuffer;
-    private final long iterations;
-    private final int batchSize;
-
-    public ValueBatchPublisher(
-        final CyclicBarrier cyclicBarrier,
-        final RingBuffer<ValueEvent> ringBuffer,
-        final long iterations,
-        final int batchSize)
-    {
-        this.cyclicBarrier = cyclicBarrier;
-        this.ringBuffer = ringBuffer;
-        this.iterations = iterations;
-        this.batchSize = batchSize;
-    }
-
-    @Override
-    public void run()
-    {
-        try
-        {
-            cyclicBarrier.await();
-
-            for (long i = 0; i < iterations; i += batchSize)
-            {
-                long hi = ringBuffer.next(batchSize);
-                long lo = hi - (batchSize - 1);
-                for (long l = lo; l <= hi; l++)
-                {
-                    ValueEvent event = ringBuffer.get(l);
-                    event.setValue(l);
-                }
-                ringBuffer.publish(lo, hi);
-            }
-        }
-        catch (Exception ex)
-        {
-            throw new RuntimeException(ex);
-        }
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/ValueEvent.java b/src/perftest/java/com/lmax/disruptor/support/ValueEvent.java
deleted file mode 100644
index 7db089b..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/ValueEvent.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import com.lmax.disruptor.EventFactory;
-
-public final class ValueEvent
-{
-    private long value;
-
-    public long getValue()
-    {
-        return value;
-    }
-
-    public void setValue(final long value)
-    {
-        this.value = value;
-    }
-
-    public static final EventFactory<ValueEvent> EVENT_FACTORY = new EventFactory<ValueEvent>()
-    {
-        public ValueEvent newInstance()
-        {
-            return new ValueEvent();
-        }
-    };
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/ValueMutationEventHandler.java b/src/perftest/java/com/lmax/disruptor/support/ValueMutationEventHandler.java
deleted file mode 100644
index 0c6b373..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/ValueMutationEventHandler.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.util.PaddedLong;
-
-import java.util.concurrent.CountDownLatch;
-
-public final class ValueMutationEventHandler implements EventHandler<ValueEvent>
-{
-    private final Operation operation;
-    private final PaddedLong value = new PaddedLong();
-    private long count;
-    private CountDownLatch latch;
-
-    public ValueMutationEventHandler(final Operation operation)
-    {
-        this.operation = operation;
-    }
-
-    public long getValue()
-    {
-        return value.get();
-    }
-
-    public void reset(final CountDownLatch latch, final long expectedCount)
-    {
-        value.set(0L);
-        this.latch = latch;
-        count = expectedCount;
-    }
-
-    @Override
-    public void onEvent(final ValueEvent event, final long sequence, final boolean endOfBatch) throws Exception
-    {
-        value.set(operation.op(value.get(), event.getValue()));
-
-        if (count == sequence)
-        {
-            latch.countDown();
-        }
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/ValueMutationQueueProcessor.java b/src/perftest/java/com/lmax/disruptor/support/ValueMutationQueueProcessor.java
deleted file mode 100644
index b76af8a..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/ValueMutationQueueProcessor.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.CountDownLatch;
-
-public final class ValueMutationQueueProcessor implements Runnable
-{
-    private volatile boolean running;
-    private long value;
-    private long sequence;
-    private CountDownLatch latch;
-
-    private final BlockingQueue<Long> blockingQueue;
-    private final Operation operation;
-    private final long count;
-
-    public ValueMutationQueueProcessor(
-        final BlockingQueue<Long> blockingQueue, final Operation operation, final long count)
-    {
-        this.blockingQueue = blockingQueue;
-        this.operation = operation;
-        this.count = count;
-    }
-
-    public long getValue()
-    {
-        return value;
-    }
-
-    public void reset(final CountDownLatch latch)
-    {
-        value = 0L;
-        sequence = 0L;
-        this.latch = latch;
-    }
-
-    public void halt()
-    {
-        running = false;
-    }
-
-    @Override
-    public void run()
-    {
-        running = true;
-        while (true)
-        {
-            try
-            {
-                long value = blockingQueue.take().longValue();
-                this.value = operation.op(this.value, value);
-
-                if (sequence++ == count)
-                {
-                    latch.countDown();
-                }
-            }
-            catch (InterruptedException ex)
-            {
-                if (!running)
-                {
-                    break;
-                }
-            }
-        }
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/ValuePublisher.java b/src/perftest/java/com/lmax/disruptor/support/ValuePublisher.java
deleted file mode 100644
index a875402..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/ValuePublisher.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import java.util.concurrent.CyclicBarrier;
-
-import com.lmax.disruptor.RingBuffer;
-
-public final class ValuePublisher implements Runnable
-{
-    private final CyclicBarrier cyclicBarrier;
-    private final RingBuffer<ValueEvent> ringBuffer;
-    private final long iterations;
-
-    public ValuePublisher(
-        final CyclicBarrier cyclicBarrier, final RingBuffer<ValueEvent> ringBuffer, final long iterations)
-    {
-        this.cyclicBarrier = cyclicBarrier;
-        this.ringBuffer = ringBuffer;
-        this.iterations = iterations;
-    }
-
-    @Override
-    public void run()
-    {
-        try
-        {
-            cyclicBarrier.await();
-
-            for (long i = 0; i < iterations; i++)
-            {
-                long sequence = ringBuffer.next();
-                ValueEvent event = ringBuffer.get(sequence);
-                event.setValue(i);
-                ringBuffer.publish(sequence);
-            }
-        }
-        catch (Exception ex)
-        {
-            throw new RuntimeException(ex);
-        }
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/support/ValueQueuePublisher.java b/src/perftest/java/com/lmax/disruptor/support/ValueQueuePublisher.java
deleted file mode 100644
index 6693601..0000000
--- a/src/perftest/java/com/lmax/disruptor/support/ValueQueuePublisher.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.CyclicBarrier;
-
-public final class ValueQueuePublisher implements Runnable
-{
-    private final CyclicBarrier cyclicBarrier;
-    private final BlockingQueue<Long> blockingQueue;
-    private final long iterations;
-
-    public ValueQueuePublisher(
-        final CyclicBarrier cyclicBarrier, final BlockingQueue<Long> blockingQueue, final long iterations)
-    {
-        this.cyclicBarrier = cyclicBarrier;
-        this.blockingQueue = blockingQueue;
-        this.iterations = iterations;
-    }
-
-    @Override
-    public void run()
-    {
-        try
-        {
-            cyclicBarrier.await();
-            for (long i = 0; i < iterations; i++)
-            {
-                blockingQueue.put(Long.valueOf(i));
-            }
-        }
-        catch (Exception ex)
-        {
-            throw new RuntimeException(ex);
-        }
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/translator/OneToOneTranslatorThroughputTest.java b/src/perftest/java/com/lmax/disruptor/translator/OneToOneTranslatorThroughputTest.java
deleted file mode 100644
index 3c483a8..0000000
--- a/src/perftest/java/com/lmax/disruptor/translator/OneToOneTranslatorThroughputTest.java
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.translator;
-
-import com.lmax.disruptor.AbstractPerfTestDisruptor;
-import com.lmax.disruptor.EventTranslatorOneArg;
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.YieldingWaitStrategy;
-import com.lmax.disruptor.dsl.Disruptor;
-import com.lmax.disruptor.dsl.ProducerType;
-import com.lmax.disruptor.support.PerfTestUtil;
-import com.lmax.disruptor.support.ValueAdditionEventHandler;
-import com.lmax.disruptor.support.ValueEvent;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-import com.lmax.disruptor.util.MutableLong;
-
-import java.util.concurrent.CountDownLatch;
-
-import static com.lmax.disruptor.support.PerfTestUtil.failIfNot;
-
-/**
- * <pre>
- * UniCast a series of items between 1 publisher and 1 event processor using the EventTranslator API
- *
- * +----+    +-----+
- * | P1 |--->| EP1 |
- * +----+    +-----+
- *
- * Disruptor:
- * ==========
- *              track to prevent wrap
- *              +------------------+
- *              |                  |
- *              |                  v
- * +----+    +====+    +====+   +-----+
- * | P1 |--->| RB |<---| SB |   | EP1 |
- * +----+    +====+    +====+   +-----+
- *      claim      get    ^        |
- *                        |        |
- *                        +--------+
- *                          waitFor
- *
- * P1  - Publisher 1
- * RB  - RingBuffer
- * SB  - SequenceBarrier
- * EP1 - EventProcessor 1
- *
- * </pre>
- */
-public final class OneToOneTranslatorThroughputTest extends AbstractPerfTestDisruptor
-{
-    private static final int BUFFER_SIZE = 1024 * 64;
-    private static final long ITERATIONS = 1000L * 1000L * 100L;
-    private final long expectedResult = PerfTestUtil.accumulatedAddition(ITERATIONS);
-    private final ValueAdditionEventHandler handler = new ValueAdditionEventHandler();
-    private final RingBuffer<ValueEvent> ringBuffer;
-    private final MutableLong value = new MutableLong(0);
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @SuppressWarnings("unchecked")
-    public OneToOneTranslatorThroughputTest()
-    {
-        Disruptor<ValueEvent> disruptor =
-            new Disruptor<ValueEvent>(
-                ValueEvent.EVENT_FACTORY,
-                BUFFER_SIZE, DaemonThreadFactory.INSTANCE,
-                ProducerType.SINGLE,
-                new YieldingWaitStrategy());
-        disruptor.handleEventsWith(handler);
-        this.ringBuffer = disruptor.start();
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 2;
-    }
-
-    @Override
-    protected long runDisruptorPass() throws InterruptedException
-    {
-        MutableLong value = this.value;
-
-        final CountDownLatch latch = new CountDownLatch(1);
-        long expectedCount = ringBuffer.getMinimumGatingSequence() + ITERATIONS;
-
-        handler.reset(latch, expectedCount);
-        long start = System.currentTimeMillis();
-
-        final RingBuffer<ValueEvent> rb = ringBuffer;
-
-        for (long l = 0; l < ITERATIONS; l++)
-        {
-            value.set(l);
-            rb.publishEvent(Translator.INSTANCE, value);
-        }
-
-        latch.await();
-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-        waitForEventProcessorSequence(expectedCount);
-
-        failIfNot(expectedResult, handler.getValue());
-
-        return opsPerSecond;
-    }
-
-    private static class Translator implements EventTranslatorOneArg<ValueEvent, MutableLong>
-    {
-        private static final Translator INSTANCE = new Translator();
-
-        @Override
-        public void translateTo(ValueEvent event, long sequence, MutableLong arg0)
-        {
-            event.setValue(arg0.get());
-        }
-    }
-
-    private void waitForEventProcessorSequence(long expectedCount) throws InterruptedException
-    {
-        while (ringBuffer.getMinimumGatingSequence() != expectedCount)
-        {
-            Thread.sleep(1);
-        }
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        OneToOneTranslatorThroughputTest test = new OneToOneTranslatorThroughputTest();
-        test.testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/workhandler/OneToThreeReleasingWorkerPoolThroughputTest.java b/src/perftest/java/com/lmax/disruptor/workhandler/OneToThreeReleasingWorkerPoolThroughputTest.java
deleted file mode 100644
index 7bf5f6d..0000000
--- a/src/perftest/java/com/lmax/disruptor/workhandler/OneToThreeReleasingWorkerPoolThroughputTest.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.workhandler;
-
-import static com.lmax.disruptor.support.PerfTestUtil.failIfNot;
-
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
-import com.lmax.disruptor.AbstractPerfTestDisruptor;
-import com.lmax.disruptor.FatalExceptionHandler;
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.WorkerPool;
-import com.lmax.disruptor.YieldingWaitStrategy;
-import com.lmax.disruptor.support.EventCountingAndReleasingWorkHandler;
-import com.lmax.disruptor.support.ValueEvent;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-import com.lmax.disruptor.util.PaddedLong;
-
-public final class OneToThreeReleasingWorkerPoolThroughputTest
-    extends AbstractPerfTestDisruptor
-{
-    private static final int NUM_WORKERS = 3;
-    private static final int BUFFER_SIZE = 1024 * 8;
-    private static final long ITERATIONS = 1000L * 1000 * 10L;
-    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_WORKERS, DaemonThreadFactory.INSTANCE);
-
-    private final PaddedLong[] counters = new PaddedLong[NUM_WORKERS];
-
-    {
-        for (int i = 0; i < NUM_WORKERS; i++)
-        {
-            counters[i] = new PaddedLong();
-        }
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final EventCountingAndReleasingWorkHandler[] handlers =
-        new EventCountingAndReleasingWorkHandler[NUM_WORKERS];
-
-    {
-        for (int i = 0; i < NUM_WORKERS; i++)
-        {
-            handlers[i] = new EventCountingAndReleasingWorkHandler(counters, i);
-        }
-    }
-
-    private final RingBuffer<ValueEvent> ringBuffer =
-        RingBuffer.createSingleProducer(
-            ValueEvent.EVENT_FACTORY,
-            BUFFER_SIZE,
-            new YieldingWaitStrategy());
-
-    private final WorkerPool<ValueEvent> workerPool =
-        new WorkerPool<ValueEvent>(
-            ringBuffer,
-            ringBuffer.newBarrier(),
-            new FatalExceptionHandler(),
-            handlers);
-
-    {
-        ringBuffer.addGatingSequences(workerPool.getWorkerSequences());
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 4;
-    }
-
-    @Override
-    protected long runDisruptorPass() throws InterruptedException
-    {
-
-        resetCounters();
-        RingBuffer<ValueEvent> ringBuffer = workerPool.start(executor);
-        long start = System.currentTimeMillis();
-
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            long sequence = ringBuffer.next();
-            ringBuffer.get(sequence).setValue(i);
-            ringBuffer.publish(sequence);
-        }
-
-        workerPool.drainAndHalt();
-
-        // Workaround to ensure that the last worker(s) have completed after releasing their events
-        Thread.sleep(1L);
-
-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-
-        failIfNot(ITERATIONS, sumCounters());
-
-        return opsPerSecond;
-    }
-
-    private void resetCounters()
-    {
-        for (int i = 0; i < NUM_WORKERS; i++)
-        {
-            counters[i].set(0L);
-        }
-    }
-
-    private long sumCounters()
-    {
-        long sumJobs = 0L;
-        for (int i = 0; i < NUM_WORKERS; i++)
-        {
-            sumJobs += counters[i].get();
-        }
-
-        return sumJobs;
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        new OneToThreeReleasingWorkerPoolThroughputTest().testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/workhandler/OneToThreeWorkerPoolThroughputTest.java b/src/perftest/java/com/lmax/disruptor/workhandler/OneToThreeWorkerPoolThroughputTest.java
deleted file mode 100644
index a02d4ac..0000000
--- a/src/perftest/java/com/lmax/disruptor/workhandler/OneToThreeWorkerPoolThroughputTest.java
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.workhandler;
-
-import static com.lmax.disruptor.support.PerfTestUtil.failIfNot;
-
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.LinkedBlockingQueue;
-
-import com.lmax.disruptor.AbstractPerfTestDisruptor;
-import com.lmax.disruptor.FatalExceptionHandler;
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.WorkerPool;
-import com.lmax.disruptor.YieldingWaitStrategy;
-import com.lmax.disruptor.support.EventCountingQueueProcessor;
-import com.lmax.disruptor.support.EventCountingWorkHandler;
-import com.lmax.disruptor.support.ValueEvent;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-import com.lmax.disruptor.util.PaddedLong;
-
-public final class OneToThreeWorkerPoolThroughputTest
-    extends AbstractPerfTestDisruptor
-{
-    private static final int NUM_WORKERS = 3;
-    private static final int BUFFER_SIZE = 1024 * 8;
-    private static final long ITERATIONS = 1000L * 1000L * 100L;
-    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_WORKERS, DaemonThreadFactory.INSTANCE);
-
-    private final PaddedLong[] counters = new PaddedLong[NUM_WORKERS];
-
-    {
-        for (int i = 0; i < NUM_WORKERS; i++)
-        {
-            counters[i] = new PaddedLong();
-        }
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final BlockingQueue<Long> blockingQueue = new LinkedBlockingQueue<Long>(BUFFER_SIZE);
-    private final EventCountingQueueProcessor[] queueWorkers = new EventCountingQueueProcessor[NUM_WORKERS];
-
-    {
-        for (int i = 0; i < NUM_WORKERS; i++)
-        {
-            queueWorkers[i] = new EventCountingQueueProcessor(blockingQueue, counters, i);
-        }
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final EventCountingWorkHandler[] handlers = new EventCountingWorkHandler[NUM_WORKERS];
-
-    {
-        for (int i = 0; i < NUM_WORKERS; i++)
-        {
-            handlers[i] = new EventCountingWorkHandler(counters, i);
-        }
-    }
-
-    private final RingBuffer<ValueEvent> ringBuffer =
-        RingBuffer.createSingleProducer(
-            ValueEvent.EVENT_FACTORY,
-            BUFFER_SIZE,
-            new YieldingWaitStrategy());
-
-    private final WorkerPool<ValueEvent> workerPool =
-        new WorkerPool<ValueEvent>(
-            ringBuffer,
-            ringBuffer.newBarrier(),
-            new FatalExceptionHandler(),
-            handlers);
-
-    {
-        ringBuffer.addGatingSequences(workerPool.getWorkerSequences());
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 4;
-    }
-
-    @Override
-    protected long runDisruptorPass() throws InterruptedException
-    {
-
-        resetCounters();
-        RingBuffer<ValueEvent> ringBuffer = workerPool.start(executor);
-        long start = System.currentTimeMillis();
-
-        for (long i = 0; i < ITERATIONS; i++)
-        {
-            long sequence = ringBuffer.next();
-            ringBuffer.get(sequence).setValue(i);
-            ringBuffer.publish(sequence);
-        }
-
-        workerPool.drainAndHalt();
-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-
-        failIfNot(ITERATIONS, sumCounters());
-
-        return opsPerSecond;
-    }
-
-    private void resetCounters()
-    {
-        for (int i = 0; i < NUM_WORKERS; i++)
-        {
-            counters[i].set(0L);
-        }
-    }
-
-    private long sumCounters()
-    {
-        long sumJobs = 0L;
-        for (int i = 0; i < NUM_WORKERS; i++)
-        {
-            sumJobs += counters[i].get();
-        }
-
-        return sumJobs;
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        new OneToThreeWorkerPoolThroughputTest().testImplementations();
-    }
-}
diff --git a/src/perftest/java/com/lmax/disruptor/workhandler/TwoToTwoWorkProcessorThroughputTest.java b/src/perftest/java/com/lmax/disruptor/workhandler/TwoToTwoWorkProcessorThroughputTest.java
deleted file mode 100644
index 42af3a3..0000000
--- a/src/perftest/java/com/lmax/disruptor/workhandler/TwoToTwoWorkProcessorThroughputTest.java
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.workhandler;
-
-import static com.lmax.disruptor.RingBuffer.createMultiProducer;
-
-import java.util.concurrent.CyclicBarrier;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.locks.LockSupport;
-
-import com.lmax.disruptor.AbstractPerfTestDisruptor;
-import com.lmax.disruptor.BusySpinWaitStrategy;
-import com.lmax.disruptor.IgnoreExceptionHandler;
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.Sequence;
-import com.lmax.disruptor.SequenceBarrier;
-import com.lmax.disruptor.WorkProcessor;
-import com.lmax.disruptor.support.ValueAdditionWorkHandler;
-import com.lmax.disruptor.support.ValueEvent;
-import com.lmax.disruptor.support.ValuePublisher;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-/**
- * <pre>
- * Sequence a series of events from multiple publishers going to multiple work processors.
- *
- * +----+                  +-----+
- * | P1 |---+          +-->| WP1 |
- * +----+   |  +-----+ |   +-----+
- *          +->| RB1 |-+
- * +----+   |  +-----+ |   +-----+
- * | P2 |---+          +-->| WP2 |
- * +----+                  +-----+
- *
- * P1  - Publisher 1
- * P2  - Publisher 2
- * RB  - RingBuffer
- * WP1 - EventProcessor 1
- * WP2 - EventProcessor 2
- * </pre>
- */
-public final class TwoToTwoWorkProcessorThroughputTest extends AbstractPerfTestDisruptor
-{
-    private static final int NUM_PUBLISHERS = 2;
-    private static final int BUFFER_SIZE = 1024 * 64;
-    private static final long ITERATIONS = 1000L * 1000L * 1L;
-    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_PUBLISHERS + 2, DaemonThreadFactory.INSTANCE);
-    private final CyclicBarrier cyclicBarrier = new CyclicBarrier(NUM_PUBLISHERS + 1);
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    private final RingBuffer<ValueEvent> ringBuffer =
-        createMultiProducer(ValueEvent.EVENT_FACTORY, BUFFER_SIZE, new BusySpinWaitStrategy());
-
-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();
-    private final Sequence workSequence = new Sequence(-1);
-
-    private final ValueAdditionWorkHandler[] handlers = new ValueAdditionWorkHandler[2];
-
-    {
-        handlers[0] = new ValueAdditionWorkHandler();
-        handlers[1] = new ValueAdditionWorkHandler();
-    }
-
-    @SuppressWarnings("unchecked")
-    private final WorkProcessor<ValueEvent>[] workProcessors = new WorkProcessor[2];
-
-    {
-        workProcessors[0] = new WorkProcessor<ValueEvent>(
-            ringBuffer, sequenceBarrier,
-            handlers[0], new IgnoreExceptionHandler(),
-            workSequence);
-        workProcessors[1] = new WorkProcessor<ValueEvent>(
-            ringBuffer, sequenceBarrier,
-            handlers[1], new IgnoreExceptionHandler(),
-            workSequence);
-    }
-
-    private final ValuePublisher[] valuePublishers = new ValuePublisher[NUM_PUBLISHERS];
-
-    {
-        for (int i = 0; i < NUM_PUBLISHERS; i++)
-        {
-            valuePublishers[i] = new ValuePublisher(cyclicBarrier, ringBuffer, ITERATIONS);
-        }
-
-        ringBuffer.addGatingSequences(workProcessors[0].getSequence(), workProcessors[1].getSequence());
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////////////////
-
-    @Override
-    protected int getRequiredProcessorCount()
-    {
-        return 4;
-    }
-
-    @Override
-    protected long runDisruptorPass() throws Exception
-    {
-        long expected = ringBuffer.getCursor() + (NUM_PUBLISHERS * ITERATIONS);
-        Future<?>[] futures = new Future[NUM_PUBLISHERS];
-        for (int i = 0; i < NUM_PUBLISHERS; i++)
-        {
-            futures[i] = executor.submit(valuePublishers[i]);
-        }
-
-        for (WorkProcessor<ValueEvent> processor : workProcessors)
-        {
-            executor.submit(processor);
-        }
-
-        long start = System.currentTimeMillis();
-        cyclicBarrier.await();
-
-        for (int i = 0; i < NUM_PUBLISHERS; i++)
-        {
-            futures[i].get();
-        }
-
-        while (workSequence.get() < expected)
-        {
-            LockSupport.parkNanos(1L);
-        }
-
-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);
-
-        Thread.sleep(1000);
-
-        for (WorkProcessor<ValueEvent> processor : workProcessors)
-        {
-            processor.halt();
-        }
-
-        return opsPerSecond;
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        new TwoToTwoWorkProcessorThroughputTest().testImplementations();
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/AggregateEventHandlerTest.java b/src/test/java/com/lmax/disruptor/AggregateEventHandlerTest.java
deleted file mode 100644
index 2e7578e..0000000
--- a/src/test/java/com/lmax/disruptor/AggregateEventHandlerTest.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor;
-
-import com.lmax.disruptor.support.DummyEventHandler;
-import org.junit.Test;
-
-import static org.hamcrest.core.Is.is;
-import static org.junit.Assert.assertThat;
-
-@SuppressWarnings("unchecked")
-public final class AggregateEventHandlerTest
-{
-    private final DummyEventHandler<int[]> eh1 = new DummyEventHandler<int[]>();
-    private final DummyEventHandler<int[]> eh2 = new DummyEventHandler<int[]>();
-    private final DummyEventHandler<int[]> eh3 = new DummyEventHandler<int[]>();
-
-    @Test
-    public void shouldCallOnEventInSequence()
-        throws Exception
-    {
-        final int[] event = {7};
-        final long sequence = 3L;
-        final boolean endOfBatch = true;
-
-        final AggregateEventHandler<int[]> aggregateEventHandler = new AggregateEventHandler<int[]>(eh1, eh2, eh3);
-
-        aggregateEventHandler.onEvent(event, sequence, endOfBatch);
-        assertLastEvent(event, sequence, eh1, eh2, eh3);
-    }
-
-    @Test
-    public void shouldCallOnStartInSequence()
-        throws Exception
-    {
-        final AggregateEventHandler<int[]> aggregateEventHandler = new AggregateEventHandler<int[]>(eh1, eh2, eh3);
-
-        aggregateEventHandler.onStart();
-
-        assertStartCalls(1, eh1, eh2, eh3);
-    }
-
-    @Test
-    public void shouldCallOnShutdownInSequence()
-        throws Exception
-    {
-        final AggregateEventHandler<int[]> aggregateEventHandler = new AggregateEventHandler<int[]>(eh1, eh2, eh3);
-
-        aggregateEventHandler.onShutdown();
-
-        assertShutoownCalls(1, eh1, eh2, eh3);
-    }
-
-    @Test
-    public void shouldHandleEmptyListOfEventHandlers() throws Exception
-    {
-        final AggregateEventHandler<int[]> aggregateEventHandler = new AggregateEventHandler<int[]>();
-
-        aggregateEventHandler.onEvent(new int[]{7}, 0L, true);
-        aggregateEventHandler.onStart();
-        aggregateEventHandler.onShutdown();
-    }
-
-    private static void assertLastEvent(int[] event, long sequence, DummyEventHandler<int[]>... eh1)
-    {
-        for (DummyEventHandler<int[]> eh : eh1)
-        {
-            assertThat(eh.lastEvent, is(event));
-            assertThat(eh.lastSequence, is(sequence));
-        }
-    }
-
-    private static void assertStartCalls(int startCalls, DummyEventHandler<int[]>... handlers)
-    {
-        for (DummyEventHandler<int[]> handler : handlers)
-        {
-            assertThat(handler.startCalls, is(startCalls));
-        }
-    }
-
-    private static void assertShutoownCalls(int startCalls, DummyEventHandler<int[]>... handlers)
-    {
-        for (DummyEventHandler<int[]> handler : handlers)
-        {
-            assertThat(handler.shutdownCalls, is(startCalls));
-        }
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/BatchEventProcessorTest.java b/src/test/java/com/lmax/disruptor/BatchEventProcessorTest.java
deleted file mode 100644
index aa8a954..0000000
--- a/src/test/java/com/lmax/disruptor/BatchEventProcessorTest.java
+++ /dev/null
@@ -1,277 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor;
-
-import com.lmax.disruptor.support.StubEvent;
-import org.junit.Test;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-import static com.lmax.disruptor.RingBuffer.createMultiProducer;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
-public final class BatchEventProcessorTest
-{
-    private final RingBuffer<StubEvent> ringBuffer = createMultiProducer(StubEvent.EVENT_FACTORY, 16);
-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();
-
-    @Test(expected = NullPointerException.class)
-    public void shouldThrowExceptionOnSettingNullExceptionHandler()
-    {
-        final BatchEventProcessor<StubEvent> batchEventProcessor = new BatchEventProcessor<StubEvent>(
-            ringBuffer, sequenceBarrier, new ExceptionEventHandler());
-        batchEventProcessor.setExceptionHandler(null);
-    }
-
-    @Test
-    public void shouldCallMethodsInLifecycleOrderForBatch()
-        throws Exception
-    {
-        CountDownLatch eventLatch = new CountDownLatch(3);
-        LatchEventHandler eventHandler = new LatchEventHandler(eventLatch);
-        final BatchEventProcessor<StubEvent> batchEventProcessor = new BatchEventProcessor<StubEvent>(
-            ringBuffer, sequenceBarrier, eventHandler);
-
-        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());
-
-        ringBuffer.publish(ringBuffer.next());
-        ringBuffer.publish(ringBuffer.next());
-        ringBuffer.publish(ringBuffer.next());
-
-        Thread thread = new Thread(batchEventProcessor);
-        thread.start();
-
-        assertTrue(eventLatch.await(2, TimeUnit.SECONDS));
-
-        batchEventProcessor.halt();
-        thread.join();
-    }
-
-    @Test
-    public void shouldCallExceptionHandlerOnUncaughtException()
-        throws Exception
-    {
-        CountDownLatch exceptionLatch = new CountDownLatch(1);
-        LatchExceptionHandler latchExceptionHandler = new LatchExceptionHandler(exceptionLatch);
-        final BatchEventProcessor<StubEvent> batchEventProcessor = new BatchEventProcessor<StubEvent>(
-            ringBuffer, sequenceBarrier, new ExceptionEventHandler());
-        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());
-
-        batchEventProcessor.setExceptionHandler(latchExceptionHandler);
-
-        Thread thread = new Thread(batchEventProcessor);
-        thread.start();
-
-        ringBuffer.publish(ringBuffer.next());
-
-        assertTrue(exceptionLatch.await(2, TimeUnit.SECONDS));
-
-        batchEventProcessor.halt();
-        thread.join();
-    }
-
-    private static class LatchEventHandler implements EventHandler<StubEvent>
-    {
-        private final CountDownLatch latch;
-
-        LatchEventHandler(CountDownLatch latch)
-        {
-            this.latch = latch;
-        }
-
-        @Override
-        public void onEvent(StubEvent event, long sequence, boolean endOfBatch) throws Exception
-        {
-            latch.countDown();
-        }
-    }
-
-    private static class LatchExceptionHandler implements ExceptionHandler<StubEvent>
-    {
-        private final CountDownLatch latch;
-
-        LatchExceptionHandler(CountDownLatch latch)
-        {
-            this.latch = latch;
-        }
-
-        @Override
-        public void handleEventException(Throwable ex, long sequence, StubEvent event)
-        {
-            latch.countDown();
-        }
-
-        @Override
-        public void handleOnStartException(Throwable ex)
-        {
-
-        }
-
-        @Override
-        public void handleOnShutdownException(Throwable ex)
-        {
-
-        }
-    }
-
-    private static class ExceptionEventHandler implements EventHandler<StubEvent>
-    {
-        @Override
-        public void onEvent(StubEvent event, long sequence, boolean endOfBatch) throws Exception
-        {
-            throw new NullPointerException(null);
-        }
-    }
-
-    @Test
-    public void reportAccurateBatchSizesAtBatchStartTime()
-        throws Exception
-    {
-        final List<Long> batchSizes = new ArrayList<Long>();
-        final CountDownLatch eventLatch = new CountDownLatch(6);
-
-        final class LoopbackEventHandler
-            implements EventHandler<StubEvent>, BatchStartAware
-        {
-
-            @Override
-            public void onBatchStart(long batchSize)
-            {
-                batchSizes.add(batchSize);
-            }
-
-            @Override
-            public void onEvent(StubEvent event, long sequence, boolean endOfBatch)
-                throws Exception
-            {
-                if (!endOfBatch)
-                {
-                    ringBuffer.publish(ringBuffer.next());
-                }
-                eventLatch.countDown();
-            }
-        }
-
-        final BatchEventProcessor<StubEvent> batchEventProcessor =
-            new BatchEventProcessor<StubEvent>(
-                ringBuffer, sequenceBarrier, new LoopbackEventHandler());
-
-        ringBuffer.publish(ringBuffer.next());
-        ringBuffer.publish(ringBuffer.next());
-        ringBuffer.publish(ringBuffer.next());
-
-        Thread thread = new Thread(batchEventProcessor);
-        thread.start();
-        eventLatch.await();
-
-        batchEventProcessor.halt();
-        thread.join();
-
-        assertEquals(Arrays.asList(3L, 2L, 1L), batchSizes);
-    }
-
-    @Test
-    public void shouldAlwaysHalt() throws InterruptedException
-    {
-        WaitStrategy waitStrategy = new BusySpinWaitStrategy();
-        final SingleProducerSequencer sequencer = new SingleProducerSequencer(8, waitStrategy);
-        final ProcessingSequenceBarrier barrier = new ProcessingSequenceBarrier(
-            sequencer, waitStrategy, new Sequence(-1), new Sequence[0]);
-        DataProvider<Object> dp = new DataProvider<Object>()
-        {
-            @Override
-            public Object get(long sequence)
-            {
-                return null;
-            }
-        };
-
-        final LatchLifeCycleHandler h1 = new LatchLifeCycleHandler();
-        final BatchEventProcessor p1 = new BatchEventProcessor<>(dp, barrier, h1);
-
-        Thread t1 = new Thread(p1);
-        p1.halt();
-        t1.start();
-
-        assertTrue(h1.awaitStart(2, TimeUnit.SECONDS));
-        assertTrue(h1.awaitStop(2, TimeUnit.SECONDS));
-
-        for (int i = 0; i < 1000; i++)
-        {
-            final LatchLifeCycleHandler h2 = new LatchLifeCycleHandler();
-            final BatchEventProcessor p2 = new BatchEventProcessor<>(dp, barrier, h2);
-            Thread t2 = new Thread(p2);
-            t2.start();
-            p2.halt();
-
-            assertTrue(h2.awaitStart(2, TimeUnit.SECONDS));
-            assertTrue(h2.awaitStop(2, TimeUnit.SECONDS));
-        }
-
-        for (int i = 0; i < 1000; i++)
-        {
-            final LatchLifeCycleHandler h2 = new LatchLifeCycleHandler();
-            final BatchEventProcessor p2 = new BatchEventProcessor<>(dp, barrier, h2);
-            Thread t2 = new Thread(p2);
-            t2.start();
-            Thread.yield();
-            p2.halt();
-
-            assertTrue(h2.awaitStart(2, TimeUnit.SECONDS));
-            assertTrue(h2.awaitStop(2, TimeUnit.SECONDS));
-        }
-    }
-
-    private static class LatchLifeCycleHandler implements EventHandler<Object>, LifecycleAware
-    {
-        private final CountDownLatch startLatch = new CountDownLatch(1);
-        private final CountDownLatch stopLatch = new CountDownLatch(1);
-
-        @Override
-        public void onEvent(Object event, long sequence, boolean endOfBatch) throws Exception
-        {
-
-        }
-
-        @Override
-        public void onStart()
-        {
-            startLatch.countDown();
-        }
-
-        @Override
-        public void onShutdown()
-        {
-            stopLatch.countDown();
-        }
-
-        public boolean awaitStart(long time, TimeUnit unit) throws InterruptedException
-        {
-            return startLatch.await(time, unit);
-        }
-
-
-        public boolean awaitStop(long time, TimeUnit unit) throws InterruptedException
-        {
-            return stopLatch.await(time, unit);
-        }
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/BatchingTest.java b/src/test/java/com/lmax/disruptor/BatchingTest.java
deleted file mode 100644
index 8c117de..0000000
--- a/src/test/java/com/lmax/disruptor/BatchingTest.java
+++ /dev/null
@@ -1,117 +0,0 @@
-package com.lmax.disruptor;
-
-import com.lmax.disruptor.dsl.Disruptor;
-import com.lmax.disruptor.dsl.ProducerType;
-import com.lmax.disruptor.support.LongEvent;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-import org.hamcrest.CoreMatchers;
-import org.junit.Assert;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.concurrent.locks.LockSupport;
-
-@RunWith(Parameterized.class)
-public class BatchingTest
-{
-    private final ProducerType producerType;
-
-    public BatchingTest(ProducerType producerType)
-    {
-        this.producerType = producerType;
-    }
-
-    @Parameters
-    public static Collection<Object[]> generateData()
-    {
-        Object[][] producerTypes = {{ProducerType.MULTI}, {ProducerType.SINGLE}};
-        return Arrays.asList(producerTypes);
-    }
-
-    private static class ParallelEventHandler implements EventHandler<LongEvent>
-    {
-        private final long mask;
-        private final long ordinal;
-        private final int batchSize = 10;
-
-        private long eventCount;
-        private long batchCount;
-        private long publishedValue;
-        private long tempValue;
-        private volatile long processed;
-
-        ParallelEventHandler(long mask, long ordinal)
-        {
-            this.mask = mask;
-            this.ordinal = ordinal;
-        }
-
-        @Override
-        public void onEvent(LongEvent event, long sequence, boolean endOfBatch) throws Exception
-        {
-            if ((sequence & mask) == ordinal)
-            {
-                eventCount++;
-                tempValue = event.get();
-            }
-
-            if (endOfBatch || ++batchCount >= batchSize)
-            {
-                publishedValue = tempValue;
-                batchCount = 0;
-            }
-            else
-            {
-                LockSupport.parkNanos(1);
-            }
-
-            processed = sequence;
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test
-    public void shouldBatch() throws Exception
-    {
-        Disruptor<LongEvent> d = new Disruptor<LongEvent>(
-            LongEvent.FACTORY, 2048, DaemonThreadFactory.INSTANCE,
-            producerType, new SleepingWaitStrategy());
-
-        ParallelEventHandler handler1 = new ParallelEventHandler(1, 0);
-        ParallelEventHandler handler2 = new ParallelEventHandler(1, 1);
-
-        d.handleEventsWith(handler1, handler2);
-
-        RingBuffer<LongEvent> buffer = d.start();
-
-        EventTranslator<LongEvent> translator = new EventTranslator<LongEvent>()
-        {
-            @Override
-            public void translateTo(LongEvent event, long sequence)
-            {
-                event.set(sequence);
-            }
-        };
-
-        int eventCount = 10000;
-        for (int i = 0; i < eventCount; i++)
-        {
-            buffer.publishEvent(translator);
-        }
-
-        while (handler1.processed != eventCount - 1 ||
-            handler2.processed != eventCount - 1)
-        {
-            Thread.sleep(1);
-        }
-
-        Assert.assertThat(handler1.publishedValue, CoreMatchers.is((long) eventCount - 2));
-        Assert.assertThat(handler1.eventCount, CoreMatchers.is((long) eventCount / 2));
-        Assert.assertThat(handler2.publishedValue, CoreMatchers.is((long) eventCount - 1));
-        Assert.assertThat(handler2.eventCount, CoreMatchers.is((long) eventCount / 2));
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/BusySpinWaitStrategyTest.java b/src/test/java/com/lmax/disruptor/BusySpinWaitStrategyTest.java
deleted file mode 100644
index b7f02b2..0000000
--- a/src/test/java/com/lmax/disruptor/BusySpinWaitStrategyTest.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright 2012 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor;
-
-import static com.lmax.disruptor.support.WaitStrategyTestUtil.assertWaitForWithDelayOf;
-
-import org.junit.Test;
-
-public class BusySpinWaitStrategyTest
-{
-
-    @Test
-    public void shouldWaitForValue() throws Exception
-    {
-        assertWaitForWithDelayOf(50, new BusySpinWaitStrategy());
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/DisruptorStressTest.java b/src/test/java/com/lmax/disruptor/DisruptorStressTest.java
deleted file mode 100644
index cf8f273..0000000
--- a/src/test/java/com/lmax/disruptor/DisruptorStressTest.java
+++ /dev/null
@@ -1,187 +0,0 @@
-package com.lmax.disruptor;
-
-import com.lmax.disruptor.dsl.Disruptor;
-import com.lmax.disruptor.dsl.ProducerType;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-import org.junit.Test;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.CyclicBarrier;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.locks.LockSupport;
-
-import static java.lang.Math.max;
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
-
-public class DisruptorStressTest
-{
-    private final ExecutorService executor = Executors.newCachedThreadPool();
-
-    @Test
-    public void shouldHandleLotsOfThreads() throws Exception
-    {
-        Disruptor<TestEvent> disruptor = new Disruptor<TestEvent>(
-                TestEvent.FACTORY, 1 << 16, DaemonThreadFactory.INSTANCE,
-                ProducerType.MULTI, new BusySpinWaitStrategy());
-        RingBuffer<TestEvent> ringBuffer = disruptor.getRingBuffer();
-        disruptor.setDefaultExceptionHandler(new FatalExceptionHandler());
-
-        int threads = max(1, Runtime.getRuntime().availableProcessors() / 2);
-
-        int iterations = 200000;
-        int publisherCount = threads;
-        int handlerCount = threads;
-
-        CyclicBarrier barrier = new CyclicBarrier(publisherCount);
-        CountDownLatch latch = new CountDownLatch(publisherCount);
-
-        TestEventHandler[] handlers = initialise(disruptor, new TestEventHandler[handlerCount]);
-        Publisher[] publishers = initialise(new Publisher[publisherCount], ringBuffer, iterations, barrier, latch);
-
-        disruptor.start();
-
-        for (Publisher publisher : publishers)
-        {
-            executor.execute(publisher);
-        }
-
-        latch.await();
-        while (ringBuffer.getCursor() < (iterations - 1))
-        {
-            LockSupport.parkNanos(1);
-        }
-
-        disruptor.shutdown();
-
-        for (Publisher publisher : publishers)
-        {
-            assertThat(publisher.failed, is(false));
-        }
-
-        for (TestEventHandler handler : handlers)
-        {
-            assertThat(handler.messagesSeen, is(not(0)));
-            assertThat(handler.failureCount, is(0));
-        }
-    }
-
-    private Publisher[] initialise(
-        Publisher[] publishers, RingBuffer<TestEvent> buffer,
-        int messageCount, CyclicBarrier barrier, CountDownLatch latch)
-    {
-        for (int i = 0; i < publishers.length; i++)
-        {
-            publishers[i] = new Publisher(buffer, messageCount, barrier, latch);
-        }
-
-        return publishers;
-    }
-
-    @SuppressWarnings("unchecked")
-    private TestEventHandler[] initialise(Disruptor<TestEvent> disruptor, TestEventHandler[] testEventHandlers)
-    {
-        for (int i = 0; i < testEventHandlers.length; i++)
-        {
-            TestEventHandler handler = new TestEventHandler();
-            disruptor.handleEventsWith(handler);
-            testEventHandlers[i] = handler;
-        }
-
-        return testEventHandlers;
-    }
-
-    private static class TestEventHandler implements EventHandler<TestEvent>
-    {
-        public int failureCount = 0;
-        public int messagesSeen = 0;
-
-        TestEventHandler()
-        {
-        }
-
-        @Override
-        public void onEvent(TestEvent event, long sequence, boolean endOfBatch) throws Exception
-        {
-            if (event.sequence != sequence ||
-                event.a != sequence + 13 ||
-                event.b != sequence - 7 ||
-                !("wibble-" + sequence).equals(event.s))
-            {
-                failureCount++;
-            }
-
-            messagesSeen++;
-        }
-    }
-
-    private static class Publisher implements Runnable
-    {
-        private final RingBuffer<TestEvent> ringBuffer;
-        private final CyclicBarrier barrier;
-        private final int iterations;
-        private final CountDownLatch shutdownLatch;
-
-        public boolean failed = false;
-
-        Publisher(
-            RingBuffer<TestEvent> ringBuffer,
-            int iterations,
-            CyclicBarrier barrier,
-            CountDownLatch shutdownLatch)
-        {
-            this.ringBuffer = ringBuffer;
-            this.barrier = barrier;
-            this.iterations = iterations;
-            this.shutdownLatch = shutdownLatch;
-        }
-
-        @Override
-        public void run()
-        {
-            try
-            {
-                barrier.await();
-
-                int i = iterations;
-                while (--i != -1)
-                {
-                    long next = ringBuffer.next();
-                    TestEvent testEvent = ringBuffer.get(next);
-                    testEvent.sequence = next;
-                    testEvent.a = next + 13;
-                    testEvent.b = next - 7;
-                    testEvent.s = "wibble-" + next;
-                    ringBuffer.publish(next);
-                }
-            }
-            catch (Exception e)
-            {
-                failed = true;
-            }
-            finally
-            {
-                shutdownLatch.countDown();
-            }
-        }
-    }
-
-    private static class TestEvent
-    {
-        public long sequence;
-        public long a;
-        public long b;
-        public String s;
-
-        public static final EventFactory<TestEvent> FACTORY = new EventFactory<DisruptorStressTest.TestEvent>()
-        {
-            @Override
-            public DisruptorStressTest.TestEvent newInstance()
-            {
-                return new DisruptorStressTest.TestEvent();
-            }
-        };
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/EventPollerTest.java b/src/test/java/com/lmax/disruptor/EventPollerTest.java
deleted file mode 100644
index 3bb792b..0000000
--- a/src/test/java/com/lmax/disruptor/EventPollerTest.java
+++ /dev/null
@@ -1,92 +0,0 @@
-package com.lmax.disruptor;
-
-import com.lmax.disruptor.EventPoller.PollState;
-import org.junit.Test;
-
-import java.util.ArrayList;
-
-import static org.hamcrest.core.Is.is;
-import static org.junit.Assert.assertThat;
-
-public class EventPollerTest
-{
-    @Test
-    @SuppressWarnings("unchecked")
-    public void shouldPollForEvents() throws Exception
-    {
-        final Sequence gatingSequence = new Sequence();
-        final SingleProducerSequencer sequencer = new SingleProducerSequencer(16, new BusySpinWaitStrategy());
-        final EventPoller.Handler<Object> handler = new EventPoller.Handler<Object>()
-        {
-            public boolean onEvent(Object event, long sequence, boolean endOfBatch) throws Exception
-            {
-                return false;
-            }
-        };
-
-        final Object[] data = new Object[16];
-        final DataProvider<Object> provider = new DataProvider<Object>()
-        {
-            public Object get(long sequence)
-            {
-                return data[(int) sequence];
-            }
-        };
-
-        final EventPoller<Object> poller = sequencer.newPoller(provider, gatingSequence);
-        final Object event = new Object();
-        data[0] = event;
-
-        assertThat(poller.poll(handler), is(PollState.IDLE));
-
-        // Publish Event.
-        sequencer.publish(sequencer.next());
-        assertThat(poller.poll(handler), is(PollState.GATING));
-
-        gatingSequence.incrementAndGet();
-        assertThat(poller.poll(handler), is(PollState.PROCESSING));
-    }
-
-    @Test
-    public void shouldSuccessfullyPollWhenBufferIsFull() throws Exception
-    {
-        final ArrayList<byte[]> events = new ArrayList<byte[]>();
-
-        final EventPoller.Handler<byte[]> handler = new EventPoller.Handler<byte[]>()
-        {
-            public boolean onEvent(byte[] event, long sequence, boolean endOfBatch) throws Exception
-            {
-                events.add(event);
-                return !endOfBatch;
-            }
-        };
-
-        EventFactory<byte[]> factory = new EventFactory<byte[]>()
-        {
-            @Override
-            public byte[] newInstance()
-            {
-                return new byte[1];
-            }
-        };
-
-        final RingBuffer<byte[]> ringBuffer = RingBuffer.createMultiProducer(factory, 4, new SleepingWaitStrategy());
-
-        final EventPoller<byte[]> poller = ringBuffer.newPoller();
-        ringBuffer.addGatingSequences(poller.getSequence());
-
-        int count = 4;
-
-        for (byte i = 1; i <= count; ++i)
-        {
-            long next = ringBuffer.next();
-            ringBuffer.get(next)[0] = i;
-            ringBuffer.publish(next);
-        }
-
-        // think of another thread
-        poller.poll(handler);
-
-        assertThat(events.size(), is(4));
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/EventPublisherTest.java b/src/test/java/com/lmax/disruptor/EventPublisherTest.java
deleted file mode 100644
index 26f3f7d..0000000
--- a/src/test/java/com/lmax/disruptor/EventPublisherTest.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor;
-
-import static com.lmax.disruptor.RingBuffer.createMultiProducer;
-import static org.hamcrest.CoreMatchers.is;
-import static org.junit.Assert.assertThat;
-
-import org.junit.Test;
-
-import com.lmax.disruptor.support.LongEvent;
-
-public class EventPublisherTest implements EventTranslator<LongEvent>
-{
-    private static final int BUFFER_SIZE = 32;
-    private RingBuffer<LongEvent> ringBuffer = createMultiProducer(LongEvent.FACTORY, BUFFER_SIZE);
-
-    @Test
-    public void shouldPublishEvent()
-    {
-        ringBuffer.addGatingSequences(new NoOpEventProcessor(ringBuffer).getSequence());
-
-        ringBuffer.publishEvent(this);
-        ringBuffer.publishEvent(this);
-
-        assertThat(Long.valueOf(ringBuffer.get(0).get()), is(Long.valueOf(0 + 29L)));
-        assertThat(Long.valueOf(ringBuffer.get(1).get()), is(Long.valueOf(1 + 29L)));
-    }
-
-    @Test
-    public void shouldTryPublishEvent() throws Exception
-    {
-        ringBuffer.addGatingSequences(new Sequence());
-
-        for (int i = 0; i < BUFFER_SIZE; i++)
-        {
-            assertThat(ringBuffer.tryPublishEvent(this), is(true));
-        }
-
-        for (int i = 0; i < BUFFER_SIZE; i++)
-        {
-            assertThat(Long.valueOf(ringBuffer.get(i).get()), is(Long.valueOf(i + 29L)));
-        }
-
-        assertThat(ringBuffer.tryPublishEvent(this), is(false));
-    }
-
-    @Override
-    public void translateTo(LongEvent event, long sequence)
-    {
-        event.set(sequence + 29);
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/EventTranslatorTest.java b/src/test/java/com/lmax/disruptor/EventTranslatorTest.java
deleted file mode 100644
index 577494e..0000000
--- a/src/test/java/com/lmax/disruptor/EventTranslatorTest.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor;
-
-import com.lmax.disruptor.support.StubEvent;
-import org.junit.Assert;
-import org.junit.Test;
-
-public final class EventTranslatorTest
-{
-    private static final String TEST_VALUE = "Wibble";
-
-    @Test
-    public void shouldTranslateOtherDataIntoAnEvent()
-    {
-        StubEvent event = StubEvent.EVENT_FACTORY.newInstance();
-        EventTranslator<StubEvent> eventTranslator = new ExampleEventTranslator(TEST_VALUE);
-
-        eventTranslator.translateTo(event, 0);
-
-        Assert.assertEquals(TEST_VALUE, event.getTestString());
-    }
-
-    public static final class ExampleEventTranslator
-        implements EventTranslator<StubEvent>
-    {
-        private final String testValue;
-
-        public ExampleEventTranslator(final String testValue)
-        {
-            this.testValue = testValue;
-        }
-
-        @Override
-        public void translateTo(final StubEvent event, long sequence)
-        {
-            event.setTestString(testValue);
-        }
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/FatalExceptionHandlerTest.java b/src/test/java/com/lmax/disruptor/FatalExceptionHandlerTest.java
deleted file mode 100644
index a3f8b1f..0000000
--- a/src/test/java/com/lmax/disruptor/FatalExceptionHandlerTest.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor;
-
-import com.lmax.disruptor.support.TestEvent;
-import org.junit.Assert;
-import org.junit.Test;
-
-public final class FatalExceptionHandlerTest
-{
-    @Test
-    public void shouldHandleFatalException()
-    {
-        final Exception causeException = new Exception();
-        final TestEvent event = new TestEvent();
-
-        ExceptionHandler<Object> exceptionHandler = new FatalExceptionHandler();
-
-        try
-        {
-            exceptionHandler.handleEventException(causeException, 0L, event);
-        }
-        catch (RuntimeException ex)
-        {
-            Assert.assertEquals(causeException, ex.getCause());
-        }
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/FixedSequenceGroupTest.java b/src/test/java/com/lmax/disruptor/FixedSequenceGroupTest.java
deleted file mode 100644
index 6349de8..0000000
--- a/src/test/java/com/lmax/disruptor/FixedSequenceGroupTest.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright 2012 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor;
-
-import static org.hamcrest.CoreMatchers.is;
-import static org.junit.Assert.assertThat;
-
-import org.junit.Test;
-
-
-public class FixedSequenceGroupTest
-{
-
-    @Test
-    public void shouldReturnMinimumOf2Sequences() throws Exception
-    {
-        Sequence sequence1 = new Sequence(34);
-        Sequence sequnece2 = new Sequence(47);
-        Sequence group = new FixedSequenceGroup(new Sequence[]{sequence1, sequnece2});
-
-        assertThat(group.get(), is(34L));
-        sequence1.set(35);
-        assertThat(group.get(), is(35L));
-        sequence1.set(48);
-        assertThat(group.get(), is(47L));
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/IgnoreExceptionHandlerTest.java b/src/test/java/com/lmax/disruptor/IgnoreExceptionHandlerTest.java
deleted file mode 100644
index 20b4c8d..0000000
--- a/src/test/java/com/lmax/disruptor/IgnoreExceptionHandlerTest.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor;
-
-import com.lmax.disruptor.support.TestEvent;
-import org.junit.Test;
-
-public final class IgnoreExceptionHandlerTest
-{
-    @Test
-    public void shouldHandleAndIgnoreException()
-    {
-        final Exception ex = new Exception();
-        final TestEvent event = new TestEvent();
-
-        ExceptionHandler<Object> exceptionHandler = new IgnoreExceptionHandler();
-        exceptionHandler.handleEventException(ex, 0L, event);
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/LifecycleAwareTest.java b/src/test/java/com/lmax/disruptor/LifecycleAwareTest.java
deleted file mode 100644
index 76867f7..0000000
--- a/src/test/java/com/lmax/disruptor/LifecycleAwareTest.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor;
-
-import com.lmax.disruptor.support.StubEvent;
-import org.junit.Test;
-
-import java.util.concurrent.CountDownLatch;
-
-import static com.lmax.disruptor.RingBuffer.createMultiProducer;
-import static org.hamcrest.core.Is.is;
-import static org.junit.Assert.assertThat;
-
-public final class LifecycleAwareTest
-{
-    private final CountDownLatch startLatch = new CountDownLatch(1);
-    private final CountDownLatch shutdownLatch = new CountDownLatch(1);
-
-
-    private final RingBuffer<StubEvent> ringBuffer = createMultiProducer(StubEvent.EVENT_FACTORY, 16);
-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();
-    private final LifecycleAwareEventHandler handler = new LifecycleAwareEventHandler();
-    private final BatchEventProcessor<StubEvent> batchEventProcessor =
-        new BatchEventProcessor<StubEvent>(ringBuffer, sequenceBarrier, handler);
-
-    @Test
-    public void shouldNotifyOfBatchProcessorLifecycle() throws Exception
-    {
-        new Thread(batchEventProcessor).start();
-
-        startLatch.await();
-        batchEventProcessor.halt();
-
-        shutdownLatch.await();
-
-        assertThat(Integer.valueOf(handler.startCounter), is(Integer.valueOf(1)));
-        assertThat(Integer.valueOf(handler.shutdownCounter), is(Integer.valueOf(1)));
-    }
-
-    private final class LifecycleAwareEventHandler implements EventHandler<StubEvent>, LifecycleAware
-    {
-        private int startCounter = 0;
-        private int shutdownCounter = 0;
-
-        @Override
-        public void onEvent(final StubEvent event, final long sequence, final boolean endOfBatch) throws Exception
-        {
-        }
-
-        @Override
-        public void onStart()
-        {
-            ++startCounter;
-            startLatch.countDown();
-        }
-
-        @Override
-        public void onShutdown()
-        {
-            ++shutdownCounter;
-            shutdownLatch.countDown();
-        }
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/LiteTimeoutBlockingWaitStrategyTest.java b/src/test/java/com/lmax/disruptor/LiteTimeoutBlockingWaitStrategyTest.java
deleted file mode 100644
index fcc2714..0000000
--- a/src/test/java/com/lmax/disruptor/LiteTimeoutBlockingWaitStrategyTest.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package com.lmax.disruptor;
-
-import com.lmax.disruptor.support.DummySequenceBarrier;
-import org.junit.Test;
-
-import java.util.concurrent.TimeUnit;
-
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public class LiteTimeoutBlockingWaitStrategyTest
-{
-    @Test
-    public void shouldTimeoutWaitFor() throws Exception
-    {
-        final SequenceBarrier sequenceBarrier = new DummySequenceBarrier();
-
-        long theTimeout = 500;
-        LiteTimeoutBlockingWaitStrategy waitStrategy = new LiteTimeoutBlockingWaitStrategy(theTimeout, TimeUnit.MILLISECONDS);
-        Sequence cursor = new Sequence(5);
-        Sequence dependent = cursor;
-
-        long t0 = System.currentTimeMillis();
-
-        try
-        {
-            waitStrategy.waitFor(6, cursor, dependent, sequenceBarrier);
-            fail("TimeoutException should have been thrown");
-        }
-        catch (TimeoutException e)
-        {
-        }
-
-        long t1 = System.currentTimeMillis();
-
-        long timeWaiting = t1 - t0;
-
-        assertTrue(timeWaiting >= theTimeout);
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/MultiProducerSequencerTest.java b/src/test/java/com/lmax/disruptor/MultiProducerSequencerTest.java
deleted file mode 100644
index 536d4a1..0000000
--- a/src/test/java/com/lmax/disruptor/MultiProducerSequencerTest.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright 2012 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor;
-
-import static org.hamcrest.CoreMatchers.is;
-import static org.junit.Assert.assertThat;
-
-import org.junit.Test;
-
-public class MultiProducerSequencerTest
-{
-    private final Sequencer publisher = new MultiProducerSequencer(1024, new BlockingWaitStrategy());
-
-    @Test
-    public void shouldOnlyAllowMessagesToBeAvailableIfSpecificallyPublished() throws Exception
-    {
-        publisher.publish(3);
-        publisher.publish(5);
-
-        assertThat(publisher.isAvailable(0), is(false));
-        assertThat(publisher.isAvailable(1), is(false));
-        assertThat(publisher.isAvailable(2), is(false));
-        assertThat(publisher.isAvailable(3), is(true));
-        assertThat(publisher.isAvailable(4), is(false));
-        assertThat(publisher.isAvailable(5), is(true));
-        assertThat(publisher.isAvailable(6), is(false));
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/PhasedBackoffWaitStrategyTest.java b/src/test/java/com/lmax/disruptor/PhasedBackoffWaitStrategyTest.java
deleted file mode 100644
index 1598e86..0000000
--- a/src/test/java/com/lmax/disruptor/PhasedBackoffWaitStrategyTest.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright 2012 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor;
-
-import static com.lmax.disruptor.support.WaitStrategyTestUtil.assertWaitForWithDelayOf;
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-
-import org.junit.Test;
-
-public class PhasedBackoffWaitStrategyTest
-{
-    @Test
-    public void shouldHandleImmediateSequenceChange() throws Exception
-    {
-        assertWaitForWithDelayOf(0, PhasedBackoffWaitStrategy.withLock(1, 1, MILLISECONDS));
-        assertWaitForWithDelayOf(0, PhasedBackoffWaitStrategy.withSleep(1, 1, MILLISECONDS));
-    }
-
-    @Test
-    public void shouldHandleSequenceChangeWithOneMillisecondDelay() throws Exception
-    {
-        assertWaitForWithDelayOf(1, PhasedBackoffWaitStrategy.withLock(1, 1, MILLISECONDS));
-        assertWaitForWithDelayOf(1, PhasedBackoffWaitStrategy.withSleep(1, 1, MILLISECONDS));
-    }
-
-    @Test
-    public void shouldHandleSequenceChangeWithTwoMillisecondDelay() throws Exception
-    {
-        assertWaitForWithDelayOf(2, PhasedBackoffWaitStrategy.withLock(1, 1, MILLISECONDS));
-        assertWaitForWithDelayOf(2, PhasedBackoffWaitStrategy.withSleep(1, 1, MILLISECONDS));
-    }
-
-    @Test
-    public void shouldHandleSequenceChangeWithTenMillisecondDelay() throws Exception
-    {
-        assertWaitForWithDelayOf(10, PhasedBackoffWaitStrategy.withLock(1, 1, MILLISECONDS));
-        assertWaitForWithDelayOf(10, PhasedBackoffWaitStrategy.withSleep(1, 1, MILLISECONDS));
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/RingBufferEventMatcher.java b/src/test/java/com/lmax/disruptor/RingBufferEventMatcher.java
deleted file mode 100644
index bb54b65..0000000
--- a/src/test/java/com/lmax/disruptor/RingBufferEventMatcher.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package com.lmax.disruptor;
-
-import org.hamcrest.Description;
-import org.hamcrest.Factory;
-import org.hamcrest.Matcher;
-import org.hamcrest.TypeSafeMatcher;
-
-import static org.hamcrest.CoreMatchers.is;
-
-final class RingBufferEventMatcher extends TypeSafeMatcher<RingBuffer<Object[]>>
-{
-    private final Matcher<?>[] expectedValueMatchers;
-
-    private RingBufferEventMatcher(final Matcher<?>[] expectedValueMatchers)
-    {
-        this.expectedValueMatchers = expectedValueMatchers;
-    }
-
-    @Factory
-    public static RingBufferEventMatcher ringBufferWithEvents(final Matcher<?>... valueMatchers)
-    {
-        return new RingBufferEventMatcher(valueMatchers);
-    }
-
-    @Factory
-    public static RingBufferEventMatcher ringBufferWithEvents(final Object... values)
-    {
-        Matcher<?>[] valueMatchers = new Matcher[values.length];
-        for (int i = 0; i < values.length; i++)
-        {
-            final Object value = values[i];
-            valueMatchers[i] = is(value);
-        }
-        return new RingBufferEventMatcher(valueMatchers);
-    }
-
-    @Override
-    public boolean matchesSafely(final RingBuffer<Object[]> ringBuffer)
-    {
-        boolean matches = true;
-        for (int i = 0; i < expectedValueMatchers.length; i++)
-        {
-            final Matcher<?> expectedValueMatcher = expectedValueMatchers[i];
-            matches &= expectedValueMatcher.matches(ringBuffer.get(i)[0]);
-        }
-        return matches;
-    }
-
-    @Override
-    public void describeTo(final Description description)
-    {
-        description.appendText("Expected ring buffer with events matching: ");
-
-        for (Matcher<?> expectedValueMatcher : expectedValueMatchers)
-        {
-            expectedValueMatcher.describeTo(description);
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/test/java/com/lmax/disruptor/RingBufferTest.java b/src/test/java/com/lmax/disruptor/RingBufferTest.java
deleted file mode 100644
index 723e2a6..0000000
--- a/src/test/java/com/lmax/disruptor/RingBufferTest.java
+++ /dev/null
@@ -1,1484 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor;
-
-import static com.lmax.disruptor.RingBuffer.createMultiProducer;
-import static com.lmax.disruptor.RingBufferEventMatcher.ringBufferWithEvents;
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.CoreMatchers.nullValue;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-import java.util.List;
-import java.util.concurrent.BrokenBarrierException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.CyclicBarrier;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import org.junit.Test;
-
-import com.lmax.disruptor.support.StubEvent;
-import com.lmax.disruptor.support.TestWaiter;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-public class RingBufferTest
-{
-    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);
-    private final RingBuffer<StubEvent> ringBuffer = RingBuffer.createMultiProducer(StubEvent.EVENT_FACTORY, 32);
-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();
-
-    {
-        ringBuffer.addGatingSequences(new NoOpEventProcessor(ringBuffer).getSequence());
-    }
-
-    @Test
-    public void shouldClaimAndGet() throws Exception
-    {
-        assertEquals(SingleProducerSequencer.INITIAL_CURSOR_VALUE, ringBuffer.getCursor());
-
-        StubEvent expectedEvent = new StubEvent(2701);
-        ringBuffer.publishEvent(StubEvent.TRANSLATOR, expectedEvent.getValue(), expectedEvent.getTestString());
-
-        long sequence = sequenceBarrier.waitFor(0);
-        assertEquals(0, sequence);
-
-        StubEvent event = ringBuffer.get(sequence);
-        assertEquals(expectedEvent, event);
-
-        assertEquals(0L, ringBuffer.getCursor());
-    }
-
-    @Test
-    public void shouldClaimAndGetInSeparateThread() throws Exception
-    {
-        Future<List<StubEvent>> messages = getMessages(0, 0);
-
-        StubEvent expectedEvent = new StubEvent(2701);
-        ringBuffer.publishEvent(StubEvent.TRANSLATOR, expectedEvent.getValue(), expectedEvent.getTestString());
-
-        assertEquals(expectedEvent, messages.get().get(0));
-    }
-
-    @Test
-    public void shouldClaimAndGetMultipleMessages() throws Exception
-    {
-        int numMessages = ringBuffer.getBufferSize();
-        for (int i = 0; i < numMessages; i++)
-        {
-            ringBuffer.publishEvent(StubEvent.TRANSLATOR, i, "");
-        }
-
-        long expectedSequence = numMessages - 1;
-        long available = sequenceBarrier.waitFor(expectedSequence);
-        assertEquals(expectedSequence, available);
-
-        for (int i = 0; i < numMessages; i++)
-        {
-            assertEquals(i, ringBuffer.get(i).getValue());
-        }
-    }
-
-    @Test
-    public void shouldWrap() throws Exception
-    {
-        int numMessages = ringBuffer.getBufferSize();
-        int offset = 1000;
-        for (int i = 0; i < numMessages + offset; i++)
-        {
-            ringBuffer.publishEvent(StubEvent.TRANSLATOR, i, "");
-        }
-
-        long expectedSequence = numMessages + offset - 1;
-        long available = sequenceBarrier.waitFor(expectedSequence);
-        assertEquals(expectedSequence, available);
-
-        for (int i = offset; i < numMessages + offset; i++)
-        {
-            assertEquals(i, ringBuffer.get(i).getValue());
-        }
-    }
-
-    @Test
-    public void shouldPreventWrapping() throws Exception
-    {
-        Sequence sequence = new Sequence(Sequencer.INITIAL_CURSOR_VALUE);
-        final RingBuffer<StubEvent> ringBuffer = createMultiProducer(StubEvent.EVENT_FACTORY, 4);
-        ringBuffer.addGatingSequences(sequence);
-
-        ringBuffer.publishEvent(StubEvent.TRANSLATOR, 0, "0");
-        ringBuffer.publishEvent(StubEvent.TRANSLATOR, 1, "1");
-        ringBuffer.publishEvent(StubEvent.TRANSLATOR, 2, "2");
-        ringBuffer.publishEvent(StubEvent.TRANSLATOR, 3, "3");
-
-        assertFalse(ringBuffer.tryPublishEvent(StubEvent.TRANSLATOR, 3, "3"));
-    }
-
-    @Test
-    public void shouldThrowExceptionIfBufferIsFull() throws Exception
-    {
-        ringBuffer.addGatingSequences(new Sequence(ringBuffer.getBufferSize()));
-
-        try
-        {
-            for (int i = 0; i < ringBuffer.getBufferSize(); i++)
-            {
-                ringBuffer.publish(ringBuffer.tryNext());
-            }
-        }
-        catch (Exception e)
-        {
-            fail("Should not of thrown exception");
-        }
-
-        try
-        {
-            ringBuffer.tryNext();
-            fail("Exception should have been thrown");
-        }
-        catch (InsufficientCapacityException e)
-        {
-        }
-    }
-
-    @Test
-    public void shouldPreventPublishersOvertakingEventProcessorWrapPoint() throws InterruptedException
-    {
-        final int ringBufferSize = 16;
-        final CountDownLatch latch = new CountDownLatch(ringBufferSize);
-        final AtomicBoolean publisherComplete = new AtomicBoolean(false);
-        final RingBuffer<StubEvent> buffer2 = createMultiProducer(StubEvent.EVENT_FACTORY, ringBufferSize);
-        final TestEventProcessor processor = new TestEventProcessor(buffer2.newBarrier());
-        buffer2.addGatingSequences(processor.getSequence());
-
-        Thread thread = new Thread(
-            new Runnable()
-            {
-                @Override
-                public void run()
-                {
-                    for (int i = 0; i <= ringBufferSize; i++)
-                    {
-                        long sequence = buffer2.next();
-                        StubEvent event = buffer2.get(sequence);
-                        event.setValue(i);
-                        buffer2.publish(sequence);
-                        latch.countDown();
-                    }
-
-                    publisherComplete.set(true);
-                }
-            });
-        thread.start();
-
-        latch.await();
-        assertThat(Long.valueOf(buffer2.getCursor()), is(Long.valueOf(ringBufferSize - 1)));
-        assertFalse(publisherComplete.get());
-
-        processor.run();
-        thread.join();
-
-        assertTrue(publisherComplete.get());
-    }
-
-    @Test
-    public void shouldPublishEvent() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        final EventTranslator<Object[]> translator = new NoArgEventTranslator();
-
-        ringBuffer.publishEvent(translator);
-        ringBuffer.tryPublishEvent(translator);
-
-        assertThat(ringBuffer, ringBufferWithEvents(0L, 1L));
-    }
-
-    @Test
-    public void shouldPublishEventOneArg() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();
-
-        ringBuffer.publishEvent(translator, "Foo");
-        ringBuffer.tryPublishEvent(translator, "Foo");
-
-        assertThat(ringBuffer, ringBufferWithEvents("Foo-0", "Foo-1"));
-    }
-
-    @Test
-    public void shouldPublishEventTwoArg() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();
-
-        ringBuffer.publishEvent(translator, "Foo", "Bar");
-        ringBuffer.tryPublishEvent(translator, "Foo", "Bar");
-
-        assertThat(ringBuffer, ringBufferWithEvents("FooBar-0", "FooBar-1"));
-    }
-
-    @Test
-    public void shouldPublishEventThreeArg() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();
-
-        ringBuffer.publishEvent(translator, "Foo", "Bar", "Baz");
-        ringBuffer.tryPublishEvent(translator, "Foo", "Bar", "Baz");
-
-        assertThat(ringBuffer, ringBufferWithEvents("FooBarBaz-0", "FooBarBaz-1"));
-    }
-
-    @Test
-    public void shouldPublishEventVarArg() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorVararg<Object[]> translator = new VarArgEventTranslator();
-
-        ringBuffer.publishEvent(translator, "Foo", "Bar", "Baz", "Bam");
-        ringBuffer.tryPublishEvent(translator, "Foo", "Bar", "Baz", "Bam");
-
-        assertThat(ringBuffer, ringBufferWithEvents("FooBarBazBam-0", "FooBarBazBam-1"));
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test
-    public void shouldPublishEvents() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        final EventTranslator<Object[]> eventTranslator = new NoArgEventTranslator();
-        final EventTranslator<Object[]>[] translators = new EventTranslator[]{eventTranslator, eventTranslator};
-
-        ringBuffer.publishEvents(translators);
-        assertTrue(ringBuffer.tryPublishEvents(translators));
-
-        assertThat(ringBuffer, ringBufferWithEvents(0L, 1L, 2L, 3L));
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsIfBatchIsLargerThanRingBuffer() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        final EventTranslator<Object[]> eventTranslator = new NoArgEventTranslator();
-        final EventTranslator<Object[]>[] translators =
-            new EventTranslator[]{eventTranslator, eventTranslator, eventTranslator, eventTranslator, eventTranslator};
-
-        try
-        {
-            ringBuffer.tryPublishEvents(translators);
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test
-    public void shouldPublishEventsWithBatchSizeOfOne() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        final EventTranslator<Object[]> eventTranslator = new NoArgEventTranslator();
-        final EventTranslator<Object[]>[] translators =
-            new EventTranslator[]{eventTranslator, eventTranslator, eventTranslator};
-
-        ringBuffer.publishEvents(translators, 0, 1);
-        assertTrue(ringBuffer.tryPublishEvents(translators, 0, 1));
-
-        assertThat(
-            ringBuffer, ringBufferWithEvents(
-                is((Object) 0L), is((Object) 1L), is(nullValue()), is(
-                    nullValue())));
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test
-    public void shouldPublishEventsWithinBatch() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        final EventTranslator<Object[]> eventTranslator = new NoArgEventTranslator();
-        final EventTranslator<Object[]>[] translators =
-            new EventTranslator[]{eventTranslator, eventTranslator, eventTranslator};
-
-        ringBuffer.publishEvents(translators, 1, 2);
-        assertTrue(ringBuffer.tryPublishEvents(translators, 1, 2));
-
-        assertThat(ringBuffer, ringBufferWithEvents(0L, 1L, 2L, 3L));
-    }
-
-    @Test
-    public void shouldPublishEventsOneArg() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();
-
-        ringBuffer.publishEvents(translator, new String[]{"Foo", "Foo"});
-        assertTrue(ringBuffer.tryPublishEvents(translator, new String[]{"Foo", "Foo"}));
-
-        assertThat(ringBuffer, ringBufferWithEvents("Foo-0", "Foo-1", "Foo-2", "Foo-3"));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsOneArgIfBatchIsLargerThanRingBuffer() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(translator, new String[]{"Foo", "Foo", "Foo", "Foo", "Foo"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test
-    public void shouldPublishEventsOneArgBatchSizeOfOne() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();
-
-        ringBuffer.publishEvents(translator, 0, 1, new String[]{"Foo", "Foo"});
-        assertTrue(ringBuffer.tryPublishEvents(translator, 0, 1, new String[]{"Foo", "Foo"}));
-
-        assertThat(
-            ringBuffer, ringBufferWithEvents(
-                is((Object) "Foo-0"), is((Object) "Foo-1"), is(nullValue()), is(
-                    nullValue())));
-    }
-
-    @Test
-    public void shouldPublishEventsOneArgWithinBatch() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();
-
-        ringBuffer.publishEvents(translator, 1, 2, new String[]{"Foo", "Foo", "Foo"});
-        assertTrue(ringBuffer.tryPublishEvents(translator, 1, 2, new String[]{"Foo", "Foo", "Foo"}));
-
-        assertThat(ringBuffer, ringBufferWithEvents("Foo-0", "Foo-1", "Foo-2", "Foo-3"));
-    }
-
-    @Test
-    public void shouldPublishEventsTwoArg() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();
-
-        ringBuffer.publishEvents(translator, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"});
-        ringBuffer.tryPublishEvents(translator, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"});
-
-        assertThat(ringBuffer, ringBufferWithEvents("FooBar-0", "FooBar-1", "FooBar-2", "FooBar-3"));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsITwoArgIfBatchSizeIsBiggerThanRingBuffer() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(
-                translator,
-                new String[]{"Foo", "Foo", "Foo", "Foo", "Foo"},
-                new String[]{"Bar", "Bar", "Bar", "Bar", "Bar"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test
-    public void shouldPublishEventsTwoArgWithBatchSizeOfOne() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();
-
-        ringBuffer.publishEvents(translator, 0, 1, new String[]{"Foo0", "Foo1"}, new String[]{"Bar0", "Bar1"});
-        ringBuffer.tryPublishEvents(translator, 0, 1, new String[]{"Foo2", "Foo3"}, new String[]{"Bar2", "Bar3"});
-
-        assertThat(
-            ringBuffer, ringBufferWithEvents(
-                is((Object) "Foo0Bar0-0"), is((Object) "Foo2Bar2-1"), is(
-                    nullValue()), is(nullValue())));
-    }
-
-    @Test
-    public void shouldPublishEventsTwoArgWithinBatch() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();
-
-        ringBuffer.publishEvents(
-            translator, 1, 2, new String[]{"Foo0", "Foo1", "Foo2"}, new String[]{"Bar0", "Bar1", "Bar2"});
-        ringBuffer.tryPublishEvents(
-            translator, 1, 2, new String[]{"Foo3", "Foo4", "Foo5"}, new String[]{"Bar3", "Bar4", "Bar5"});
-
-        assertThat(ringBuffer, ringBufferWithEvents("Foo1Bar1-0", "Foo2Bar2-1", "Foo4Bar4-2", "Foo5Bar5-3"));
-    }
-
-    @Test
-    public void shouldPublishEventsThreeArg() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();
-
-        ringBuffer.publishEvents(
-            translator, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"}, new String[]{"Baz", "Baz"});
-        ringBuffer.tryPublishEvents(
-            translator, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"}, new String[]{"Baz", "Baz"});
-
-        assertThat(ringBuffer, ringBufferWithEvents("FooBarBaz-0", "FooBarBaz-1", "FooBarBaz-2", "FooBarBaz-3"));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsThreeArgIfBatchIsLargerThanRingBuffer() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(
-                translator,
-                new String[]{"Foo", "Foo", "Foo", "Foo", "Foo"},
-                new String[]{"Bar", "Bar", "Bar", "Bar", "Bar"},
-                new String[]{"Baz", "Baz", "Baz", "Baz", "Baz"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test
-    public void shouldPublishEventsThreeArgBatchSizeOfOne() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();
-
-        ringBuffer.publishEvents(
-            translator, 0, 1, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"}, new String[]{"Baz", "Baz"});
-        ringBuffer.tryPublishEvents(
-            translator, 0, 1, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"}, new String[]{"Baz", "Baz"});
-
-        assertThat(
-            ringBuffer, ringBufferWithEvents(
-                is((Object) "FooBarBaz-0"), is((Object) "FooBarBaz-1"), is(
-                    nullValue()), is(nullValue())));
-    }
-
-    @Test
-    public void shouldPublishEventsThreeArgWithinBatch() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();
-
-        ringBuffer.publishEvents(
-            translator, 1, 2, new String[]{"Foo0", "Foo1", "Foo2"}, new String[]{"Bar0", "Bar1", "Bar2"},
-            new String[]{"Baz0", "Baz1", "Baz2"}
-        );
-        assertTrue(
-            ringBuffer.tryPublishEvents(
-                translator, 1, 2, new String[]{"Foo3", "Foo4", "Foo5"}, new String[]{"Bar3", "Bar4", "Bar5"},
-                new String[]{"Baz3", "Baz4", "Baz5"}));
-
-        assertThat(
-            ringBuffer, ringBufferWithEvents(
-                "Foo1Bar1Baz1-0", "Foo2Bar2Baz2-1", "Foo4Bar4Baz4-2", "Foo5Bar5Baz5-3"));
-    }
-
-    @Test
-    public void shouldPublishEventsVarArg() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorVararg<Object[]> translator = new VarArgEventTranslator();
-
-        ringBuffer.publishEvents(
-            translator, new String[]{"Foo", "Bar", "Baz", "Bam"}, new String[]{"Foo", "Bar", "Baz", "Bam"});
-        assertTrue(
-            ringBuffer.tryPublishEvents(
-                translator, new String[]{"Foo", "Bar", "Baz", "Bam"}, new String[]{"Foo", "Bar", "Baz", "Bam"}));
-
-        assertThat(
-            ringBuffer, ringBufferWithEvents(
-                "FooBarBazBam-0", "FooBarBazBam-1", "FooBarBazBam-2", "FooBarBazBam-3"));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsVarArgIfBatchIsLargerThanRingBuffer() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorVararg<Object[]> translator = new VarArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(
-                translator,
-                new String[]{"Foo", "Bar", "Baz", "Bam"},
-                new String[]{"Foo", "Bar", "Baz", "Bam"},
-                new String[]{"Foo", "Bar", "Baz", "Bam"},
-                new String[]{"Foo", "Bar", "Baz", "Bam"},
-                new String[]{"Foo", "Bar", "Baz", "Bam"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test
-    public void shouldPublishEventsVarArgBatchSizeOfOne() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorVararg<Object[]> translator = new VarArgEventTranslator();
-
-        ringBuffer.publishEvents(
-            translator, 0, 1, new String[]{"Foo", "Bar", "Baz", "Bam"}, new String[]{"Foo", "Bar", "Baz", "Bam"});
-        assertTrue(
-            ringBuffer.tryPublishEvents(
-                translator, 0, 1, new String[]{"Foo", "Bar", "Baz", "Bam"}, new String[]{"Foo", "Bar", "Baz", "Bam"}));
-
-        assertThat(
-            ringBuffer, ringBufferWithEvents(
-                is((Object) "FooBarBazBam-0"), is((Object) "FooBarBazBam-1"), is(
-                    nullValue()), is(nullValue())));
-    }
-
-    @Test
-    public void shouldPublishEventsVarArgWithinBatch() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorVararg<Object[]> translator = new VarArgEventTranslator();
-
-        ringBuffer.publishEvents(
-            translator, 1, 2, new String[]{"Foo0", "Bar0", "Baz0", "Bam0"},
-            new String[]{"Foo1", "Bar1", "Baz1", "Bam1"},
-            new String[]{"Foo2", "Bar2", "Baz2", "Bam2"});
-        assertTrue(
-            ringBuffer.tryPublishEvents(
-                translator, 1, 2, new String[]{"Foo3", "Bar3", "Baz3", "Bam3"},
-                new String[]{"Foo4", "Bar4", "Baz4", "Bam4"},
-                new String[]{"Foo5", "Bar5", "Baz5", "Bam5"}));
-
-        assertThat(
-            ringBuffer, ringBufferWithEvents(
-                "Foo1Bar1Baz1Bam1-0", "Foo2Bar2Baz2Bam2-1", "Foo4Bar4Baz4Bam4-2", "Foo5Bar5Baz5Bam5-3"));
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsWhenBatchSizeIs0() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslator<Object[]> translator = new NoArgEventTranslator();
-
-        try
-        {
-            ringBuffer.publishEvents(new EventTranslator[]{translator, translator, translator, translator}, 1, 0);
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotTryPublishEventsWhenBatchSizeIs0() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslator<Object[]> translator = new NoArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(new EventTranslator[]{translator, translator, translator, translator}, 1, 0);
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsWhenBatchExtendsPastEndOfArray() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslator<Object[]> translator = new NoArgEventTranslator();
-
-        try
-        {
-            ringBuffer.publishEvents(new EventTranslator[]{translator, translator, translator}, 1, 3);
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotTryPublishEventsWhenBatchExtendsPastEndOfArray() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslator<Object[]> translator = new NoArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(new EventTranslator[]{translator, translator, translator}, 1, 3);
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsWhenBatchSizeIsNegative() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslator<Object[]> translator = new NoArgEventTranslator();
-
-        try
-        {
-            ringBuffer.publishEvents(new EventTranslator[]{translator, translator, translator, translator}, 1, -1);
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotTryPublishEventsWhenBatchSizeIsNegative() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslator<Object[]> translator = new NoArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(new EventTranslator[]{translator, translator, translator, translator}, 1, -1);
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsWhenBatchStartsAtIsNegative() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslator<Object[]> translator = new NoArgEventTranslator();
-        try
-        {
-            ringBuffer.publishEvents(new EventTranslator[]{translator, translator, translator, translator}, -1, 2);
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotTryPublishEventsWhenBatchStartsAtIsNegative() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslator<Object[]> translator = new NoArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(new EventTranslator[]{translator, translator, translator, translator}, -1, 2);
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsOneArgWhenBatchSizeIs0() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();
-
-        try
-        {
-            ringBuffer.publishEvents(translator, 1, 0, new String[]{"Foo", "Foo"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotTryPublishEventsOneArgWhenBatchSizeIs0() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(translator, 1, 0, new String[]{"Foo", "Foo"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsOneArgWhenBatchExtendsPastEndOfArray() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();
-
-        try
-        {
-            ringBuffer.publishEvents(translator, 1, 3, new String[]{"Foo", "Foo"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsOneArgWhenBatchSizeIsNegative() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();
-
-        try
-        {
-            ringBuffer.publishEvents(translator, 1, -1, new String[]{"Foo", "Foo"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsOneArgWhenBatchStartsAtIsNegative() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();
-        try
-        {
-            ringBuffer.publishEvents(translator, -1, 2, new String[]{"Foo", "Foo"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotTryPublishEventsOneArgWhenBatchExtendsPastEndOfArray() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(translator, 1, 3, new String[]{"Foo", "Foo"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotTryPublishEventsOneArgWhenBatchSizeIsNegative() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();
-
-        try
-        {
-            assertFalse(ringBuffer.tryPublishEvents(translator, 1, -1, new String[]{"Foo", "Foo"}));
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotTryPublishEventsOneArgWhenBatchStartsAtIsNegative() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(translator, -1, 2, new String[]{"Foo", "Foo"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsTwoArgWhenBatchSizeIs0() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();
-
-        try
-        {
-            ringBuffer.publishEvents(translator, 1, 0, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotTryPublishEventsTwoArgWhenBatchSizeIs0() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(translator, 1, 0, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsTwoArgWhenBatchExtendsPastEndOfArray() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();
-
-        try
-        {
-            ringBuffer.publishEvents(translator, 1, 3, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsTwoArgWhenBatchSizeIsNegative() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();
-
-        try
-        {
-            ringBuffer.publishEvents(translator, 1, -1, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsTwoArgWhenBatchStartsAtIsNegative() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();
-        try
-        {
-            ringBuffer.publishEvents(translator, -1, 2, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotTryPublishEventsTwoArgWhenBatchExtendsPastEndOfArray() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(translator, 1, 3, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotTryPublishEventsTwoArgWhenBatchSizeIsNegative() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(translator, 1, -1, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotTryPublishEventsTwoArgWhenBatchStartsAtIsNegative() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(translator, -1, 2, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsThreeArgWhenBatchSizeIs0() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();
-
-        try
-        {
-            ringBuffer.publishEvents(
-                translator, 1, 0, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"},
-                new String[]{"Baz", "Baz"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotTryPublishEventsThreeArgWhenBatchSizeIs0() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(
-                    translator, 1, 0, new String[]{"Foo", "Foo"},
-                    new String[]{"Bar", "Bar"}, new String[]{"Baz", "Baz"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsThreeArgWhenBatchExtendsPastEndOfArray() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();
-
-        try
-        {
-            ringBuffer.publishEvents(
-                translator, 1, 3, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"},
-                new String[]{"Baz", "Baz"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsThreeArgWhenBatchSizeIsNegative() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();
-
-        try
-        {
-            ringBuffer.publishEvents(
-                translator, 1, -1, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"},
-                new String[]{"Baz", "Baz"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsThreeArgWhenBatchStartsAtIsNegative() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();
-
-        try
-        {
-            ringBuffer.publishEvents(
-                translator, -1, 2, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"},
-                new String[]{"Baz", "Baz"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotTryPublishEventsThreeArgWhenBatchExtendsPastEndOfArray() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(
-                translator, 1, 3, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"},
-                new String[]{"Baz", "Baz"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotTryPublishEventsThreeArgWhenBatchSizeIsNegative() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(
-                translator, 1, -1, new String[]{"Foo", "Foo"},
-                new String[]{"Bar", "Bar"}, new String[]{"Baz", "Baz"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotTryPublishEventsThreeArgWhenBatchStartsAtIsNegative() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(
-                translator, -1, 2, new String[]{"Foo", "Foo"},
-                new String[]{"Bar", "Bar"}, new String[]{"Baz", "Baz"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsVarArgWhenBatchSizeIs0() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        VarArgEventTranslator translator = new VarArgEventTranslator();
-
-        try
-        {
-            ringBuffer.publishEvents(
-                translator, 1, 0, new String[]{"Foo0", "Bar0", "Baz0", "Bam0"},
-                new String[]{"Foo1", "Bar1", "Baz1", "Bam1"}, new String[]{
-                    "Foo2", "Bar2",
-                    "Baz2", "Bam2"
-                });
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotTryPublishEventsVarArgWhenBatchSizeIs0() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        VarArgEventTranslator translator = new VarArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(
-                    translator, 1, 0, new String[]{"Foo0", "Bar0", "Baz0", "Bam0"},
-                    new String[]{"Foo1", "Bar1", "Baz1", "Bam1"},
-                    new String[]{"Foo2", "Bar2", "Baz2", "Bam2"});
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsVarArgWhenBatchExtendsPastEndOfArray() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        VarArgEventTranslator translator = new VarArgEventTranslator();
-
-        try
-        {
-            ringBuffer.publishEvents(
-                translator, 1, 3, new String[]{"Foo0", "Bar0", "Baz0", "Bam0"},
-                new String[]{"Foo1", "Bar1", "Baz1", "Bam1"}, new String[]{
-                    "Foo2", "Bar2",
-                    "Baz2", "Bam2"
-                });
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsVarArgWhenBatchSizeIsNegative() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        VarArgEventTranslator translator = new VarArgEventTranslator();
-
-        try
-        {
-            ringBuffer.publishEvents(
-                translator, 1, -1, new String[]{"Foo0", "Bar0", "Baz0", "Bam0"},
-                new String[]{"Foo1", "Bar1", "Baz1", "Bam1"}, new String[]{
-                    "Foo2", "Bar2",
-                    "Baz2", "Bam2"
-                });
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotPublishEventsVarArgWhenBatchStartsAtIsNegative() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        VarArgEventTranslator translator = new VarArgEventTranslator();
-
-        try
-        {
-            ringBuffer.publishEvents(
-                translator, -1, 2, new String[]{"Foo0", "Bar0", "Baz0", "Bam0"},
-                new String[]{"Foo1", "Bar1", "Baz1", "Bam1"}, new String[]{
-                    "Foo2", "Bar2",
-                    "Baz2", "Bam2"
-                });
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotTryPublishEventsVarArgWhenBatchExtendsPastEndOfArray() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        VarArgEventTranslator translator = new VarArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(
-                translator, 1, 3, new String[]{"Foo0", "Bar0", "Baz0", "Bam0"},
-                new String[]{"Foo1", "Bar1", "Baz1", "Bam1"}, new String[]{
-                    "Foo2", "Bar2",
-                    "Baz2", "Bam2"
-                });
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotTryPublishEventsVarArgWhenBatchSizeIsNegative() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        VarArgEventTranslator translator = new VarArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(
-                translator, 1, -1, new String[]{"Foo0", "Bar0", "Baz0", "Bam0"},
-                new String[]{"Foo1", "Bar1", "Baz1", "Bam1"}, new String[]{
-                    "Foo2", "Bar2",
-                    "Baz2", "Bam2"
-                });
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotTryPublishEventsVarArgWhenBatchStartsAtIsNegative() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);
-        VarArgEventTranslator translator = new VarArgEventTranslator();
-
-        try
-        {
-            ringBuffer.tryPublishEvents(
-                translator, -1, 2, new String[]{"Foo0", "Bar0", "Baz0", "Bam0"},
-                new String[]{"Foo1", "Bar1", "Baz1", "Bam1"}, new String[]{
-                    "Foo2", "Bar2",
-                    "Baz2", "Bam2"
-                });
-        }
-        finally
-        {
-            assertEmptyRingBuffer(ringBuffer);
-        }
-    }
-
-    @Test
-    public void shouldAddAndRemoveSequences() throws Exception
-    {
-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 16);
-
-        Sequence sequenceThree = new Sequence(-1);
-        Sequence sequenceSeven = new Sequence(-1);
-        ringBuffer.addGatingSequences(sequenceThree, sequenceSeven);
-
-        for (int i = 0; i < 10; i++)
-        {
-            ringBuffer.publish(ringBuffer.next());
-        }
-
-        sequenceThree.set(3);
-        sequenceSeven.set(7);
-
-        assertThat(ringBuffer.getMinimumGatingSequence(), is(3L));
-        assertTrue(ringBuffer.removeGatingSequence(sequenceThree));
-        assertThat(ringBuffer.getMinimumGatingSequence(), is(7L));
-    }
-
-    @Test
-    public void shouldHandleResetToAndNotWrapUnnecessarilySingleProducer() throws Exception
-    {
-        assertHandleResetAndNotWrap(RingBuffer.createSingleProducer(StubEvent.EVENT_FACTORY, 4));
-    }
-
-    @Test
-    public void shouldHandleResetToAndNotWrapUnnecessarilyMultiProducer() throws Exception
-    {
-        assertHandleResetAndNotWrap(RingBuffer.createMultiProducer(StubEvent.EVENT_FACTORY, 4));
-    }
-
-    @SuppressWarnings("deprecation")
-    private void assertHandleResetAndNotWrap(RingBuffer<StubEvent> rb)
-    {
-        Sequence sequence = new Sequence();
-        rb.addGatingSequences(sequence);
-
-        for (int i = 0; i < 128; i++)
-        {
-            rb.publish(rb.next());
-            sequence.incrementAndGet();
-        }
-
-        assertThat(rb.getCursor(), is(127L));
-
-        rb.resetTo(31);
-        sequence.set(31);
-
-        for (int i = 0; i < 4; i++)
-        {
-            rb.publish(rb.next());
-        }
-
-        assertThat(rb.hasAvailableCapacity(1), is(false));
-    }
-
-    private Future<List<StubEvent>> getMessages(final long initial, final long toWaitFor) throws InterruptedException,
-        BrokenBarrierException
-    {
-        final CyclicBarrier cyclicBarrier = new CyclicBarrier(2);
-        final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();
-
-        final Future<List<StubEvent>> f = executor.submit(
-            new TestWaiter(
-                cyclicBarrier, sequenceBarrier, ringBuffer,
-                initial, toWaitFor));
-
-        cyclicBarrier.await();
-
-        return f;
-    }
-
-    private void assertEmptyRingBuffer(final RingBuffer<Object[]> ringBuffer)
-    {
-        assertThat(ringBuffer.get(0)[0], is(nullValue()));
-        assertThat(ringBuffer.get(1)[0], is(nullValue()));
-        assertThat(ringBuffer.get(2)[0], is(nullValue()));
-        assertThat(ringBuffer.get(3)[0], is(nullValue()));
-    }
-
-    private static final class TestEventProcessor implements EventProcessor
-    {
-        private final SequenceBarrier sequenceBarrier;
-        private final Sequence sequence = new Sequence(SingleProducerSequencer.INITIAL_CURSOR_VALUE);
-        private final AtomicBoolean running = new AtomicBoolean();
-
-
-        TestEventProcessor(final SequenceBarrier sequenceBarrier)
-        {
-            this.sequenceBarrier = sequenceBarrier;
-        }
-
-        @Override
-        public Sequence getSequence()
-        {
-            return sequence;
-        }
-
-        @Override
-        public void halt()
-        {
-            running.set(false);
-        }
-
-        @Override
-        public boolean isRunning()
-        {
-            return running.get();
-        }
-
-        @Override
-        public void run()
-        {
-            if (!running.compareAndSet(false, true))
-            {
-                throw new IllegalStateException("Already running");
-            }
-            try
-            {
-                sequenceBarrier.waitFor(0L);
-            }
-            catch (Exception ex)
-            {
-                throw new RuntimeException(ex);
-            }
-
-            sequence.set(sequence.get() + 1L);
-        }
-    }
-
-    private static class ArrayFactory implements EventFactory<Object[]>
-    {
-        private final int size;
-
-        ArrayFactory(int size)
-        {
-            this.size = size;
-        }
-
-        @Override
-        public Object[] newInstance()
-        {
-            return new Object[size];
-        }
-    }
-
-    private static class NoArgEventTranslator implements EventTranslator<Object[]>
-    {
-        @Override
-        public void translateTo(Object[] event, long sequence)
-        {
-            event[0] = sequence;
-        }
-    }
-
-    private static class VarArgEventTranslator implements EventTranslatorVararg<Object[]>
-    {
-        @Override
-        public void translateTo(Object[] event, long sequence, Object... args)
-        {
-            event[0] = (String) args[0] + args[1] + args[2] + args[3] + "-" + sequence;
-        }
-    }
-
-    private static class ThreeArgEventTranslator implements EventTranslatorThreeArg<Object[], String, String, String>
-    {
-        @Override
-        public void translateTo(Object[] event, long sequence, String arg0, String arg1, String arg2)
-        {
-            event[0] = arg0 + arg1 + arg2 + "-" + sequence;
-        }
-    }
-
-    private static class TwoArgEventTranslator implements EventTranslatorTwoArg<Object[], String, String>
-    {
-        @Override
-        public void translateTo(Object[] event, long sequence, String arg0, String arg1)
-        {
-            event[0] = arg0 + arg1 + "-" + sequence;
-        }
-    }
-
-    private static class OneArgEventTranslator implements EventTranslatorOneArg<Object[], String>
-    {
-        @Override
-        public void translateTo(Object[] event, long sequence, String arg0)
-        {
-            event[0] = arg0 + "-" + sequence;
-        }
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/RingBufferWithAssertingStubTest.java b/src/test/java/com/lmax/disruptor/RingBufferWithAssertingStubTest.java
deleted file mode 100644
index 3654f3e..0000000
--- a/src/test/java/com/lmax/disruptor/RingBufferWithAssertingStubTest.java
+++ /dev/null
@@ -1,176 +0,0 @@
-package com.lmax.disruptor;
-
-import com.lmax.disruptor.support.StubEvent;
-import org.junit.Before;
-import org.junit.Test;
-
-import java.util.concurrent.ThreadLocalRandom;
-
-import static org.hamcrest.core.Is.is;
-import static org.junit.Assert.assertThat;
-
-public class RingBufferWithAssertingStubTest
-{
-    private RingBuffer<StubEvent> ringBuffer;
-    private Sequencer sequencer;
-
-    @Before
-    public void setUp()
-    {
-        sequencer = new AssertingSequencer(16);
-
-        ringBuffer = new RingBuffer<StubEvent>(StubEvent.EVENT_FACTORY, sequencer);
-    }
-
-    @Test
-    public void shouldDelegateNextAndPublish()
-    {
-        ringBuffer.publish(ringBuffer.next());
-    }
-
-    @Test
-    public void shouldDelegateTryNextAndPublish() throws Exception
-    {
-        ringBuffer.publish(ringBuffer.tryNext());
-    }
-
-    @Test
-    public void shouldDelegateNextNAndPublish() throws Exception
-    {
-        long hi = ringBuffer.next(10);
-        ringBuffer.publish(hi - 9, hi);
-    }
-
-    @Test
-    public void shouldDelegateTryNextNAndPublish() throws Exception
-    {
-        long hi = ringBuffer.tryNext(10);
-        ringBuffer.publish(hi - 9, hi);
-    }
-
-    private static final class AssertingSequencer implements Sequencer
-    {
-        private final int size;
-        private long lastBatchSize = -1;
-        private long lastValue = -1;
-
-        private AssertingSequencer(int size)
-        {
-            this.size = size;
-        }
-
-        @Override
-        public int getBufferSize()
-        {
-            return size;
-        }
-
-        @Override
-        public boolean hasAvailableCapacity(int requiredCapacity)
-        {
-            return requiredCapacity <= size;
-        }
-
-        @Override
-        public long remainingCapacity()
-        {
-            return size;
-        }
-
-        @Override
-        public long next()
-        {
-            lastValue = ThreadLocalRandom.current().nextLong(0, 1000000);
-            lastBatchSize = 1;
-            return lastValue;
-        }
-
-        @Override
-        public long next(int n)
-        {
-            lastValue = ThreadLocalRandom.current().nextLong(n, 1000000);
-            lastBatchSize = n;
-            return lastValue;
-        }
-
-        @Override
-        public long tryNext() throws InsufficientCapacityException
-        {
-            return next();
-        }
-
-        @Override
-        public long tryNext(int n) throws InsufficientCapacityException
-        {
-            return next(n);
-        }
-
-        @Override
-        public void publish(long sequence)
-        {
-            assertThat(sequence, is(lastValue));
-            assertThat(lastBatchSize, is(1L));
-        }
-
-        @Override
-        public void publish(long lo, long hi)
-        {
-            assertThat(hi, is(lastValue));
-            assertThat((hi - lo) + 1, is(lastBatchSize));
-        }
-
-        @Override
-        public long getCursor()
-        {
-            return lastValue;
-        }
-
-        @Override
-        public void claim(long sequence)
-        {
-
-        }
-
-        @Override
-        public boolean isAvailable(long sequence)
-        {
-            return false;
-        }
-
-        @Override
-        public void addGatingSequences(Sequence... gatingSequences)
-        {
-
-        }
-
-        @Override
-        public boolean removeGatingSequence(Sequence sequence)
-        {
-            return false;
-        }
-
-        @Override
-        public SequenceBarrier newBarrier(Sequence... sequencesToTrack)
-        {
-            return null;
-        }
-
-        @Override
-        public long getMinimumSequence()
-        {
-            return 0;
-        }
-
-        @Override
-        public long getHighestPublishedSequence(long nextSequence, long availableSequence)
-        {
-            return 0;
-        }
-
-        @Override
-        public <T> EventPoller<T> newPoller(DataProvider<T> provider, Sequence... gatingSequences)
-        {
-            return null;
-        }
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/SequenceBarrierTest.java b/src/test/java/com/lmax/disruptor/SequenceBarrierTest.java
deleted file mode 100644
index 32adf57..0000000
--- a/src/test/java/com/lmax/disruptor/SequenceBarrierTest.java
+++ /dev/null
@@ -1,215 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor;
-
-import com.lmax.disruptor.support.DummyEventProcessor;
-import com.lmax.disruptor.support.StubEvent;
-import com.lmax.disruptor.util.Util;
-import org.junit.Test;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-import static com.lmax.disruptor.RingBuffer.createMultiProducer;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-
-public final class SequenceBarrierTest
-{
-    private final RingBuffer<StubEvent> ringBuffer = createMultiProducer(StubEvent.EVENT_FACTORY, 64);
-
-    public SequenceBarrierTest()
-    {
-        ringBuffer.addGatingSequences(new NoOpEventProcessor(ringBuffer).getSequence());
-    }
-
-    @Test
-    public void shouldWaitForWorkCompleteWhereCompleteWorkThresholdIsAhead() throws Exception
-    {
-        final long expectedNumberMessages = 10;
-        final long expectedWorkSequence = 9;
-        fillRingBuffer(expectedNumberMessages);
-
-        final Sequence sequence1 = new Sequence(expectedNumberMessages);
-        final Sequence sequence2 = new Sequence(expectedWorkSequence);
-        final Sequence sequence3 = new Sequence(expectedNumberMessages);
-
-        final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier(sequence1, sequence2, sequence3);
-
-        long completedWorkSequence = sequenceBarrier.waitFor(expectedWorkSequence);
-        assertTrue(completedWorkSequence >= expectedWorkSequence);
-    }
-
-    @Test
-    public void shouldWaitForWorkCompleteWhereAllWorkersAreBlockedOnRingBuffer() throws Exception
-    {
-        long expectedNumberMessages = 10;
-        fillRingBuffer(expectedNumberMessages);
-
-        final DummyEventProcessor[] workers = new DummyEventProcessor[3];
-        for (int i = 0, size = workers.length; i < size; i++)
-        {
-            workers[i] = new DummyEventProcessor();
-            workers[i].setSequence(expectedNumberMessages - 1);
-        }
-
-        final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier(Util.getSequencesFor(workers));
-
-        Runnable runnable = new Runnable()
-        {
-            public void run()
-            {
-                long sequence = ringBuffer.next();
-                StubEvent event = ringBuffer.get(sequence);
-                event.setValue((int) sequence);
-                ringBuffer.publish(sequence);
-
-                for (DummyEventProcessor stubWorker : workers)
-                {
-                    stubWorker.setSequence(sequence);
-                }
-            }
-        };
-
-        new Thread(runnable).start();
-
-        long expectedWorkSequence = expectedNumberMessages;
-        long completedWorkSequence = sequenceBarrier.waitFor(expectedNumberMessages);
-        assertTrue(completedWorkSequence >= expectedWorkSequence);
-    }
-
-    @Test
-    public void shouldInterruptDuringBusySpin() throws Exception
-    {
-        final long expectedNumberMessages = 10;
-        fillRingBuffer(expectedNumberMessages);
-
-        final CountDownLatch latch = new CountDownLatch(3);
-        final Sequence sequence1 = new CountDownLatchSequence(8L, latch);
-        final Sequence sequence2 = new CountDownLatchSequence(8L, latch);
-        final Sequence sequence3 = new CountDownLatchSequence(8L, latch);
-
-        final SequenceBarrier sequenceBarrier =
-            ringBuffer.newBarrier(sequence1, sequence2, sequence3);
-
-        final boolean[] alerted = {false};
-        Thread t = new Thread(
-            new Runnable()
-            {
-                public void run()
-                {
-                    try
-                    {
-                        sequenceBarrier.waitFor(expectedNumberMessages - 1);
-                    }
-                    catch (AlertException e)
-                    {
-                        alerted[0] = true;
-                    }
-                    catch (Exception e)
-                    {
-                        // don't care
-                    }
-                }
-            });
-
-        t.start();
-        latch.await(3, TimeUnit.SECONDS);
-        sequenceBarrier.alert();
-        t.join();
-
-        assertTrue("Thread was not interrupted", alerted[0]);
-    }
-
-    @Test
-    public void shouldWaitForWorkCompleteWhereCompleteWorkThresholdIsBehind() throws Exception
-    {
-        long expectedNumberMessages = 10;
-        fillRingBuffer(expectedNumberMessages);
-
-        final DummyEventProcessor[] eventProcessors = new DummyEventProcessor[3];
-        for (int i = 0, size = eventProcessors.length; i < size; i++)
-        {
-            eventProcessors[i] = new DummyEventProcessor();
-            eventProcessors[i].setSequence(expectedNumberMessages - 2);
-        }
-
-        final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier(Util.getSequencesFor(eventProcessors));
-
-        Runnable runnable = new Runnable()
-        {
-            public void run()
-            {
-                for (DummyEventProcessor stubWorker : eventProcessors)
-                {
-                    stubWorker.setSequence(stubWorker.getSequence().get() + 1L);
-                }
-            }
-        };
-
-        Thread thread = new Thread(runnable);
-        thread.start();
-        thread.join();
-
-        long expectedWorkSequence = expectedNumberMessages - 1;
-        long completedWorkSequence = sequenceBarrier.waitFor(expectedWorkSequence);
-        assertTrue(completedWorkSequence >= expectedWorkSequence);
-    }
-
-    @Test
-    public void shouldSetAndClearAlertStatus()
-    {
-        SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();
-
-        assertFalse(sequenceBarrier.isAlerted());
-
-        sequenceBarrier.alert();
-        assertTrue(sequenceBarrier.isAlerted());
-
-        sequenceBarrier.clearAlert();
-        assertFalse(sequenceBarrier.isAlerted());
-    }
-
-    private void fillRingBuffer(long expectedNumberMessages) throws InterruptedException
-    {
-        for (long i = 0; i < expectedNumberMessages; i++)
-        {
-            long sequence = ringBuffer.next();
-            StubEvent event = ringBuffer.get(sequence);
-            event.setValue((int) i);
-            ringBuffer.publish(sequence);
-        }
-    }
-
-    private static final class CountDownLatchSequence extends Sequence
-    {
-        private final CountDownLatch latch;
-
-        private CountDownLatchSequence(final long initialValue, final CountDownLatch latch)
-        {
-            super(initialValue);
-            this.latch = latch;
-        }
-
-        @Override
-        public long get()
-        {
-            latch.countDown();
-            return super.get();
-        }
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/SequenceGroupTest.java b/src/test/java/com/lmax/disruptor/SequenceGroupTest.java
deleted file mode 100644
index 6980441..0000000
--- a/src/test/java/com/lmax/disruptor/SequenceGroupTest.java
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor;
-
-import static org.hamcrest.CoreMatchers.is;
-import static org.junit.Assert.*;
-
-import org.junit.Test;
-
-import com.lmax.disruptor.support.TestEvent;
-
-public final class SequenceGroupTest
-{
-    @Test
-    public void shouldReturnMaxSequenceWhenEmptyGroup()
-    {
-        final SequenceGroup sequenceGroup = new SequenceGroup();
-        assertEquals(Long.MAX_VALUE, sequenceGroup.get());
-    }
-
-    @Test
-    public void shouldAddOneSequenceToGroup()
-    {
-        final Sequence sequence = new Sequence(7L);
-        final SequenceGroup sequenceGroup = new SequenceGroup();
-
-        sequenceGroup.add(sequence);
-
-        assertEquals(sequence.get(), sequenceGroup.get());
-    }
-
-    @Test
-    public void shouldNotFailIfTryingToRemoveNotExistingSequence() throws Exception
-    {
-        SequenceGroup group = new SequenceGroup();
-        group.add(new Sequence());
-        group.add(new Sequence());
-        group.remove(new Sequence());
-    }
-
-    @Test
-    public void shouldReportTheMinimumSequenceForGroupOfTwo()
-    {
-        final Sequence sequenceThree = new Sequence(3L);
-        final Sequence sequenceSeven = new Sequence(7L);
-        final SequenceGroup sequenceGroup = new SequenceGroup();
-
-        sequenceGroup.add(sequenceSeven);
-        sequenceGroup.add(sequenceThree);
-
-        assertEquals(sequenceThree.get(), sequenceGroup.get());
-    }
-
-    @Test
-    public void shouldReportSizeOfGroup()
-    {
-        final SequenceGroup sequenceGroup = new SequenceGroup();
-        sequenceGroup.add(new Sequence());
-        sequenceGroup.add(new Sequence());
-        sequenceGroup.add(new Sequence());
-
-        assertEquals(3, sequenceGroup.size());
-    }
-
-    @Test
-    public void shouldRemoveSequenceFromGroup()
-    {
-        final Sequence sequenceThree = new Sequence(3L);
-        final Sequence sequenceSeven = new Sequence(7L);
-        final SequenceGroup sequenceGroup = new SequenceGroup();
-
-        sequenceGroup.add(sequenceSeven);
-        sequenceGroup.add(sequenceThree);
-
-        assertEquals(sequenceThree.get(), sequenceGroup.get());
-
-        assertTrue(sequenceGroup.remove(sequenceThree));
-        assertEquals(sequenceSeven.get(), sequenceGroup.get());
-        assertEquals(1, sequenceGroup.size());
-    }
-
-    @Test
-    public void shouldRemoveSequenceFromGroupWhereItBeenAddedMultipleTimes()
-    {
-        final Sequence sequenceThree = new Sequence(3L);
-        final Sequence sequenceSeven = new Sequence(7L);
-        final SequenceGroup sequenceGroup = new SequenceGroup();
-
-        sequenceGroup.add(sequenceThree);
-        sequenceGroup.add(sequenceSeven);
-        sequenceGroup.add(sequenceThree);
-
-        assertEquals(sequenceThree.get(), sequenceGroup.get());
-
-        assertTrue(sequenceGroup.remove(sequenceThree));
-        assertEquals(sequenceSeven.get(), sequenceGroup.get());
-        assertEquals(1, sequenceGroup.size());
-    }
-
-    @Test
-    public void shouldSetGroupSequenceToSameValue()
-    {
-        final Sequence sequenceThree = new Sequence(3L);
-        final Sequence sequenceSeven = new Sequence(7L);
-        final SequenceGroup sequenceGroup = new SequenceGroup();
-
-        sequenceGroup.add(sequenceSeven);
-        sequenceGroup.add(sequenceThree);
-
-        final long expectedSequence = 11L;
-        sequenceGroup.set(expectedSequence);
-
-        assertEquals(expectedSequence, sequenceThree.get());
-        assertEquals(expectedSequence, sequenceSeven.get());
-    }
-
-    @Test
-    public void shouldAddWhileRunning() throws Exception
-    {
-        RingBuffer<TestEvent> ringBuffer = RingBuffer.createSingleProducer(TestEvent.EVENT_FACTORY, 32);
-        final Sequence sequenceThree = new Sequence(3L);
-        final Sequence sequenceSeven = new Sequence(7L);
-        final SequenceGroup sequenceGroup = new SequenceGroup();
-        sequenceGroup.add(sequenceSeven);
-
-        for (int i = 0; i < 11; i++)
-        {
-            ringBuffer.publish(ringBuffer.next());
-        }
-
-        sequenceGroup.addWhileRunning(ringBuffer, sequenceThree);
-        assertThat(sequenceThree.get(), is(10L));
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/SequenceReportingCallbackTest.java b/src/test/java/com/lmax/disruptor/SequenceReportingCallbackTest.java
deleted file mode 100644
index 8c37b4e..0000000
--- a/src/test/java/com/lmax/disruptor/SequenceReportingCallbackTest.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor;
-
-import com.lmax.disruptor.support.StubEvent;
-import org.junit.Test;
-
-import java.util.concurrent.CountDownLatch;
-
-import static com.lmax.disruptor.RingBuffer.createMultiProducer;
-import static org.junit.Assert.assertEquals;
-
-public class SequenceReportingCallbackTest
-{
-    private final CountDownLatch callbackLatch = new CountDownLatch(1);
-    private final CountDownLatch onEndOfBatchLatch = new CountDownLatch(1);
-
-    @Test
-    public void shouldReportProgressByUpdatingSequenceViaCallback()
-        throws Exception
-    {
-        final RingBuffer<StubEvent> ringBuffer = createMultiProducer(StubEvent.EVENT_FACTORY, 16);
-        final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();
-        final SequenceReportingEventHandler<StubEvent> handler = new TestSequenceReportingEventHandler();
-        final BatchEventProcessor<StubEvent> batchEventProcessor = new BatchEventProcessor<StubEvent>(
-            ringBuffer, sequenceBarrier, handler);
-        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());
-
-        Thread thread = new Thread(batchEventProcessor);
-        thread.setDaemon(true);
-        thread.start();
-
-        assertEquals(-1L, batchEventProcessor.getSequence().get());
-        ringBuffer.publish(ringBuffer.next());
-
-        callbackLatch.await();
-        assertEquals(0L, batchEventProcessor.getSequence().get());
-
-        onEndOfBatchLatch.countDown();
-        assertEquals(0L, batchEventProcessor.getSequence().get());
-
-        batchEventProcessor.halt();
-        thread.join();
-    }
-
-    private class TestSequenceReportingEventHandler implements SequenceReportingEventHandler<StubEvent>
-    {
-        private Sequence sequenceCallback;
-
-        @Override
-        public void setSequenceCallback(final Sequence sequenceTrackerCallback)
-        {
-            this.sequenceCallback = sequenceTrackerCallback;
-        }
-
-        @Override
-        public void onEvent(final StubEvent event, final long sequence, final boolean endOfBatch) throws Exception
-        {
-            sequenceCallback.set(sequence);
-            callbackLatch.countDown();
-
-            if (endOfBatch)
-            {
-                onEndOfBatchLatch.await();
-            }
-        }
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/SequencerTest.java b/src/test/java/com/lmax/disruptor/SequencerTest.java
deleted file mode 100644
index 94e1ab6..0000000
--- a/src/test/java/com/lmax/disruptor/SequencerTest.java
+++ /dev/null
@@ -1,280 +0,0 @@
-package com.lmax.disruptor;
-
-import com.lmax.disruptor.dsl.ProducerType;
-import com.lmax.disruptor.support.DummyWaitStrategy;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
-import static org.hamcrest.CoreMatchers.is;
-import static org.junit.Assert.*;
-
-@RunWith(Parameterized.class)
-public class SequencerTest
-{
-    private static final int BUFFER_SIZE = 16;
-    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);
-
-    private final Sequencer sequencer;
-    private final Sequence gatingSequence = new Sequence();
-    private final ProducerType producerType;
-
-    public SequencerTest(ProducerType producerType, WaitStrategy waitStrategy)
-    {
-        this.producerType = producerType;
-        this.sequencer = newProducer(producerType, BUFFER_SIZE, waitStrategy);
-    }
-
-    @Parameters
-    public static Collection<Object[]> generateData()
-    {
-        Object[][] allocators =
-            {
-                {ProducerType.SINGLE, new BlockingWaitStrategy()},
-                {ProducerType.MULTI, new BlockingWaitStrategy()},
-            };
-        return Arrays.asList(allocators);
-    }
-
-    @Test
-    public void shouldStartWithInitialValue()
-    {
-        assertEquals(0, sequencer.next());
-    }
-
-    @Test
-    public void shouldBatchClaim()
-    {
-        assertEquals(3, sequencer.next(4));
-    }
-
-    @Test
-    public void shouldIndicateHasAvailableCapacity()
-    {
-        sequencer.addGatingSequences(gatingSequence);
-
-        assertTrue(sequencer.hasAvailableCapacity(1));
-        assertTrue(sequencer.hasAvailableCapacity(BUFFER_SIZE));
-        assertFalse(sequencer.hasAvailableCapacity(BUFFER_SIZE + 1));
-
-        sequencer.publish(sequencer.next());
-
-        assertTrue(sequencer.hasAvailableCapacity(BUFFER_SIZE - 1));
-        assertFalse(sequencer.hasAvailableCapacity(BUFFER_SIZE));
-    }
-
-    @Test
-    public void shouldIndicateNoAvailableCapacity()
-    {
-        sequencer.addGatingSequences(gatingSequence);
-        long sequence = sequencer.next(BUFFER_SIZE);
-        sequencer.publish(sequence - (BUFFER_SIZE - 1), sequence);
-
-        assertFalse(sequencer.hasAvailableCapacity(1));
-    }
-
-    @Test
-    public void shouldHoldUpPublisherWhenBufferIsFull()
-        throws InterruptedException
-    {
-        sequencer.addGatingSequences(gatingSequence);
-        long sequence = sequencer.next(BUFFER_SIZE);
-        sequencer.publish(sequence - (BUFFER_SIZE - 1), sequence);
-
-        final CountDownLatch waitingLatch = new CountDownLatch(1);
-        final CountDownLatch doneLatch = new CountDownLatch(1);
-
-        final long expectedFullSequence = Sequencer.INITIAL_CURSOR_VALUE + sequencer.getBufferSize();
-        assertThat(sequencer.getCursor(), is(expectedFullSequence));
-
-        executor.submit(
-            new Runnable()
-            {
-                @Override
-                public void run()
-                {
-                    waitingLatch.countDown();
-
-                    long next = sequencer.next();
-                    sequencer.publish(next);
-
-                    doneLatch.countDown();
-                }
-            });
-
-        waitingLatch.await();
-        assertThat(sequencer.getCursor(), is(expectedFullSequence));
-
-        gatingSequence.set(Sequencer.INITIAL_CURSOR_VALUE + 1L);
-
-        doneLatch.await();
-        assertThat(sequencer.getCursor(), is(expectedFullSequence + 1L));
-    }
-
-    @Test(expected = InsufficientCapacityException.class)
-    public void shouldThrowInsufficientCapacityExceptionWhenSequencerIsFull() throws Exception
-    {
-        sequencer.addGatingSequences(gatingSequence);
-        for (int i = 0; i < BUFFER_SIZE; i++)
-        {
-            sequencer.next();
-        }
-        sequencer.tryNext();
-    }
-
-    @Test
-    public void shouldCalculateRemainingCapacity() throws Exception
-    {
-        sequencer.addGatingSequences(gatingSequence);
-
-        assertThat(sequencer.remainingCapacity(), is((long) BUFFER_SIZE));
-        for (int i = 1; i < BUFFER_SIZE; i++)
-        {
-            sequencer.next();
-            assertThat(sequencer.remainingCapacity(), is((long) BUFFER_SIZE - i));
-        }
-    }
-
-    @Test
-    public void shouldNotBeAvailableUntilPublished() throws Exception
-    {
-        long next = sequencer.next(6);
-
-        for (int i = 0; i <= 5; i++)
-        {
-            assertThat(sequencer.isAvailable(i), is(false));
-        }
-
-        sequencer.publish(next - (6 - 1), next);
-
-        for (int i = 0; i <= 5; i++)
-        {
-            assertThat(sequencer.isAvailable(i), is(true));
-        }
-
-        assertThat(sequencer.isAvailable(6), is(false));
-    }
-
-    @Test
-    public void shouldNotifyWaitStrategyOnPublish() throws Exception
-    {
-        final DummyWaitStrategy waitStrategy = new DummyWaitStrategy();
-        final Sequenced sequencer = newProducer(producerType, BUFFER_SIZE, waitStrategy);
-
-        sequencer.publish(sequencer.next());
-
-        assertThat(waitStrategy.signalAllWhenBlockingCalls, is(1));
-    }
-
-    @Test
-    public void shouldNotifyWaitStrategyOnPublishBatch() throws Exception
-    {
-        final DummyWaitStrategy waitStrategy = new DummyWaitStrategy();
-        final Sequenced sequencer = newProducer(producerType, BUFFER_SIZE, waitStrategy);
-
-        long next = sequencer.next(4);
-        sequencer.publish(next - (4 - 1), next);
-
-        assertThat(waitStrategy.signalAllWhenBlockingCalls, is(1));
-    }
-
-    @Test
-    public void shouldWaitOnPublication() throws Exception
-    {
-        SequenceBarrier barrier = sequencer.newBarrier();
-
-        long next = sequencer.next(10);
-        long lo = next - (10 - 1);
-        long mid = next - 5;
-
-        for (long l = lo; l < mid; l++)
-        {
-            sequencer.publish(l);
-        }
-
-        assertThat(barrier.waitFor(-1), is(mid - 1));
-
-        for (long l = mid; l <= next; l++)
-        {
-            sequencer.publish(l);
-        }
-
-        assertThat(barrier.waitFor(-1), is(next));
-    }
-
-    @Test
-    public void shouldTryNext() throws Exception
-    {
-        sequencer.addGatingSequences(gatingSequence);
-
-        for (int i = 0; i < BUFFER_SIZE; i++)
-        {
-            sequencer.publish(sequencer.tryNext());
-        }
-
-        try
-        {
-            sequencer.tryNext();
-            fail("Should of thrown: " + InsufficientCapacityException.class.getSimpleName());
-        }
-        catch (InsufficientCapacityException e)
-        {
-            // No-op
-        }
-    }
-
-    @Test
-    public void shouldClaimSpecificSequence() throws Exception
-    {
-        long sequence = 14L;
-
-        sequencer.claim(sequence);
-        sequencer.publish(sequence);
-        assertThat(sequencer.next(), is(sequence + 1));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotAllowBulkNextLessThanZero() throws Exception
-    {
-        sequencer.next(-1);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotAllowBulkNextOfZero() throws Exception
-    {
-        sequencer.next(0);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotAllowBulkTryNextLessThanZero() throws Exception
-    {
-        sequencer.tryNext(-1);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldNotAllowBulkTryNextOfZero() throws Exception
-    {
-        sequencer.tryNext(0);
-    }
-
-    private Sequencer newProducer(ProducerType producerType, int bufferSize, WaitStrategy waitStrategy)
-    {
-        switch (producerType)
-        {
-            case SINGLE:
-                return new SingleProducerSequencer(bufferSize, waitStrategy);
-            case MULTI:
-                return new MultiProducerSequencer(bufferSize, waitStrategy);
-            default:
-                throw new IllegalStateException(producerType.toString());
-        }
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/ShutdownOnFatalExceptionTest.java b/src/test/java/com/lmax/disruptor/ShutdownOnFatalExceptionTest.java
deleted file mode 100644
index 367f33a..0000000
--- a/src/test/java/com/lmax/disruptor/ShutdownOnFatalExceptionTest.java
+++ /dev/null
@@ -1,100 +0,0 @@
-package com.lmax.disruptor;
-
-import com.lmax.disruptor.dsl.Disruptor;
-import com.lmax.disruptor.dsl.ProducerType;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import java.util.Random;
-
-public class ShutdownOnFatalExceptionTest
-{
-
-    private final Random random = new Random();
-
-    private final FailingEventHandler eventHandler = new FailingEventHandler();
-
-    private Disruptor<byte[]> disruptor;
-
-    @SuppressWarnings("unchecked")
-    @Before
-    public void setUp()
-    {
-        disruptor = new Disruptor<byte[]>(
-            new ByteArrayFactory(256), 1024, DaemonThreadFactory.INSTANCE, ProducerType.SINGLE,
-            new BlockingWaitStrategy());
-        disruptor.handleEventsWith(eventHandler);
-        disruptor.setDefaultExceptionHandler(new FatalExceptionHandler());
-    }
-
-    @Test(timeout = 1000)
-    public void shouldShutdownGracefulEvenWithFatalExceptionHandler()
-    {
-        disruptor.start();
-
-        byte[] bytes;
-        for (int i = 1; i < 10; i++)
-        {
-            bytes = new byte[32];
-            random.nextBytes(bytes);
-            disruptor.publishEvent(new ByteArrayTranslator(bytes));
-        }
-    }
-
-    @After
-    public void tearDown()
-    {
-        disruptor.shutdown();
-    }
-
-    private static class ByteArrayTranslator implements EventTranslator<byte[]>
-    {
-
-        private final byte[] bytes;
-
-        ByteArrayTranslator(byte[] bytes)
-        {
-            this.bytes = bytes;
-        }
-
-        @Override
-        public void translateTo(byte[] event, long sequence)
-        {
-            System.arraycopy(bytes, 0, event, 0, bytes.length);
-        }
-    }
-
-    private static class FailingEventHandler implements EventHandler<byte[]>
-    {
-        private int count = 0;
-
-        @Override
-        public void onEvent(byte[] event, long sequence, boolean endOfBatch) throws Exception
-        {
-            // some logging
-            count++;
-            if (count == 3)
-            {
-                throw new IllegalStateException();
-            }
-        }
-    }
-
-    private static class ByteArrayFactory implements EventFactory<byte[]>
-    {
-        private int eventSize;
-
-        ByteArrayFactory(int eventSize)
-        {
-            this.eventSize = eventSize;
-        }
-
-        @Override
-        public byte[] newInstance()
-        {
-            return new byte[eventSize];
-        }
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/SingleProducerSequencerTest.java b/src/test/java/com/lmax/disruptor/SingleProducerSequencerTest.java
deleted file mode 100644
index f4c0100..0000000
--- a/src/test/java/com/lmax/disruptor/SingleProducerSequencerTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package com.lmax.disruptor;
-
-import org.junit.Test;
-
-import static org.hamcrest.core.IsNot.not;
-import static org.junit.Assert.*;
-
-public class SingleProducerSequencerTest
-{
-    @Test
-    public void shouldNotUpdateCursorDuringHasAvailableCapacity() throws Exception
-    {
-        SingleProducerSequencer sequencer = new SingleProducerSequencer(16, new BusySpinWaitStrategy());
-
-        for (int i = 0; i < 32; i++)
-        {
-            long next = sequencer.next();
-            assertThat(sequencer.cursor.get(), not(next));
-
-            sequencer.hasAvailableCapacity(13);
-            assertThat(sequencer.cursor.get(), not(next));
-
-            sequencer.publish(next);
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/test/java/com/lmax/disruptor/SleepingWaitStrategyTest.java b/src/test/java/com/lmax/disruptor/SleepingWaitStrategyTest.java
deleted file mode 100644
index 2926524..0000000
--- a/src/test/java/com/lmax/disruptor/SleepingWaitStrategyTest.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright 2012 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor;
-
-import static com.lmax.disruptor.support.WaitStrategyTestUtil.assertWaitForWithDelayOf;
-
-import org.junit.Test;
-
-public class SleepingWaitStrategyTest
-{
-    @Test
-    public void shouldWaitForValue() throws Exception
-    {
-        assertWaitForWithDelayOf(50, new SleepingWaitStrategy());
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/TimeoutBlockingWaitStrategyTest.java b/src/test/java/com/lmax/disruptor/TimeoutBlockingWaitStrategyTest.java
deleted file mode 100644
index d4d66ed..0000000
--- a/src/test/java/com/lmax/disruptor/TimeoutBlockingWaitStrategyTest.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package com.lmax.disruptor;
-
-import com.lmax.disruptor.support.DummySequenceBarrier;
-import org.junit.Test;
-
-import java.util.concurrent.TimeUnit;
-
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public class TimeoutBlockingWaitStrategyTest
-{
-    @Test
-    public void shouldTimeoutWaitFor() throws Exception
-    {
-        final SequenceBarrier sequenceBarrier = new DummySequenceBarrier();
-
-        long theTimeout = 500;
-        TimeoutBlockingWaitStrategy waitStrategy = new TimeoutBlockingWaitStrategy(theTimeout, TimeUnit.MILLISECONDS);
-        Sequence cursor = new Sequence(5);
-        Sequence dependent = cursor;
-
-        long t0 = System.currentTimeMillis();
-
-        try
-        {
-            waitStrategy.waitFor(6, cursor, dependent, sequenceBarrier);
-            fail("TimeoutException should have been thrown");
-        }
-        catch (TimeoutException e)
-        {
-        }
-
-        long t1 = System.currentTimeMillis();
-
-        long timeWaiting = t1 - t0;
-
-        assertTrue(timeWaiting >= theTimeout);
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/WorkerPoolTest.java b/src/test/java/com/lmax/disruptor/WorkerPoolTest.java
deleted file mode 100644
index 0756cf1..0000000
--- a/src/test/java/com/lmax/disruptor/WorkerPoolTest.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package com.lmax.disruptor;
-
-import static org.hamcrest.CoreMatchers.is;
-import static org.junit.Assert.assertThat;
-
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-import java.util.concurrent.atomic.AtomicLong;
-
-import org.junit.Test;
-
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-
-public class WorkerPoolTest
-{
-    @SuppressWarnings("unchecked")
-    @Test
-    public void shouldProcessEachMessageByOnlyOneWorker() throws Exception
-    {
-        Executor executor = Executors.newCachedThreadPool(DaemonThreadFactory.INSTANCE);
-        WorkerPool<AtomicLong> pool = new WorkerPool<AtomicLong>(
-            new AtomicLongEventFactory(), new FatalExceptionHandler(),
-            new AtomicLongWorkHandler(), new AtomicLongWorkHandler());
-
-        RingBuffer<AtomicLong> ringBuffer = pool.start(executor);
-
-        ringBuffer.next();
-        ringBuffer.next();
-        ringBuffer.publish(0);
-        ringBuffer.publish(1);
-
-        Thread.sleep(500);
-
-        assertThat(ringBuffer.get(0).get(), is(1L));
-        assertThat(ringBuffer.get(1).get(), is(1L));
-    }
-
-    @SuppressWarnings("unchecked")
-    @Test
-    public void shouldProcessOnlyOnceItHasBeenPublished() throws Exception
-    {
-        Executor executor = Executors.newCachedThreadPool(DaemonThreadFactory.INSTANCE);
-        WorkerPool<AtomicLong> pool = new WorkerPool<AtomicLong>(
-            new AtomicLongEventFactory(), new FatalExceptionHandler(),
-            new AtomicLongWorkHandler(), new AtomicLongWorkHandler());
-
-        RingBuffer<AtomicLong> ringBuffer = pool.start(executor);
-
-        ringBuffer.next();
-        ringBuffer.next();
-
-        Thread.sleep(1000);
-
-        assertThat(ringBuffer.get(0).get(), is(0L));
-        assertThat(ringBuffer.get(1).get(), is(0L));
-    }
-
-    private static class AtomicLongWorkHandler implements WorkHandler<AtomicLong>
-    {
-        @Override
-        public void onEvent(AtomicLong event) throws Exception
-        {
-            event.incrementAndGet();
-        }
-    }
-
-
-    private static class AtomicLongEventFactory implements EventFactory<AtomicLong>
-    {
-        @Override
-        public AtomicLong newInstance()
-        {
-            return new AtomicLong(0);
-        }
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/WorkerStressTest.java b/src/test/java/com/lmax/disruptor/WorkerStressTest.java
deleted file mode 100644
index 9723bf5..0000000
--- a/src/test/java/com/lmax/disruptor/WorkerStressTest.java
+++ /dev/null
@@ -1,174 +0,0 @@
-package com.lmax.disruptor;
-
-import com.lmax.disruptor.dsl.Disruptor;
-import com.lmax.disruptor.dsl.ProducerType;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-import org.junit.Test;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.CyclicBarrier;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.locks.LockSupport;
-
-import static java.lang.Math.max;
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.CoreMatchers.not;
-import static org.junit.Assert.assertThat;
-
-public class WorkerStressTest
-{
-    private final ExecutorService executor = Executors.newCachedThreadPool();
-
-    @Test
-    public void shouldHandleLotsOfThreads() throws Exception
-    {
-        Disruptor<TestEvent> disruptor = new Disruptor<TestEvent>(
-            TestEvent.FACTORY, 1 << 16, DaemonThreadFactory.INSTANCE,
-            ProducerType.MULTI, new SleepingWaitStrategy());
-        RingBuffer<TestEvent> ringBuffer = disruptor.getRingBuffer();
-        disruptor.setDefaultExceptionHandler(new FatalExceptionHandler());
-
-        int threads = max(1, Runtime.getRuntime().availableProcessors() / 2);
-
-        int iterations = 200000;
-        int publisherCount = threads;
-        int handlerCount = threads;
-
-        CyclicBarrier barrier = new CyclicBarrier(publisherCount);
-        CountDownLatch latch = new CountDownLatch(publisherCount);
-
-        TestWorkHandler[] handlers = initialise(new TestWorkHandler[handlerCount]);
-        Publisher[] publishers = initialise(new Publisher[publisherCount], ringBuffer, iterations, barrier, latch);
-
-        disruptor.handleEventsWithWorkerPool(handlers);
-
-        disruptor.start();
-
-        for (Publisher publisher : publishers)
-        {
-            executor.execute(publisher);
-        }
-
-        latch.await();
-        while (ringBuffer.getCursor() < (iterations - 1))
-        {
-            LockSupport.parkNanos(1);
-        }
-
-        disruptor.shutdown();
-
-        for (Publisher publisher : publishers)
-        {
-            assertThat(publisher.failed, is(false));
-        }
-
-        for (TestWorkHandler handler : handlers)
-        {
-            assertThat(handler.seen, is(not(0)));
-        }
-    }
-
-    private Publisher[] initialise(
-        Publisher[] publishers, RingBuffer<TestEvent> buffer,
-        int messageCount, CyclicBarrier barrier, CountDownLatch latch)
-    {
-        for (int i = 0; i < publishers.length; i++)
-        {
-            publishers[i] = new Publisher(buffer, messageCount, barrier, latch);
-        }
-
-        return publishers;
-    }
-
-    @SuppressWarnings("unchecked")
-    private TestWorkHandler[] initialise(TestWorkHandler[] testEventHandlers)
-    {
-        for (int i = 0; i < testEventHandlers.length; i++)
-        {
-            TestWorkHandler handler = new TestWorkHandler();
-            testEventHandlers[i] = handler;
-        }
-
-        return testEventHandlers;
-    }
-
-    private static class TestWorkHandler implements WorkHandler<TestEvent>
-    {
-        private int seen;
-
-        @Override
-        public void onEvent(TestEvent event) throws Exception
-        {
-            seen++;
-        }
-    }
-
-    private static class Publisher implements Runnable
-    {
-        private final RingBuffer<TestEvent> ringBuffer;
-        private final CyclicBarrier barrier;
-        private final int iterations;
-        private final CountDownLatch shutdownLatch;
-
-        public boolean failed = false;
-
-        Publisher(
-            RingBuffer<TestEvent> ringBuffer,
-            int iterations,
-            CyclicBarrier barrier,
-            CountDownLatch shutdownLatch)
-        {
-            this.ringBuffer = ringBuffer;
-            this.barrier = barrier;
-            this.iterations = iterations;
-            this.shutdownLatch = shutdownLatch;
-        }
-
-        @Override
-        public void run()
-        {
-            try
-            {
-                barrier.await();
-
-                int i = iterations;
-                while (--i != -1)
-                {
-                    long next = ringBuffer.next();
-                    TestEvent testEvent = ringBuffer.get(next);
-                    testEvent.sequence = next;
-                    testEvent.a = next + 13;
-                    testEvent.b = next - 7;
-                    testEvent.s = "wibble-" + next;
-                    ringBuffer.publish(next);
-                }
-            }
-            catch (Exception e)
-            {
-                failed = true;
-            }
-            finally
-            {
-                shutdownLatch.countDown();
-            }
-        }
-    }
-
-    private static class TestEvent
-    {
-        public long sequence;
-        public long a;
-        public long b;
-        public String s;
-
-        public static final EventFactory<TestEvent> FACTORY = new EventFactory<WorkerStressTest.TestEvent>()
-        {
-            @Override
-            public TestEvent newInstance()
-            {
-                return new TestEvent();
-            }
-        };
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/YieldingWaitStrategyTest.java b/src/test/java/com/lmax/disruptor/YieldingWaitStrategyTest.java
deleted file mode 100644
index 75a37b3..0000000
--- a/src/test/java/com/lmax/disruptor/YieldingWaitStrategyTest.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright 2012 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor;
-
-import static com.lmax.disruptor.support.WaitStrategyTestUtil.assertWaitForWithDelayOf;
-
-import org.junit.Test;
-
-public class YieldingWaitStrategyTest
-{
-
-    @Test
-    public void shouldWaitForValue() throws Exception
-    {
-        assertWaitForWithDelayOf(50, new YieldingWaitStrategy());
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/dsl/ConsumerRepositoryTest.java b/src/test/java/com/lmax/disruptor/dsl/ConsumerRepositoryTest.java
deleted file mode 100644
index 6e9c560..0000000
--- a/src/test/java/com/lmax/disruptor/dsl/ConsumerRepositoryTest.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.dsl;
-
-import com.lmax.disruptor.EventProcessor;
-import com.lmax.disruptor.Sequence;
-import com.lmax.disruptor.SequenceBarrier;
-import com.lmax.disruptor.dsl.stubs.SleepingEventHandler;
-import com.lmax.disruptor.support.DummyEventProcessor;
-import com.lmax.disruptor.support.DummySequenceBarrier;
-import com.lmax.disruptor.support.TestEvent;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.hamcrest.CoreMatchers.*;
-import static org.junit.Assert.*;
-
-public class ConsumerRepositoryTest
-{
-    private ConsumerRepository<TestEvent> consumerRepository;
-    private EventProcessor eventProcessor1;
-    private EventProcessor eventProcessor2;
-    private SleepingEventHandler handler1;
-    private SleepingEventHandler handler2;
-    private SequenceBarrier barrier1;
-    private SequenceBarrier barrier2;
-
-    @Before
-    public void setUp() throws Exception
-    {
-        consumerRepository = new ConsumerRepository<TestEvent>();
-        eventProcessor1 = new DummyEventProcessor(new Sequence());
-        eventProcessor2 = new DummyEventProcessor(new Sequence());
-
-        eventProcessor1.run();
-        eventProcessor2.run();
-
-        handler1 = new SleepingEventHandler();
-        handler2 = new SleepingEventHandler();
-
-        barrier1 = new DummySequenceBarrier();
-        barrier2 = new DummySequenceBarrier();
-    }
-
-    @Test
-    public void shouldGetBarrierByHandler() throws Exception
-    {
-        consumerRepository.add(eventProcessor1, handler1, barrier1);
-
-        assertThat(consumerRepository.getBarrierFor(handler1), sameInstance(barrier1));
-    }
-
-    @Test
-    public void shouldReturnNullForBarrierWhenHandlerIsNotRegistered() throws Exception
-    {
-        assertThat(consumerRepository.getBarrierFor(handler1), is(nullValue()));
-    }
-
-    @Test
-    public void shouldGetLastEventProcessorsInChain() throws Exception
-    {
-        consumerRepository.add(eventProcessor1, handler1, barrier1);
-        consumerRepository.add(eventProcessor2, handler2, barrier2);
-
-        consumerRepository.unMarkEventProcessorsAsEndOfChain(eventProcessor2.getSequence());
-
-
-        final Sequence[] lastEventProcessorsInChain = consumerRepository.getLastSequenceInChain(true);
-        assertThat(lastEventProcessorsInChain.length, equalTo(1));
-        assertThat(lastEventProcessorsInChain[0], sameInstance(eventProcessor1.getSequence()));
-    }
-
-    @Test
-    public void shouldRetrieveEventProcessorForHandler() throws Exception
-    {
-        consumerRepository.add(eventProcessor1, handler1, barrier1);
-
-        assertThat(consumerRepository.getEventProcessorFor(handler1), sameInstance(eventProcessor1));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldThrowExceptionWhenHandlerIsNotRegistered() throws Exception
-    {
-        consumerRepository.getEventProcessorFor(new SleepingEventHandler());
-    }
-
-    @Test
-    public void shouldIterateAllEventProcessors() throws Exception
-    {
-        consumerRepository.add(eventProcessor1, handler1, barrier1);
-        consumerRepository.add(eventProcessor2, handler2, barrier2);
-
-        boolean seen1 = false;
-        boolean seen2 = false;
-        for (ConsumerInfo testEntryEventProcessorInfo : consumerRepository)
-        {
-            final EventProcessorInfo<?> eventProcessorInfo = (EventProcessorInfo<?>) testEntryEventProcessorInfo;
-            if (!seen1 && eventProcessorInfo.getEventProcessor() == eventProcessor1 &&
-                eventProcessorInfo.getHandler() == handler1)
-            {
-                seen1 = true;
-            }
-            else if (!seen2 && eventProcessorInfo.getEventProcessor() == eventProcessor2 &&
-                eventProcessorInfo.getHandler() == handler2)
-            {
-                seen2 = true;
-            }
-            else
-            {
-                fail("Unexpected eventProcessor info: " + testEntryEventProcessorInfo);
-            }
-        }
-
-        assertTrue("Included eventProcessor 1", seen1);
-        assertTrue("Included eventProcessor 2", seen2);
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/dsl/DisruptorTest.java b/src/test/java/com/lmax/disruptor/dsl/DisruptorTest.java
deleted file mode 100644
index 5309e87..0000000
--- a/src/test/java/com/lmax/disruptor/dsl/DisruptorTest.java
+++ /dev/null
@@ -1,910 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.dsl;
-
-import com.lmax.disruptor.BatchEventProcessor;
-import com.lmax.disruptor.BlockingWaitStrategy;
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.EventProcessor;
-import com.lmax.disruptor.EventTranslator;
-import com.lmax.disruptor.EventTranslatorOneArg;
-import com.lmax.disruptor.ExceptionHandler;
-import com.lmax.disruptor.FatalExceptionHandler;
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.Sequence;
-import com.lmax.disruptor.SequenceBarrier;
-import com.lmax.disruptor.TimeoutException;
-import com.lmax.disruptor.dsl.stubs.DelayedEventHandler;
-import com.lmax.disruptor.dsl.stubs.EventHandlerStub;
-import com.lmax.disruptor.dsl.stubs.EvilEqualsEventHandler;
-import com.lmax.disruptor.dsl.stubs.ExceptionThrowingEventHandler;
-import com.lmax.disruptor.dsl.stubs.SleepingEventHandler;
-import com.lmax.disruptor.dsl.stubs.StubExceptionHandler;
-import com.lmax.disruptor.dsl.stubs.StubPublisher;
-import com.lmax.disruptor.dsl.stubs.StubThreadFactory;
-import com.lmax.disruptor.dsl.stubs.TestWorkHandler;
-import com.lmax.disruptor.support.TestEvent;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.concurrent.BrokenBarrierException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-
-import static java.lang.Thread.yield;
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.hamcrest.CoreMatchers.is;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-@SuppressWarnings(value = {"unchecked"})
-public class DisruptorTest
-{
-    private static final int TIMEOUT_IN_SECONDS = 2;
-
-    private final Collection<DelayedEventHandler> delayedEventHandlers = new ArrayList<DelayedEventHandler>();
-    private final Collection<TestWorkHandler> testWorkHandlers = new ArrayList<TestWorkHandler>();
-    private Disruptor<TestEvent> disruptor;
-    private StubThreadFactory executor;
-    private RingBuffer<TestEvent> ringBuffer;
-    private TestEvent lastPublishedEvent;
-
-    @Before
-    public void setUp() throws Exception
-    {
-        createDisruptor();
-    }
-
-    @After
-    public void tearDown() throws Exception
-    {
-        for (DelayedEventHandler delayedEventHandler : delayedEventHandlers)
-        {
-            delayedEventHandler.stopWaiting();
-        }
-        for (TestWorkHandler testWorkHandler : testWorkHandlers)
-        {
-            testWorkHandler.stopWaiting();
-        }
-
-        disruptor.halt();
-        executor.joinAllThreads();
-    }
-
-    @Test
-    public void shouldProcessMessagesPublishedBeforeStartIsCalled() throws Exception
-    {
-        final CountDownLatch eventCounter = new CountDownLatch(2);
-        disruptor.handleEventsWith(new EventHandler<TestEvent>()
-        {
-            @Override
-            public void onEvent(final TestEvent event, final long sequence, final boolean endOfBatch) throws Exception
-            {
-                eventCounter.countDown();
-            }
-        });
-
-        disruptor.publishEvent(
-         new EventTranslator<TestEvent>()
-         {
-             @Override
-             public void translateTo(final TestEvent event, final long sequence)
-             {
-                 lastPublishedEvent = event;
-             }
-         });
-
-        disruptor.start();
-
-        disruptor.publishEvent(
-         new EventTranslator<TestEvent>()
-         {
-             @Override
-             public void translateTo(final TestEvent event, final long sequence)
-             {
-                 lastPublishedEvent = event;
-             }
-         });
-
-        if (!eventCounter.await(5, TimeUnit.SECONDS))
-        {
-            fail("Did not process event published before start was called. Missed events: " + eventCounter.getCount());
-        }
-    }
-
-
-    @Test
-    public void shouldBatchOfEvents() throws Exception
-    {
-        final CountDownLatch eventCounter = new CountDownLatch(2);
-        disruptor.handleEventsWith(new EventHandler<TestEvent>()
-        {
-            @Override
-            public void onEvent(final TestEvent event, final long sequence, final boolean endOfBatch) throws Exception
-            {
-                eventCounter.countDown();
-            }
-        });
-
-        disruptor.start();
-
-        disruptor.publishEvents(
-            new EventTranslatorOneArg<TestEvent, Object>()
-            {
-                @Override
-                public void translateTo(final TestEvent event, final long sequence, Object arg)
-                {
-                    lastPublishedEvent = event;
-                }
-            },
-            new Object[] { "a", "b" }
-        );
-
-        if (!eventCounter.await(5, TimeUnit.SECONDS))
-        {
-            fail("Did not process event published before start was called. Missed events: " + eventCounter.getCount());
-        }
-    }
-
-    @Test
-    public void shouldAddEventProcessorsAfterPublishing() throws Exception
-    {
-        RingBuffer<TestEvent> rb = disruptor.getRingBuffer();
-        BatchEventProcessor<TestEvent> b1 = new BatchEventProcessor<TestEvent>(
-            rb, rb.newBarrier(), new SleepingEventHandler());
-        BatchEventProcessor<TestEvent> b2 = new BatchEventProcessor<TestEvent>(
-            rb, rb.newBarrier(b1.getSequence()), new SleepingEventHandler());
-        BatchEventProcessor<TestEvent> b3 = new BatchEventProcessor<TestEvent>(
-            rb, rb.newBarrier(b2.getSequence()), new SleepingEventHandler());
-
-        assertThat(b1.getSequence().get(), is(-1L));
-        assertThat(b2.getSequence().get(), is(-1L));
-        assertThat(b3.getSequence().get(), is(-1L));
-
-        rb.publish(rb.next());
-        rb.publish(rb.next());
-        rb.publish(rb.next());
-        rb.publish(rb.next());
-        rb.publish(rb.next());
-        rb.publish(rb.next());
-
-        disruptor.handleEventsWith(b1, b2, b3);
-
-        assertThat(b1.getSequence().get(), is(5L));
-        assertThat(b2.getSequence().get(), is(5L));
-        assertThat(b3.getSequence().get(), is(5L));
-    }
-
-    @Test
-    public void shouldSetSequenceForHandlerIfAddedAfterPublish() throws Exception
-    {
-        RingBuffer<TestEvent> rb = disruptor.getRingBuffer();
-        EventHandler<TestEvent> b1 = new SleepingEventHandler();
-        EventHandler<TestEvent> b2 = new SleepingEventHandler();
-        EventHandler<TestEvent> b3 = new SleepingEventHandler();
-
-        rb.publish(rb.next());
-        rb.publish(rb.next());
-        rb.publish(rb.next());
-        rb.publish(rb.next());
-        rb.publish(rb.next());
-        rb.publish(rb.next());
-
-        disruptor.handleEventsWith(b1, b2, b3);
-
-        assertThat(disruptor.getSequenceValueFor(b1), is(5L));
-        assertThat(disruptor.getSequenceValueFor(b2), is(5L));
-        assertThat(disruptor.getSequenceValueFor(b3), is(5L));
-    }
-
-    @Test
-    public void shouldSetSequenceForWorkProcessorIfAddedAfterPublish() throws Exception
-    {
-        RingBuffer<TestEvent> rb = disruptor.getRingBuffer();
-        TestWorkHandler wh1 = createTestWorkHandler();
-        TestWorkHandler wh2 = createTestWorkHandler();
-        TestWorkHandler wh3 = createTestWorkHandler();
-
-        rb.publish(rb.next());
-        rb.publish(rb.next());
-        rb.publish(rb.next());
-        rb.publish(rb.next());
-        rb.publish(rb.next());
-        rb.publish(rb.next());
-
-        disruptor.handleEventsWithWorkerPool(wh1, wh2, wh3);
-
-        assertThat(disruptor.getRingBuffer().getMinimumGatingSequence(), is(5L));
-    }
-
-
-    @Test
-    public void shouldCreateEventProcessorGroupForFirstEventProcessors()
-        throws Exception
-    {
-        executor.ignoreExecutions();
-        final EventHandler<TestEvent> eventHandler1 = new SleepingEventHandler();
-        EventHandler<TestEvent> eventHandler2 = new SleepingEventHandler();
-
-        final EventHandlerGroup<TestEvent> eventHandlerGroup =
-            disruptor.handleEventsWith(eventHandler1, eventHandler2);
-        disruptor.start();
-
-        assertNotNull(eventHandlerGroup);
-        assertThat(Integer.valueOf(executor.getExecutionCount()), equalTo(Integer.valueOf(2)));
-    }
-
-    @Test
-    public void shouldMakeEntriesAvailableToFirstHandlersImmediately() throws Exception
-    {
-        CountDownLatch countDownLatch = new CountDownLatch(2);
-        EventHandler<TestEvent> eventHandler = new EventHandlerStub<TestEvent>(countDownLatch);
-
-        disruptor.handleEventsWith(createDelayedEventHandler(), eventHandler);
-
-        ensureTwoEventsProcessedAccordingToDependencies(countDownLatch);
-    }
-
-    @Test
-    public void shouldWaitUntilAllFirstEventProcessorsProcessEventBeforeMakingItAvailableToDependentEventProcessors()
-        throws Exception
-    {
-        DelayedEventHandler eventHandler1 = createDelayedEventHandler();
-
-        CountDownLatch countDownLatch = new CountDownLatch(2);
-        EventHandler<TestEvent> eventHandler2 = new EventHandlerStub<TestEvent>(countDownLatch);
-
-        disruptor.handleEventsWith(eventHandler1).then(eventHandler2);
-
-        ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, eventHandler1);
-    }
-
-    @Test
-    public void should()
-        throws Exception
-    {
-        RingBuffer<TestEvent> rb = disruptor.getRingBuffer();
-        BatchEventProcessor<TestEvent> b1 = new BatchEventProcessor<TestEvent>(
-            rb, rb.newBarrier(), new SleepingEventHandler());
-        EventProcessorFactory<TestEvent> b2 = new EventProcessorFactory<TestEvent>()
-        {
-            @Override
-            public EventProcessor createEventProcessor(
-                RingBuffer<TestEvent> ringBuffer, Sequence[] barrierSequences)
-            {
-                return new BatchEventProcessor<TestEvent>(
-                    ringBuffer, ringBuffer.newBarrier(barrierSequences), new SleepingEventHandler());
-            }
-        };
-
-        disruptor.handleEventsWith(b1).then(b2);
-
-        disruptor.start();
-    }
-
-    @Test
-    public void shouldAllowSpecifyingSpecificEventProcessorsToWaitFor()
-        throws Exception
-    {
-        DelayedEventHandler handler1 = createDelayedEventHandler();
-        DelayedEventHandler handler2 = createDelayedEventHandler();
-
-        CountDownLatch countDownLatch = new CountDownLatch(2);
-        EventHandler<TestEvent> handlerWithBarrier = new EventHandlerStub<TestEvent>(countDownLatch);
-
-        disruptor.handleEventsWith(handler1, handler2);
-        disruptor.after(handler1, handler2).handleEventsWith(handlerWithBarrier);
-
-        ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, handler1, handler2);
-    }
-
-    @Test
-    public void shouldWaitOnAllProducersJoinedByAnd()
-        throws Exception
-    {
-        DelayedEventHandler handler1 = createDelayedEventHandler();
-        DelayedEventHandler handler2 = createDelayedEventHandler();
-
-        CountDownLatch countDownLatch = new CountDownLatch(2);
-        EventHandler<TestEvent> handlerWithBarrier = new EventHandlerStub<TestEvent>(countDownLatch);
-
-        disruptor.handleEventsWith(handler1);
-        final EventHandlerGroup<TestEvent> handler2Group = disruptor.handleEventsWith(handler2);
-        disruptor.after(handler1).and(handler2Group).handleEventsWith(handlerWithBarrier);
-
-        ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, handler1, handler2);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldThrowExceptionIfHandlerIsNotAlreadyConsuming()
-        throws Exception
-    {
-        disruptor.after(createDelayedEventHandler()).handleEventsWith(createDelayedEventHandler());
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void shouldTrackEventHandlersByIdentityNotEquality()
-        throws Exception
-    {
-        EvilEqualsEventHandler handler1 = new EvilEqualsEventHandler();
-        EvilEqualsEventHandler handler2 = new EvilEqualsEventHandler();
-
-        disruptor.handleEventsWith(handler1);
-
-        // handler2.equals(handler1) but it hasn't yet been registered so should throw exception.
-        disruptor.after(handler2);
-    }
-
-    @SuppressWarnings("deprecation")
-    @Test
-    public void shouldSupportSpecifyingAExceptionHandlerForEventProcessors()
-        throws Exception
-    {
-        AtomicReference<Throwable> eventHandled = new AtomicReference<Throwable>();
-        ExceptionHandler exceptionHandler = new StubExceptionHandler(eventHandled);
-        RuntimeException testException = new RuntimeException();
-        ExceptionThrowingEventHandler handler = new ExceptionThrowingEventHandler(testException);
-
-        disruptor.handleExceptionsWith(exceptionHandler);
-        disruptor.handleEventsWith(handler);
-
-        publishEvent();
-
-        final Throwable actualException = waitFor(eventHandled);
-        assertSame(testException, actualException);
-    }
-
-    @SuppressWarnings("deprecation")
-    @Test
-    public void shouldOnlyApplyExceptionsHandlersSpecifiedViaHandleExceptionsWithOnNewEventProcessors()
-        throws Exception
-    {
-        AtomicReference<Throwable> eventHandled = new AtomicReference<Throwable>();
-        ExceptionHandler exceptionHandler = new StubExceptionHandler(eventHandled);
-        RuntimeException testException = new RuntimeException();
-        ExceptionThrowingEventHandler handler = new ExceptionThrowingEventHandler(testException);
-
-        disruptor.handleExceptionsWith(exceptionHandler);
-        disruptor.handleEventsWith(handler);
-        disruptor.handleExceptionsWith(new FatalExceptionHandler());
-
-        publishEvent();
-
-        final Throwable actualException = waitFor(eventHandled);
-        assertSame(testException, actualException);
-    }
-
-    @Test
-    public void shouldSupportSpecifyingADefaultExceptionHandlerForEventProcessors()
-        throws Exception
-    {
-        AtomicReference<Throwable> eventHandled = new AtomicReference<Throwable>();
-        ExceptionHandler exceptionHandler = new StubExceptionHandler(eventHandled);
-        RuntimeException testException = new RuntimeException();
-        ExceptionThrowingEventHandler handler = new ExceptionThrowingEventHandler(testException);
-
-        disruptor.setDefaultExceptionHandler(exceptionHandler);
-        disruptor.handleEventsWith(handler);
-
-        publishEvent();
-
-        final Throwable actualException = waitFor(eventHandled);
-        assertSame(testException, actualException);
-    }
-
-    @Test
-    public void shouldApplyDefaultExceptionHandlerToExistingEventProcessors()
-        throws Exception
-    {
-        AtomicReference<Throwable> eventHandled = new AtomicReference<Throwable>();
-        ExceptionHandler exceptionHandler = new StubExceptionHandler(eventHandled);
-        RuntimeException testException = new RuntimeException();
-        ExceptionThrowingEventHandler handler = new ExceptionThrowingEventHandler(testException);
-
-        disruptor.handleEventsWith(handler);
-        disruptor.setDefaultExceptionHandler(exceptionHandler);
-
-        publishEvent();
-
-        final Throwable actualException = waitFor(eventHandled);
-        assertSame(testException, actualException);
-    }
-
-    @Test
-    public void shouldBlockProducerUntilAllEventProcessorsHaveAdvanced()
-        throws Exception
-    {
-        final DelayedEventHandler delayedEventHandler = createDelayedEventHandler();
-        disruptor.handleEventsWith(delayedEventHandler);
-
-        final RingBuffer<TestEvent> ringBuffer = disruptor.start();
-        delayedEventHandler.awaitStart();
-
-        final StubPublisher stubPublisher = new StubPublisher(ringBuffer);
-        try
-        {
-            executor.newThread(stubPublisher).start();
-
-            assertProducerReaches(stubPublisher, 4, true);
-
-            delayedEventHandler.processEvent();
-            delayedEventHandler.processEvent();
-            delayedEventHandler.processEvent();
-            delayedEventHandler.processEvent();
-            delayedEventHandler.processEvent();
-
-            assertProducerReaches(stubPublisher, 5, false);
-        }
-        finally
-        {
-            stubPublisher.halt();
-        }
-    }
-
-    @Test
-    public void shouldBeAbleToOverrideTheExceptionHandlerForAEventProcessor()
-        throws Exception
-    {
-        final RuntimeException testException = new RuntimeException();
-        final ExceptionThrowingEventHandler eventHandler = new ExceptionThrowingEventHandler(testException);
-        disruptor.handleEventsWith(eventHandler);
-
-        AtomicReference<Throwable> reference = new AtomicReference<Throwable>();
-        StubExceptionHandler exceptionHandler = new StubExceptionHandler(reference);
-        disruptor.handleExceptionsFor(eventHandler).with(exceptionHandler);
-
-        publishEvent();
-
-        waitFor(reference);
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void shouldThrowExceptionWhenAddingEventProcessorsAfterTheProducerBarrierHasBeenCreated()
-        throws Exception
-    {
-        executor.ignoreExecutions();
-        disruptor.handleEventsWith(new SleepingEventHandler());
-        disruptor.start();
-        disruptor.handleEventsWith(new SleepingEventHandler());
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void shouldThrowExceptionIfStartIsCalledTwice()
-        throws Exception
-    {
-        executor.ignoreExecutions();
-        disruptor.handleEventsWith(new SleepingEventHandler());
-        disruptor.start();
-        disruptor.start();
-    }
-
-    @Test
-    public void shouldSupportCustomProcessorsAsDependencies()
-        throws Exception
-    {
-        RingBuffer<TestEvent> ringBuffer = disruptor.getRingBuffer();
-
-        final DelayedEventHandler delayedEventHandler = createDelayedEventHandler();
-
-        CountDownLatch countDownLatch = new CountDownLatch(2);
-        EventHandler<TestEvent> handlerWithBarrier = new EventHandlerStub<TestEvent>(countDownLatch);
-
-        final BatchEventProcessor<TestEvent> processor =
-            new BatchEventProcessor<TestEvent>(ringBuffer, ringBuffer.newBarrier(), delayedEventHandler);
-
-        disruptor.handleEventsWith(processor).then(handlerWithBarrier);
-
-        ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, delayedEventHandler);
-    }
-
-    @Test
-    public void shouldSupportHandlersAsDependenciesToCustomProcessors()
-        throws Exception
-    {
-        final DelayedEventHandler delayedEventHandler = createDelayedEventHandler();
-        disruptor.handleEventsWith(delayedEventHandler);
-
-
-        RingBuffer<TestEvent> ringBuffer = disruptor.getRingBuffer();
-        CountDownLatch countDownLatch = new CountDownLatch(2);
-        EventHandler<TestEvent> handlerWithBarrier = new EventHandlerStub<TestEvent>(countDownLatch);
-
-        final SequenceBarrier sequenceBarrier = disruptor.after(delayedEventHandler).asSequenceBarrier();
-        final BatchEventProcessor<TestEvent> processor =
-            new BatchEventProcessor<TestEvent>(ringBuffer, sequenceBarrier, handlerWithBarrier);
-        disruptor.handleEventsWith(processor);
-
-        ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, delayedEventHandler);
-    }
-
-    @Test
-    public void shouldSupportCustomProcessorsAndHandlersAsDependencies() throws Exception
-    {
-        final DelayedEventHandler delayedEventHandler1 = createDelayedEventHandler();
-        final DelayedEventHandler delayedEventHandler2 = createDelayedEventHandler();
-        disruptor.handleEventsWith(delayedEventHandler1);
-
-
-        RingBuffer<TestEvent> ringBuffer = disruptor.getRingBuffer();
-        CountDownLatch countDownLatch = new CountDownLatch(2);
-        EventHandler<TestEvent> handlerWithBarrier = new EventHandlerStub<TestEvent>(countDownLatch);
-
-        final SequenceBarrier sequenceBarrier = disruptor.after(delayedEventHandler1).asSequenceBarrier();
-        final BatchEventProcessor<TestEvent> processor =
-            new BatchEventProcessor<TestEvent>(ringBuffer, sequenceBarrier, delayedEventHandler2);
-
-        disruptor.after(delayedEventHandler1).and(processor).handleEventsWith(handlerWithBarrier);
-
-        ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, delayedEventHandler1, delayedEventHandler2);
-    }
-
-    @Test
-    public void shouldProvideEventsToWorkHandlers() throws Exception
-    {
-        final TestWorkHandler workHandler1 = createTestWorkHandler();
-        final TestWorkHandler workHandler2 = createTestWorkHandler();
-        disruptor.handleEventsWithWorkerPool(workHandler1, workHandler2);
-
-        publishEvent();
-        publishEvent();
-
-        workHandler1.processEvent();
-        workHandler2.processEvent();
-    }
-
-
-    @Test
-    public void shouldProvideEventsMultipleWorkHandlers() throws Exception
-    {
-        final TestWorkHandler workHandler1 = createTestWorkHandler();
-        final TestWorkHandler workHandler2 = createTestWorkHandler();
-        final TestWorkHandler workHandler3 = createTestWorkHandler();
-        final TestWorkHandler workHandler4 = createTestWorkHandler();
-        final TestWorkHandler workHandler5 = createTestWorkHandler();
-        final TestWorkHandler workHandler6 = createTestWorkHandler();
-        final TestWorkHandler workHandler7 = createTestWorkHandler();
-        final TestWorkHandler workHandler8 = createTestWorkHandler();
-
-        disruptor
-            .handleEventsWithWorkerPool(workHandler1, workHandler2)
-            .thenHandleEventsWithWorkerPool(workHandler3, workHandler4);
-        disruptor
-            .handleEventsWithWorkerPool(workHandler5, workHandler6)
-            .thenHandleEventsWithWorkerPool(workHandler7, workHandler8);
-    }
-
-
-    @Test
-    public void shouldSupportUsingWorkerPoolAsDependency() throws Exception
-    {
-        final TestWorkHandler workHandler1 = createTestWorkHandler();
-        final TestWorkHandler workHandler2 = createTestWorkHandler();
-        final DelayedEventHandler delayedEventHandler = createDelayedEventHandler();
-        disruptor.handleEventsWithWorkerPool(workHandler1, workHandler2).then(delayedEventHandler);
-
-        publishEvent();
-        publishEvent();
-
-        assertThat(disruptor.getBarrierFor(delayedEventHandler).getCursor(), equalTo(-1L));
-
-        workHandler2.processEvent();
-        workHandler1.processEvent();
-
-        delayedEventHandler.processEvent();
-    }
-
-    @Test
-    public void shouldSupportUsingWorkerPoolAsDependencyAndProcessFirstEventAsSoonAsItIsAvailable() throws Exception
-    {
-        final TestWorkHandler workHandler1 = createTestWorkHandler();
-        final TestWorkHandler workHandler2 = createTestWorkHandler();
-        final DelayedEventHandler delayedEventHandler = createDelayedEventHandler();
-        disruptor.handleEventsWithWorkerPool(workHandler1, workHandler2).then(delayedEventHandler);
-
-        publishEvent();
-        publishEvent();
-
-        workHandler1.processEvent();
-        delayedEventHandler.processEvent();
-
-        workHandler2.processEvent();
-        delayedEventHandler.processEvent();
-    }
-
-    @Test
-    public void shouldSupportUsingWorkerPoolWithADependency() throws Exception
-    {
-        final TestWorkHandler workHandler1 = createTestWorkHandler();
-        final TestWorkHandler workHandler2 = createTestWorkHandler();
-        final DelayedEventHandler delayedEventHandler = createDelayedEventHandler();
-        disruptor.handleEventsWith(delayedEventHandler).thenHandleEventsWithWorkerPool(workHandler1, workHandler2);
-
-        publishEvent();
-        publishEvent();
-
-        delayedEventHandler.processEvent();
-        delayedEventHandler.processEvent();
-
-        workHandler1.processEvent();
-        workHandler2.processEvent();
-    }
-
-    @Test
-    public void shouldSupportCombiningWorkerPoolWithEventHandlerAsDependencyWhenNotPreviouslyRegistered()
-        throws Exception
-    {
-        final TestWorkHandler workHandler1 = createTestWorkHandler();
-        final DelayedEventHandler delayedEventHandler1 = createDelayedEventHandler();
-        final DelayedEventHandler delayedEventHandler2 = createDelayedEventHandler();
-        disruptor
-            .handleEventsWith(delayedEventHandler1)
-            .and(disruptor.handleEventsWithWorkerPool(workHandler1))
-            .then(delayedEventHandler2);
-
-        publishEvent();
-        publishEvent();
-
-        delayedEventHandler1.processEvent();
-        delayedEventHandler1.processEvent();
-
-        workHandler1.processEvent();
-        delayedEventHandler2.processEvent();
-
-        workHandler1.processEvent();
-        delayedEventHandler2.processEvent();
-    }
-
-    @Test(expected = TimeoutException.class, timeout = 2000)
-    public void shouldThrowTimeoutExceptionIfShutdownDoesNotCompleteNormally() throws Exception
-    {
-        //Given
-        final DelayedEventHandler delayedEventHandler = createDelayedEventHandler();
-        disruptor.handleEventsWith(delayedEventHandler);
-        publishEvent();
-
-        //When
-        disruptor.shutdown(1, SECONDS);
-
-        //Then
-    }
-
-    @Test(timeout = 1000)
-    public void shouldTrackRemainingCapacity() throws Exception
-    {
-        final long[] remainingCapacity = {-1};
-        //Given
-        final EventHandler<TestEvent> eventHandler = new EventHandler<TestEvent>()
-        {
-            @Override
-            public void onEvent(final TestEvent event, final long sequence, final boolean endOfBatch) throws Exception
-            {
-                remainingCapacity[0] = disruptor.getRingBuffer().remainingCapacity();
-            }
-        };
-
-        disruptor.handleEventsWith(eventHandler);
-
-        //When
-        publishEvent();
-
-        //Then
-        while (remainingCapacity[0] == -1)
-        {
-            Thread.sleep(100);
-        }
-        assertThat(remainingCapacity[0], is(ringBuffer.getBufferSize() - 1L));
-        assertThat(disruptor.getRingBuffer().remainingCapacity(), is(ringBuffer.getBufferSize() - 0L));
-    }
-
-    @Test
-    public void shouldAllowEventHandlerWithSuperType() throws Exception
-    {
-        final CountDownLatch latch = new CountDownLatch(2);
-        final EventHandler<Object> objectHandler = new EventHandlerStub<Object>(latch);
-
-        disruptor.handleEventsWith(objectHandler);
-
-        ensureTwoEventsProcessedAccordingToDependencies(latch);
-    }
-
-    @Test
-    public void shouldAllowChainingEventHandlersWithSuperType() throws Exception
-    {
-        final CountDownLatch latch = new CountDownLatch(2);
-        final DelayedEventHandler delayedEventHandler = createDelayedEventHandler();
-        final EventHandler<Object> objectHandler = new EventHandlerStub<Object>(latch);
-
-        disruptor.handleEventsWith(delayedEventHandler).then(objectHandler);
-
-        ensureTwoEventsProcessedAccordingToDependencies(latch, delayedEventHandler);
-    }
-
-    @Test
-    public void shouldMakeEntriesAvailableToFirstCustomProcessorsImmediately() throws Exception
-    {
-        final CountDownLatch countDownLatch = new CountDownLatch(2);
-        final EventHandler<TestEvent> eventHandler = new EventHandlerStub<TestEvent>(countDownLatch);
-
-        disruptor.handleEventsWith(
-            new EventProcessorFactory<TestEvent>()
-            {
-                @Override
-                public EventProcessor createEventProcessor(
-                    final RingBuffer<TestEvent> ringBuffer, final Sequence[] barrierSequences)
-                {
-                    assertEquals("Should not have had any barrier sequences", 0, barrierSequences.length);
-                    return new BatchEventProcessor<TestEvent>(
-                        disruptor.getRingBuffer(), ringBuffer.newBarrier(
-                        barrierSequences), eventHandler);
-                }
-            });
-
-        ensureTwoEventsProcessedAccordingToDependencies(countDownLatch);
-    }
-
-    @Test
-    public void shouldHonourDependenciesForCustomProcessors() throws Exception
-    {
-        final CountDownLatch countDownLatch = new CountDownLatch(2);
-        final EventHandler<TestEvent> eventHandler = new EventHandlerStub<TestEvent>(countDownLatch);
-        final DelayedEventHandler delayedEventHandler = createDelayedEventHandler();
-
-        disruptor.handleEventsWith(delayedEventHandler).then(
-            new EventProcessorFactory<TestEvent>()
-            {
-                @Override
-                public EventProcessor createEventProcessor(
-                    final RingBuffer<TestEvent> ringBuffer, final Sequence[] barrierSequences)
-                {
-                    assertSame("Should have had a barrier sequence", 1, barrierSequences.length);
-                    return new BatchEventProcessor<TestEvent>(
-                        disruptor.getRingBuffer(), ringBuffer.newBarrier(
-                        barrierSequences), eventHandler);
-                }
-            });
-
-        ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, delayedEventHandler);
-    }
-
-    private TestWorkHandler createTestWorkHandler()
-    {
-        final TestWorkHandler testWorkHandler = new TestWorkHandler();
-        testWorkHandlers.add(testWorkHandler);
-        return testWorkHandler;
-    }
-
-    private void ensureTwoEventsProcessedAccordingToDependencies(
-        final CountDownLatch countDownLatch,
-        final DelayedEventHandler... dependencies)
-        throws InterruptedException, BrokenBarrierException
-    {
-        publishEvent();
-        publishEvent();
-
-        for (DelayedEventHandler dependency : dependencies)
-        {
-            assertThatCountDownLatchEquals(countDownLatch, 2L);
-            dependency.processEvent();
-            dependency.processEvent();
-        }
-
-        assertThatCountDownLatchIsZero(countDownLatch);
-    }
-
-    private void assertProducerReaches(
-        final StubPublisher stubPublisher,
-        final int expectedPublicationCount,
-        boolean strict)
-    {
-        long loopStart = System.currentTimeMillis();
-        while (stubPublisher.getPublicationCount() < expectedPublicationCount && System
-            .currentTimeMillis() - loopStart < 5000)
-        {
-            yield();
-        }
-
-        if (strict)
-        {
-            assertThat(stubPublisher.getPublicationCount(), equalTo(expectedPublicationCount));
-        }
-        else
-        {
-            final int actualPublicationCount = stubPublisher.getPublicationCount();
-            assertTrue(
-                "Producer reached unexpected count. Expected at least " + expectedPublicationCount +
-                    " but only reached " + actualPublicationCount, actualPublicationCount >= expectedPublicationCount);
-        }
-    }
-
-    private void createDisruptor()
-    {
-        executor = new StubThreadFactory();
-        createDisruptor(executor);
-    }
-
-    private void createDisruptor(final ThreadFactory threadFactory)
-    {
-        disruptor = new Disruptor<TestEvent>(
-            TestEvent.EVENT_FACTORY, 4, threadFactory,
-            ProducerType.SINGLE, new BlockingWaitStrategy());
-    }
-
-    private TestEvent publishEvent() throws InterruptedException, BrokenBarrierException
-    {
-        if (ringBuffer == null)
-        {
-            ringBuffer = disruptor.start();
-
-            for (DelayedEventHandler eventHandler : delayedEventHandlers)
-            {
-                eventHandler.awaitStart();
-            }
-        }
-
-        disruptor.publishEvent(
-            new EventTranslator<TestEvent>()
-            {
-                @Override
-                public void translateTo(final TestEvent event, final long sequence)
-                {
-                    lastPublishedEvent = event;
-                }
-            });
-
-        return lastPublishedEvent;
-    }
-
-    private Throwable waitFor(final AtomicReference<Throwable> reference)
-    {
-        while (reference.get() == null)
-        {
-            yield();
-        }
-
-        return reference.get();
-    }
-
-    private DelayedEventHandler createDelayedEventHandler()
-    {
-        final DelayedEventHandler delayedEventHandler = new DelayedEventHandler();
-        delayedEventHandlers.add(delayedEventHandler);
-        return delayedEventHandler;
-    }
-
-    private void assertThatCountDownLatchEquals(
-        final CountDownLatch countDownLatch,
-        final long expectedCountDownValue)
-    {
-        assertThat(Long.valueOf(countDownLatch.getCount()), equalTo(Long.valueOf(expectedCountDownValue)));
-    }
-
-    private void assertThatCountDownLatchIsZero(final CountDownLatch countDownLatch)
-        throws InterruptedException
-    {
-        boolean released = countDownLatch.await(TIMEOUT_IN_SECONDS, SECONDS);
-        assertTrue("Batch handler did not receive entries: " + countDownLatch.getCount(), released);
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/dsl/stubs/DelayedEventHandler.java b/src/test/java/com/lmax/disruptor/dsl/stubs/DelayedEventHandler.java
deleted file mode 100644
index aae7443..0000000
--- a/src/test/java/com/lmax/disruptor/dsl/stubs/DelayedEventHandler.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.dsl.stubs;
-
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.LifecycleAware;
-import com.lmax.disruptor.support.TestEvent;
-
-import java.util.concurrent.BrokenBarrierException;
-import java.util.concurrent.CyclicBarrier;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-public class DelayedEventHandler implements EventHandler<TestEvent>, LifecycleAware
-{
-    private final AtomicBoolean readyToProcessEvent = new AtomicBoolean(false);
-    private volatile boolean stopped = false;
-    private final CyclicBarrier barrier;
-
-    public DelayedEventHandler(CyclicBarrier barrier)
-    {
-        this.barrier = barrier;
-    }
-
-    public DelayedEventHandler()
-    {
-        this(new CyclicBarrier(2));
-    }
-
-    @Override
-    public void onEvent(final TestEvent entry, final long sequence, final boolean endOfBatch) throws Exception
-    {
-        waitForAndSetFlag(false);
-    }
-
-    public void processEvent()
-    {
-        waitForAndSetFlag(true);
-    }
-
-    public void stopWaiting()
-    {
-        stopped = true;
-    }
-
-    private void waitForAndSetFlag(final boolean newValue)
-    {
-        while (!stopped && !Thread.currentThread().isInterrupted() &&
-            !readyToProcessEvent.compareAndSet(!newValue, newValue))
-        {
-            Thread.yield();
-        }
-    }
-
-    @Override
-    public void onStart()
-    {
-        try
-        {
-            barrier.await();
-        }
-        catch (InterruptedException e)
-        {
-            throw new RuntimeException(e);
-        }
-        catch (BrokenBarrierException e)
-        {
-            throw new RuntimeException(e);
-        }
-    }
-
-    @Override
-    public void onShutdown()
-    {
-    }
-
-    public void awaitStart() throws InterruptedException, BrokenBarrierException
-    {
-        barrier.await();
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/dsl/stubs/EventHandlerStub.java b/src/test/java/com/lmax/disruptor/dsl/stubs/EventHandlerStub.java
deleted file mode 100644
index 152eb38..0000000
--- a/src/test/java/com/lmax/disruptor/dsl/stubs/EventHandlerStub.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.dsl.stubs;
-
-import com.lmax.disruptor.EventHandler;
-
-import java.util.concurrent.CountDownLatch;
-
-public class EventHandlerStub<T> implements EventHandler<T>
-{
-    private final CountDownLatch countDownLatch;
-
-    public EventHandlerStub(final CountDownLatch countDownLatch)
-    {
-        this.countDownLatch = countDownLatch;
-    }
-
-    @Override
-    public void onEvent(final T entry, final long sequence, final boolean endOfBatch) throws Exception
-    {
-        countDownLatch.countDown();
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/dsl/stubs/EvilEqualsEventHandler.java b/src/test/java/com/lmax/disruptor/dsl/stubs/EvilEqualsEventHandler.java
deleted file mode 100644
index d24715a..0000000
--- a/src/test/java/com/lmax/disruptor/dsl/stubs/EvilEqualsEventHandler.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.dsl.stubs;
-
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.support.TestEvent;
-
-public class EvilEqualsEventHandler implements EventHandler<TestEvent>
-{
-    @Override
-    public void onEvent(final TestEvent entry, final long sequence, boolean endOfBatch) throws Exception
-    {
-    }
-
-    @SuppressWarnings({"EqualsWhichDoesntCheckParameterClass"})
-    public boolean equals(Object o)
-    {
-        return true;
-    }
-
-    public int hashCode()
-    {
-        return 1;
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/dsl/stubs/ExceptionThrowingEventHandler.java b/src/test/java/com/lmax/disruptor/dsl/stubs/ExceptionThrowingEventHandler.java
deleted file mode 100644
index 219cca1..0000000
--- a/src/test/java/com/lmax/disruptor/dsl/stubs/ExceptionThrowingEventHandler.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.dsl.stubs;
-
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.support.TestEvent;
-
-public class ExceptionThrowingEventHandler implements EventHandler<TestEvent>
-{
-    private final RuntimeException testException;
-
-    public ExceptionThrowingEventHandler(final RuntimeException testException)
-    {
-        this.testException = testException;
-    }
-
-    @Override
-    public void onEvent(final TestEvent entry, final long sequence, final boolean endOfBatch) throws Exception
-    {
-        throw testException;
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/dsl/stubs/SleepingEventHandler.java b/src/test/java/com/lmax/disruptor/dsl/stubs/SleepingEventHandler.java
deleted file mode 100644
index d6da3e0..0000000
--- a/src/test/java/com/lmax/disruptor/dsl/stubs/SleepingEventHandler.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.dsl.stubs;
-
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.support.TestEvent;
-
-public class SleepingEventHandler implements EventHandler<TestEvent>
-{
-    @Override
-    public void onEvent(final TestEvent entry, final long sequence, final boolean endOfBatch) throws Exception
-    {
-        Thread.sleep(1000);
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/dsl/stubs/StubExceptionHandler.java b/src/test/java/com/lmax/disruptor/dsl/stubs/StubExceptionHandler.java
deleted file mode 100644
index c8f6264..0000000
--- a/src/test/java/com/lmax/disruptor/dsl/stubs/StubExceptionHandler.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.dsl.stubs;
-
-import com.lmax.disruptor.ExceptionHandler;
-
-import java.util.concurrent.atomic.AtomicReference;
-
-public class StubExceptionHandler implements ExceptionHandler<Object>
-{
-    private final AtomicReference<Throwable> exceptionHandled;
-
-    public StubExceptionHandler(final AtomicReference<Throwable> exceptionHandled)
-    {
-        this.exceptionHandled = exceptionHandled;
-    }
-
-    public void handleEventException(final Throwable ex, final long sequence, final Object event)
-    {
-        exceptionHandled.set(ex);
-    }
-
-    @Override
-    public void handleOnStartException(final Throwable ex)
-    {
-        exceptionHandled.set(ex);
-    }
-
-    @Override
-    public void handleOnShutdownException(final Throwable ex)
-    {
-        exceptionHandled.set(ex);
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/dsl/stubs/StubPublisher.java b/src/test/java/com/lmax/disruptor/dsl/stubs/StubPublisher.java
deleted file mode 100644
index f27434a..0000000
--- a/src/test/java/com/lmax/disruptor/dsl/stubs/StubPublisher.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.dsl.stubs;
-
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.support.TestEvent;
-
-public class StubPublisher implements Runnable
-{
-    private volatile boolean running = true;
-    private volatile int publicationCount = 0;
-
-    private final RingBuffer<TestEvent> ringBuffer;
-
-    public StubPublisher(final RingBuffer<TestEvent> ringBuffer)
-    {
-        this.ringBuffer = ringBuffer;
-    }
-
-    public void run()
-    {
-        while (running)
-        {
-            final long sequence = ringBuffer.next();
-            //final TestEvent entry = ringBuffer.get(sequence);
-            ringBuffer.publish(sequence);
-            publicationCount++;
-        }
-    }
-
-    public int getPublicationCount()
-    {
-        return publicationCount;
-    }
-
-    public void halt()
-    {
-        running = false;
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/dsl/stubs/StubThreadFactory.java b/src/test/java/com/lmax/disruptor/dsl/stubs/StubThreadFactory.java
deleted file mode 100644
index 0e160e2..0000000
--- a/src/test/java/com/lmax/disruptor/dsl/stubs/StubThreadFactory.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.dsl.stubs;
-
-import com.lmax.disruptor.util.DaemonThreadFactory;
-import org.junit.Assert;
-
-import java.util.Collection;
-import java.util.concurrent.CopyOnWriteArrayList;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-
-public final class StubThreadFactory implements ThreadFactory
-{
-    private final DaemonThreadFactory threadFactory = DaemonThreadFactory.INSTANCE;
-    private final Collection<Thread> threads = new CopyOnWriteArrayList<Thread>();
-    private final AtomicBoolean ignoreExecutions = new AtomicBoolean(false);
-    private final AtomicInteger executionCount = new AtomicInteger(0);
-
-    @Override
-    public Thread newThread(final Runnable command)
-    {
-        executionCount.getAndIncrement();
-        Runnable toExecute = command;
-        if(ignoreExecutions.get())
-        {
-            toExecute = new NoOpRunnable();
-        }
-        final Thread thread = threadFactory.newThread(toExecute);
-        thread.setName(command.toString());
-        threads.add(thread);
-        return thread;
-    }
-
-    public void joinAllThreads()
-    {
-        for (Thread thread : threads)
-        {
-            if (thread.isAlive())
-            {
-                try
-                {
-                    thread.interrupt();
-                    thread.join(5000);
-                }
-                catch (InterruptedException e)
-                {
-                    e.printStackTrace();
-                }
-            }
-
-            Assert.assertFalse("Failed to stop thread: " + thread, thread.isAlive());
-        }
-
-        threads.clear();
-    }
-
-    public void ignoreExecutions()
-    {
-        ignoreExecutions.set(true);
-    }
-
-    public int getExecutionCount()
-    {
-        return executionCount.get();
-    }
-
-    private static final class NoOpRunnable implements Runnable
-    {
-        @Override
-        public void run()
-        {
-        }
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/dsl/stubs/TestWorkHandler.java b/src/test/java/com/lmax/disruptor/dsl/stubs/TestWorkHandler.java
deleted file mode 100644
index c70d61a..0000000
--- a/src/test/java/com/lmax/disruptor/dsl/stubs/TestWorkHandler.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package com.lmax.disruptor.dsl.stubs;
-
-import com.lmax.disruptor.WorkHandler;
-import com.lmax.disruptor.support.TestEvent;
-
-import java.util.concurrent.atomic.AtomicBoolean;
-
-public class TestWorkHandler implements WorkHandler<TestEvent>
-{
-    private final AtomicBoolean readyToProcessEvent = new AtomicBoolean(false);
-    private volatile boolean stopped = false;
-
-    @Override
-    public void onEvent(final TestEvent event) throws Exception
-    {
-        waitForAndSetFlag(false);
-    }
-
-    public void processEvent()
-    {
-        waitForAndSetFlag(true);
-    }
-
-    public void stopWaiting()
-    {
-        stopped = true;
-    }
-
-    private void waitForAndSetFlag(final boolean newValue)
-    {
-        while (!stopped && !Thread.currentThread().isInterrupted() &&
-            !readyToProcessEvent.compareAndSet(!newValue, newValue))
-        {
-            Thread.yield();
-        }
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/example/DynamiclyAddHandler.java b/src/test/java/com/lmax/disruptor/example/DynamiclyAddHandler.java
deleted file mode 100644
index a5346fd..0000000
--- a/src/test/java/com/lmax/disruptor/example/DynamiclyAddHandler.java
+++ /dev/null
@@ -1,75 +0,0 @@
-package com.lmax.disruptor.example;
-
-import com.lmax.disruptor.*;
-import com.lmax.disruptor.dsl.Disruptor;
-import com.lmax.disruptor.support.StubEvent;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
-public class DynamiclyAddHandler
-{
-    private static class DynamicHandler implements EventHandler<StubEvent>, LifecycleAware
-    {
-        private final CountDownLatch shutdownLatch = new CountDownLatch(1);
-
-        @Override
-        public void onEvent(final StubEvent event, final long sequence, final boolean endOfBatch) throws Exception
-        {
-        }
-
-        @Override
-        public void onStart()
-        {
-
-        }
-
-        @Override
-        public void onShutdown()
-        {
-            shutdownLatch.countDown();
-        }
-
-        public void awaitShutdown() throws InterruptedException
-        {
-            shutdownLatch.await();
-        }
-    }
-
-    public static void main(String[] args) throws InterruptedException
-    {
-        ExecutorService executor = Executors.newCachedThreadPool(DaemonThreadFactory.INSTANCE);
-
-        // Build a disruptor and start it.
-        Disruptor<StubEvent> disruptor = new Disruptor<StubEvent>(
-            StubEvent.EVENT_FACTORY, 1024, DaemonThreadFactory.INSTANCE);
-        RingBuffer<StubEvent> ringBuffer = disruptor.start();
-
-        // Construct 2 batch event processors.
-        DynamicHandler handler1 = new DynamicHandler();
-        BatchEventProcessor<StubEvent> processor1 =
-            new BatchEventProcessor<StubEvent>(ringBuffer, ringBuffer.newBarrier(), handler1);
-
-        DynamicHandler handler2 = new DynamicHandler();
-        BatchEventProcessor<StubEvent> processor2 =
-            new BatchEventProcessor<StubEvent>(ringBuffer, ringBuffer.newBarrier(processor1.getSequence()), handler2);
-
-        // Dynamically add both sequences to the ring buffer
-        ringBuffer.addGatingSequences(processor1.getSequence(), processor2.getSequence());
-
-        // Start the new batch processors.
-        executor.execute(processor1);
-        executor.execute(processor2);
-
-        // Remove a processor.
-
-        // Stop the processor
-        processor2.halt();
-        // Wait for shutdown the complete
-        handler2.awaitShutdown();
-        // Remove the gating sequence from the ring buffer
-        ringBuffer.removeGatingSequence(processor2.getSequence());
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/example/HandleExceptionOnTranslate.java b/src/test/java/com/lmax/disruptor/example/HandleExceptionOnTranslate.java
deleted file mode 100644
index 9867a65..0000000
--- a/src/test/java/com/lmax/disruptor/example/HandleExceptionOnTranslate.java
+++ /dev/null
@@ -1,68 +0,0 @@
-package com.lmax.disruptor.example;
-
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.EventTranslator;
-import com.lmax.disruptor.dsl.Disruptor;
-import com.lmax.disruptor.support.LongEvent;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-public class HandleExceptionOnTranslate
-{
-    private static final int NO_VALUE_SPECIFIED = -1;
-
-    private static class MyHandler implements EventHandler<LongEvent>
-    {
-
-        @Override
-        public void onEvent(LongEvent event, long sequence, boolean endOfBatch) throws Exception
-        {
-            if (event.get() == NO_VALUE_SPECIFIED)
-            {
-                System.out.printf("Discarded%n");
-            }
-            else
-            {
-                System.out.printf("Processed: %s%n", event.get() == sequence);
-            }
-        }
-    }
-
-    public static void main(String[] args) throws InterruptedException
-    {
-        Disruptor<LongEvent> disruptor = new Disruptor<LongEvent>(LongEvent.FACTORY, 1024, DaemonThreadFactory.INSTANCE);
-
-        disruptor.handleEventsWith(new MyHandler());
-
-        disruptor.start();
-
-        EventTranslator<LongEvent> t = new EventTranslator<LongEvent>()
-        {
-            @Override
-            public void translateTo(LongEvent event, long sequence)
-            {
-                event.set(NO_VALUE_SPECIFIED);
-
-                if (sequence % 3 == 0)
-                {
-                    throw new RuntimeException("Skipping");
-                }
-
-                event.set(sequence);
-            }
-        };
-
-        for (int i = 0; i < 10; i++)
-        {
-            try
-            {
-                disruptor.publishEvent(t);
-            }
-            catch (RuntimeException e)
-            {
-                // Skipping
-            }
-        }
-
-        Thread.sleep(5000);
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/example/KeyedBatching.java b/src/test/java/com/lmax/disruptor/example/KeyedBatching.java
deleted file mode 100644
index c642790..0000000
--- a/src/test/java/com/lmax/disruptor/example/KeyedBatching.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.lmax.disruptor.example;
-
-import com.lmax.disruptor.EventHandler;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class KeyedBatching implements EventHandler<KeyedBatching.KeyedEvent>
-{
-    private static final int MAX_BATCH_SIZE = 100;
-    private long key = 0;
-    private List<Object> batch = new ArrayList<Object>();
-
-    @Override
-    public void onEvent(KeyedEvent event, long sequence, boolean endOfBatch) throws Exception
-    {
-        if (!batch.isEmpty() && event.key != key)
-        {
-            processBatch(batch);
-        }
-
-        batch.add(event.data);
-        key = event.key;
-
-        if (endOfBatch || batch.size() >= MAX_BATCH_SIZE)
-        {
-            processBatch(batch);
-        }
-    }
-
-    private void processBatch(List<Object> batch)
-    {
-        // do work.
-        batch.clear();
-    }
-
-    public static class KeyedEvent
-    {
-        long key;
-        Object data;
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/example/MultiProducerWithTranslator.java b/src/test/java/com/lmax/disruptor/example/MultiProducerWithTranslator.java
deleted file mode 100644
index 7102523..0000000
--- a/src/test/java/com/lmax/disruptor/example/MultiProducerWithTranslator.java
+++ /dev/null
@@ -1,101 +0,0 @@
-package com.lmax.disruptor.example;
-
-import com.lmax.disruptor.BlockingWaitStrategy;
-import com.lmax.disruptor.EventFactory;
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.EventTranslatorThreeArg;
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.dsl.Disruptor;
-import com.lmax.disruptor.dsl.ProducerType;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-public class MultiProducerWithTranslator
-{
-    private static class IMessage
-    {
-    }
-
-    private static class ITransportable
-    {
-    }
-
-    private static class ObjectBox
-    {
-        IMessage message;
-        ITransportable transportable;
-        String string;
-
-        private static final EventFactory<ObjectBox> FACTORY = new EventFactory<ObjectBox>()
-        {
-            @Override
-            public ObjectBox newInstance()
-            {
-                return new ObjectBox();
-            }
-        };
-
-        public void setMessage(IMessage arg0)
-        {
-            message = arg0;
-        }
-
-        public void setTransportable(ITransportable arg1)
-        {
-            transportable = arg1;
-        }
-
-        public void setStreamName(String arg2)
-        {
-            string = arg2;
-        }
-    }
-
-    public static class Publisher implements EventTranslatorThreeArg<ObjectBox, IMessage, ITransportable, String>
-    {
-        @Override
-        public void translateTo(ObjectBox event, long sequence, IMessage arg0, ITransportable arg1, String arg2)
-        {
-            event.setMessage(arg0);
-            event.setTransportable(arg1);
-            event.setStreamName(arg2);
-        }
-    }
-
-    public static class Consumer implements EventHandler<ObjectBox>
-    {
-        @Override
-        public void onEvent(ObjectBox event, long sequence, boolean endOfBatch) throws Exception
-        {
-
-        }
-    }
-
-    static final int RING_SIZE = 1024;
-
-    public static void main(String[] args) throws InterruptedException
-    {
-        Disruptor<ObjectBox> disruptor = new Disruptor<ObjectBox>(
-            ObjectBox.FACTORY, RING_SIZE, DaemonThreadFactory.INSTANCE, ProducerType.MULTI,
-            new BlockingWaitStrategy());
-        disruptor.handleEventsWith(new Consumer()).then(new Consumer());
-        final RingBuffer<ObjectBox> ringBuffer = disruptor.getRingBuffer();
-        Publisher p = new Publisher();
-        IMessage message = new IMessage();
-        ITransportable transportable = new ITransportable();
-        String streamName = "com.lmax.wibble";
-        System.out.println("publishing " + RING_SIZE + " messages");
-        for (int i = 0; i < RING_SIZE; i++)
-        {
-            ringBuffer.publishEvent(p, message, transportable, streamName);
-            Thread.sleep(10);
-        }
-        System.out.println("start disruptor");
-        disruptor.start();
-        System.out.println("continue publishing");
-        while (true)
-        {
-            ringBuffer.publishEvent(p, message, transportable, streamName);
-            Thread.sleep(10);
-        }
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/example/NamedEventHandler.java b/src/test/java/com/lmax/disruptor/example/NamedEventHandler.java
deleted file mode 100644
index 13a5cb2..0000000
--- a/src/test/java/com/lmax/disruptor/example/NamedEventHandler.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package com.lmax.disruptor.example;
-
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.LifecycleAware;
-
-public class NamedEventHandler<T> implements EventHandler<T>, LifecycleAware
-{
-    private String oldName;
-    private final String name;
-
-    public NamedEventHandler(final String name)
-    {
-        this.name = name;
-    }
-
-    @Override
-    public void onEvent(final T event, final long sequence, final boolean endOfBatch) throws Exception
-    {
-    }
-
-    @Override
-    public void onStart()
-    {
-        final Thread currentThread = Thread.currentThread();
-        oldName = currentThread.getName();
-        currentThread.setName(name);
-    }
-
-    @Override
-    public void onShutdown()
-    {
-        Thread.currentThread().setName(oldName);
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/example/Pipeliner.java b/src/test/java/com/lmax/disruptor/example/Pipeliner.java
deleted file mode 100644
index 22e7d8d..0000000
--- a/src/test/java/com/lmax/disruptor/example/Pipeliner.java
+++ /dev/null
@@ -1,100 +0,0 @@
-package com.lmax.disruptor.example;
-
-import com.lmax.disruptor.EventFactory;
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.dsl.Disruptor;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-public class Pipeliner
-{
-    public static void main(String[] args)
-    {
-        Disruptor<PipelinerEvent> disruptor = new Disruptor<PipelinerEvent>(
-            PipelinerEvent.FACTORY, 1024, DaemonThreadFactory.INSTANCE);
-
-        disruptor.handleEventsWith(
-            new ParallelHandler(0, 3),
-            new ParallelHandler(1, 3),
-            new ParallelHandler(2, 3)
-        ).then(new JoiningHandler());
-
-        RingBuffer<PipelinerEvent> ringBuffer = disruptor.start();
-
-        for (int i = 0; i < 1000; i++)
-        {
-            long next = ringBuffer.next();
-            try
-            {
-                PipelinerEvent pipelinerEvent = ringBuffer.get(next);
-                pipelinerEvent.input = i;
-            }
-            finally
-            {
-                ringBuffer.publish(next);
-            }
-        }
-    }
-
-    private static class ParallelHandler implements EventHandler<PipelinerEvent>
-    {
-        private final int ordinal;
-        private final int totalHandlers;
-
-        ParallelHandler(int ordinal, int totalHandlers)
-        {
-            this.ordinal = ordinal;
-            this.totalHandlers = totalHandlers;
-        }
-
-        @Override
-        public void onEvent(PipelinerEvent event, long sequence, boolean endOfBatch) throws Exception
-        {
-            if (sequence % totalHandlers == ordinal)
-            {
-                event.result = Long.toString(event.input);
-            }
-        }
-    }
-
-    private static class JoiningHandler implements EventHandler<PipelinerEvent>
-    {
-        private long lastEvent = -1;
-
-        @Override
-        public void onEvent(PipelinerEvent event, long sequence, boolean endOfBatch) throws Exception
-        {
-            if (event.input != lastEvent + 1 || event.result == null)
-            {
-                System.out.println("Error: " + event);
-            }
-
-            lastEvent = event.input;
-            event.result = null;
-        }
-    }
-
-    private static class PipelinerEvent
-    {
-        long input;
-        Object result;
-
-        private static final EventFactory<PipelinerEvent> FACTORY = new EventFactory<PipelinerEvent>()
-        {
-            @Override
-            public PipelinerEvent newInstance()
-            {
-                return new PipelinerEvent();
-            }
-        };
-
-        @Override
-        public String toString()
-        {
-            return "PipelinerEvent{" +
-                "input=" + input +
-                ", result=" + result +
-                '}';
-        }
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/example/PullWithBatchedPoller.java b/src/test/java/com/lmax/disruptor/example/PullWithBatchedPoller.java
deleted file mode 100644
index 7960be2..0000000
--- a/src/test/java/com/lmax/disruptor/example/PullWithBatchedPoller.java
+++ /dev/null
@@ -1,162 +0,0 @@
-package com.lmax.disruptor.example;
-
-import com.lmax.disruptor.EventFactory;
-import com.lmax.disruptor.EventPoller;
-import com.lmax.disruptor.RingBuffer;
-
-/**
- * Alternative usage of EventPoller, here we wrap it around BatchedEventPoller
- * to achieve Disruptor's batching. this speeds up the polling feature
- */
-public class PullWithBatchedPoller
-{
-    public static void main(String[] args) throws Exception
-    {
-        int batchSize = 40;
-        RingBuffer<BatchedPoller.DataEvent<Object>> ringBuffer = RingBuffer.createMultiProducer(BatchedPoller.DataEvent.factory(), 1024);
-
-        BatchedPoller<Object> poller = new BatchedPoller<Object>(ringBuffer, batchSize);
-
-        Object value = poller.poll();
-
-        // Value could be null if no events are available.
-        if (null != value)
-        {
-            // Process value.
-        }
-    }
-}
-
-class BatchedPoller<T>
-{
-
-    private final EventPoller<BatchedPoller.DataEvent<T>> poller;
-    private final int maxBatchSize;
-    private final BatchedData<T> polledData;
-
-    BatchedPoller(RingBuffer<BatchedPoller.DataEvent<T>> ringBuffer, int batchSize)
-    {
-        this.poller = ringBuffer.newPoller();
-        ringBuffer.addGatingSequences(poller.getSequence());
-
-        if (batchSize < 1)
-        {
-            batchSize = 20;
-        }
-        this.maxBatchSize = batchSize;
-        this.polledData = new BatchedData<T>(this.maxBatchSize);
-    }
-
-    public T poll() throws Exception
-    {
-        if (polledData.getMsgCount() > 0)
-        {
-            return polledData.pollMessage(); // we just fetch from our local
-        }
-
-        loadNextValues(poller, polledData); // we try to load from the ring
-        return polledData.getMsgCount() > 0 ? polledData.pollMessage() : null;
-    }
-
-    private EventPoller.PollState loadNextValues(EventPoller<BatchedPoller.DataEvent<T>> poller, final BatchedData<T> batch)
-            throws Exception
-    {
-        return poller.poll(new EventPoller.Handler<BatchedPoller.DataEvent<T>>()
-        {
-            @Override
-            public boolean onEvent(BatchedPoller.DataEvent<T> event, long sequence, boolean endOfBatch) throws Exception
-            {
-                T item = event.copyOfData();
-                return item != null ? batch.addDataItem(item) : false;
-            }
-        });
-    }
-
-    public static class DataEvent<T>
-    {
-
-        T data;
-
-        public static <T> EventFactory<BatchedPoller.DataEvent<T>> factory()
-        {
-            return new EventFactory<BatchedPoller.DataEvent<T>>()
-            {
-
-                @Override
-                public BatchedPoller.DataEvent<T> newInstance()
-                {
-                    return new BatchedPoller.DataEvent<T>();
-                }
-            };
-        }
-
-        public T copyOfData()
-        {
-            // Copy the data out here. In this case we have a single reference
-            // object, so the pass by
-            // reference is sufficient. But if we were reusing a byte array,
-            // then we
-            // would need to copy
-            // the actual contents.
-            return data;
-        }
-
-        void set(T d)
-        {
-            data = d;
-        }
-
-    }
-
-    private static class BatchedData<T>
-    {
-
-        private int msgHighBound;
-        private final int capacity;
-        private final T[] data;
-        private int cursor;
-
-        @SuppressWarnings("unchecked")
-        BatchedData(int size)
-        {
-            this.capacity = size;
-            data = (T[]) new Object[this.capacity];
-        }
-
-        private void clearCount()
-        {
-            msgHighBound = 0;
-            cursor = 0;
-        }
-
-        public int getMsgCount()
-        {
-            return msgHighBound - cursor;
-        }
-
-        public boolean addDataItem(T item) throws IndexOutOfBoundsException
-        {
-            if (msgHighBound >= capacity)
-            {
-                throw new IndexOutOfBoundsException("Attempting to add item to full batch");
-            }
-
-            data[msgHighBound++] = item;
-            return msgHighBound < capacity;
-        }
-
-        public T pollMessage()
-        {
-            T rtVal = null;
-            if (cursor < msgHighBound)
-            {
-                rtVal = data[cursor++];
-            }
-            if (cursor > 0 && cursor >= msgHighBound)
-            {
-                clearCount();
-            }
-            return rtVal;
-        }
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/example/PullWithPoller.java b/src/test/java/com/lmax/disruptor/example/PullWithPoller.java
deleted file mode 100644
index b0ee622..0000000
--- a/src/test/java/com/lmax/disruptor/example/PullWithPoller.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package com.lmax.disruptor.example;
-
-import com.lmax.disruptor.EventFactory;
-import com.lmax.disruptor.EventPoller;
-import com.lmax.disruptor.RingBuffer;
-
-/**
- * Created by barkerm on 02/02/15.
- */
-public class PullWithPoller
-{
-    public static class DataEvent<T>
-    {
-        T data;
-
-        public static <T> EventFactory<DataEvent<T>> factory()
-        {
-            return new EventFactory<DataEvent<T>>()
-            {
-                @Override
-                public DataEvent<T> newInstance()
-                {
-                    return new DataEvent<T>();
-                }
-            };
-        }
-
-        public T copyOfData()
-        {
-            // Copy the data out here.  In this case we have a single reference object, so the pass by
-            // reference is sufficient.  But if we were reusing a byte array, then we would need to copy
-            // the actual contents.
-            return data;
-        }
-    }
-
-    public static void main(String[] args) throws Exception
-    {
-        RingBuffer<DataEvent<Object>> ringBuffer = RingBuffer.createMultiProducer(DataEvent.factory(), 1024);
-
-        final EventPoller<DataEvent<Object>> poller = ringBuffer.newPoller();
-
-        Object value = getNextValue(poller);
-
-        // Value could be null if no events are available.
-        if (null != value)
-        {
-            // Process value.
-        }
-    }
-
-    private static Object getNextValue(EventPoller<DataEvent<Object>> poller) throws Exception
-    {
-        final Object[] out = new Object[1];
-
-        poller.poll(
-            new EventPoller.Handler<DataEvent<Object>>()
-            {
-                @Override
-                public boolean onEvent(DataEvent<Object> event, long sequence, boolean endOfBatch) throws Exception
-                {
-                    out[0] = event.copyOfData();
-
-                    // Return false so that only one event is processed at a time.
-                    return false;
-                }
-            });
-
-        return out[0];
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/example/SequentialThreeConsumers.java b/src/test/java/com/lmax/disruptor/example/SequentialThreeConsumers.java
deleted file mode 100644
index 0273ff2..0000000
--- a/src/test/java/com/lmax/disruptor/example/SequentialThreeConsumers.java
+++ /dev/null
@@ -1,62 +0,0 @@
-package com.lmax.disruptor.example;
-
-import com.lmax.disruptor.EventFactory;
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.dsl.Disruptor;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-public class SequentialThreeConsumers
-{
-    private static class MyEvent
-    {
-        private Object a;
-        private Object b;
-        private Object c;
-        private Object d;
-    }
-
-    private static EventFactory<MyEvent> factory = new EventFactory<MyEvent>()
-    {
-        @Override
-        public MyEvent newInstance()
-        {
-            return new MyEvent();
-        }
-    };
-
-    private static EventHandler<MyEvent> handler1 = new EventHandler<MyEvent>()
-    {
-        @Override
-        public void onEvent(MyEvent event, long sequence, boolean endOfBatch) throws Exception
-        {
-            event.b = event.a;
-        }
-    };
-
-    private static EventHandler<MyEvent> handler2 = new EventHandler<MyEvent>()
-    {
-        @Override
-        public void onEvent(MyEvent event, long sequence, boolean endOfBatch) throws Exception
-        {
-            event.c = event.b;
-        }
-    };
-
-    private static EventHandler<MyEvent> handler3 = new EventHandler<MyEvent>()
-    {
-        @Override
-        public void onEvent(MyEvent event, long sequence, boolean endOfBatch) throws Exception
-        {
-            event.d = event.c;
-        }
-    };
-
-    public static void main(String[] args)
-    {
-        Disruptor<MyEvent> disruptor = new Disruptor<MyEvent>(factory, 1024, DaemonThreadFactory.INSTANCE);
-
-        disruptor.handleEventsWith(handler1).then(handler2).then(handler3);
-
-        disruptor.start();
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/example/ShutdownOnError.java b/src/test/java/com/lmax/disruptor/example/ShutdownOnError.java
deleted file mode 100644
index ab5e4a5..0000000
--- a/src/test/java/com/lmax/disruptor/example/ShutdownOnError.java
+++ /dev/null
@@ -1,132 +0,0 @@
-package com.lmax.disruptor.example;
-
-import com.lmax.disruptor.EventFactory;
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.EventTranslator;
-import com.lmax.disruptor.ExceptionHandler;
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.dsl.Disruptor;
-
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-public class ShutdownOnError
-{
-    private static class Event
-    {
-        public long value;
-
-        public static final EventFactory<Event> FACTORY = new EventFactory<Event>()
-        {
-            @Override
-            public Event newInstance()
-            {
-                return new Event();
-            }
-        };
-    }
-
-    private static class DefaultThreadFactory implements ThreadFactory
-    {
-        @Override
-        public Thread newThread(Runnable r)
-        {
-            return new Thread(r);
-        }
-    }
-
-    private static class Handler implements EventHandler<Event>
-    {
-        @Override
-        public void onEvent(Event event, long sequence, boolean endOfBatch) throws Exception
-        {
-            // do work, if a failure occurs throw exception.
-        }
-    }
-
-    private static final class ErrorHandler implements ExceptionHandler<Event>
-    {
-        private final AtomicBoolean running;
-
-        private ErrorHandler(AtomicBoolean running)
-        {
-            this.running = running;
-        }
-
-        @Override
-        public void handleEventException(Throwable ex, long sequence, Event event)
-        {
-            if (execeptionIsFatal(ex))
-            {
-                throw new RuntimeException(ex);
-            }
-        }
-
-        private boolean execeptionIsFatal(Throwable ex)
-        {
-            // Do what is appropriate here.
-            return true;
-        }
-
-        @Override
-        public void handleOnStartException(Throwable ex)
-        {
-
-        }
-
-        @Override
-        public void handleOnShutdownException(Throwable ex)
-        {
-
-        }
-    }
-
-    public static void main(String[] args)
-    {
-        Disruptor<Event> disruptor = new Disruptor<>(Event.FACTORY, 1024, new DefaultThreadFactory());
-
-        AtomicBoolean running = new AtomicBoolean(true);
-
-        ErrorHandler errorHandler = new ErrorHandler(running);
-
-        final Handler handler = new Handler();
-        disruptor.handleEventsWith(handler);
-        disruptor.handleExceptionsFor(handler).with(errorHandler);
-
-        simplePublish(disruptor, running);
-    }
-
-    private static void simplePublish(Disruptor<Event> disruptor, AtomicBoolean running)
-    {
-        while (running.get())
-        {
-            disruptor.publishEvent(new EventTranslator<Event>()
-            {
-                @Override
-                public void translateTo(Event event, long sequence)
-                {
-                    event.value = sequence;
-                }
-            });
-        }
-    }
-
-    private static void smarterPublish(Disruptor<Event> disruptor, AtomicBoolean running)
-    {
-        final RingBuffer<Event> ringBuffer = disruptor.getRingBuffer();
-
-        boolean publishOk;
-        do
-        {
-            publishOk = ringBuffer.tryPublishEvent(new EventTranslator<Event>()
-            {
-                @Override
-                public void translateTo(Event event, long sequence)
-                {
-                    event.value = sequence;
-                }
-            });
-        }
-        while (publishOk && running.get());
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/example/ThreeToOneDisruptor.java b/src/test/java/com/lmax/disruptor/example/ThreeToOneDisruptor.java
deleted file mode 100644
index f4afd04..0000000
--- a/src/test/java/com/lmax/disruptor/example/ThreeToOneDisruptor.java
+++ /dev/null
@@ -1,86 +0,0 @@
-package com.lmax.disruptor.example;
-
-
-import com.lmax.disruptor.EventFactory;
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.dsl.Disruptor;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-
-public class ThreeToOneDisruptor
-{
-    public static class DataEvent
-    {
-        Object input;
-        Object[] output;
-
-        public DataEvent(int size)
-        {
-            output = new Object[size];
-        }
-
-        public static final EventFactory<DataEvent> FACTORY = new EventFactory<DataEvent>()
-        {
-            @Override
-            public DataEvent newInstance()
-            {
-                return new DataEvent(3);
-            }
-        };
-    }
-
-    public static class TransformingHandler implements EventHandler<DataEvent>
-    {
-        private final int outputIndex;
-
-        public TransformingHandler(int outputIndex)
-        {
-            this.outputIndex = outputIndex;
-        }
-
-        @Override
-        public void onEvent(DataEvent event, long sequence, boolean endOfBatch) throws Exception
-        {
-            // Do Stuff.
-            event.output[outputIndex] = doSomething(event.input);
-        }
-
-        private Object doSomething(Object input)
-        {
-            // Do required transformation here....
-            return input;
-        }
-    }
-
-    public static class CollatingHandler implements EventHandler<DataEvent>
-    {
-        @Override
-        public void onEvent(DataEvent event, long sequence, boolean endOfBatch) throws Exception
-        {
-            collate(event.output);
-        }
-
-        private void collate(Object[] output)
-        {
-            // Do required collation here....
-        }
-    }
-
-    public static void main(String[] args)
-    {
-        Executor executor = Executors.newFixedThreadPool(4);
-        Disruptor<DataEvent> disruptor = new Disruptor<DataEvent>(
-            DataEvent.FACTORY, 1024, DaemonThreadFactory.INSTANCE);
-
-        TransformingHandler handler1 = new TransformingHandler(0);
-        TransformingHandler handler2 = new TransformingHandler(1);
-        TransformingHandler handler3 = new TransformingHandler(2);
-        CollatingHandler collator = new CollatingHandler();
-
-        disruptor.handleEventsWith(handler1, handler2, handler3).then(collator);
-
-        disruptor.start();
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/example/WaitForShutdown.java b/src/test/java/com/lmax/disruptor/example/WaitForShutdown.java
deleted file mode 100644
index 27e19a3..0000000
--- a/src/test/java/com/lmax/disruptor/example/WaitForShutdown.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package com.lmax.disruptor.example;
-
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.LifecycleAware;
-import com.lmax.disruptor.TimeoutException;
-import com.lmax.disruptor.dsl.Disruptor;
-import com.lmax.disruptor.support.LongEvent;
-import com.lmax.disruptor.util.DaemonThreadFactory;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-public class WaitForShutdown
-{
-    private static volatile int value = 0;
-
-    private static class Handler implements EventHandler<LongEvent>, LifecycleAware
-    {
-        private final CountDownLatch latch;
-
-        Handler(CountDownLatch latch)
-        {
-            this.latch = latch;
-        }
-
-        @Override
-        public void onStart()
-        {
-        }
-
-        @Override
-        public void onShutdown()
-        {
-            latch.countDown();
-        }
-
-        @Override
-        public void onEvent(LongEvent event, long sequence, boolean endOfBatch) throws Exception
-        {
-            value = 1;
-        }
-    }
-
-    public static void main(String[] args) throws TimeoutException, InterruptedException
-    {
-        Disruptor<LongEvent> disruptor = new Disruptor<LongEvent>(
-            LongEvent.FACTORY, 16, DaemonThreadFactory.INSTANCE
-        );
-
-        CountDownLatch shutdownLatch = new CountDownLatch(2);
-
-        disruptor.handleEventsWith(new Handler(shutdownLatch)).then(new Handler(shutdownLatch));
-        disruptor.start();
-
-        long next = disruptor.getRingBuffer().next();
-        disruptor.getRingBuffer().get(next).set(next);
-        disruptor.getRingBuffer().publish(next);
-
-        disruptor.shutdown(10, TimeUnit.SECONDS);
-
-        shutdownLatch.await();
-
-        System.out.println(value);
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/support/DummyEventHandler.java b/src/test/java/com/lmax/disruptor/support/DummyEventHandler.java
deleted file mode 100644
index 82a4b7a..0000000
--- a/src/test/java/com/lmax/disruptor/support/DummyEventHandler.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package com.lmax.disruptor.support;
-
-import com.lmax.disruptor.EventHandler;
-import com.lmax.disruptor.LifecycleAware;
-
-public class DummyEventHandler<T> implements EventHandler<T>, LifecycleAware
-{
-    public int startCalls = 0;
-    public int shutdownCalls = 0;
-    public T lastEvent;
-    public long lastSequence;
-
-    @Override
-    public void onStart()
-    {
-        startCalls++;
-    }
-
-    @Override
-    public void onShutdown()
-    {
-        shutdownCalls++;
-    }
-
-    @Override
-    public void onEvent(T event, long sequence, boolean endOfBatch) throws Exception
-    {
-        lastEvent = event;
-        lastSequence = sequence;
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/support/DummyEventProcessor.java b/src/test/java/com/lmax/disruptor/support/DummyEventProcessor.java
deleted file mode 100644
index edc3201..0000000
--- a/src/test/java/com/lmax/disruptor/support/DummyEventProcessor.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package com.lmax.disruptor.support;
-
-import com.lmax.disruptor.EventProcessor;
-import com.lmax.disruptor.Sequence;
-import com.lmax.disruptor.SingleProducerSequencer;
-
-import java.util.concurrent.atomic.AtomicBoolean;
-
-public class DummyEventProcessor implements EventProcessor
-{
-    private final Sequence sequence;
-    private final AtomicBoolean running = new AtomicBoolean(false);
-
-    public DummyEventProcessor(Sequence sequence)
-    {
-        this.sequence = sequence;
-    }
-
-    public DummyEventProcessor()
-    {
-        this(new Sequence(SingleProducerSequencer.INITIAL_CURSOR_VALUE));
-    }
-
-    public void setSequence(long sequence)
-    {
-        this.sequence.set(sequence);
-    }
-
-    @Override
-    public Sequence getSequence()
-    {
-        return sequence;
-    }
-
-    @Override
-    public void halt()
-    {
-        running.set(false);
-    }
-
-    @Override
-    public boolean isRunning()
-    {
-        return running.get();
-    }
-
-    @Override
-    public void run()
-    {
-        if (!running.compareAndSet(false, true))
-        {
-            throw new IllegalStateException("Already running");
-        }
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/support/DummySequenceBarrier.java b/src/test/java/com/lmax/disruptor/support/DummySequenceBarrier.java
deleted file mode 100644
index 586619b..0000000
--- a/src/test/java/com/lmax/disruptor/support/DummySequenceBarrier.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright 2012 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-
-import com.lmax.disruptor.AlertException;
-import com.lmax.disruptor.SequenceBarrier;
-
-public class DummySequenceBarrier implements SequenceBarrier
-{
-    @Override
-    public long waitFor(long sequence) throws AlertException, InterruptedException
-    {
-        return 0;
-    }
-
-    @Override
-    public long getCursor()
-    {
-        return 0;
-    }
-
-    @Override
-    public boolean isAlerted()
-    {
-        return false;
-    }
-
-    @Override
-    public void alert()
-    {
-    }
-
-    @Override
-    public void clearAlert()
-    {
-    }
-
-    @Override
-    public void checkAlert() throws AlertException
-    {
-    }
-}
\ No newline at end of file
diff --git a/src/test/java/com/lmax/disruptor/support/DummyWaitStrategy.java b/src/test/java/com/lmax/disruptor/support/DummyWaitStrategy.java
deleted file mode 100644
index a627eb3..0000000
--- a/src/test/java/com/lmax/disruptor/support/DummyWaitStrategy.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package com.lmax.disruptor.support;
-
-import com.lmax.disruptor.*;
-
-public class DummyWaitStrategy implements WaitStrategy
-{
-    public int signalAllWhenBlockingCalls = 0;
-
-    @Override
-    public long waitFor(
-        long sequence, Sequence cursor, Sequence dependentSequence, SequenceBarrier barrier)
-        throws AlertException, InterruptedException, TimeoutException
-    {
-        return 0;
-    }
-
-    @Override
-    public void signalAllWhenBlocking()
-    {
-        signalAllWhenBlockingCalls++;
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/support/LongEvent.java b/src/test/java/com/lmax/disruptor/support/LongEvent.java
deleted file mode 100644
index 0b81ed9..0000000
--- a/src/test/java/com/lmax/disruptor/support/LongEvent.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import com.lmax.disruptor.EventFactory;
-
-public class LongEvent
-{
-    private long value;
-
-    public void set(long value)
-    {
-        this.value = value;
-    }
-
-    public long get()
-    {
-        return value;
-    }
-
-    public static final EventFactory<LongEvent> FACTORY = new EventFactory<LongEvent>()
-    {
-        @Override
-        public LongEvent newInstance()
-        {
-            return new LongEvent();
-        }
-    };
-}
diff --git a/src/test/java/com/lmax/disruptor/support/SequenceUpdater.java b/src/test/java/com/lmax/disruptor/support/SequenceUpdater.java
deleted file mode 100644
index 7bda478..0000000
--- a/src/test/java/com/lmax/disruptor/support/SequenceUpdater.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright 2012 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import com.lmax.disruptor.Sequence;
-import com.lmax.disruptor.WaitStrategy;
-
-import java.util.concurrent.BrokenBarrierException;
-import java.util.concurrent.CyclicBarrier;
-
-class SequenceUpdater implements Runnable
-{
-    public final Sequence sequence = new Sequence();
-    private final CyclicBarrier barrier = new CyclicBarrier(2);
-    private final long sleepTime;
-    private WaitStrategy waitStrategy;
-
-    SequenceUpdater(long sleepTime, WaitStrategy waitStrategy)
-    {
-        this.sleepTime = sleepTime;
-        this.waitStrategy = waitStrategy;
-    }
-
-    @Override
-    public void run()
-    {
-        try
-        {
-            barrier.await();
-            if (0 != sleepTime)
-            {
-                Thread.sleep(sleepTime);
-            }
-            sequence.incrementAndGet();
-            waitStrategy.signalAllWhenBlocking();
-        }
-        catch (Exception e)
-        {
-            e.printStackTrace();
-        }
-    }
-
-    public void waitForStartup() throws InterruptedException, BrokenBarrierException
-    {
-        barrier.await();
-    }
-}
\ No newline at end of file
diff --git a/src/test/java/com/lmax/disruptor/support/StubEvent.java b/src/test/java/com/lmax/disruptor/support/StubEvent.java
deleted file mode 100644
index 5fd6820..0000000
--- a/src/test/java/com/lmax/disruptor/support/StubEvent.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import com.lmax.disruptor.EventFactory;
-import com.lmax.disruptor.EventTranslatorTwoArg;
-
-public final class StubEvent
-{
-    private int value;
-    private String testString;
-    public static final EventTranslatorTwoArg<StubEvent, Integer, String> TRANSLATOR =
-        new EventTranslatorTwoArg<StubEvent, Integer, String>()
-        {
-            @Override
-            public void translateTo(StubEvent event, long sequence, Integer arg0, String arg1)
-            {
-                event.setValue(arg0);
-                event.setTestString(arg1);
-            }
-        };
-
-    public StubEvent(int i)
-    {
-        this.value = i;
-    }
-
-    public void copy(StubEvent event)
-    {
-        value = event.value;
-    }
-
-    public int getValue()
-    {
-        return value;
-    }
-
-    public void setValue(int value)
-    {
-        this.value = value;
-    }
-
-    public String getTestString()
-    {
-        return testString;
-    }
-
-    public void setTestString(final String testString)
-    {
-        this.testString = testString;
-    }
-
-    public static final EventFactory<StubEvent> EVENT_FACTORY = new EventFactory<StubEvent>()
-    {
-        public StubEvent newInstance()
-        {
-            return new StubEvent(-1);
-        }
-    };
-
-    @Override
-    public int hashCode()
-    {
-        final int prime = 31;
-        int result = 1;
-        result = prime * result + value;
-        return result;
-    }
-
-    @Override
-    public boolean equals(Object obj)
-    {
-        if (this == obj)
-        {
-            return true;
-        }
-        if (obj == null)
-        {
-            return false;
-        }
-        if (getClass() != obj.getClass())
-        {
-            return false;
-        }
-        StubEvent other = (StubEvent) obj;
-
-        return value == other.value;
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/support/TestEvent.java b/src/test/java/com/lmax/disruptor/support/TestEvent.java
deleted file mode 100644
index 978f36f..0000000
--- a/src/test/java/com/lmax/disruptor/support/TestEvent.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import com.lmax.disruptor.EventFactory;
-
-public final class TestEvent
-{
-    @Override
-    public String toString()
-    {
-        return "Test Event";
-    }
-
-    public static final EventFactory<TestEvent> EVENT_FACTORY = new EventFactory<TestEvent>()
-    {
-        public TestEvent newInstance()
-        {
-            return new TestEvent();
-        }
-    };
-}
diff --git a/src/test/java/com/lmax/disruptor/support/TestWaiter.java b/src/test/java/com/lmax/disruptor/support/TestWaiter.java
deleted file mode 100644
index 01e497c..0000000
--- a/src/test/java/com/lmax/disruptor/support/TestWaiter.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.Callable;
-import java.util.concurrent.CyclicBarrier;
-
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.SequenceBarrier;
-
-public final class TestWaiter implements Callable<List<StubEvent>>
-{
-    private final long toWaitForSequence;
-    private final long initialSequence;
-    private final CyclicBarrier cyclicBarrier;
-    private final SequenceBarrier sequenceBarrier;
-    private final RingBuffer<StubEvent> ringBuffer;
-
-    public TestWaiter(
-        final CyclicBarrier cyclicBarrier,
-        final SequenceBarrier sequenceBarrier,
-        final RingBuffer<StubEvent> ringBuffer,
-        final long initialSequence,
-        final long toWaitForSequence)
-    {
-        this.cyclicBarrier = cyclicBarrier;
-        this.initialSequence = initialSequence;
-        this.ringBuffer = ringBuffer;
-        this.toWaitForSequence = toWaitForSequence;
-        this.sequenceBarrier = sequenceBarrier;
-    }
-
-    @Override
-    public List<StubEvent> call() throws Exception
-    {
-        cyclicBarrier.await();
-        sequenceBarrier.waitFor(toWaitForSequence);
-
-        final List<StubEvent> messages = new ArrayList<StubEvent>();
-        for (long l = initialSequence; l <= toWaitForSequence; l++)
-        {
-            messages.add(ringBuffer.get(l));
-        }
-
-        return messages;
-    }
-}
\ No newline at end of file
diff --git a/src/test/java/com/lmax/disruptor/support/WaitStrategyTestUtil.java b/src/test/java/com/lmax/disruptor/support/WaitStrategyTestUtil.java
deleted file mode 100644
index c9269b5..0000000
--- a/src/test/java/com/lmax/disruptor/support/WaitStrategyTestUtil.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright 2012 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.support;
-
-import com.lmax.disruptor.AlertException;
-import com.lmax.disruptor.Sequence;
-import com.lmax.disruptor.TimeoutException;
-import com.lmax.disruptor.WaitStrategy;
-
-import java.util.concurrent.BrokenBarrierException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
-import static org.hamcrest.CoreMatchers.is;
-import static org.junit.Assert.assertThat;
-
-public class WaitStrategyTestUtil
-{
-    private static final ExecutorService EXECUTOR = Executors.newCachedThreadPool();
-
-    public static void assertWaitForWithDelayOf(long sleepTimeMillis, WaitStrategy waitStrategy)
-        throws InterruptedException, BrokenBarrierException, AlertException, TimeoutException
-    {
-        SequenceUpdater sequenceUpdater = new SequenceUpdater(sleepTimeMillis, waitStrategy);
-        EXECUTOR.execute(sequenceUpdater);
-        sequenceUpdater.waitForStartup();
-        Sequence cursor = new Sequence(0);
-        long sequence = waitStrategy.waitFor(0, cursor, sequenceUpdater.sequence, new DummySequenceBarrier());
-
-        assertThat(sequence, is(0L));
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/util/MutableLong.java b/src/test/java/com/lmax/disruptor/util/MutableLong.java
deleted file mode 100644
index 61c988e..0000000
--- a/src/test/java/com/lmax/disruptor/util/MutableLong.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.util;
-
-/**
- * Holder class for a long value.
- */
-public class MutableLong
-{
-    private long value = 0L;
-
-    /**
-     * Default constructor
-     */
-    public MutableLong()
-    {
-    }
-
-    /**
-     * Construct the holder with initial value.
-     *
-     * @param initialValue to be initially set.
-     */
-    public MutableLong(final long initialValue)
-    {
-        this.value = initialValue;
-    }
-
-    /**
-     * Get the long value.
-     *
-     * @return the long value.
-     */
-    public long get()
-    {
-        return value;
-    }
-
-    /**
-     * Set the long value.
-     *
-     * @param value to set.
-     */
-    public void set(final long value)
-    {
-        this.value = value;
-    }
-
-    /**
-     * Increments the value
-     */
-    public void increment()
-    {
-        value++;
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/util/PaddedLong.java b/src/test/java/com/lmax/disruptor/util/PaddedLong.java
deleted file mode 100644
index 118cbb2..0000000
--- a/src/test/java/com/lmax/disruptor/util/PaddedLong.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.util;
-
-/**
- * Cache line padded long variable to be used when false sharing maybe an issue.
- */
-public final class PaddedLong extends MutableLong
-{
-    public volatile long p1, p2, p3, p4, p5, p6 = 7L;
-
-    /**
-     * Default constructor
-     */
-    public PaddedLong()
-    {
-    }
-
-    /**
-     * Construct with an initial value.
-     *
-     * @param initialValue for construction
-     */
-    public PaddedLong(final long initialValue)
-    {
-        super(initialValue);
-    }
-
-    public long sumPaddingToPreventOptimisation()
-    {
-        return p1 + p2 + p3 + p4 + p5 + p6;
-    }
-}
diff --git a/src/test/java/com/lmax/disruptor/util/UtilTest.java b/src/test/java/com/lmax/disruptor/util/UtilTest.java
deleted file mode 100644
index 9b9da0a..0000000
--- a/src/test/java/com/lmax/disruptor/util/UtilTest.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright 2011 LMAX Ltd.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.lmax.disruptor.util;
-
-import com.lmax.disruptor.Sequence;
-
-import org.junit.Assert;
-import org.junit.Test;
-
-public final class UtilTest
-{
-    @Test
-    public void shouldReturnNextPowerOfTwo()
-    {
-        int powerOfTwo = Util.ceilingNextPowerOfTwo(1000);
-
-        Assert.assertEquals(1024, powerOfTwo);
-    }
-
-    @Test
-    public void shouldReturnExactPowerOfTwo()
-    {
-        int powerOfTwo = Util.ceilingNextPowerOfTwo(1024);
-
-        Assert.assertEquals(1024, powerOfTwo);
-    }
-
-    @Test
-    public void shouldReturnMinimumSequence()
-    {
-        final Sequence[] sequences = {new Sequence(7L), new Sequence(3L), new Sequence(12L)};
-        Assert.assertEquals(3L, Util.getMinimumSequence(sequences));
-    }
-
-    @Test
-    public void shouldReturnLongMaxWhenNoEventProcessors()
-    {
-        final Sequence[] sequences = new Sequence[0];
-
-        Assert.assertEquals(Long.MAX_VALUE, Util.getMinimumSequence(sequences));
-    }
-}
