[1mdiff --git a/README.coda b/README.coda[m
[1mnew file mode 100644[m
[1mindex 0000000..64d384f[m
[1m--- /dev/null[m
[1m+++ b/README.coda[m
[36m@@ -0,0 +1,3 @@[m
[32m+[m[32mA note to CODA users.[m
[32m+[m[32mThe code originally in src/perftest and src/test has been deleted since it's not used in CODA and[m
[32m+[m[32mcan only be compiled with the addition of other, external jars[m
\ No newline at end of file[m
[1mdiff --git a/build.xml b/build.xml[m
[1mnew file mode 100644[m
[1mindex 0000000..a4fd56b[m
[1m--- /dev/null[m
[1m+++ b/build.xml[m
[36m@@ -0,0 +1,241 @@[m
[32m+[m[32m<?xml version="1.0" encoding="UTF-8"?>[m[41m[m
[32m+[m[41m[m
[32m+[m[32m<project name="disruptor" default="compile" basedir=".">[m[41m[m
[32m+[m[41m[m
[32m+[m[32m    <!-- environmental variables -->[m[41m[m
[32m+[m[32m    <property environment="env"/>[m[41m[m
[32m+[m[41m    [m
[32m+[m[32m    <!-- Version -->[m[41m[m
[32m+[m[32m    <property name="dis.version" value="3.4" />[m[41m[m
[32m+[m[41m    [m
[32m+[m[32m    <!-- Debug -->[m[41m[m
[32m+[m[32m    <property name="javac.debug" value="on" />[m[41m[m
[32m+[m[41m    [m
[32m+[m[32m    <!-- Directories/Files -->[m[41m[m
[32m+[m[32m    <property name="src.dir"       value="src/main/java" />[m[41m[m
[32m+[m[32m    <property name="build.dir"     value="build" />[m[41m[m
[32m+[m[32m    <property name="build.classes" value="${build.dir}/classes" />[m[41m[m
[32m+[m[32m    <property name="build.lib"     value="${build.dir}/lib" />[m[41m[m
[32m+[m[32m    <property name="doc.dir"       value="doc/javadoc" />[m[41m[m
[32m+[m[32m    <property name="jarName"       value="disruptor-${dis.version}.jar" />[m[41m[m
[32m+[m[32m    <property name="allJarNames"   value="disruptor-*.jar" />[m[41m[m
[32m+[m[32m    <property name="jarPath"       value="${build.lib}/${jarName}" />[m[41m[m
[32m+[m[41m[m
[32m+[m[41m[m
[32m+[m[32m    <!-- Set Classpath, ignore caller's classpath -->[m[41m[m
[32m+[m[32m    <property name="build.sysclasspath" value="ignore" />[m[41m[m
[32m+[m[32m    <path id="classpath" />[m[41m[m
[32m+[m[41m[m
[32m+[m[41m    [m
[32m+[m[32m    <!-- Targets -->[m[41m[m
[32m+[m[41m    [m
[32m+[m[32m    <!-- Help -->[m[41m[m
[32m+[m[32m    <target name="help">[m[41m[m
[32m+[m[32m        <echo message="Usage: ant [ant options] &lt;target1&gt; [target2 | target3 | ...]" />[m[41m[m
[32m+[m[32m        <echo message="" />[m[41m[m
[32m+[m[32m        <echo message="       targets:" />[m[41m[m
[32m+[m[32m        <echo message="       help       - print out usage" />[m[41m[m
[32m+[m[32m        <echo message="       env        - print out build file variables' values" />[m[41m[m
[32m+[m[32m        <echo message="       compile    - compile java files" />[m[41m[m
[32m+[m[32m        <echo message="       clean      - remove class files" />[m[41m[m
[32m+[m[32m        <echo message="       cleanall   - remove all generated files" />[m[41m[m
[32m+[m[32m        <echo message="       jar        - compile and create jar file" />[m[41m[m
[32m+[m[32m        <echo message="       install    - create jar file and install into 'prefix'" />[m[41m[m
[32m+[m[32m        <echo message="                    if given on command line by -Dprefix=dir'," />[m[41m[m
[32m+[m[32m        <echo message="                    else install into CODA if defined" />[m[41m[m
[32m+[m[32m        <echo message="       uninstall  - remove jar file previously installed into 'prefix'" />[m[41m[m
[32m+[m[32m        <echo message="                    if given on command line by -Dprefix=dir'," />[m[41m[m
[32m+[m[32m        <echo message="                    else installed into CODA if defined" />[m[41m[m
[32m+[m[32m        <echo message="       all        - clean, compile and create jar file" />[m[41m[m
[32m+[m[32m        <echo message="       javadoc    - create javadoc documentation" />[m[41m[m
[32m+[m[32m        <echo message="       developdoc - create javadoc documentation for developer" />[m[41m[m
[32m+[m[32m        <echo message="       undoc      - remove all javadoc documentation" />[m[41m[m
[32m+[m[32m        <echo message="       prepare    - create necessary directories" />[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[41m[m
[32m+[m[32m    <!-- Environment -->[m[41m[m
[32m+[m[32m    <target name="env">[m[41m[m
[32m+[m[32m        <echo message="Ant environment:" />[m[41m[m
[32m+[m[32m        <echo message="" />[m[41m[m
[32m+[m[32m        <echo message="    src.dir       = ${src.dir}" />[m[41m[m
[32m+[m[32m        <echo message="    build.dir     = ${build.dir}" />[m[41m[m
[32m+[m[32m        <echo message="    build.lib     = ${build.lib}" />[m[41m[m
[32m+[m[32m        <echo message="    build.classes = ${build.classes}" />[m[41m[m
[32m+[m[32m        <echo message="    doc.dir       = ${doc.dir}" />[m[41m[m
[32m+[m[32m        <echo message="    javac.debug   = ${javac.debug}" />[m[41m[m
[32m+[m[32m        <echo message="    classpath     = ${env.CLASSPATH}" />[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[41m[m
[32m+[m[41m[m
[32m+[m[32m    <!-- ************************************************************* -->[m[41m[m
[32m+[m[32m    <target name="installCheck"  >[m[41m[m
[32m+[m[41m[m
[32m+[m[32m        <!-- Test to see if -Dprefix=<dir> used on command line -->[m[41m[m
[32m+[m[32m        <condition property="prefixDefined">[m[41m[m
[32m+[m[32m            <isset property="prefix"/>[m[41m[m
[32m+[m[32m        </condition>[m[41m[m
[32m+[m[41m[m
[32m+[m[32m        <!-- Test to see if CODA environmental variable defined -->[m[41m[m
[32m+[m[32m        <condition property="codaDefined">[m[41m[m
[32m+[m[32m            <isset property="env.CODA"/>[m[41m[m
[32m+[m[32m        </condition>[m[41m[m
[32m+[m[41m[m
[32m+[m[32m        <!-- Test to see if no installation directory defined   -->[m[41m[m
[32m+[m[32m        <condition property="noInstallDir">[m[41m[m
[32m+[m[32m            <and>[m[41m[m
[32m+[m[32m                <not>[m[41m[m
[32m+[m[32m                    <isset property="prefix"/>[m[41m[m
[32m+[m[32m                </not>[m[41m[m
[32m+[m[32m                <not>[m[41m[m
[32m+[m[32m                    <isset property="env.CODA"/>[m[41m[m
[32m+[m[32m                </not>[m[41m[m
[32m+[m[32m            </and>[m[41m[m
[32m+[m[32m        </condition>[m[41m[m
[32m+[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[32m    <!-- ************************************************************* -->[m[41m[m
[32m+[m[41m[m
[32m+[m[41m[m
[32m+[m[32m    <!-- Prepare things by creating directories -->[m[41m[m
[32m+[m[32m    <target name="prepare" depends="installCheck" >[m[41m[m
[32m+[m[32m        <mkdir dir="${build.dir}" />[m[41m[m
[32m+[m[32m        <mkdir dir="${build.classes}" />[m[41m[m
[32m+[m[32m        <mkdir dir="${build.lib}" />[m[41m[m
[32m+[m[32m        <antcall target="preparePrefixDir"/>[m[41m[m
[32m+[m[32m        <antcall target="prepareCodaDir"/>[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[41m[m
[32m+[m[32m    <target name="preparePrefixDir" if="prefixDefined">[m[41m[m
[32m+[m[32m        <mkdir dir="${prefix}/jar" />[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[41m[m
[32m+[m[32m    <target name="prepareCodaDir" if="codaDefined">[m[41m[m
[32m+[m[32m        <mkdir dir="${env.CODA}/common/jar" />[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[41m[m
[32m+[m[41m[m
[32m+[m[41m[m
[32m+[m[32m    <!-- Clean by removing class files -->[m[41m[m
[32m+[m[32m    <target name="clean" description="Remove all class files">[m[41m[m
[32m+[m[32m        <delete failonerror="no" >[m[41m[m
[32m+[m[32m            <fileset dir="${build.classes}" includes="**/*.class" />[m[41m[m
[32m+[m[32m        </delete>[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[41m    [m
[32m+[m[32m    <!-- Clean by removing build & doc directories -->[m[41m[m
[32m+[m[32m    <target name="cleanall" depends="clean" description="Remove all generated files.">[m[41m[m
[32m+[m[32m        <delete dir="${build.dir}" failonerror="no" />[m[41m[m
[32m+[m[32m        <delete dir="${doc.dir}"   failonerror="no" />[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[41m    [m
[32m+[m[32m    <!-- Compile all source -->[m[41m[m
[32m+[m[32m    <target name="compile" depends="prepare" description="Compiles all source code.">[m[41m[m
[32m+[m[32m        <javac destdir="${build.classes}" debug="${javac.debug}" optimize="yes" >[m[41m[m
[32m+[m[32m            <src path="${src.dir}" />[m[41m[m
[32m+[m[32m            <classpath refid="classpath" />[m[41m[m
[32m+[m[32m        </javac>[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[41m    [m
[32m+[m[41m[m
[32m+[m[41m[m
[32m+[m[32m    <!-- Javadoc -->[m[41m[m
[32m+[m[32m    <target name="javadoc" description="Create javadoc.">[m[41m[m
[32m+[m[32m        <mkdir dir="${doc.dir}" />[m[41m[m
[32m+[m[32m        <javadoc packagenames="com.lmax.disruptor"[m[41m[m
[32m+[m[32m                 sourcepath="java"[m[41m[m
[32m+[m[32m                 access="public"[m[41m[m
[32m+[m[32m                 destdir="${doc.dir}"[m[41m[m
[32m+[m[32m                 use="true" >[m[41m[m
[32m+[m[32m            <classpath refid="classpath" />[m[41m[m
[32m+[m[32m        </javadoc>[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[41m    [m
[32m+[m[32m    <!-- Javadoc for developer -->[m[41m[m
[32m+[m[32m    <target name="developdoc" description="Create javadoc for developer.">[m[41m[m
[32m+[m[32m        <mkdir dir="${doc.dir}" />[m[41m[m
[32m+[m[32m        <javadoc packagenames="com.lmax.disruptor"[m[41m[m
[32m+[m[32m                 sourcepath="java"[m[41m[m
[32m+[m[32m                 access="package"[m[41m[m
[32m+[m[32m                 destdir="${doc.dir}"[m[41m[m
[32m+[m[32m                 use="true" >[m[41m[m
[32m+[m[32m            <classpath refid="classpath" />[m[41m[m
[32m+[m[32m        </javadoc>[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[41m[m
[32m+[m[32m    <!-- Removing Javadoc -->[m[41m[m
[32m+[m[32m    <target name="undoc" description="remove all javadoc.">[m[41m[m
[32m+[m[32m        <delete dir="${doc.dir}" />[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[41m[m
[32m+[m[41m[m
[32m+[m[41m[m
[32m+[m[32m    <!-- Create Jar file -->[m[41m[m
[32m+[m[32m    <target name="jar" depends="compile" description="Generates jar file.">[m[41m[m
[32m+[m[32m        <jar jarfile="${jarPath}" >[m[41m[m
[32m+[m[32m            <fileset dir="${build.classes}" excludes="*.class" />[m[41m[m
[32m+[m[32m        </jar>[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[41m    [m
[32m+[m[32m    <!-- Clean, compile, and create jar -->[m[41m[m
[32m+[m[32m    <target name="all" depends="clean,jar" description="Cleans, compile, then builds jar file." />[m[41m[m
[32m+[m[41m[m
[32m+[m[41m[m
[32m+[m[41m[m
[32m+[m[32m    <!-- Install Jar file -->[m[41m[m
[32m+[m[32m    <target name="install" depends="jar,installCheck" description="Installs jar file.">[m[41m[m
[32m+[m[32m        <antcall target="error"/>[m[41m[m
[32m+[m[32m        <antcall target="installInPrefix"/>[m[41m[m
[32m+[m[32m        <antcall target="installInCODA"/>[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[41m[m
[32m+[m[32m    <!-- Install in prefix -->[m[41m[m
[32m+[m[32m    <target name="installInPrefix" if="prefixDefined">[m[41m[m
[32m+[m[32m        <echo>Install ${jarName} into ${prefix}</echo>[m[41m[m
[32m+[m[32m        <delete>[m[41m[m
[32m+[m[32m            <fileset dir="${prefix}/jar" includes="${allJarNames}" />[m[41m[m
[32m+[m[32m        </delete>[m[41m[m
[32m+[m[32m        <copy file="${jarPath}" todir="${prefix}/jar"/>[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[41m[m
[32m+[m[32m    <!-- Install in $CODA -->[m[41m[m
[32m+[m[32m    <target name="installInCODA" unless="prefixDefined" if="codaDefined">[m[41m[m
[32m+[m[32m        <echo>Install ${jarName} into ${env.CODA}/common/jar</echo>[m[41m[m
[32m+[m[32m        <delete>[m[41m[m
[32m+[m[32m            <fileset dir="${env.CODA}/common/jar" includes="${allJarNames}" />[m[41m[m
[32m+[m[32m        </delete>[m[41m[m
[32m+[m[32m        <copy file="${jarPath}" todir="${env.CODA}/common/jar"/>[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[41m[m
[32m+[m[32m    <!-- No installation directory defined -->[m[41m[m
[32m+[m[32m    <target name="error" if="noInstallDir">[m[41m[m
[32m+[m[32m        <fail message="CODA env var not defined and -Dprefix not used, jar NOT installed" />[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[41m[m
[32m+[m[41m[m
[32m+[m[41m[m
[32m+[m[32m    <!-- Uninstall Jar file -->[m[41m[m
[32m+[m[32m    <target name="uninstall" depends="installCheck" description="Uninstalls jar file.">[m[41m[m
[32m+[m[32m        <antcall target="error2"/>[m[41m[m
[32m+[m[32m        <antcall target="uninstallFromPrefix"/>[m[41m[m
[32m+[m[32m        <antcall target="uninstallFromCODA"/>[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[41m[m
[32m+[m[32m    <!-- Uninstall from prefix -->[m[41m[m
[32m+[m[32m    <target name="uninstallFromPrefix" if="prefixDefined">[m[41m[m
[32m+[m[32m        <echo>Remove ${jarName} from ${prefix}</echo>[m[41m[m
[32m+[m[32m        <delete file="${prefix}/jar/${jarName}"/>[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[41m[m
[32m+[m[32m    <!-- Uninstall from $CODA -->[m[41m[m
[32m+[m[32m    <target name="uninstallFromCODA" unless="prefixDefined" if="codaDefined">[m[41m[m
[32m+[m[32m        <echo>Remove ${jarName} from ${env.CODA}/common/jar</echo>[m[41m[m
[32m+[m[32m        <delete file="${env.CODA}/common/jar/${jarName}"/>[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[41m[m
[32m+[m[32m    <!-- No installation directory defined to uninstall from -->[m[41m[m
[32m+[m[32m    <target name="error2" if="noInstallDir">[m[41m[m
[32m+[m[32m        <fail message="Installation directory not defined, jar NOT installed" />[m[41m[m
[32m+[m[32m    </target>[m[41m[m
[32m+[m[41m[m
[32m+[m[41m[m
[32m+[m[32m</project>[m[41m[m
[1mdiff --git a/src/examples/java/com/lmax/disruptor/examples/DynamicallyAddHandler.java b/src/examples/java/com/lmax/disruptor/examples/DynamicallyAddHandler.java[m
[1mdeleted file mode 100644[m
[1mindex 81cf548..0000000[m
[1m--- a/src/examples/java/com/lmax/disruptor/examples/DynamicallyAddHandler.java[m
[1m+++ /dev/null[m
[36m@@ -1,78 +0,0 @@[m
[31m-package com.lmax.disruptor.examples;[m
[31m-[m
[31m-import com.lmax.disruptor.BatchEventProcessor;[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.LifecycleAware;[m
[31m-import com.lmax.disruptor.RingBuffer;[m
[31m-import com.lmax.disruptor.dsl.Disruptor;[m
[31m-import com.lmax.disruptor.examples.support.StubEvent;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-[m
[31m-public class DynamicallyAddHandler[m
[31m-{[m
[31m-    private static class DynamicHandler implements EventHandler<StubEvent>, LifecycleAware[m
[31m-    {[m
[31m-        private final CountDownLatch shutdownLatch = new CountDownLatch(1);[m
[31m-[m
[31m-        @Override[m
[31m-        public void onEvent(final StubEvent event, final long sequence, final boolean endOfBatch)[m
[31m-        {[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onStart()[m
[31m-        {[m
[31m-[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onShutdown()[m
[31m-        {[m
[31m-            shutdownLatch.countDown();[m
[31m-        }[m
[31m-[m
[31m-        public void awaitShutdown() throws InterruptedException[m
[31m-        {[m
[31m-            shutdownLatch.await();[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws InterruptedException[m
[31m-    {[m
[31m-        ExecutorService executor = Executors.newCachedThreadPool(DaemonThreadFactory.INSTANCE);[m
[31m-[m
[31m-        // Build a disruptor and start it.[m
[31m-        Disruptor<StubEvent> disruptor = new Disruptor<>([m
[31m-                StubEvent.EVENT_FACTORY, 1024, DaemonThreadFactory.INSTANCE);[m
[31m-        RingBuffer<StubEvent> ringBuffer = disruptor.start();[m
[31m-[m
[31m-        // Construct 2 batch event processors.[m
[31m-        DynamicHandler handler1 = new DynamicHandler();[m
[31m-        BatchEventProcessor<StubEvent> processor1 =[m
[31m-                new BatchEventProcessor<>(ringBuffer, ringBuffer.newBarrier(), handler1);[m
[31m-[m
[31m-        DynamicHandler handler2 = new DynamicHandler();[m
[31m-        BatchEventProcessor<StubEvent> processor2 =[m
[31m-                new BatchEventProcessor<>(ringBuffer, ringBuffer.newBarrier(processor1.getSequence()), handler2);[m
[31m-[m
[31m-        // Dynamically add both sequences to the ring buffer[m
[31m-        ringBuffer.addGatingSequences(processor1.getSequence(), processor2.getSequence());[m
[31m-[m
[31m-        // Start the new batch processors.[m
[31m-        executor.execute(processor1);[m
[31m-        executor.execute(processor2);[m
[31m-[m
[31m-        // Remove a processor.[m
[31m-[m
[31m-        // Stop the processor[m
[31m-        processor2.halt();[m
[31m-        // Wait for shutdown the complete[m
[31m-        handler2.awaitShutdown();[m
[31m-        // Remove the gating sequence from the ring buffer[m
[31m-        ringBuffer.removeGatingSequence(processor2.getSequence());[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/examples/java/com/lmax/disruptor/examples/EarlyReleaseHandler.java b/src/examples/java/com/lmax/disruptor/examples/EarlyReleaseHandler.java[m
[1mdeleted file mode 100644[m
[1mindex 63c57ea..0000000[m
[1m--- a/src/examples/java/com/lmax/disruptor/examples/EarlyReleaseHandler.java[m
[1m+++ /dev/null[m
[36m@@ -1,46 +0,0 @@[m
[31m-package com.lmax.disruptor.examples;[m
[31m-[m
[31m-import com.lmax.disruptor.Sequence;[m
[31m-import com.lmax.disruptor.SequenceReportingEventHandler;[m
[31m-import com.lmax.disruptor.examples.support.LongEvent;[m
[31m-[m
[31m-public class EarlyReleaseHandler implements SequenceReportingEventHandler<LongEvent>[m
[31m-{[m
[31m-    private Sequence sequenceCallback;[m
[31m-    private int batchRemaining = 20;[m
[31m-[m
[31m-    @Override[m
[31m-    public void setSequenceCallback(Sequence sequenceCallback)[m
[31m-    {[m
[31m-        this.sequenceCallback = sequenceCallback;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void onEvent(LongEvent event, long sequence, boolean endOfBatch)[m
[31m-    {[m
[31m-        processEvent(event);[m
[31m-[m
[31m-        boolean logicalChunkOfWorkComplete = isLogicalChunkOfWorkComplete();[m
[31m-        if (logicalChunkOfWorkComplete)[m
[31m-        {[m
[31m-            sequenceCallback.set(sequence);[m
[31m-        }[m
[31m-[m
[31m-        batchRemaining = logicalChunkOfWorkComplete || endOfBatch ? 20 : batchRemaining;[m
[31m-    }[m
[31m-[m
[31m-    private boolean isLogicalChunkOfWorkComplete()[m
[31m-    {[m
[31m-        // Ret true or false based on whatever criteria is required for the smaller[m
[31m-        // chunk.  If this is doing I/O, it may be after flushing/syncing to disk[m
[31m-        // or at the end of DB batch+commit.[m
[31m-        // Or it could simply be working off a smaller batch size.[m
[31m-[m
[31m-        return --batchRemaining == -1;[m
[31m-    }[m
[31m-[m
[31m-    private void processEvent(LongEvent event)[m
[31m-    {[m
[31m-        // Do processing[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/examples/java/com/lmax/disruptor/examples/HandleExceptionOnTranslate.java b/src/examples/java/com/lmax/disruptor/examples/HandleExceptionOnTranslate.java[m
[1mdeleted file mode 100644[m
[1mindex b5133d6..0000000[m
[1m--- a/src/examples/java/com/lmax/disruptor/examples/HandleExceptionOnTranslate.java[m
[1m+++ /dev/null[m
[36m@@ -1,64 +0,0 @@[m
[31m-package com.lmax.disruptor.examples;[m
[31m-[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.EventTranslator;[m
[31m-import com.lmax.disruptor.dsl.Disruptor;[m
[31m-import com.lmax.disruptor.examples.support.LongEvent;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-public class HandleExceptionOnTranslate[m
[31m-{[m
[31m-    private static final int NO_VALUE_SPECIFIED = -1;[m
[31m-[m
[31m-    private static class MyHandler implements EventHandler<LongEvent>[m
[31m-    {[m
[31m-[m
[31m-        @Override[m
[31m-        public void onEvent(LongEvent event, long sequence, boolean endOfBatch)[m
[31m-        {[m
[31m-            if (event.get() == NO_VALUE_SPECIFIED)[m
[31m-            {[m
[31m-                System.out.printf("Discarded%n");[m
[31m-            }[m
[31m-            else[m
[31m-            {[m
[31m-                System.out.printf("Processed: %s%n", event.get() == sequence);[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws InterruptedException[m
[31m-    {[m
[31m-        Disruptor<LongEvent> disruptor = new Disruptor<>(LongEvent.FACTORY, 1024, DaemonThreadFactory.INSTANCE);[m
[31m-[m
[31m-        disruptor.handleEventsWith(new MyHandler());[m
[31m-[m
[31m-        disruptor.start();[m
[31m-[m
[31m-        EventTranslator<LongEvent> t = (event, sequence) ->[m
[31m-        {[m
[31m-            event.set(NO_VALUE_SPECIFIED);[m
[31m-[m
[31m-            if (sequence % 3 == 0)[m
[31m-            {[m
[31m-                throw new RuntimeException("Skipping");[m
[31m-            }[m
[31m-[m
[31m-            event.set(sequence);[m
[31m-        };[m
[31m-[m
[31m-        for (int i = 0; i < 10; i++)[m
[31m-        {[m
[31m-            try[m
[31m-            {[m
[31m-                disruptor.publishEvent(t);[m
[31m-            }[m
[31m-            catch (RuntimeException e)[m
[31m-            {[m
[31m-                // Skipping[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        Thread.sleep(5000);[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/examples/java/com/lmax/disruptor/examples/KeyedBatching.java b/src/examples/java/com/lmax/disruptor/examples/KeyedBatching.java[m
[1mdeleted file mode 100644[m
[1mindex ab8c476..0000000[m
[1m--- a/src/examples/java/com/lmax/disruptor/examples/KeyedBatching.java[m
[1m+++ /dev/null[m
[36m@@ -1,42 +0,0 @@[m
[31m-package com.lmax.disruptor.examples;[m
[31m-[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-[m
[31m-import java.util.ArrayList;[m
[31m-import java.util.List;[m
[31m-[m
[31m-public class KeyedBatching implements EventHandler<KeyedBatching.KeyedEvent>[m
[31m-{[m
[31m-    private static final int MAX_BATCH_SIZE = 100;[m
[31m-    private final List<Object> batch = new ArrayList<>();[m
[31m-    private long key = 0;[m
[31m-[m
[31m-    @Override[m
[31m-    public void onEvent(KeyedEvent event, long sequence, boolean endOfBatch)[m
[31m-    {[m
[31m-        if (!batch.isEmpty() && event.key != key)[m
[31m-        {[m
[31m-            processBatch(batch);[m
[31m-        }[m
[31m-[m
[31m-        batch.add(event.data);[m
[31m-        key = event.key;[m
[31m-[m
[31m-        if (endOfBatch || batch.size() >= MAX_BATCH_SIZE)[m
[31m-        {[m
[31m-            processBatch(batch);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private void processBatch(List<Object> batch)[m
[31m-    {[m
[31m-        // do work.[m
[31m-        batch.clear();[m
[31m-    }[m
[31m-[m
[31m-    public static class KeyedEvent[m
[31m-    {[m
[31m-        long key;[m
[31m-        Object data;[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/examples/java/com/lmax/disruptor/examples/MultiProducerWithTranslator.java b/src/examples/java/com/lmax/disruptor/examples/MultiProducerWithTranslator.java[m
[1mdeleted file mode 100644[m
[1mindex b71463b..0000000[m
[1m--- a/src/examples/java/com/lmax/disruptor/examples/MultiProducerWithTranslator.java[m
[1m+++ /dev/null[m
[36m@@ -1,94 +0,0 @@[m
[31m-package com.lmax.disruptor.examples;[m
[31m-[m
[31m-import com.lmax.disruptor.BlockingWaitStrategy;[m
[31m-import com.lmax.disruptor.EventFactory;[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.EventTranslatorThreeArg;[m
[31m-import com.lmax.disruptor.RingBuffer;[m
[31m-import com.lmax.disruptor.dsl.Disruptor;[m
[31m-import com.lmax.disruptor.dsl.ProducerType;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-public class MultiProducerWithTranslator[m
[31m-{[m
[31m-    private static class IMessage[m
[31m-    {[m
[31m-    }[m
[31m-[m
[31m-    private static class ITransportable[m
[31m-    {[m
[31m-    }[m
[31m-[m
[31m-    private static class ObjectBox[m
[31m-    {[m
[31m-        IMessage message;[m
[31m-        ITransportable transportable;[m
[31m-        String string;[m
[31m-[m
[31m-        private static final EventFactory<ObjectBox> FACTORY = ObjectBox::new;[m
[31m-[m
[31m-        public void setMessage(IMessage arg0)[m
[31m-        {[m
[31m-            message = arg0;[m
[31m-        }[m
[31m-[m
[31m-        public void setTransportable(ITransportable arg1)[m
[31m-        {[m
[31m-            transportable = arg1;[m
[31m-        }[m
[31m-[m
[31m-        public void setStreamName(String arg2)[m
[31m-        {[m
[31m-            string = arg2;[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static class Publisher implements EventTranslatorThreeArg<ObjectBox, IMessage, ITransportable, String>[m
[31m-    {[m
[31m-        @Override[m
[31m-        public void translateTo(ObjectBox event, long sequence, IMessage arg0, ITransportable arg1, String arg2)[m
[31m-        {[m
[31m-            event.setMessage(arg0);[m
[31m-            event.setTransportable(arg1);[m
[31m-            event.setStreamName(arg2);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static class Consumer implements EventHandler<ObjectBox>[m
[31m-    {[m
[31m-        @Override[m
[31m-        public void onEvent(ObjectBox event, long sequence, boolean endOfBatch)[m
[31m-        {[m
[31m-[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    static final int RING_SIZE = 1024;[m
[31m-[m
[31m-    public static void main(String[] args) throws InterruptedException[m
[31m-    {[m
[31m-        Disruptor<ObjectBox> disruptor = new Disruptor<>([m
[31m-                ObjectBox.FACTORY, RING_SIZE, DaemonThreadFactory.INSTANCE, ProducerType.MULTI,[m
[31m-                new BlockingWaitStrategy());[m
[31m-        disruptor.handleEventsWith(new Consumer()).then(new Consumer());[m
[31m-        final RingBuffer<ObjectBox> ringBuffer = disruptor.getRingBuffer();[m
[31m-        Publisher p = new Publisher();[m
[31m-        IMessage message = new IMessage();[m
[31m-        ITransportable transportable = new ITransportable();[m
[31m-        String streamName = "com.lmax.wibble";[m
[31m-        System.out.println("publishing " + RING_SIZE + " messages");[m
[31m-        for (int i = 0; i < RING_SIZE; i++)[m
[31m-        {[m
[31m-            ringBuffer.publishEvent(p, message, transportable, streamName);[m
[31m-            Thread.sleep(10);[m
[31m-        }[m
[31m-        System.out.println("start disruptor");[m
[31m-        disruptor.start();[m
[31m-        System.out.println("continue publishing");[m
[31m-        while (true)[m
[31m-        {[m
[31m-            ringBuffer.publishEvent(p, message, transportable, streamName);[m
[31m-            Thread.sleep(10);[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/examples/java/com/lmax/disruptor/examples/NamedEventHandler.java b/src/examples/java/com/lmax/disruptor/examples/NamedEventHandler.java[m
[1mdeleted file mode 100644[m
[1mindex 09ee9ac..0000000[m
[1m--- a/src/examples/java/com/lmax/disruptor/examples/NamedEventHandler.java[m
[1m+++ /dev/null[m
[36m@@ -1,34 +0,0 @@[m
[31m-package com.lmax.disruptor.examples;[m
[31m-[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.LifecycleAware;[m
[31m-[m
[31m-public class NamedEventHandler<T> implements EventHandler<T>, LifecycleAware[m
[31m-{[m
[31m-    private String oldName;[m
[31m-    private final String name;[m
[31m-[m
[31m-    public NamedEventHandler(final String name)[m
[31m-    {[m
[31m-        this.name = name;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void onEvent(final T event, final long sequence, final boolean endOfBatch)[m
[31m-    {[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void onStart()[m
[31m-    {[m
[31m-        final Thread currentThread = Thread.currentThread();[m
[31m-        oldName = currentThread.getName();[m
[31m-        currentThread.setName(name);[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void onShutdown()[m
[31m-    {[m
[31m-        Thread.currentThread().setName(oldName);[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/examples/java/com/lmax/disruptor/examples/Pipeliner.java b/src/examples/java/com/lmax/disruptor/examples/Pipeliner.java[m
[1mdeleted file mode 100644[m
[1mindex e0e5fac..0000000[m
[1m--- a/src/examples/java/com/lmax/disruptor/examples/Pipeliner.java[m
[1m+++ /dev/null[m
[36m@@ -1,93 +0,0 @@[m
[31m-package com.lmax.disruptor.examples;[m
[31m-[m
[31m-import com.lmax.disruptor.EventFactory;[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.RingBuffer;[m
[31m-import com.lmax.disruptor.dsl.Disruptor;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-public class Pipeliner[m
[31m-{[m
[31m-    public static void main(String[] args)[m
[31m-    {[m
[31m-        Disruptor<PipelinerEvent> disruptor = new Disruptor<>([m
[31m-                PipelinerEvent.FACTORY, 1024, DaemonThreadFactory.INSTANCE);[m
[31m-[m
[31m-        disruptor.handleEventsWith([m
[31m-            new ParallelHandler(0, 3),[m
[31m-            new ParallelHandler(1, 3),[m
[31m-            new ParallelHandler(2, 3)[m
[31m-        ).then(new JoiningHandler());[m
[31m-[m
[31m-        RingBuffer<PipelinerEvent> ringBuffer = disruptor.start();[m
[31m-[m
[31m-        for (int i = 0; i < 1000; i++)[m
[31m-        {[m
[31m-            long next = ringBuffer.next();[m
[31m-            try[m
[31m-            {[m
[31m-                PipelinerEvent pipelinerEvent = ringBuffer.get(next);[m
[31m-                pipelinerEvent.input = i;[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                ringBuffer.publish(next);[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class ParallelHandler implements EventHandler<PipelinerEvent>[m
[31m-    {[m
[31m-        private final int ordinal;[m
[31m-        private final int totalHandlers;[m
[31m-[m
[31m-        ParallelHandler(int ordinal, int totalHandlers)[m
[31m-        {[m
[31m-            this.ordinal = ordinal;[m
[31m-            this.totalHandlers = totalHandlers;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onEvent(PipelinerEvent event, long sequence, boolean endOfBatch)[m
[31m-        {[m
[31m-            if (sequence % totalHandlers == ordinal)[m
[31m-            {[m
[31m-                event.result = Long.toString(event.input);[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class JoiningHandler implements EventHandler<PipelinerEvent>[m
[31m-    {[m
[31m-        private long lastEvent = -1;[m
[31m-[m
[31m-        @Override[m
[31m-        public void onEvent(PipelinerEvent event, long sequence, boolean endOfBatch)[m
[31m-        {[m
[31m-            if (event.input != lastEvent + 1 || event.result == null)[m
[31m-            {[m
[31m-                System.out.println("Error: " + event);[m
[31m-            }[m
[31m-[m
[31m-            lastEvent = event.input;[m
[31m-            event.result = null;[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class PipelinerEvent[m
[31m-    {[m
[31m-        long input;[m
[31m-        Object result;[m
[31m-[m
[31m-        private static final EventFactory<PipelinerEvent> FACTORY = PipelinerEvent::new;[m
[31m-[m
[31m-        @Override[m
[31m-        public String toString()[m
[31m-        {[m
[31m-            return "PipelinerEvent{" +[m
[31m-                "input=" + input +[m
[31m-                ", result=" + result +[m
[31m-                '}';[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/examples/java/com/lmax/disruptor/examples/PullWithBatchedPoller.java b/src/examples/java/com/lmax/disruptor/examples/PullWithBatchedPoller.java[m
[1mdeleted file mode 100644[m
[1mindex 90663dc..0000000[m
[1m--- a/src/examples/java/com/lmax/disruptor/examples/PullWithBatchedPoller.java[m
[1m+++ /dev/null[m
[36m@@ -1,148 +0,0 @@[m
[31m-package com.lmax.disruptor.examples;[m
[31m-[m
[31m-import com.lmax.disruptor.EventFactory;[m
[31m-import com.lmax.disruptor.EventPoller;[m
[31m-import com.lmax.disruptor.RingBuffer;[m
[31m-[m
[31m-/**[m
[31m- * Alternative usage of EventPoller, here we wrap it around BatchedEventPoller[m
[31m- * to achieve Disruptor's batching. this speeds up the polling feature[m
[31m- */[m
[31m-public class PullWithBatchedPoller[m
[31m-{[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        int batchSize = 40;[m
[31m-        RingBuffer<BatchedPoller.DataEvent<Object>> ringBuffer =[m
[31m-                RingBuffer.createMultiProducer(BatchedPoller.DataEvent.factory(), 1024);[m
[31m-[m
[31m-        BatchedPoller<Object> poller = new BatchedPoller<>(ringBuffer, batchSize);[m
[31m-[m
[31m-        Object value = poller.poll();[m
[31m-[m
[31m-        // Value could be null if no events are available.[m
[31m-        if (null != value)[m
[31m-        {[m
[31m-            // Process value.[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    static class BatchedPoller<T>[m
[31m-    {[m
[31m-[m
[31m-        private final EventPoller<DataEvent<T>> poller;[m
[31m-        private final int maxBatchSize;[m
[31m-        private final BatchedData<T> polledData;[m
[31m-[m
[31m-        BatchedPoller(RingBuffer<DataEvent<T>> ringBuffer, int batchSize)[m
[31m-        {[m
[31m-            this.poller = ringBuffer.newPoller();[m
[31m-            ringBuffer.addGatingSequences(poller.getSequence());[m
[31m-[m
[31m-            if (batchSize < 1)[m
[31m-            {[m
[31m-                batchSize = 20;[m
[31m-            }[m
[31m-            this.maxBatchSize = batchSize;[m
[31m-            this.polledData = new BatchedData<>(this.maxBatchSize);[m
[31m-        }[m
[31m-[m
[31m-        public T poll() throws Exception[m
[31m-        {[m
[31m-            if (polledData.getMsgCount() > 0)[m
[31m-            {[m
[31m-                return polledData.pollMessage(); // we just fetch from our local[m
[31m-            }[m
[31m-[m
[31m-            loadNextValues(poller, polledData); // we try to load from the ring[m
[31m-            return polledData.getMsgCount() > 0 ? polledData.pollMessage() : null;[m
[31m-        }[m
[31m-[m
[31m-        private EventPoller.PollState loadNextValues(EventPoller<DataEvent<T>> poller, final BatchedData<T> batch)[m
[31m-                throws Exception[m
[31m-        {[m
[31m-            return poller.poll((event, sequence, endOfBatch) ->[m
[31m-            {[m
[31m-                T item = event.copyOfData();[m
[31m-                return item != null ? batch.addDataItem(item) : false;[m
[31m-            });[m
[31m-        }[m
[31m-[m
[31m-        public static class DataEvent<T>[m
[31m-        {[m
[31m-            T data;[m
[31m-[m
[31m-            public static <T> EventFactory<DataEvent<T>> factory()[m
[31m-            {[m
[31m-                return DataEvent::new;[m
[31m-            }[m
[31m-[m
[31m-            public T copyOfData()[m
[31m-            {[m
[31m-                // Copy the data out here. In this case we have a single reference[m
[31m-                // object, so the pass by[m
[31m-                // reference is sufficient. But if we were reusing a byte array,[m
[31m-                // then we[m
[31m-                // would need to copy[m
[31m-                // the actual contents.[m
[31m-                return data;[m
[31m-            }[m
[31m-[m
[31m-            void set(T d)[m
[31m-            {[m
[31m-                data = d;[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        private static class BatchedData<T>[m
[31m-        {[m
[31m-            private int msgHighBound;[m
[31m-            private final int capacity;[m
[31m-            private final T[] data;[m
[31m-            private int cursor;[m
[31m-[m
[31m-            @SuppressWarnings("unchecked")[m
[31m-            BatchedData(int size)[m
[31m-            {[m
[31m-                this.capacity = size;[m
[31m-                data = (T[]) new Object[this.capacity];[m
[31m-            }[m
[31m-[m
[31m-            private void clearCount()[m
[31m-            {[m
[31m-                msgHighBound = 0;[m
[31m-                cursor = 0;[m
[31m-            }[m
[31m-[m
[31m-            public int getMsgCount()[m
[31m-            {[m
[31m-                return msgHighBound - cursor;[m
[31m-            }[m
[31m-[m
[31m-            public boolean addDataItem(T item) throws IndexOutOfBoundsException[m
[31m-            {[m
[31m-                if (msgHighBound >= capacity)[m
[31m-                {[m
[31m-                    throw new IndexOutOfBoundsException("Attempting to add item to full batch");[m
[31m-                }[m
[31m-[m
[31m-                data[msgHighBound++] = item;[m
[31m-                return msgHighBound < capacity;[m
[31m-            }[m
[31m-[m
[31m-            public T pollMessage()[m
[31m-            {[m
[31m-                T rtVal = null;[m
[31m-                if (cursor < msgHighBound)[m
[31m-                {[m
[31m-                    rtVal = data[cursor++];[m
[31m-                }[m
[31m-                if (cursor > 0 && cursor >= msgHighBound)[m
[31m-                {[m
[31m-                    clearCount();[m
[31m-                }[m
[31m-                return rtVal;[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/examples/java/com/lmax/disruptor/examples/PullWithPoller.java b/src/examples/java/com/lmax/disruptor/examples/PullWithPoller.java[m
[1mdeleted file mode 100644[m
[1mindex 24ec4ee..0000000[m
[1m--- a/src/examples/java/com/lmax/disruptor/examples/PullWithPoller.java[m
[1m+++ /dev/null[m
[36m@@ -1,57 +0,0 @@[m
[31m-package com.lmax.disruptor.examples;[m
[31m-[m
[31m-import com.lmax.disruptor.EventFactory;[m
[31m-import com.lmax.disruptor.EventPoller;[m
[31m-import com.lmax.disruptor.RingBuffer;[m
[31m-[m
[31m-public class PullWithPoller[m
[31m-{[m
[31m-    public static class DataEvent<T>[m
[31m-    {[m
[31m-        T data;[m
[31m-[m
[31m-        public static <T> EventFactory<DataEvent<T>> factory()[m
[31m-        {[m
[31m-            return DataEvent::new;[m
[31m-        }[m
[31m-[m
[31m-        public T copyOfData()[m
[31m-        {[m
[31m-            // Copy the data out here.  In this case we have a single reference object, so the pass by[m
[31m-            // reference is sufficient.  But if we were reusing a byte array, then we would need to copy[m
[31m-            // the actual contents.[m
[31m-            return data;[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        RingBuffer<DataEvent<Object>> ringBuffer = RingBuffer.createMultiProducer(DataEvent.factory(), 1024);[m
[31m-[m
[31m-        final EventPoller<DataEvent<Object>> poller = ringBuffer.newPoller();[m
[31m-[m
[31m-        Object value = getNextValue(poller);[m
[31m-[m
[31m-        // Value could be null if no events are available.[m
[31m-        if (null != value)[m
[31m-        {[m
[31m-            // Process value.[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static Object getNextValue(EventPoller<DataEvent<Object>> poller) throws Exception[m
[31m-    {[m
[31m-        final Object[] out = new Object[1];[m
[31m-[m
[31m-        poller.poll([m
[31m-                (event, sequence, endOfBatch) ->[m
[31m-                {[m
[31m-                    out[0] = event.copyOfData();[m
[31m-[m
[31m-                    // Return false so that only one event is processed at a time.[m
[31m-                    return false;[m
[31m-                });[m
[31m-[m
[31m-        return out[0];[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/examples/java/com/lmax/disruptor/examples/SequentialThreeConsumers.java b/src/examples/java/com/lmax/disruptor/examples/SequentialThreeConsumers.java[m
[1mdeleted file mode 100644[m
[1mindex d122f38..0000000[m
[1m--- a/src/examples/java/com/lmax/disruptor/examples/SequentialThreeConsumers.java[m
[1m+++ /dev/null[m
[36m@@ -1,26 +0,0 @@[m
[31m-package com.lmax.disruptor.examples;[m
[31m-[m
[31m-import com.lmax.disruptor.dsl.Disruptor;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-public class SequentialThreeConsumers[m
[31m-{[m
[31m-    private static class MyEvent[m
[31m-    {[m
[31m-        private Object a;[m
[31m-        private Object b;[m
[31m-        private Object c;[m
[31m-        private Object d;[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args)[m
[31m-    {[m
[31m-        Disruptor<MyEvent> disruptor = new Disruptor<>(MyEvent::new, 1024, DaemonThreadFactory.INSTANCE);[m
[31m-[m
[31m-        disruptor.handleEventsWith((event, sequence, endOfBatch) -> event.b = event.a)[m
[31m-                .then((event, sequence, endOfBatch) -> event.c = event.b)[m
[31m-                .then((event, sequence, endOfBatch) -> event.d = event.c);[m
[31m-[m
[31m-        disruptor.start();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/examples/java/com/lmax/disruptor/examples/ShutdownOnError.java b/src/examples/java/com/lmax/disruptor/examples/ShutdownOnError.java[m
[1mdeleted file mode 100644[m
[1mindex dce5b02..0000000[m
[1m--- a/src/examples/java/com/lmax/disruptor/examples/ShutdownOnError.java[m
[1m+++ /dev/null[m
[36m@@ -1,101 +0,0 @@[m
[31m-package com.lmax.disruptor.examples;[m
[31m-[m
[31m-import com.lmax.disruptor.EventFactory;[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.ExceptionHandler;[m
[31m-import com.lmax.disruptor.RingBuffer;[m
[31m-import com.lmax.disruptor.dsl.Disruptor;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-import java.util.concurrent.atomic.AtomicBoolean;[m
[31m-[m
[31m-public class ShutdownOnError[m
[31m-{[m
[31m-    private static class Event[m
[31m-    {[m
[31m-        public long value;[m
[31m-[m
[31m-        public static final EventFactory<Event> FACTORY = Event::new;[m
[31m-    }[m
[31m-[m
[31m-    private static class Handler implements EventHandler<Event>[m
[31m-    {[m
[31m-        @Override[m
[31m-        public void onEvent(Event event, long sequence, boolean endOfBatch)[m
[31m-        {[m
[31m-            // do work, if a failure occurs throw exception.[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static final class ErrorHandler implements ExceptionHandler<Event>[m
[31m-    {[m
[31m-        private final AtomicBoolean running;[m
[31m-[m
[31m-        private ErrorHandler(AtomicBoolean running)[m
[31m-        {[m
[31m-            this.running = running;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void handleEventException(Throwable ex, long sequence, Event event)[m
[31m-        {[m
[31m-            if (execeptionIsFatal(ex))[m
[31m-            {[m
[31m-                throw new RuntimeException(ex);[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        private boolean execeptionIsFatal(Throwable ex)[m
[31m-        {[m
[31m-            // Do what is appropriate here.[m
[31m-            return true;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void handleOnStartException(Throwable ex)[m
[31m-        {[m
[31m-[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void handleOnShutdownException(Throwable ex)[m
[31m-        {[m
[31m-[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args)[m
[31m-    {[m
[31m-        Disruptor<Event> disruptor = new Disruptor<>(Event.FACTORY, 1024, DaemonThreadFactory.INSTANCE);[m
[31m-[m
[31m-        AtomicBoolean running = new AtomicBoolean(true);[m
[31m-[m
[31m-        ErrorHandler errorHandler = new ErrorHandler(running);[m
[31m-[m
[31m-        final Handler handler = new Handler();[m
[31m-        disruptor.handleEventsWith(handler);[m
[31m-        disruptor.handleExceptionsFor(handler).with(errorHandler);[m
[31m-[m
[31m-        simplePublish(disruptor, running);[m
[31m-    }[m
[31m-[m
[31m-    private static void simplePublish(Disruptor<Event> disruptor, AtomicBoolean running)[m
[31m-    {[m
[31m-        while (running.get())[m
[31m-        {[m
[31m-            disruptor.publishEvent((event, sequence) -> event.value = sequence);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static void smarterPublish(Disruptor<Event> disruptor, AtomicBoolean running)[m
[31m-    {[m
[31m-        final RingBuffer<Event> ringBuffer = disruptor.getRingBuffer();[m
[31m-[m
[31m-        boolean publishOk;[m
[31m-        do[m
[31m-        {[m
[31m-            publishOk = ringBuffer.tryPublishEvent((event, sequence) -> event.value = sequence);[m
[31m-        }[m
[31m-        while (publishOk && running.get());[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/examples/java/com/lmax/disruptor/examples/ThreeToOneDisruptor.java b/src/examples/java/com/lmax/disruptor/examples/ThreeToOneDisruptor.java[m
[1mdeleted file mode 100644[m
[1mindex 11ce5e8..0000000[m
[1m--- a/src/examples/java/com/lmax/disruptor/examples/ThreeToOneDisruptor.java[m
[1m+++ /dev/null[m
[36m@@ -1,75 +0,0 @@[m
[31m-package com.lmax.disruptor.examples;[m
[31m-[m
[31m-[m
[31m-import com.lmax.disruptor.EventFactory;[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.dsl.Disruptor;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-public class ThreeToOneDisruptor[m
[31m-{[m
[31m-    public static class DataEvent[m
[31m-    {[m
[31m-        Object input;[m
[31m-        Object[] output;[m
[31m-[m
[31m-        public DataEvent(int size)[m
[31m-        {[m
[31m-            output = new Object[size];[m
[31m-        }[m
[31m-[m
[31m-        public static final EventFactory<DataEvent> FACTORY = () -> new DataEvent(3);[m
[31m-    }[m
[31m-[m
[31m-    public static class TransformingHandler implements EventHandler<DataEvent>[m
[31m-    {[m
[31m-        private final int outputIndex;[m
[31m-[m
[31m-        public TransformingHandler(int outputIndex)[m
[31m-        {[m
[31m-            this.outputIndex = outputIndex;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onEvent(DataEvent event, long sequence, boolean endOfBatch)[m
[31m-        {[m
[31m-            // Do Stuff.[m
[31m-            event.output[outputIndex] = doSomething(event.input);[m
[31m-        }[m
[31m-[m
[31m-        private Object doSomething(Object input)[m
[31m-        {[m
[31m-            // Do required transformation here....[m
[31m-            return input;[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static class CollatingHandler implements EventHandler<DataEvent>[m
[31m-    {[m
[31m-        @Override[m
[31m-        public void onEvent(DataEvent event, long sequence, boolean endOfBatch)[m
[31m-        {[m
[31m-            collate(event.output);[m
[31m-        }[m
[31m-[m
[31m-        private void collate(Object[] output)[m
[31m-        {[m
[31m-            // Do required collation here....[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args)[m
[31m-    {[m
[31m-        Disruptor<DataEvent> disruptor = new Disruptor<>([m
[31m-                DataEvent.FACTORY, 1024, DaemonThreadFactory.INSTANCE);[m
[31m-[m
[31m-        TransformingHandler handler1 = new TransformingHandler(0);[m
[31m-        TransformingHandler handler2 = new TransformingHandler(1);[m
[31m-        TransformingHandler handler3 = new TransformingHandler(2);[m
[31m-        CollatingHandler collator = new CollatingHandler();[m
[31m-[m
[31m-        disruptor.handleEventsWith(handler1, handler2, handler3).then(collator);[m
[31m-[m
[31m-        disruptor.start();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/examples/java/com/lmax/disruptor/examples/WaitForProcessing.java b/src/examples/java/com/lmax/disruptor/examples/WaitForProcessing.java[m
[1mdeleted file mode 100644[m
[1mindex f279794..0000000[m
[1m--- a/src/examples/java/com/lmax/disruptor/examples/WaitForProcessing.java[m
[1m+++ /dev/null[m
[36m@@ -1,62 +0,0 @@[m
[31m-package com.lmax.disruptor.examples;[m
[31m-[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.EventTranslator;[m
[31m-import com.lmax.disruptor.RingBuffer;[m
[31m-import com.lmax.disruptor.dsl.Disruptor;[m
[31m-import com.lmax.disruptor.examples.support.LongEvent;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-public class WaitForProcessing[m
[31m-{[m
[31m-    public static class Consumer implements EventHandler<LongEvent>[m
[31m-    {[m
[31m-        @Override[m
[31m-        public void onEvent(LongEvent event, long sequence, boolean endOfBatch)[m
[31m-        {[m
[31m-[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args)[m
[31m-    {[m
[31m-        final Disruptor<LongEvent> disruptor = new Disruptor<>([m
[31m-            LongEvent.FACTORY, 1024, DaemonThreadFactory.INSTANCE);[m
[31m-[m
[31m-        Consumer firstConsumer = new Consumer();[m
[31m-        Consumer lastConsumer = new Consumer();[m
[31m-        disruptor.handleEventsWith(firstConsumer).then(lastConsumer);[m
[31m-        final RingBuffer<LongEvent> ringBuffer = disruptor.getRingBuffer();[m
[31m-[m
[31m-        EventTranslator<LongEvent> translator = (event, sequence) -> event.set(sequence - 4);[m
[31m-[m
[31m-        ringBuffer.tryPublishEvent(translator);[m
[31m-[m
[31m-        waitForSpecificConsumer(disruptor, lastConsumer, ringBuffer);[m
[31m-        waitForRingBufferToBeIdle(ringBuffer);[m
[31m-    }[m
[31m-[m
[31m-    @SuppressWarnings("StatementWithEmptyBody")[m
[31m-    private static void waitForRingBufferToBeIdle(RingBuffer<LongEvent> ringBuffer)[m
[31m-    {[m
[31m-        while (ringBuffer.getBufferSize() - ringBuffer.remainingCapacity() != 0)[m
[31m-        {[m
[31m-            // Wait for priocessing...[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static void waitForSpecificConsumer([m
[31m-        Disruptor<LongEvent> disruptor,[m
[31m-        Consumer lastConsumer,[m
[31m-        RingBuffer<LongEvent> ringBuffer)[m
[31m-    {[m
[31m-        long lastPublishedValue;[m
[31m-        long sequenceValueFor;[m
[31m-        do[m
[31m-        {[m
[31m-            lastPublishedValue = ringBuffer.getCursor();[m
[31m-            sequenceValueFor = disruptor.getSequenceValueFor(lastConsumer);[m
[31m-        }[m
[31m-        while (sequenceValueFor < lastPublishedValue);[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/examples/java/com/lmax/disruptor/examples/WaitForShutdown.java b/src/examples/java/com/lmax/disruptor/examples/WaitForShutdown.java[m
[1mdeleted file mode 100644[m
[1mindex e9bbe9d..0000000[m
[1m--- a/src/examples/java/com/lmax/disruptor/examples/WaitForShutdown.java[m
[1m+++ /dev/null[m
[36m@@ -1,65 +0,0 @@[m
[31m-package com.lmax.disruptor.examples;[m
[31m-[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.LifecycleAware;[m
[31m-import com.lmax.disruptor.TimeoutException;[m
[31m-import com.lmax.disruptor.dsl.Disruptor;[m
[31m-import com.lmax.disruptor.examples.support.LongEvent;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.TimeUnit;[m
[31m-[m
[31m-public class WaitForShutdown[m
[31m-{[m
[31m-    private static volatile int value = 0;[m
[31m-[m
[31m-    private static class Handler implements EventHandler<LongEvent>, LifecycleAware[m
[31m-    {[m
[31m-        private final CountDownLatch latch;[m
[31m-[m
[31m-        Handler(CountDownLatch latch)[m
[31m-        {[m
[31m-            this.latch = latch;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onStart()[m
[31m-        {[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onShutdown()[m
[31m-        {[m
[31m-            latch.countDown();[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onEvent(LongEvent event, long sequence, boolean endOfBatch)[m
[31m-        {[m
[31m-            value = 1;[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws TimeoutException, InterruptedException[m
[31m-    {[m
[31m-        Disruptor<LongEvent> disruptor = new Disruptor<>([m
[31m-                LongEvent.FACTORY, 16, DaemonThreadFactory.INSTANCE[m
[31m-        );[m
[31m-[m
[31m-        CountDownLatch shutdownLatch = new CountDownLatch(2);[m
[31m-[m
[31m-        disruptor.handleEventsWith(new Handler(shutdownLatch)).then(new Handler(shutdownLatch));[m
[31m-        disruptor.start();[m
[31m-[m
[31m-        long next = disruptor.getRingBuffer().next();[m
[31m-        disruptor.getRingBuffer().get(next).set(next);[m
[31m-        disruptor.getRingBuffer().publish(next);[m
[31m-[m
[31m-        disruptor.shutdown(10, TimeUnit.SECONDS);[m
[31m-[m
[31m-        shutdownLatch.await();[m
[31m-[m
[31m-        System.out.println(value);[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/examples/java/com/lmax/disruptor/examples/support/LongEvent.java b/src/examples/java/com/lmax/disruptor/examples/support/LongEvent.java[m
[1mdeleted file mode 100644[m
[1mindex a609489..0000000[m
[1m--- a/src/examples/java/com/lmax/disruptor/examples/support/LongEvent.java[m
[1m+++ /dev/null[m
[36m@@ -1,20 +0,0 @@[m
[31m-package com.lmax.disruptor.examples.support;[m
[31m-[m
[31m-import com.lmax.disruptor.EventFactory;[m
[31m-[m
[31m-public class LongEvent[m
[31m-{[m
[31m-    public static final EventFactory<LongEvent> FACTORY = LongEvent::new;[m
[31m-[m
[31m-    private long value;[m
[31m-[m
[31m-    public void set(long value)[m
[31m-    {[m
[31m-        this.value = value;[m
[31m-    }[m
[31m-[m
[31m-    public long get()[m
[31m-    {[m
[31m-        return value;[m
[31m-    }[m
[31m-}[m
\ No newline at end of file[m
[1mdiff --git a/src/examples/java/com/lmax/disruptor/examples/support/StubEvent.java b/src/examples/java/com/lmax/disruptor/examples/support/StubEvent.java[m
[1mdeleted file mode 100644[m
[1mindex 5b7729c..0000000[m
[1m--- a/src/examples/java/com/lmax/disruptor/examples/support/StubEvent.java[m
[1m+++ /dev/null[m
[36m@@ -1,91 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.examples.support;[m
[31m-[m
[31m-import com.lmax.disruptor.EventFactory;[m
[31m-import com.lmax.disruptor.EventTranslatorTwoArg;[m
[31m-[m
[31m-public final class StubEvent[m
[31m-{[m
[31m-    private int value;[m
[31m-    private String testString;[m
[31m-    public static final EventTranslatorTwoArg<StubEvent, Integer, String> TRANSLATOR = (event, sequence, arg0, arg1) ->[m
[31m-            {[m
[31m-                event.setValue(arg0);[m
[31m-                event.setTestString(arg1);[m
[31m-            };[m
[31m-[m
[31m-    public StubEvent(int i)[m
[31m-    {[m
[31m-        this.value = i;[m
[31m-    }[m
[31m-[m
[31m-    public void copy(StubEvent event)[m
[31m-    {[m
[31m-        value = event.value;[m
[31m-    }[m
[31m-[m
[31m-    public int getValue()[m
[31m-    {[m
[31m-        return value;[m
[31m-    }[m
[31m-[m
[31m-    public void setValue(int value)[m
[31m-    {[m
[31m-        this.value = value;[m
[31m-    }[m
[31m-[m
[31m-    public String getTestString()[m
[31m-    {[m
[31m-        return testString;[m
[31m-    }[m
[31m-[m
[31m-    public void setTestString(final String testString)[m
[31m-    {[m
[31m-        this.testString = testString;[m
[31m-    }[m
[31m-[m
[31m-    public static final EventFactory<StubEvent> EVENT_FACTORY = () -> new StubEvent(-1);[m
[31m-[m
[31m-    @Override[m
[31m-    public int hashCode()[m
[31m-    {[m
[31m-        final int prime = 31;[m
[31m-        int result = 1;[m
[31m-        result = prime * result + value;[m
[31m-        return result;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public boolean equals(Object obj)[m
[31m-    {[m
[31m-        if (this == obj)[m
[31m-        {[m
[31m-            return true;[m
[31m-        }[m
[31m-        if (obj == null)[m
[31m-        {[m
[31m-            return false;[m
[31m-        }[m
[31m-        if (getClass() != obj.getClass())[m
[31m-        {[m
[31m-            return false;[m
[31m-        }[m
[31m-        StubEvent other = (StubEvent) obj;[m
[31m-[m
[31m-        return value == other.value;[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/main/java/com/lmax/disruptor/MultiProducerSequencer.java b/src/main/java/com/lmax/disruptor/MultiProducerSequencer.java[m
[1mindex 05363e9..69d0f95 100644[m
[1m--- a/src/main/java/com/lmax/disruptor/MultiProducerSequencer.java[m
[1m+++ b/src/main/java/com/lmax/disruptor/MultiProducerSequencer.java[m
[36m@@ -150,6 +150,54 @@[m [mpublic final class MultiProducerSequencer extends AbstractSequencer[m
     }[m
 [m
     /**[m
[32m+[m[32m     * @see Sequencer#nextIntr(int)[m
[32m+[m[32m     * @author Carl Timmer[m
[32m+[m[32m     */[m
[32m+[m[32m    @Override[m
[32m+[m[32m    public long nextIntr(int n) throws InterruptedException[m
[32m+[m[32m    {[m
[32m+[m[32m        if (n < 1 || n > bufferSize)[m
[32m+[m[32m        {[m
[32m+[m[32m            throw new IllegalArgumentException("n must be > 0 and < bufferSize");[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        long current;[m
[32m+[m[32m        long next;[m
[32m+[m
[32m+[m[32m        do[m
[32m+[m[32m        {[m
[32m+[m[32m            current = cursor.get();[m
[32m+[m[32m            next = current + n;[m
[32m+[m
[32m+[m[32m            long wrapPoint = next - bufferSize;[m
[32m+[m[32m            long cachedGatingSequence = gatingSequenceCache.get();[m
[32m+[m
[32m+[m[32m            if (wrapPoint > cachedGatingSequence || cachedGatingSequence > current)[m
[32m+[m[32m            {[m
[32m+[m[32m                long gatingSequence = Util.getMinimumSequence(gatingSequences, current);[m
[32m+[m
[32m+[m[32m                if (wrapPoint > gatingSequence)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (Thread.currentThread().isInterrupted()) {[m
[32m+[m[32m                        throw new InterruptedException();[m
[32m+[m[32m                    }[m
[32m+[m[32m                    LockSupport.parkNanos(1);[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                gatingSequenceCache.set(gatingSequence);[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (cursor.compareAndSet(current, next))[m
[32m+[m[32m            {[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        while (true);[m
[32m+[m
[32m+[m[32m        return next;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /**[m
      * @see Sequencer#tryNext()[m
      */[m
     @Override[m
[1mdiff --git a/src/main/java/com/lmax/disruptor/RingBuffer.java b/src/main/java/com/lmax/disruptor/RingBuffer.java[m
[1mindex fbd849d..6d4a2ff 100644[m
[1m--- a/src/main/java/com/lmax/disruptor/RingBuffer.java[m
[1m+++ b/src/main/java/com/lmax/disruptor/RingBuffer.java[m
[36m@@ -278,6 +278,23 @@[m [mpublic final class RingBuffer<E> extends RingBufferFields<E> implements Cursored[m
     }[m
 [m
     /**[m
[32m+[m[32m     * The same functionality as {@link RingBuffer#next(int)}.[m
[32m+[m[32m     * This method throws an InterruptedException if the thread[m
[32m+[m[32m     * which calls it is interrupted.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @author Carl Timmer[m
[32m+[m[32m     * @see Sequencer#next(int)[m
[32m+[m[32m     * @param n number of slots to claim[m
[32m+[m[32m     * @return sequence number of the highest slot claimed[m
[32m+[m[32m     * @throws InterruptedException if thread is interrupted[m
[32m+[m[32m     */[m
[32m+[m[32m    @Override[m
[32m+[m[32m    public long nextIntr(int n) throws InterruptedException[m
[32m+[m[32m    {[m
[32m+[m[32m        return sequencer.nextIntr(n);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /**[m
      * <p>Increment and return the next sequence for the ring buffer.  Calls of this[m
      * method should ensure that they always publish the sequence afterward.  E.g.</p>[m
      * <pre>[m
[1mdiff --git a/src/main/java/com/lmax/disruptor/Sequenced.java b/src/main/java/com/lmax/disruptor/Sequenced.java[m
[1mindex 3c8ba69..89e4770 100644[m
[1m--- a/src/main/java/com/lmax/disruptor/Sequenced.java[m
[1m+++ b/src/main/java/com/lmax/disruptor/Sequenced.java[m
[36m@@ -51,6 +51,18 @@[m [mpublic interface Sequenced[m
     long next(int n);[m
 [m
     /**[m
[32m+[m[32m     * Claim the next n events in sequence for publishing.[m
[32m+[m[32m     * This method is interruptible and will throw an[m
[32m+[m[32m     * InterruptedException if it is.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @author Carl Timmer[m
[32m+[m[32m     * @param n the number of sequences to claim[m
[32m+[m[32m     * @return the highest claimed sequence value[m
[32m+[m[32m     * @throws InterruptedException if interrupted[m
[32m+[m[32m     */[m
[32m+[m[32m    long nextIntr(int n) throws InterruptedException;[m
[32m+[m
[32m+[m[32m    /**[m
      * Attempt to claim the next event in sequence for publishing.  Will return the[m
      * number of the slot if there is at least <code>requiredCapacity</code> slots[m
      * available.[m
[1mdiff --git a/src/main/java/com/lmax/disruptor/SingleProducerSequencer.java b/src/main/java/com/lmax/disruptor/SingleProducerSequencer.java[m
[1mindex d5a7ae0..cc7202d 100644[m
[1m--- a/src/main/java/com/lmax/disruptor/SingleProducerSequencer.java[m
[1m+++ b/src/main/java/com/lmax/disruptor/SingleProducerSequencer.java[m
[36m@@ -146,6 +146,43 @@[m [mpublic final class SingleProducerSequencer extends SingleProducerSequencerFields[m
     }[m
 [m
     /**[m
[32m+[m[32m     * @see Sequencer#nextIntr(int)[m
[32m+[m[32m     * @author Carl Timmer[m
[32m+[m[32m     */[m
[32m+[m[32m    @Override[m
[32m+[m[32m    public long nextIntr(int n) throws InterruptedException[m
[32m+[m[32m    {[m
[32m+[m[32m        if (n < 1 || n > bufferSize)[m
[32m+[m[32m        {[m
[32m+[m[32m            throw new IllegalArgumentException("n must be > 0 and < bufferSize");[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        long nextValue = this.nextValue;[m
[32m+[m
[32m+[m[32m        long nextSequence = nextValue + n;[m
[32m+[m[32m        long wrapPoint = nextSequence - bufferSize;[m
[32m+[m[32m        long cachedGatingSequence = this.cachedValue;[m
[32m+[m
[32m+[m[32m        if (wrapPoint > cachedGatingSequence || cachedGatingSequence > nextValue)[m
[32m+[m[32m        {[m
[32m+[m[32m            long minSequence;[m
[32m+[m[32m            while (wrapPoint > (minSequence = Util.getMinimumSequence(gatingSequences, nextValue)))[m
[32m+[m[32m            {[m
[32m+[m[32m                if (Thread.currentThread().isInterrupted()) {[m
[32m+[m[32m                    throw new InterruptedException();[m
[32m+[m[32m                }[m
[32m+[m[32m                LockSupport.parkNanos(1L);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            this.cachedValue = minSequence;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        this.nextValue = nextSequence;[m
[32m+[m
[32m+[m[32m        return nextSequence;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /**[m
      * @see Sequencer#tryNext()[m
      */[m
     @Override[m
[1mdiff --git a/src/main/java/com/lmax/disruptor/SpinCountBackoffWaitStrategy.java b/src/main/java/com/lmax/disruptor/SpinCountBackoffWaitStrategy.java[m
[1mnew file mode 100644[m
[1mindex 0000000..1818f3c[m
[1m--- /dev/null[m
[1m+++ b/src/main/java/com/lmax/disruptor/SpinCountBackoffWaitStrategy.java[m
[36m@@ -0,0 +1,48 @@[m
[32m+[m[32mpackage com.lmax.disruptor;[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * <p>Spin first wait strategy for waiting {@link EventProcessor}s on a barrier.</p>[m
[32m+[m[32m *[m
[32m+[m[32m * <p>This strategy can be used when throughput and low-latency are not as important as CPU resource.[m
[32m+[m[32m * Spins for a given number of times then waits using the configured fallback WaitStrategy.</p>[m
[32m+[m[32m * @author timmer[m
[32m+[m[32m */[m
[32m+[m[32mpublic final class SpinCountBackoffWaitStrategy implements WaitStrategy[m
[32m+[m[32m{[m
[32m+[m[32m    private final int SPIN_TRIES;[m
[32m+[m[32m    private final WaitStrategy fallbackStrategy;[m
[32m+[m
[32m+[m[32m    public SpinCountBackoffWaitStrategy(int spinTries,[m
[32m+[m[32m                                        WaitStrategy fallbackStrategy)[m
[32m+[m[32m    {[m
[32m+[m[32m        this.SPIN_TRIES = spinTries;[m
[32m+[m[32m        this.fallbackStrategy = fallbackStrategy;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m
[32m+[m[32m    @Override[m
[32m+[m[32m    public long waitFor(long sequence, Sequence cursor, Sequence dependentSequence, SequenceBarrier barrier)[m
[32m+[m[32m        throws AlertException, InterruptedException, TimeoutException[m
[32m+[m[32m    {[m
[32m+[m[32m        long availableSequence;[m
[32m+[m[32m        int counter = SPIN_TRIES;[m
[32m+[m
[32m+[m[32m        do {[m
[32m+[m[32m            if ((availableSequence = dependentSequence.get()) >= sequence) {[m
[32m+[m[32m                return availableSequence;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            if (0 == --counter) {[m
[32m+[m[32m                return fallbackStrategy.waitFor(sequence, cursor, dependentSequence, barrier);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m        } while (true);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    @Override[m
[32m+[m[32m    public void signalAllWhenBlocking()[m
[32m+[m[32m    {[m
[32m+[m[32m        fallbackStrategy.signalAllWhenBlocking();[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/src/main/java/com/lmax/disruptor/YieldingWaitStrategy.java b/src/main/java/com/lmax/disruptor/YieldingWaitStrategy.java[m
[1mindex ba357ac..4097313 100644[m
[1m--- a/src/main/java/com/lmax/disruptor/YieldingWaitStrategy.java[m
[1m+++ b/src/main/java/com/lmax/disruptor/YieldingWaitStrategy.java[m
[36m@@ -49,13 +49,17 @@[m [mpublic final class YieldingWaitStrategy implements WaitStrategy[m
     }[m
 [m
     private int applyWaitMethod(final SequenceBarrier barrier, int counter)[m
[31m-        throws AlertException[m
[32m+[m[32m        throws AlertException, InterruptedException // InterruptedException added by Carl Timmer[m
     {[m
         barrier.checkAlert();[m
 [m
         if (0 == counter)[m
         {[m
             Thread.yield();[m
[32m+[m[32m            // Next 3 lines added by Carl Timmer to make it interruptible[m
[32m+[m[32m            if (Thread.interrupted()) {[m
[32m+[m[32m                throw new InterruptedException();[m
[32m+[m[32m            }[m
         }[m
         else[m
         {[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/AbstractPerfTestDisruptor.java b/src/perftest/java/com/lmax/disruptor/AbstractPerfTestDisruptor.java[m
[1mdeleted file mode 100644[m
[1mindex 8daf937..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/AbstractPerfTestDisruptor.java[m
[1m+++ /dev/null[m
[36m@@ -1,61 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-[m
[31m-public abstract class AbstractPerfTestDisruptor[m
[31m-{[m
[31m-    public static final int RUNS = 7;[m
[31m-[m
[31m-    protected void testImplementations()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        final int availableProcessors = Runtime.getRuntime().availableProcessors();[m
[31m-        if (getRequiredProcessorCount() > availableProcessors)[m
[31m-        {[m
[31m-            System.out.print("*** Warning ***: your system has insufficient processors to execute the test efficiently. ");[m
[31m-            System.out.println("Processors required = " + getRequiredProcessorCount() + " available = " + availableProcessors);[m
[31m-        }[m
[31m-[m
[31m-        PerfTestContext[] contexts = new PerfTestContext[RUNS];[m
[31m-[m
[31m-        System.out.println("Starting Disruptor tests");[m
[31m-        for (int i = 0; i < RUNS; i++)[m
[31m-        {[m
[31m-            System.gc();[m
[31m-            PerfTestContext context = runDisruptorPass();[m
[31m-            contexts[i] = context;[m
[31m-            System.out.format("Run %d, Disruptor=%,d ops/sec BatchPercent=%.2f%% AverageBatchSize=%,d\n",[m
[31m-                    i, context.getDisruptorOps(), context.getBatchPercent() * 100, (long)context.getAverageBatchSize());[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static void printResults(final String className, final PerfTestContext[] contexts, final long[] queueOps)[m
[31m-    {[m
[31m-        for (int i = 0; i < RUNS; i++)[m
[31m-        {[m
[31m-            PerfTestContext context = contexts[i];[m
[31m-            System.out.format("%s run %d: BlockingQueue=%,d Disruptor=%,d ops/sec BatchPercent=%,d AverageBatchSize=%,d\n",[m
[31m-                              className, Integer.valueOf(i), Long.valueOf(queueOps[i]), Long.valueOf(context.getDisruptorOps()),[m
[31m-                              Double.valueOf(context.getBatchPercent()), Double.valueOf(context.getAverageBatchSize()));[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    protected abstract int getRequiredProcessorCount();[m
[31m-[m
[31m-    protected abstract PerfTestContext runDisruptorPass() throws Exception;[m
[31m-}[m
[31m-[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/AbstractPerfTestQueue.java b/src/perftest/java/com/lmax/disruptor/AbstractPerfTestQueue.java[m
[1mdeleted file mode 100644[m
[1mindex 1d16661..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/AbstractPerfTestQueue.java[m
[1m+++ /dev/null[m
[36m@@ -1,59 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-[m
[31m-public abstract class AbstractPerfTestQueue[m
[31m-{[m
[31m-    public static final int RUNS = 7;[m
[31m-[m
[31m-    protected void testImplementations()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        final int availableProcessors = Runtime.getRuntime().availableProcessors();[m
[31m-        if (getRequiredProcessorCount() > availableProcessors)[m
[31m-        {[m
[31m-            System.out.print([m
[31m-                "*** Warning ***: your system has insufficient processors to execute the test efficiently. ");[m
[31m-            System.out.println([m
[31m-                "Processors required = " + getRequiredProcessorCount() + " available = " + availableProcessors);[m
[31m-        }[m
[31m-[m
[31m-        long[] queueOps = new long[RUNS];[m
[31m-[m
[31m-        System.out.println("Starting Queue tests");[m
[31m-        for (int i = 0; i < RUNS; i++)[m
[31m-        {[m
[31m-            System.gc();[m
[31m-            queueOps[i] = runQueuePass();[m
[31m-            System.out.format("Run %d, BlockingQueue=%,d ops/sec%n", i, Long.valueOf(queueOps[i]));[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static void printResults(final String className, final long[] disruptorOps, final long[] queueOps)[m
[31m-    {[m
[31m-        for (int i = 0; i < RUNS; i++)[m
[31m-        {[m
[31m-            System.out.format([m
[31m-                "%s run %d: BlockingQueue=%,d Disruptor=%,d ops/sec\n",[m
[31m-                className, Integer.valueOf(i), Long.valueOf(queueOps[i]), Long.valueOf(disruptorOps[i]));[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    protected abstract int getRequiredProcessorCount();[m
[31m-[m
[31m-    protected abstract long runQueuePass() throws Exception;[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/PerfTestContext.java b/src/perftest/java/com/lmax/disruptor/PerfTestContext.java[m
[1mdeleted file mode 100644[m
[1mindex 252f8e4..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/PerfTestContext.java[m
[1m+++ /dev/null[m
[36m@@ -1,45 +0,0 @@[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-public class PerfTestContext[m
[31m-{[m
[31m-    private long disruptorOps;[m
[31m-    private long batchesProcessedCount;[m
[31m-    private long iterations;[m
[31m-[m
[31m-    public PerfTestContext()[m
[31m-    {[m
[31m-    }[m
[31m-[m
[31m-    public long getDisruptorOps()[m
[31m-    {[m
[31m-        return disruptorOps;[m
[31m-    }[m
[31m-[m
[31m-    public void setDisruptorOps(long disruptorOps)[m
[31m-    {[m
[31m-        this.disruptorOps = disruptorOps;[m
[31m-    }[m
[31m-[m
[31m-    public long getBatchesProcessedCount()[m
[31m-    {[m
[31m-        return batchesProcessedCount;[m
[31m-    }[m
[31m-[m
[31m-    public double getBatchPercent()[m
[31m-    {[m
[31m-        if (batchesProcessedCount == 0) return 0;[m
[31m-        return 1 - (double)batchesProcessedCount / iterations;[m
[31m-    }[m
[31m-[m
[31m-    public double getAverageBatchSize()[m
[31m-    {[m
[31m-        if (batchesProcessedCount == 0) return -1;[m
[31m-        return (double)iterations / batchesProcessedCount;[m
[31m-    }[m
[31m-[m
[31m-    public void setBatchData(long batchesProcessedCount, long iterations)[m
[31m-    {[m
[31m-        this.batchesProcessedCount = batchesProcessedCount;[m
[31m-        this.iterations = iterations;[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/immutable/Constants.java b/src/perftest/java/com/lmax/disruptor/immutable/Constants.java[m
[1mdeleted file mode 100644[m
[1mindex 7c55258..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/immutable/Constants.java[m
[1m+++ /dev/null[m
[36m@@ -1,7 +0,0 @@[m
[31m-package com.lmax.disruptor.immutable;[m
[31m-[m
[31m-public class Constants[m
[31m-{[m
[31m-    public static final long ITERATIONS = 1000 * 1000 * 100L;[m
[31m-    public static final int SIZE = 1 << 20;[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/immutable/CustomPerformanceTest.java b/src/perftest/java/com/lmax/disruptor/immutable/CustomPerformanceTest.java[m
[1mdeleted file mode 100644[m
[1mindex d9a8f65..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/immutable/CustomPerformanceTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,59 +0,0 @@[m
[31m-package com.lmax.disruptor.immutable;[m
[31m-[m
[31m-import java.util.concurrent.locks.LockSupport;[m
[31m-[m
[31m-import com.lmax.disruptor.BatchEventProcessor;[m
[31m-import com.lmax.disruptor.SingleProducerSequencer;[m
[31m-import com.lmax.disruptor.YieldingWaitStrategy;[m
[31m-[m
[31m-public class CustomPerformanceTest[m
[31m-{[m
[31m-    private final CustomRingBuffer<SimpleEvent> ringBuffer;[m
[31m-[m
[31m-    public CustomPerformanceTest()[m
[31m-    {[m
[31m-        ringBuffer =[m
[31m-                new CustomRingBuffer<>(new SingleProducerSequencer(Constants.SIZE, new YieldingWaitStrategy()));[m
[31m-    }[m
[31m-[m
[31m-    public void run()[m
[31m-    {[m
[31m-        try[m
[31m-        {[m
[31m-            doRun();[m
[31m-        }[m
[31m-        catch (InterruptedException e)[m
[31m-        {[m
[31m-            e.printStackTrace();[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private void doRun() throws InterruptedException[m
[31m-    {[m
[31m-        BatchEventProcessor<?> batchEventProcessor = ringBuffer.createHandler(new SimpleEventHandler());[m
[31m-[m
[31m-        Thread t = new Thread(batchEventProcessor);[m
[31m-        t.start();[m
[31m-[m
[31m-        long iterations = Constants.ITERATIONS;[m
[31m-        for (long l = 0; l < iterations; l++)[m
[31m-        {[m
[31m-            SimpleEvent e = new SimpleEvent(l, l, l, l);[m
[31m-            ringBuffer.put(e);[m
[31m-        }[m
[31m-[m
[31m-        while (batchEventProcessor.getSequence().get() != iterations - 1)[m
[31m-        {[m
[31m-            LockSupport.parkNanos(1);[m
[31m-        }[m
[31m-[m
[31m-        batchEventProcessor.halt();[m
[31m-        t.join();[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args)[m
[31m-    {[m
[31m-        new CustomPerformanceTest().run();[m
[31m-    }[m
[31m-[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/immutable/CustomRingBuffer.java b/src/perftest/java/com/lmax/disruptor/immutable/CustomRingBuffer.java[m
[1mdeleted file mode 100644[m
[1mindex ae58849..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/immutable/CustomRingBuffer.java[m
[1m+++ /dev/null[m
[36m@@ -1,99 +0,0 @@[m
[31m-package com.lmax.disruptor.immutable;[m
[31m-[m
[31m-import com.lmax.disruptor.BatchEventProcessor;[m
[31m-import com.lmax.disruptor.DataProvider;[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.LifecycleAware;[m
[31m-import com.lmax.disruptor.Sequencer;[m
[31m-[m
[31m-public class CustomRingBuffer<T> implements DataProvider<EventAccessor<T>>, EventAccessor<T>[m
[31m-{[m
[31m-    private static final class AccessorEventHandler<T> implements EventHandler<EventAccessor<T>>, LifecycleAware[m
[31m-    {[m
[31m-        private final EventHandler<T> handler;[m
[31m-        private final LifecycleAware lifecycle;[m
[31m-[m
[31m-        private AccessorEventHandler(EventHandler<T> handler)[m
[31m-        {[m
[31m-            this.handler = handler;[m
[31m-            lifecycle = handler instanceof LifecycleAware ? (LifecycleAware) handler : null;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onEvent(EventAccessor<T> accessor, long sequence, boolean endOfBatch) throws Exception[m
[31m-        {[m
[31m-            this.handler.onEvent(accessor.take(sequence), sequence, endOfBatch);[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onShutdown()[m
[31m-        {[m
[31m-            if (null != lifecycle)[m
[31m-            {[m
[31m-                lifecycle.onShutdown();[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onStart()[m
[31m-        {[m
[31m-            if (null != lifecycle)[m
[31m-            {[m
[31m-                lifecycle.onStart();[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private final Sequencer sequencer;[m
[31m-    private final Object[] buffer;[m
[31m-    private final int mask;[m
[31m-[m
[31m-    public CustomRingBuffer(Sequencer sequencer)[m
[31m-    {[m
[31m-        this.sequencer = sequencer;[m
[31m-        buffer = new Object[sequencer.getBufferSize()];[m
[31m-        mask = sequencer.getBufferSize() - 1;[m
[31m-    }[m
[31m-[m
[31m-    private int index(long sequence)[m
[31m-    {[m
[31m-        return (int) sequence & mask;[m
[31m-    }[m
[31m-[m
[31m-    public void put(T e)[m
[31m-    {[m
[31m-        long next = sequencer.next();[m
[31m-        buffer[index(next)] = e;[m
[31m-        sequencer.publish(next);[m
[31m-    }[m
[31m-[m
[31m-    @SuppressWarnings("unchecked")[m
[31m-    @Override[m
[31m-    public T take(long sequence)[m
[31m-    {[m
[31m-        int index = index(sequence);[m
[31m-[m
[31m-        T t = (T) buffer[index];[m
[31m-        buffer[index] = null;[m
[31m-[m
[31m-        return t;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public EventAccessor<T> get(long sequence)[m
[31m-    {[m
[31m-        return this;[m
[31m-    }[m
[31m-[m
[31m-    public BatchEventProcessor<EventAccessor<T>> createHandler(final EventHandler<T> handler)[m
[31m-    {[m
[31m-        BatchEventProcessor<EventAccessor<T>> processor =[m
[31m-                new BatchEventProcessor<>([m
[31m-                        this,[m
[31m-                        sequencer.newBarrier(),[m
[31m-                        new AccessorEventHandler<>(handler));[m
[31m-        sequencer.addGatingSequences(processor.getSequence());[m
[31m-[m
[31m-        return processor;[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/immutable/EventAccessor.java b/src/perftest/java/com/lmax/disruptor/immutable/EventAccessor.java[m
[1mdeleted file mode 100644[m
[1mindex 2f0fe86..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/immutable/EventAccessor.java[m
[1m+++ /dev/null[m
[36m@@ -1,6 +0,0 @@[m
[31m-package com.lmax.disruptor.immutable;[m
[31m-[m
[31m-public interface EventAccessor<T>[m
[31m-{[m
[31m-    T take(long sequence);[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/immutable/EventHolder.java b/src/perftest/java/com/lmax/disruptor/immutable/EventHolder.java[m
[1mdeleted file mode 100644[m
[1mindex ef5f348..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/immutable/EventHolder.java[m
[1m+++ /dev/null[m
[36m@@ -1,11 +0,0 @@[m
[31m-package com.lmax.disruptor.immutable;[m
[31m-[m
[31m-import com.lmax.disruptor.EventFactory;[m
[31m-[m
[31m-public class EventHolder[m
[31m-{[m
[31m-[m
[31m-    public static final EventFactory<EventHolder> FACTORY = EventHolder::new;[m
[31m-[m
[31m-    public SimpleEvent event;[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/immutable/EventHolderHandler.java b/src/perftest/java/com/lmax/disruptor/immutable/EventHolderHandler.java[m
[1mdeleted file mode 100644[m
[1mindex f597187..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/immutable/EventHolderHandler.java[m
[1m+++ /dev/null[m
[36m@@ -1,20 +0,0 @@[m
[31m-package com.lmax.disruptor.immutable;[m
[31m-[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-[m
[31m-public class EventHolderHandler implements EventHandler<EventHolder>[m
[31m-{[m
[31m-    private final EventHandler<SimpleEvent> delegate;[m
[31m-[m
[31m-    public EventHolderHandler(EventHandler<SimpleEvent> delegate)[m
[31m-    {[m
[31m-        this.delegate = delegate;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void onEvent(EventHolder holder, long sequence, boolean endOfBatch) throws Exception[m
[31m-    {[m
[31m-        delegate.onEvent(holder.event, sequence, endOfBatch);[m
[31m-        holder.event = null;[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/immutable/SimpleEvent.java b/src/perftest/java/com/lmax/disruptor/immutable/SimpleEvent.java[m
[1mdeleted file mode 100644[m
[1mindex 2614c24..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/immutable/SimpleEvent.java[m
[1m+++ /dev/null[m
[36m@@ -1,28 +0,0 @@[m
[31m-package com.lmax.disruptor.immutable;[m
[31m-[m
[31m-public class SimpleEvent[m
[31m-{[m
[31m-    private final long id;[m
[31m-    private final long v1;[m
[31m-    private final long v2;[m
[31m-    private final long v3;[m
[31m-[m
[31m-    public SimpleEvent(long id, long v1, long v2, long v3)[m
[31m-    {[m
[31m-        this.id = id;[m
[31m-        this.v1 = v1;[m
[31m-        this.v2 = v2;[m
[31m-        this.v3 = v3;[m
[31m-    }[m
[31m-[m
[31m-    public long getCounter()[m
[31m-    {[m
[31m-        return v1;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public String toString()[m
[31m-    {[m
[31m-        return "SimpleEvent [id=" + id + ", v1=" + v1 + ", v2=" + v2 + ", v3=" + v3 + "]";[m
[31m-    }[m
[31m-}[m
\ No newline at end of file[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/immutable/SimpleEventHandler.java b/src/perftest/java/com/lmax/disruptor/immutable/SimpleEventHandler.java[m
[1mdeleted file mode 100644[m
[1mindex cc4560f..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/immutable/SimpleEventHandler.java[m
[1m+++ /dev/null[m
[36m@@ -1,14 +0,0 @@[m
[31m-package com.lmax.disruptor.immutable;[m
[31m-[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-[m
[31m-public class SimpleEventHandler implements EventHandler<SimpleEvent>[m
[31m-{[m
[31m-    public long counter;[m
[31m-[m
[31m-    @Override[m
[31m-    public void onEvent(SimpleEvent arg0, long arg1, boolean arg2) throws Exception[m
[31m-    {[m
[31m-        counter += arg0.getCounter();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/immutable/SimplePerformanceTest.java b/src/perftest/java/com/lmax/disruptor/immutable/SimplePerformanceTest.java[m
[1mdeleted file mode 100644[m
[1mindex 7ef91ec..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/immutable/SimplePerformanceTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,68 +0,0 @@[m
[31m-package com.lmax.disruptor.immutable;[m
[31m-[m
[31m-import java.util.concurrent.locks.LockSupport;[m
[31m-[m
[31m-import com.lmax.disruptor.BatchEventProcessor;[m
[31m-import com.lmax.disruptor.EventTranslatorOneArg;[m
[31m-import com.lmax.disruptor.RingBuffer;[m
[31m-import com.lmax.disruptor.YieldingWaitStrategy;[m
[31m-[m
[31m-public class SimplePerformanceTest[m
[31m-{[m
[31m-    private final RingBuffer<EventHolder> ringBuffer;[m
[31m-    private final EventHolderHandler eventHolderHandler;[m
[31m-[m
[31m-    public SimplePerformanceTest()[m
[31m-    {[m
[31m-        ringBuffer = RingBuffer.createSingleProducer(EventHolder.FACTORY, Constants.SIZE, new YieldingWaitStrategy());[m
[31m-        eventHolderHandler = new EventHolderHandler(new SimpleEventHandler());[m
[31m-    }[m
[31m-[m
[31m-    public void run()[m
[31m-    {[m
[31m-        try[m
[31m-        {[m
[31m-            doRun();[m
[31m-        }[m
[31m-        catch (InterruptedException e)[m
[31m-        {[m
[31m-            e.printStackTrace();[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private void doRun() throws InterruptedException[m
[31m-    {[m
[31m-        BatchEventProcessor<EventHolder> batchEventProcessor =[m
[31m-                new BatchEventProcessor<>([m
[31m-                        ringBuffer,[m
[31m-                        ringBuffer.newBarrier(),[m
[31m-                        eventHolderHandler);[m
[31m-        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());[m
[31m-[m
[31m-        Thread t = new Thread(batchEventProcessor);[m
[31m-        t.start();[m
[31m-[m
[31m-        long iterations = Constants.ITERATIONS;[m
[31m-        for (long l = 0; l < iterations; l++)[m
[31m-        {[m
[31m-            SimpleEvent e = new SimpleEvent(l, l, l, l);[m
[31m-            ringBuffer.publishEvent(TRANSLATOR, e);[m
[31m-        }[m
[31m-[m
[31m-        while (batchEventProcessor.getSequence().get() != iterations - 1)[m
[31m-        {[m
[31m-            LockSupport.parkNanos(1);[m
[31m-        }[m
[31m-[m
[31m-        batchEventProcessor.halt();[m
[31m-        t.join();[m
[31m-    }[m
[31m-[m
[31m-    private static final EventTranslatorOneArg<EventHolder, SimpleEvent> TRANSLATOR =[m
[31m-            (holder, arg1, event) -> holder.event = event;[m
[31m-[m
[31m-    public static void main(String[] args)[m
[31m-    {[m
[31m-        new SimplePerformanceTest().run();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/offheap/OneToOneOffHeapThroughputTest.java b/src/perftest/java/com/lmax/disruptor/offheap/OneToOneOffHeapThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex 7ff4fb4..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/offheap/OneToOneOffHeapThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,200 +0,0 @@[m
[31m-package com.lmax.disruptor.offheap;[m
[31m-[m
[31m-import com.lmax.disruptor.*;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-import com.lmax.disruptor.util.PaddedLong;[m
[31m-[m
[31m-import java.nio.ByteBuffer;[m
[31m-import java.nio.ByteOrder;[m
[31m-import java.util.Random;[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.Executor;[m
[31m-import java.util.concurrent.Executors;[m
[31m-import java.util.concurrent.locks.LockSupport;[m
[31m-[m
[31m-public class OneToOneOffHeapThroughputTest extends AbstractPerfTestDisruptor[m
[31m-{[m
[31m-    private static final int BLOCK_SIZE = 256;[m
[31m-    private static final int BUFFER_SIZE = 1024 * 1024;[m
[31m-    private static final long ITERATIONS = 1000 * 1000 * 10L;[m
[31m-[m
[31m-    private final Executor executor = Executors.newFixedThreadPool(1, DaemonThreadFactory.INSTANCE);[m
[31m-    private final WaitStrategy waitStrategy = new YieldingWaitStrategy();[m
[31m-    private final OffHeapRingBuffer buffer =[m
[31m-        new OffHeapRingBuffer(new SingleProducerSequencer(BUFFER_SIZE, waitStrategy), BLOCK_SIZE);[m
[31m-    private final ByteBufferHandler handler = new ByteBufferHandler();[m
[31m-    private final BatchEventProcessor<ByteBuffer> processor =[m
[31m-            new BatchEventProcessor<>(buffer, buffer.newBarrier(), handler);[m
[31m-[m
[31m-    {[m
[31m-        buffer.addGatingSequences(processor.getSequence());[m
[31m-    }[m
[31m-[m
[31m-    private final Random r = new Random(1);[m
[31m-    private final byte[] data = new byte[BLOCK_SIZE];[m
[31m-[m
[31m-    public OneToOneOffHeapThroughputTest()[m
[31m-    {[m
[31m-        r.nextBytes(data);[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 2;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected PerfTestContext runDisruptorPass() throws Exception[m
[31m-    {[m
[31m-        PerfTestContext perfTestContext = new PerfTestContext();[m
[31m-        byte[] data = this.data;[m
[31m-[m
[31m-        final CountDownLatch latch = new CountDownLatch(1);[m
[31m-        long expectedCount = processor.getSequence().get() + ITERATIONS;[m
[31m-        handler.reset(latch, ITERATIONS);[m
[31m-        executor.execute(processor);[m
[31m-        long start = System.currentTimeMillis();[m
[31m-[m
[31m-        final OffHeapRingBuffer rb = buffer;[m
[31m-[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            rb.put(data);[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-        perfTestContext.setDisruptorOps((ITERATIONS * 1000L) / (System.currentTimeMillis() - start));[m
[31m-        perfTestContext.setBatchData(handler.getBatchesProcessed(), ITERATIONS);[m
[31m-        waitForEventProcessorSequence(expectedCount);[m
[31m-        processor.halt();[m
[31m-[m
[31m-        return perfTestContext;[m
[31m-    }[m
[31m-[m
[31m-    private void waitForEventProcessorSequence(long expectedCount)[m
[31m-    {[m
[31m-        while (processor.getSequence().get() < expectedCount)[m
[31m-        {[m
[31m-            LockSupport.parkNanos(1);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        new OneToOneOffHeapThroughputTest().testImplementations();[m
[31m-    }[m
[31m-[m
[31m-    public static class ByteBufferHandler implements EventHandler<ByteBuffer>, BatchStartAware[m
[31m-    {[m
[31m-        private final PaddedLong total = new PaddedLong();[m
[31m-        private final PaddedLong batchesProcessed = new PaddedLong();[m
[31m-        private long expectedCount;[m
[31m-        private CountDownLatch latch;[m
[31m-[m
[31m-        @Override[m
[31m-        public void onEvent(ByteBuffer event, long sequence, boolean endOfBatch) throws Exception[m
[31m-        {[m
[31m-            final int start = event.position();[m
[31m-            for (int i = start, size = start + BLOCK_SIZE; i < size; i += 8)[m
[31m-            {[m
[31m-                total.set(total.get() + event.getLong(i));[m
[31m-            }[m
[31m-[m
[31m-            if (--expectedCount == 0)[m
[31m-            {[m
[31m-                latch.countDown();[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        public long getTotal()[m
[31m-        {[m
[31m-            return total.get();[m
[31m-        }[m
[31m-[m
[31m-        public long getBatchesProcessed()[m
[31m-        {[m
[31m-            return batchesProcessed.get();[m
[31m-        }[m
[31m-[m
[31m-        public void reset(CountDownLatch latch, long expectedCount)[m
[31m-        {[m
[31m-            this.latch = latch;[m
[31m-            this.expectedCount = expectedCount;[m
[31m-            this.total.set(0);[m
[31m-            this.batchesProcessed.set(0);[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onBatchStart(long batchSize)[m
[31m-        {[m
[31m-            batchesProcessed.increment();[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static class OffHeapRingBuffer implements DataProvider<ByteBuffer>[m
[31m-    {[m
[31m-        private final Sequencer sequencer;[m
[31m-        private final int entrySize;[m
[31m-        private final ByteBuffer buffer;[m
[31m-        private final int mask;[m
[31m-[m
[31m-        private final ThreadLocal<ByteBuffer> perThreadBuffer = new ThreadLocal<>()[m
[31m-        {[m
[31m-            @Override[m
[31m-            protected ByteBuffer initialValue()[m
[31m-            {[m
[31m-                return buffer.duplicate().order(ByteOrder.nativeOrder());[m
[31m-            }[m
[31m-        };[m
[31m-[m
[31m-        public OffHeapRingBuffer(Sequencer sequencer, int entrySize)[m
[31m-        {[m
[31m-            this.sequencer = sequencer;[m
[31m-            this.entrySize = entrySize;[m
[31m-            this.mask = sequencer.getBufferSize() - 1;[m
[31m-            buffer = ByteBuffer.allocateDirect(sequencer.getBufferSize() * entrySize).order(ByteOrder.nativeOrder());[m
[31m-        }[m
[31m-[m
[31m-        public void addGatingSequences(Sequence sequence)[m
[31m-        {[m
[31m-            sequencer.addGatingSequences(sequence);[m
[31m-        }[m
[31m-[m
[31m-        public SequenceBarrier newBarrier()[m
[31m-        {[m
[31m-            return sequencer.newBarrier();[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public ByteBuffer get(long sequence)[m
[31m-        {[m
[31m-            int index = index(sequence);[m
[31m-            int position = index * entrySize;[m
[31m-            int limit = position + entrySize;[m
[31m-[m
[31m-            ByteBuffer byteBuffer = perThreadBuffer.get();[m
[31m-            byteBuffer.position(position).limit(limit);[m
[31m-[m
[31m-            return byteBuffer;[m
[31m-        }[m
[31m-[m
[31m-        public void put(byte[] data)[m
[31m-        {[m
[31m-            long next = sequencer.next();[m
[31m-            try[m
[31m-            {[m
[31m-                get(next).put(data);[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                sequencer.publish(next);[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        private int index(long next)[m
[31m-        {[m
[31m-            return (int) (next & mask);[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/offheap/OneToOneOnHeapThroughputTest.java b/src/perftest/java/com/lmax/disruptor/offheap/OneToOneOnHeapThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex 0d13759..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/offheap/OneToOneOnHeapThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,224 +0,0 @@[m
[31m-package com.lmax.disruptor.offheap;[m
[31m-[m
[31m-import com.lmax.disruptor.*;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-import com.lmax.disruptor.util.PaddedLong;[m
[31m-[m
[31m-import java.nio.ByteBuffer;[m
[31m-import java.nio.ByteOrder;[m
[31m-import java.util.Random;[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.Executor;[m
[31m-import java.util.concurrent.Executors;[m
[31m-import java.util.concurrent.locks.LockSupport;[m
[31m-[m
[31m-public class OneToOneOnHeapThroughputTest extends AbstractPerfTestDisruptor[m
[31m-{[m
[31m-    private static final int BLOCK_SIZE = 256;[m
[31m-    private static final int BUFFER_SIZE = 1024 * 1024;[m
[31m-    private static final long ITERATIONS = 1000 * 1000 * 10L;[m
[31m-[m
[31m-    private static final boolean SLICED_BUFFER = Boolean.getBoolean("sliced");[m
[31m-    private final Executor executor = Executors.newFixedThreadPool(1, DaemonThreadFactory.INSTANCE);[m
[31m-    private final WaitStrategy waitStrategy = new YieldingWaitStrategy();[m
[31m-    private final RingBuffer<ByteBuffer> buffer =[m
[31m-        RingBuffer.createSingleProducer([m
[31m-            SLICED_BUFFER ? SlicedBufferFactory.direct(BLOCK_SIZE, BUFFER_SIZE) : BufferFactory.direct(BLOCK_SIZE),[m
[31m-            BUFFER_SIZE, waitStrategy);[m
[31m-        private final ByteBufferHandler handler = new ByteBufferHandler();[m
[31m-    private final BatchEventProcessor<ByteBuffer> processor =[m
[31m-            new BatchEventProcessor<>(buffer, buffer.newBarrier(), handler);[m
[31m-[m
[31m-    {[m
[31m-        buffer.addGatingSequences(processor.getSequence());[m
[31m-    }[m
[31m-[m
[31m-    private final Random r = new Random(1);[m
[31m-    private final byte[] data = new byte[BLOCK_SIZE];[m
[31m-[m
[31m-    public OneToOneOnHeapThroughputTest()[m
[31m-    {[m
[31m-        r.nextBytes(data);[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 2;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected PerfTestContext runDisruptorPass() throws Exception[m
[31m-    {[m
[31m-        PerfTestContext perfTestContext = new PerfTestContext();[m
[31m-        byte[] data = this.data;[m
[31m-[m
[31m-        final CountDownLatch latch = new CountDownLatch(1);[m
[31m-        long expectedCount = processor.getSequence().get() + ITERATIONS;[m
[31m-        handler.reset(latch, ITERATIONS);[m
[31m-        executor.execute(processor);[m
[31m-        long start = System.currentTimeMillis();[m
[31m-[m
[31m-        final RingBuffer<ByteBuffer> rb = buffer;[m
[31m-[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            long next = rb.next();[m
[31m-            ByteBuffer event = rb.get(next);[m
[31m-            event.clear();[m
[31m-            event.put(data);[m
[31m-            event.flip();[m
[31m-            rb.publish(next);[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-        perfTestContext.setDisruptorOps((ITERATIONS * 1000L) / (System.currentTimeMillis() - start));[m
[31m-        perfTestContext.setBatchData(handler.getBatchesProcessed(), ITERATIONS);[m
[31m-        waitForEventProcessorSequence(expectedCount);[m
[31m-        processor.halt();[m
[31m-[m
[31m-        return perfTestContext;[m
[31m-    }[m
[31m-[m
[31m-    private void waitForEventProcessorSequence(long expectedCount)[m
[31m-    {[m
[31m-        while (processor.getSequence().get() < expectedCount)[m
[31m-        {[m
[31m-            LockSupport.parkNanos(1);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        new OneToOneOnHeapThroughputTest().testImplementations();[m
[31m-    }[m
[31m-[m
[31m-    public static class ByteBufferHandler implements EventHandler<ByteBuffer>, BatchStartAware[m
[31m-    {[m
[31m-        private final PaddedLong total = new PaddedLong();[m
[31m-        private final PaddedLong batchesProcessed = new PaddedLong();[m
[31m-        private long expectedCount;[m
[31m-        private CountDownLatch latch;[m
[31m-[m
[31m-        @Override[m
[31m-        public void onEvent(ByteBuffer event, long sequence, boolean endOfBatch) throws Exception[m
[31m-        {[m
[31m-            for (int i = 0; i < BLOCK_SIZE; i += 8)[m
[31m-            {[m
[31m-                total.set(total.get() + event.getLong(i));[m
[31m-            }[m
[31m-[m
[31m-            if (--expectedCount == 0)[m
[31m-            {[m
[31m-                latch.countDown();[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        public long getTotal()[m
[31m-        {[m
[31m-            return total.get();[m
[31m-        }[m
[31m-[m
[31m-        public long getBatchesProcessed()[m
[31m-        {[m
[31m-            return batchesProcessed.get();[m
[31m-        }[m
[31m-[m
[31m-        public void reset(CountDownLatch latch, long expectedCount)[m
[31m-        {[m
[31m-            this.latch = latch;[m
[31m-            this.expectedCount = expectedCount;[m
[31m-            this.total.set(0);[m
[31m-            this.batchesProcessed.set(0);[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onBatchStart(long batchSize)[m
[31m-        {[m
[31m-            batchesProcessed.increment();[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static final class BufferFactory implements EventFactory<ByteBuffer>[m
[31m-    {[m
[31m-        private final boolean isDirect;[m
[31m-        private final int size;[m
[31m-[m
[31m-        private BufferFactory(boolean isDirect, int size)[m
[31m-        {[m
[31m-            this.isDirect = isDirect;[m
[31m-            this.size = size;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public ByteBuffer newInstance()[m
[31m-        {[m
[31m-            if (isDirect)[m
[31m-            {[m
[31m-                return ByteBuffer.allocateDirect(size).order(ByteOrder.nativeOrder());[m
[31m-            }[m
[31m-            else[m
[31m-            {[m
[31m-                return ByteBuffer.allocate(size).order(ByteOrder.nativeOrder());[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        public static BufferFactory direct(int size)[m
[31m-        {[m
[31m-            return new BufferFactory(true, size);[m
[31m-        }[m
[31m-[m
[31m-        @SuppressWarnings("unused")[m
[31m-        public static BufferFactory heap(int size)[m
[31m-        {[m
[31m-            return new BufferFactory(false, size);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static final class SlicedBufferFactory implements EventFactory<ByteBuffer>[m
[31m-    {[m
[31m-        private final boolean isDirect;[m
[31m-        private final int size;[m
[31m-        private final int total;[m
[31m-        private ByteBuffer buffer;[m
[31m-[m
[31m-        private SlicedBufferFactory(boolean isDirect, int size, int total)[m
[31m-        {[m
[31m-            this.isDirect = isDirect;[m
[31m-            this.size = size;[m
[31m-            this.total = total;[m
[31m-            this.buffer =[m
[31m-                (isDirect ? ByteBuffer.allocateDirect(size * total) : ByteBuffer.allocate(size * total))[m
[31m-                    .order(ByteOrder.nativeOrder());[m
[31m-            this.buffer.limit(0);[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public ByteBuffer newInstance()[m
[31m-        {[m
[31m-            if (this.buffer.limit() == this.buffer.capacity())[m
[31m-            {[m
[31m-                this.buffer =[m
[31m-                    (isDirect ? ByteBuffer.allocateDirect(size * total) : ByteBuffer.allocate(size * total))[m
[31m-                        .order(ByteOrder.nativeOrder());[m
[31m-                this.buffer.limit(0);[m
[31m-            }[m
[31m-            final int limit = this.buffer.limit();[m
[31m-            this.buffer.limit(limit + size);[m
[31m-            this.buffer.position(limit);[m
[31m-            final ByteBuffer slice = this.buffer.slice().order(ByteOrder.nativeOrder());[m
[31m-            return slice;[m
[31m-        }[m
[31m-[m
[31m-        public static SlicedBufferFactory direct(int size, int total)[m
[31m-        {[m
[31m-            return new SlicedBufferFactory(true, size, total);[m
[31m-        }[m
[31m-[m
[31m-        @SuppressWarnings("unused")[m
[31m-        public static SlicedBufferFactory heap(int size, int total)[m
[31m-        {[m
[31m-            return new SlicedBufferFactory(false, size, total);[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/primitive/LongRingBuffer.java b/src/perftest/java/com/lmax/disruptor/primitive/LongRingBuffer.java[m
[1mdeleted file mode 100644[m
[1mindex 600a9d2..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/primitive/LongRingBuffer.java[m
[1m+++ /dev/null[m
[36m@@ -1,61 +0,0 @@[m
[31m-package com.lmax.disruptor.primitive;[m
[31m-[m
[31m-import com.lmax.disruptor.BatchEventProcessor;[m
[31m-import com.lmax.disruptor.DataProvider;[m
[31m-import com.lmax.disruptor.Sequencer;[m
[31m-[m
[31m-public class LongRingBuffer[m
[31m-{[m
[31m-    private final Sequencer sequencer;[m
[31m-    private final long[] buffer;[m
[31m-    private final int mask;[m
[31m-[m
[31m-    public LongRingBuffer(final Sequencer sequencer)[m
[31m-    {[m
[31m-        this.sequencer = sequencer;[m
[31m-        this.buffer = new long[sequencer.getBufferSize()];[m
[31m-        this.mask = sequencer.getBufferSize() - 1;[m
[31m-    }[m
[31m-[m
[31m-    private int index(final long sequence)[m
[31m-    {[m
[31m-        return (int) sequence & mask;[m
[31m-    }[m
[31m-[m
[31m-    public void put(final long e)[m
[31m-    {[m
[31m-        final long next = sequencer.next();[m
[31m-        buffer[index(next)] = e;[m
[31m-        sequencer.publish(next);[m
[31m-    }[m
[31m-[m
[31m-    public interface LongHandler[m
[31m-    {[m
[31m-        void onEvent(long value, long sequence, boolean endOfBatch);[m
[31m-    }[m
[31m-[m
[31m-    private class LongEvent implements DataProvider<LongEvent>[m
[31m-    {[m
[31m-        private long sequence;[m
[31m-[m
[31m-        public long get()[m
[31m-        {[m
[31m-            return buffer[index(sequence)];[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public LongEvent get(final long sequence)[m
[31m-        {[m
[31m-            this.sequence = sequence;[m
[31m-            return this;[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public BatchEventProcessor<LongEvent> createProcessor(final LongHandler handler)[m
[31m-    {[m
[31m-        return new BatchEventProcessor<>([m
[31m-                new LongEvent(),[m
[31m-                sequencer.newBarrier(),[m
[31m-                (event, sequence, endOfBatch) -> handler.onEvent(event.get(), sequence, endOfBatch));[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/queue/OneToOneQueueBatchedThroughputTest.java b/src/perftest/java/com/lmax/disruptor/queue/OneToOneQueueBatchedThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex 1104e08..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/queue/OneToOneQueueBatchedThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,97 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.queue;[m
[31m-[m
[31m-import com.lmax.disruptor.AbstractPerfTestQueue;[m
[31m-import com.lmax.disruptor.support.ValueAdditionBatchQueueProcessor;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-import java.util.concurrent.*;[m
[31m-[m
[31m-import static com.lmax.disruptor.support.PerfTestUtil.failIf;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- * UniCast a series of items between 1 publisher and 1 event processor.[m
[31m- *[m
[31m- * +----+    +-----+[m
[31m- * | P1 |--->| EP1 |[m
[31m- * +----+    +-----+[m
[31m- *[m
[31m- * Queue Based:[m
[31m- * ============[m
[31m- *[m
[31m- *        put      take[m
[31m- * +----+    +====+    +-----+[m
[31m- * | P1 |--->| Q1 |<---| EP1 |[m
[31m- * +----+    +====+    +-----+[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * Q1  - Queue 1[m
[31m- * EP1 - EventProcessor 1[m
[31m- *[m
[31m- * </pre>[m
[31m- */[m
[31m-public final class OneToOneQueueBatchedThroughputTest extends AbstractPerfTestQueue[m
[31m-{[m
[31m-    private static final int BUFFER_SIZE = 1024 * 64;[m
[31m-    private static final long ITERATIONS = 1000L * 1000L * 10L;[m
[31m-    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);[m
[31m-    private final long expectedResult = ITERATIONS * 3L;[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    private final BlockingQueue<Long> blockingQueue = new LinkedBlockingQueue<>(BUFFER_SIZE);[m
[31m-    private final ValueAdditionBatchQueueProcessor queueProcessor =[m
[31m-        new ValueAdditionBatchQueueProcessor(blockingQueue, ITERATIONS);[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 2;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected long runQueuePass() throws InterruptedException[m
[31m-    {[m
[31m-        final CountDownLatch latch = new CountDownLatch(1);[m
[31m-        queueProcessor.reset(latch);[m
[31m-        Future<?> future = executor.submit(queueProcessor);[m
[31m-        long start = System.currentTimeMillis();[m
[31m-[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            blockingQueue.put(3L);[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);[m
[31m-        queueProcessor.halt();[m
[31m-        future.cancel(true);[m
[31m-[m
[31m-        failIf(expectedResult, 0);[m
[31m-[m
[31m-        return opsPerSecond;[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        OneToOneQueueBatchedThroughputTest test = new OneToOneQueueBatchedThroughputTest();[m
[31m-        test.testImplementations();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/queue/OneToOneQueueThroughputTest.java b/src/perftest/java/com/lmax/disruptor/queue/OneToOneQueueThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex 5e3c4c5..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/queue/OneToOneQueueThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,97 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.queue;[m
[31m-[m
[31m-import com.lmax.disruptor.AbstractPerfTestQueue;[m
[31m-import com.lmax.disruptor.support.ValueAdditionQueueProcessor;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-import java.util.concurrent.*;[m
[31m-[m
[31m-import static com.lmax.disruptor.support.PerfTestUtil.failIf;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- * UniCast a series of items between 1 publisher and 1 event processor.[m
[31m- *[m
[31m- * +----+    +-----+[m
[31m- * | P1 |--->| EP1 |[m
[31m- * +----+    +-----+[m
[31m- *[m
[31m- * Queue Based:[m
[31m- * ============[m
[31m- *[m
[31m- *        put      take[m
[31m- * +----+    +====+    +-----+[m
[31m- * | P1 |--->| Q1 |<---| EP1 |[m
[31m- * +----+    +====+    +-----+[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * Q1  - Queue 1[m
[31m- * EP1 - EventProcessor 1[m
[31m- *[m
[31m- * </pre>[m
[31m- */[m
[31m-public final class OneToOneQueueThroughputTest extends AbstractPerfTestQueue[m
[31m-{[m
[31m-    private static final int BUFFER_SIZE = 1024 * 64;[m
[31m-    private static final long ITERATIONS = 1000L * 1000L * 10L;[m
[31m-    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);[m
[31m-    private final long expectedResult = ITERATIONS * 3L;[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    private final BlockingQueue<Long> blockingQueue = new LinkedBlockingQueue<>(BUFFER_SIZE);[m
[31m-    private final ValueAdditionQueueProcessor queueProcessor =[m
[31m-        new ValueAdditionQueueProcessor(blockingQueue, ITERATIONS - 1);[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 2;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected long runQueuePass() throws InterruptedException[m
[31m-    {[m
[31m-        final CountDownLatch latch = new CountDownLatch(1);[m
[31m-        queueProcessor.reset(latch);[m
[31m-        Future<?> future = executor.submit(queueProcessor);[m
[31m-        long start = System.currentTimeMillis();[m
[31m-[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            blockingQueue.put(3L);[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);[m
[31m-        queueProcessor.halt();[m
[31m-        future.cancel(true);[m
[31m-[m
[31m-        failIf(expectedResult, 0);[m
[31m-[m
[31m-        return opsPerSecond;[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        OneToOneQueueThroughputTest test = new OneToOneQueueThroughputTest();[m
[31m-        test.testImplementations();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/queue/OneToThreeDiamondQueueThroughputTest.java b/src/perftest/java/com/lmax/disruptor/queue/OneToThreeDiamondQueueThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex 1800234..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/queue/OneToThreeDiamondQueueThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,190 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.queue;[m
[31m-[m
[31m-import static com.lmax.disruptor.support.PerfTestUtil.failIf;[m
[31m-[m
[31m-import java.util.concurrent.BlockingQueue;[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-import java.util.concurrent.Future;[m
[31m-import java.util.concurrent.LinkedBlockingQueue;[m
[31m-[m
[31m-import com.lmax.disruptor.AbstractPerfTestQueue;[m
[31m-import com.lmax.disruptor.support.FizzBuzzQueueProcessor;[m
[31m-import com.lmax.disruptor.support.FizzBuzzStep;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- * Produce an event replicated to two event processors and fold back to a single third event processor.[m
[31m- *[m
[31m- *           +-----+[m
[31m- *    +----->| EP1 |------+[m
[31m- *    |      +-----+      |[m
[31m- *    |                   v[m
[31m- * +----+              +-----+[m
[31m- * | P1 |              | EP3 |[m
[31m- * +----+              +-----+[m
[31m- *    |                   ^[m
[31m- *    |      +-----+      |[m
[31m- *    +----->| EP2 |------+[m
[31m- *           +-----+[m
[31m- *[m
[31m- *[m
[31m- * Queue Based:[m
[31m- * ============[m
[31m- *                 take       put[m
[31m- *     put   +====+    +-----+    +====+  take[m
[31m- *    +----->| Q1 |<---| EP1 |--->| Q3 |<------+[m
[31m- *    |      +====+    +-----+    +====+       |[m
[31m- *    |                                        |[m
[31m- * +----+    +====+    +-----+    +====+    +-----+[m
[31m- * | P1 |--->| Q2 |<---| EP2 |--->| Q4 |<---| EP3 |[m
[31m- * +----+    +====+    +-----+    +====+    +-----+[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * Q1  - Queue 1[m
[31m- * Q2  - Queue 2[m
[31m- * Q3  - Queue 3[m
[31m- * Q4  - Queue 4[m
[31m- * EP1 - EventProcessor 1[m
[31m- * EP2 - EventProcessor 2[m
[31m- * EP3 - EventProcessor 3[m
[31m- *[m
[31m- *[m
[31m- * Disruptor:[m
[31m- * ==========[m
[31m- *                    track to prevent wrap[m
[31m- *              +-------------------------------+[m
[31m- *              |                               |[m
[31m- *              |                               v[m
[31m- * +----+    +====+               +=====+    +-----+[m
[31m- * | P1 |--->| RB |<--------------| SB2 |<---| EP3 |[m
[31m- * +----+    +====+               +=====+    +-----+[m
[31m- *      claim   ^  get               |   waitFor[m
[31m- *              |                    |[m
[31m- *           +=====+    +-----+      |[m
[31m- *           | SB1 |<---| EP1 |<-----+[m
[31m- *           +=====+    +-----+      |[m
[31m- *              ^                    |[m
[31m- *              |       +-----+      |[m
[31m- *              +-------| EP2 |<-----+[m
[31m- *             waitFor  +-----+[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * RB  - RingBuffer[m
[31m- * SB1 - SequenceBarrier 1[m
[31m- * EP1 - EventProcessor 1[m
[31m- * EP2 - EventProcessor 2[m
[31m- * SB2 - SequenceBarrier 2[m
[31m- * EP3 - EventProcessor 3[m
[31m- *[m
[31m- * </pre>[m
[31m- */[m
[31m-public final class OneToThreeDiamondQueueThroughputTest extends AbstractPerfTestQueue[m
[31m-{[m
[31m-    private static final int NUM_EVENT_PROCESSORS = 3;[m
[31m-    private static final int BUFFER_SIZE = 1024 * 8;[m
[31m-    private static final long ITERATIONS = 1000L * 1000L * 100L;[m
[31m-    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_EVENT_PROCESSORS, DaemonThreadFactory.INSTANCE);[m
[31m-[m
[31m-    private final long expectedResult;[m
[31m-[m
[31m-    {[m
[31m-        long temp = 0L;[m
[31m-[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            boolean fizz = 0 == (i % 3L);[m
[31m-            boolean buzz = 0 == (i % 5L);[m
[31m-[m
[31m-            if (fizz && buzz)[m
[31m-            {[m
[31m-                ++temp;[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        expectedResult = temp;[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    private final BlockingQueue<Long> fizzInputQueue = new LinkedBlockingQueue<>(BUFFER_SIZE);[m
[31m-    private final BlockingQueue<Long> buzzInputQueue = new LinkedBlockingQueue<>(BUFFER_SIZE);[m
[31m-    private final BlockingQueue<Boolean> fizzOutputQueue = new LinkedBlockingQueue<>(BUFFER_SIZE);[m
[31m-    private final BlockingQueue<Boolean> buzzOutputQueue = new LinkedBlockingQueue<>(BUFFER_SIZE);[m
[31m-[m
[31m-    private final FizzBuzzQueueProcessor fizzQueueProcessor =[m
[31m-        new FizzBuzzQueueProcessor(FizzBuzzStep.FIZZ, fizzInputQueue, buzzInputQueue, fizzOutputQueue, buzzOutputQueue, ITERATIONS - 1);[m
[31m-[m
[31m-    private final FizzBuzzQueueProcessor buzzQueueProcessor =[m
[31m-        new FizzBuzzQueueProcessor(FizzBuzzStep.BUZZ, fizzInputQueue, buzzInputQueue, fizzOutputQueue, buzzOutputQueue, ITERATIONS - 1);[m
[31m-[m
[31m-    private final FizzBuzzQueueProcessor fizzBuzzQueueProcessor =[m
[31m-        new FizzBuzzQueueProcessor(FizzBuzzStep.FIZZ_BUZZ, fizzInputQueue, buzzInputQueue, fizzOutputQueue, buzzOutputQueue, ITERATIONS - 1);[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 4;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected long runQueuePass() throws Exception[m
[31m-    {[m
[31m-        final CountDownLatch latch = new CountDownLatch(1);[m
[31m-        fizzBuzzQueueProcessor.reset(latch);[m
[31m-[m
[31m-        Future<?>[] futures = new Future[NUM_EVENT_PROCESSORS];[m
[31m-        futures[0] = executor.submit(fizzQueueProcessor);[m
[31m-        futures[1] = executor.submit(buzzQueueProcessor);[m
[31m-        futures[2] = executor.submit(fizzBuzzQueueProcessor);[m
[31m-[m
[31m-        long start = System.currentTimeMillis();[m
[31m-[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            Long value = Long.valueOf(i);[m
[31m-            fizzInputQueue.put(value);[m
[31m-            buzzInputQueue.put(value);[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);[m
[31m-[m
[31m-        fizzQueueProcessor.halt();[m
[31m-        buzzQueueProcessor.halt();[m
[31m-        fizzBuzzQueueProcessor.halt();[m
[31m-[m
[31m-        for (Future<?> future : futures)[m
[31m-        {[m
[31m-            future.cancel(true);[m
[31m-        }[m
[31m-[m
[31m-        failIf(expectedResult, 0);[m
[31m-[m
[31m-        return opsPerSecond;[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        new OneToThreeDiamondQueueThroughputTest().testImplementations();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/queue/OneToThreePipelineQueueThroughputTest.java b/src/perftest/java/com/lmax/disruptor/queue/OneToThreePipelineQueueThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex 565c77a..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/queue/OneToThreePipelineQueueThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,153 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.queue;[m
[31m-[m
[31m-import static com.lmax.disruptor.support.PerfTestUtil.failIf;[m
[31m-[m
[31m-import java.util.concurrent.BlockingQueue;[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-import java.util.concurrent.Future;[m
[31m-import java.util.concurrent.LinkedBlockingQueue;[m
[31m-[m
[31m-import com.lmax.disruptor.AbstractPerfTestQueue;[m
[31m-import com.lmax.disruptor.support.FunctionQueueProcessor;[m
[31m-import com.lmax.disruptor.support.FunctionStep;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- *[m
[31m- * Pipeline a series of stages from a publisher to ultimate event processor.[m
[31m- * Each event processor depends on the output of the event processor.[m
[31m- *[m
[31m- * +----+    +-----+    +-----+    +-----+[m
[31m- * | P1 |--->| EP1 |--->| EP2 |--->| EP3 |[m
[31m- * +----+    +-----+    +-----+    +-----+[m
[31m- *[m
[31m- *[m
[31m- * Queue Based:[m
[31m- * ============[m
[31m- *[m
[31m- *        put      take        put      take        put      take[m
[31m- * +----+    +====+    +-----+    +====+    +-----+    +====+    +-----+[m
[31m- * | P1 |--->| Q1 |<---| EP1 |--->| Q2 |<---| EP2 |--->| Q3 |<---| EP3 |[m
[31m- * +----+    +====+    +-----+    +====+    +-----+    +====+    +-----+[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * Q1  - Queue 1[m
[31m- * EP1 - EventProcessor 1[m
[31m- * Q2  - Queue 2[m
[31m- * EP2 - EventProcessor 2[m
[31m- * Q3  - Queue 3[m
[31m- * EP3 - EventProcessor 3[m
[31m- *[m
[31m- * </pre>[m
[31m- */[m
[31m-public final class OneToThreePipelineQueueThroughputTest extends AbstractPerfTestQueue[m
[31m-{[m
[31m-    private static final int NUM_EVENT_PROCESSORS = 3;[m
[31m-    private static final int BUFFER_SIZE = 1024 * 8;[m
[31m-    private static final long ITERATIONS = 1000L * 1000L * 10L;[m
[31m-    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_EVENT_PROCESSORS, DaemonThreadFactory.INSTANCE);[m
[31m-[m
[31m-    private static final long OPERAND_TWO_INITIAL_VALUE = 777L;[m
[31m-    private final long expectedResult;[m
[31m-[m
[31m-    {[m
[31m-        long temp = 0L;[m
[31m-        long operandTwo = OPERAND_TWO_INITIAL_VALUE;[m
[31m-[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            long stepOneResult = i + operandTwo--;[m
[31m-            long stepTwoResult = stepOneResult + 3;[m
[31m-[m
[31m-            if ((stepTwoResult & 4L) == 4L)[m
[31m-            {[m
[31m-                ++temp;[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        expectedResult = temp;[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    private final BlockingQueue<long[]> stepOneQueue = new LinkedBlockingQueue<>(BUFFER_SIZE);[m
[31m-    private final BlockingQueue<Long> stepTwoQueue = new LinkedBlockingQueue<>(BUFFER_SIZE);[m
[31m-    private final BlockingQueue<Long> stepThreeQueue = new LinkedBlockingQueue<>(BUFFER_SIZE);[m
[31m-[m
[31m-    private final FunctionQueueProcessor stepOneQueueProcessor =[m
[31m-        new FunctionQueueProcessor(FunctionStep.ONE, stepOneQueue, stepTwoQueue, stepThreeQueue, ITERATIONS - 1);[m
[31m-    private final FunctionQueueProcessor stepTwoQueueProcessor =[m
[31m-        new FunctionQueueProcessor(FunctionStep.TWO, stepOneQueue, stepTwoQueue, stepThreeQueue, ITERATIONS - 1);[m
[31m-    private final FunctionQueueProcessor stepThreeQueueProcessor =[m
[31m-        new FunctionQueueProcessor(FunctionStep.THREE, stepOneQueue, stepTwoQueue, stepThreeQueue, ITERATIONS - 1);[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 4;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected long runQueuePass() throws Exception[m
[31m-    {[m
[31m-        CountDownLatch latch = new CountDownLatch(1);[m
[31m-        stepThreeQueueProcessor.reset(latch);[m
[31m-[m
[31m-        Future<?>[] futures = new Future[NUM_EVENT_PROCESSORS];[m
[31m-        futures[0] = executor.submit(stepOneQueueProcessor);[m
[31m-        futures[1] = executor.submit(stepTwoQueueProcessor);[m
[31m-        futures[2] = executor.submit(stepThreeQueueProcessor);[m
[31m-[m
[31m-        long start = System.currentTimeMillis();[m
[31m-[m
[31m-        long operandTwo = OPERAND_TWO_INITIAL_VALUE;[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            long[] values = new long[2];[m
[31m-            values[0] = i;[m
[31m-            values[1] = operandTwo--;[m
[31m-            stepOneQueue.put(values);[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);[m
[31m-[m
[31m-        stepOneQueueProcessor.halt();[m
[31m-        stepTwoQueueProcessor.halt();[m
[31m-        stepThreeQueueProcessor.halt();[m
[31m-[m
[31m-        for (Future<?> future : futures)[m
[31m-        {[m
[31m-            future.cancel(true);[m
[31m-        }[m
[31m-[m
[31m-        failIf(expectedResult, 0);[m
[31m-[m
[31m-        return opsPerSecond;[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        new OneToThreePipelineQueueThroughputTest().testImplementations();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/queue/OneToThreeQueueThroughputTest.java b/src/perftest/java/com/lmax/disruptor/queue/OneToThreeQueueThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex 1abafe8..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/queue/OneToThreeQueueThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,158 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.queue;[m
[31m-[m
[31m-import static com.lmax.disruptor.support.PerfTestUtil.failIf;[m
[31m-[m
[31m-import java.util.concurrent.BlockingQueue;[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-import java.util.concurrent.Future;[m
[31m-import java.util.concurrent.LinkedBlockingQueue;[m
[31m-[m
[31m-import com.lmax.disruptor.AbstractPerfTestQueue;[m
[31m-import com.lmax.disruptor.support.Operation;[m
[31m-import com.lmax.disruptor.support.ValueMutationQueueProcessor;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- *[m
[31m- * MultiCast a series of items between 1 publisher and 3 event processors.[m
[31m- *[m
[31m- *           +-----+[m
[31m- *    +----->| EP1 |[m
[31m- *    |      +-----+[m
[31m- *    |[m
[31m- * +----+    +-----+[m
[31m- * | P1 |--->| EP2 |[m
[31m- * +----+    +-----+[m
[31m- *    |[m
[31m- *    |      +-----+[m
[31m- *    +----->| EP3 |[m
[31m- *           +-----+[m
[31m- *[m
[31m- *[m
[31m- * Queue Based:[m
[31m- * ============[m
[31m- *                 take[m
[31m- *   put     +====+    +-----+[m
[31m- *    +----->| Q1 |<---| EP1 |[m
[31m- *    |      +====+    +-----+[m
[31m- *    |[m
[31m- * +----+    +====+    +-----+[m
[31m- * | P1 |--->| Q2 |<---| EP2 |[m
[31m- * +----+    +====+    +-----+[m
[31m- *    |[m
[31m- *    |      +====+    +-----+[m
[31m- *    +----->| Q3 |<---| EP3 |[m
[31m- *           +====+    +-----+[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * Q1  - Queue 1[m
[31m- * Q2  - Queue 2[m
[31m- * Q3  - Queue 3[m
[31m- * EP1 - EventProcessor 1[m
[31m- * EP2 - EventProcessor 2[m
[31m- * EP3 - EventProcessor 3[m
[31m- *[m
[31m- * </pre>[m
[31m- */[m
[31m-public final class OneToThreeQueueThroughputTest extends AbstractPerfTestQueue[m
[31m-{[m
[31m-    private static final int NUM_EVENT_PROCESSORS = 3;[m
[31m-    private static final int BUFFER_SIZE = 1024 * 8;[m
[31m-    private static final long ITERATIONS = 1000L * 1000L * 1L;[m
[31m-    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_EVENT_PROCESSORS, DaemonThreadFactory.INSTANCE);[m
[31m-[m
[31m-    private final long[] results = new long[NUM_EVENT_PROCESSORS];[m
[31m-[m
[31m-    {[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            results[0] = Operation.ADDITION.op(results[0], i);[m
[31m-            results[1] = Operation.SUBTRACTION.op(results[1], i);[m
[31m-            results[2] = Operation.AND.op(results[2], i);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @SuppressWarnings("unchecked")[m
[31m-    private final BlockingQueue<Long>[] blockingQueues = new BlockingQueue[NUM_EVENT_PROCESSORS];[m
[31m-[m
[31m-    {[m
[31m-        blockingQueues[0] = new LinkedBlockingQueue<>(BUFFER_SIZE);[m
[31m-        blockingQueues[1] = new LinkedBlockingQueue<>(BUFFER_SIZE);[m
[31m-        blockingQueues[2] = new LinkedBlockingQueue<>(BUFFER_SIZE);[m
[31m-    }[m
[31m-[m
[31m-    private final ValueMutationQueueProcessor[] queueProcessors = new ValueMutationQueueProcessor[NUM_EVENT_PROCESSORS];[m
[31m-[m
[31m-    {[m
[31m-        queueProcessors[0] = new ValueMutationQueueProcessor(blockingQueues[0], Operation.ADDITION, ITERATIONS - 1);[m
[31m-        queueProcessors[1] = new ValueMutationQueueProcessor(blockingQueues[1], Operation.SUBTRACTION, ITERATIONS - 1);[m
[31m-        queueProcessors[2] = new ValueMutationQueueProcessor(blockingQueues[2], Operation.AND, ITERATIONS - 1);[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 4;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected long runQueuePass() throws InterruptedException[m
[31m-    {[m
[31m-        CountDownLatch latch = new CountDownLatch(NUM_EVENT_PROCESSORS);[m
[31m-        Future<?>[] futures = new Future[NUM_EVENT_PROCESSORS];[m
[31m-        for (int i = 0; i < NUM_EVENT_PROCESSORS; i++)[m
[31m-        {[m
[31m-            queueProcessors[i].reset(latch);[m
[31m-            futures[i] = executor.submit(queueProcessors[i]);[m
[31m-        }[m
[31m-[m
[31m-        long start = System.currentTimeMillis();[m
[31m-[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            final Long value = Long.valueOf(i);[m
[31m-            for (BlockingQueue<Long> queue : blockingQueues)[m
[31m-            {[m
[31m-                queue.put(value);[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);[m
[31m-        for (int i = 0; i < NUM_EVENT_PROCESSORS; i++)[m
[31m-        {[m
[31m-            queueProcessors[i].halt();[m
[31m-            futures[i].cancel(true);[m
[31m-            failIf(queueProcessors[i].getValue(), -1);[m
[31m-        }[m
[31m-[m
[31m-        return opsPerSecond;[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        new OneToThreeQueueThroughputTest().testImplementations();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/queue/PingPongQueueLatencyTest.java b/src/perftest/java/com/lmax/disruptor/queue/PingPongQueueLatencyTest.java[m
[1mdeleted file mode 100644[m
[1mindex 2c48920..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/queue/PingPongQueueLatencyTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,226 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.queue;[m
[31m-[m
[31m-import java.io.PrintStream;[m
[31m-import java.util.concurrent.*;[m
[31m-[m
[31m-import org.HdrHistogram.Histogram;[m
[31m-[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- *[m
[31m- * Ping pongs between 2 event handlers and measures the latency of[m
[31m- * a round trip.[m
[31m- *[m
[31m- * Queue Based:[m
[31m- * ============[m
[31m- *               +---take---+[m
[31m- *               |          |[m
[31m- *               |          V[m
[31m- *            +====+      +====+[m
[31m- *    +------>| Q1 |      | P2 |-------+[m
[31m- *    |       +====+      +====+       |[m
[31m- *   put                              put[m
[31m- *    |       +====+      +====+       |[m
[31m- *    +-------| P1 |      | Q2 |<------+[m
[31m- *            +====+      +====+[m
[31m- *               ^          |[m
[31m- *               |          |[m
[31m- *               +---take---+[m
[31m- *[m
[31m- * P1 - QueuePinger[m
[31m- * P2 - QueuePonger[m
[31m- * Q1 - PingQueue[m
[31m- * Q2 - PongQueue[m
[31m- *[m
[31m- * </pre>[m
[31m- * <p>[m
[31m- * Note: <b>This test is only useful on a system using an invariant TSC in user space from the System.nanoTime() call.</b>[m
[31m- */[m
[31m-public final class PingPongQueueLatencyTest[m
[31m-{[m
[31m-    private static final int BUFFER_SIZE = 1024;[m
[31m-    private static final long ITERATIONS = 100L * 1000L * 30L;[m
[31m-    private static final long PAUSE_NANOS = 1000L;[m
[31m-    private final ExecutorService executor = Executors.newCachedThreadPool(DaemonThreadFactory.INSTANCE);[m
[31m-[m
[31m-    private final Histogram histogram = new Histogram(10000000000L, 4);[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    private final BlockingQueue<Long> pingQueue = new ArrayBlockingQueue<>(BUFFER_SIZE);[m
[31m-    private final BlockingQueue<Long> pongQueue = new ArrayBlockingQueue<>(BUFFER_SIZE);[m
[31m-    private final QueuePinger qPinger = new QueuePinger(pingQueue, pongQueue, ITERATIONS, PAUSE_NANOS);[m
[31m-    private final QueuePonger qPonger = new QueuePonger(pingQueue, pongQueue);[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    public void testImplementation() throws Exception[m
[31m-    {[m
[31m-        final int runs = 3;[m
[31m-[m
[31m-        for (int i = 0; i < runs; i++)[m
[31m-        {[m
[31m-            System.gc();[m
[31m-            histogram.reset();[m
[31m-[m
[31m-            runQueuePass();[m
[31m-[m
[31m-            System.out.format("%s run %d BlockingQueue %s\n", getClass().getSimpleName(), Long.valueOf(i), histogram);[m
[31m-            dumpHistogram(histogram, System.out);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static void dumpHistogram(final Histogram histogram, final PrintStream out)[m
[31m-    {[m
[31m-        histogram.outputPercentileDistribution(out, 1, 1000.0);[m
[31m-    }[m
[31m-[m
[31m-    private void runQueuePass() throws Exception[m
[31m-    {[m
[31m-        final CountDownLatch latch = new CountDownLatch(1);[m
[31m-        final CyclicBarrier barrier = new CyclicBarrier(3);[m
[31m-        qPinger.reset(barrier, latch, histogram);[m
[31m-        qPonger.reset(barrier);[m
[31m-[m
[31m-        final Future<?> pingFuture = executor.submit(qPinger);[m
[31m-        final Future<?> pongFuture = executor.submit(qPonger);[m
[31m-[m
[31m-        barrier.await();[m
[31m-        latch.await();[m
[31m-[m
[31m-        pingFuture.cancel(true);[m
[31m-        pongFuture.cancel(true);[m
[31m-    }[m
[31m-[m
[31m-    public static void main(final String[] args) throws Exception[m
[31m-    {[m
[31m-        final PingPongQueueLatencyTest test = new PingPongQueueLatencyTest();[m
[31m-        test.testImplementation();[m
[31m-    }[m
[31m-[m
[31m-    private static class QueuePinger implements Runnable[m
[31m-    {[m
[31m-        private final BlockingQueue<Long> pingQueue;[m
[31m-        private final BlockingQueue<Long> pongQueue;[m
[31m-        private final long pauseTimeNs;[m
[31m-[m
[31m-        private Histogram histogram;[m
[31m-        private CyclicBarrier barrier;[m
[31m-        private CountDownLatch latch;[m
[31m-        private long counter;[m
[31m-        private final long maxEvents;[m
[31m-[m
[31m-        QueuePinger([m
[31m-            final BlockingQueue<Long> pingQueue, final BlockingQueue<Long> pongQueue, final long maxEvents,[m
[31m-            final long pauseTimeNs)[m
[31m-        {[m
[31m-            this.pingQueue = pingQueue;[m
[31m-            this.pongQueue = pongQueue;[m
[31m-            this.maxEvents = maxEvents;[m
[31m-            this.pauseTimeNs = pauseTimeNs;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void run()[m
[31m-        {[m
[31m-            try[m
[31m-            {[m
[31m-                barrier.await();[m
[31m-[m
[31m-                Thread.sleep(1000);[m
[31m-[m
[31m-                long counter = 0;[m
[31m-[m
[31m-                while (counter < maxEvents)[m
[31m-                {[m
[31m-                    final long t0 = System.nanoTime();[m
[31m-                    pingQueue.put(1L);[m
[31m-                    counter += pongQueue.take();[m
[31m-                    final long t1 = System.nanoTime();[m
[31m-[m
[31m-                    histogram.recordValueWithExpectedInterval(t1 - t0, pauseTimeNs);[m
[31m-[m
[31m-                    while (pauseTimeNs > (System.nanoTime() - t1))[m
[31m-                    {[m
[31m-                        Thread.yield();[m
[31m-                    }[m
[31m-                }[m
[31m-[m
[31m-                latch.countDown();[m
[31m-            }[m
[31m-            catch (final Exception e)[m
[31m-            {[m
[31m-                e.printStackTrace();[m
[31m-                return;[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        public void reset(final CyclicBarrier barrier, final CountDownLatch latch, final Histogram histogram)[m
[31m-        {[m
[31m-            this.histogram = histogram;[m
[31m-            this.barrier = barrier;[m
[31m-            this.latch = latch;[m
[31m-[m
[31m-            counter = 0;[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class QueuePonger implements Runnable[m
[31m-    {[m
[31m-        private final BlockingQueue<Long> pingQueue;[m
[31m-        private final BlockingQueue<Long> pongQueue;[m
[31m-        private CyclicBarrier barrier;[m
[31m-[m
[31m-        QueuePonger(final BlockingQueue<Long> pingQueue, final BlockingQueue<Long> pongQueue)[m
[31m-        {[m
[31m-            this.pingQueue = pingQueue;[m
[31m-            this.pongQueue = pongQueue;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void run()[m
[31m-        {[m
[31m-            final Thread thread = Thread.currentThread();[m
[31m-            try[m
[31m-            {[m
[31m-                barrier.await();[m
[31m-[m
[31m-                while (!thread.isInterrupted())[m
[31m-                {[m
[31m-                    final Long value = pingQueue.take();[m
[31m-                    pongQueue.put(value);[m
[31m-                }[m
[31m-            }[m
[31m-            catch (final InterruptedException e)[m
[31m-            {[m
[31m-                // do-nothing.[m
[31m-            }[m
[31m-            catch (final Exception e)[m
[31m-            {[m
[31m-                e.printStackTrace();[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        public void reset(final CyclicBarrier barrier)[m
[31m-        {[m
[31m-            this.barrier = barrier;[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/queue/ThreeToOneQueueBatchThroughputTest.java b/src/perftest/java/com/lmax/disruptor/queue/ThreeToOneQueueBatchThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex f70504b..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/queue/ThreeToOneQueueBatchThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,131 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.queue;[m
[31m-[m
[31m-import com.lmax.disruptor.AbstractPerfTestQueue;[m
[31m-import com.lmax.disruptor.support.ValueAdditionQueueBatchProcessor;[m
[31m-import com.lmax.disruptor.support.ValueQueuePublisher;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-import java.util.concurrent.*;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- *[m
[31m- * Sequence a series of events from multiple publishers going to one event processor.[m
[31m- *[m
[31m- * +----+[m
[31m- * | P1 |------+[m
[31m- * +----+      |[m
[31m- *             v[m
[31m- * +----+    +-----+[m
[31m- * | P1 |--->| EP1 |[m
[31m- * +----+    +-----+[m
[31m- *             ^[m
[31m- * +----+      |[m
[31m- * | P3 |------+[m
[31m- * +----+[m
[31m- *[m
[31m- *[m
[31m- * Queue Based:[m
[31m- * ============[m
[31m- *[m
[31m- * +----+  put[m
[31m- * | P1 |------+[m
[31m- * +----+      |[m
[31m- *             v   take[m
[31m- * +----+    +====+    +-----+[m
[31m- * | P2 |--->| Q1 |<---| EP1 |[m
[31m- * +----+    +====+    +-----+[m
[31m- *             ^[m
[31m- * +----+      |[m
[31m- * | P3 |------+[m
[31m- * +----+[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * P2  - Publisher 2[m
[31m- * P3  - Publisher 3[m
[31m- * Q1  - Queue 1[m
[31m- * EP1 - EventProcessor 1[m
[31m- *[m
[31m- * </pre>[m
[31m- */[m
[31m-public final class ThreeToOneQueueBatchThroughputTest extends AbstractPerfTestQueue[m
[31m-{[m
[31m-    private static final int NUM_PUBLISHERS = 3;[m
[31m-    private static final int BUFFER_SIZE = 1024 * 64;[m
[31m-    private static final long ITERATIONS = 1000L * 1000L * 20L;[m
[31m-    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_PUBLISHERS + 1, DaemonThreadFactory.INSTANCE);[m
[31m-    private final CyclicBarrier cyclicBarrier = new CyclicBarrier(NUM_PUBLISHERS + 1);[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    private final BlockingQueue<Long> blockingQueue = new ArrayBlockingQueue<>(BUFFER_SIZE);[m
[31m-    private final ValueAdditionQueueBatchProcessor queueProcessor =[m
[31m-        new ValueAdditionQueueBatchProcessor(blockingQueue, ((ITERATIONS / NUM_PUBLISHERS) * NUM_PUBLISHERS) - 1L);[m
[31m-    private final ValueQueuePublisher[] valueQueuePublishers = new ValueQueuePublisher[NUM_PUBLISHERS];[m
[31m-[m
[31m-    {[m
[31m-        for (int i = 0; i < NUM_PUBLISHERS; i++)[m
[31m-        {[m
[31m-            valueQueuePublishers[i] =[m
[31m-                new ValueQueuePublisher(cyclicBarrier, blockingQueue, ITERATIONS / NUM_PUBLISHERS);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 4;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected long runQueuePass() throws Exception[m
[31m-    {[m
[31m-        final CountDownLatch latch = new CountDownLatch(1);[m
[31m-        queueProcessor.reset(latch);[m
[31m-[m
[31m-        Future<?>[] futures = new Future[NUM_PUBLISHERS];[m
[31m-        for (int i = 0; i < NUM_PUBLISHERS; i++)[m
[31m-        {[m
[31m-            futures[i] = executor.submit(valueQueuePublishers[i]);[m
[31m-        }[m
[31m-        Future<?> processorFuture = executor.submit(queueProcessor);[m
[31m-[m
[31m-        long start = System.currentTimeMillis();[m
[31m-        cyclicBarrier.await();[m
[31m-[m
[31m-        for (int i = 0; i < NUM_PUBLISHERS; i++)[m
[31m-        {[m
[31m-            futures[i].get();[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-[m
[31m-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);[m
[31m-        queueProcessor.halt();[m
[31m-        processorFuture.cancel(true);[m
[31m-[m
[31m-        return opsPerSecond;[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        new ThreeToOneQueueBatchThroughputTest().testImplementations();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/queue/ThreeToOneQueueThroughputTest.java b/src/perftest/java/com/lmax/disruptor/queue/ThreeToOneQueueThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex a0b5e28..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/queue/ThreeToOneQueueThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,137 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.queue;[m
[31m-[m
[31m-import java.util.concurrent.ArrayBlockingQueue;[m
[31m-import java.util.concurrent.BlockingQueue;[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.CyclicBarrier;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-import java.util.concurrent.Future;[m
[31m-[m
[31m-import com.lmax.disruptor.AbstractPerfTestQueue;[m
[31m-import com.lmax.disruptor.support.ValueAdditionQueueProcessor;[m
[31m-import com.lmax.disruptor.support.ValueQueuePublisher;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- *[m
[31m- * Sequence a series of events from multiple publishers going to one event processor.[m
[31m- *[m
[31m- * +----+[m
[31m- * | P1 |------+[m
[31m- * +----+      |[m
[31m- *             v[m
[31m- * +----+    +-----+[m
[31m- * | P1 |--->| EP1 |[m
[31m- * +----+    +-----+[m
[31m- *             ^[m
[31m- * +----+      |[m
[31m- * | P3 |------+[m
[31m- * +----+[m
[31m- *[m
[31m- *[m
[31m- * Queue Based:[m
[31m- * ============[m
[31m- *[m
[31m- * +----+  put[m
[31m- * | P1 |------+[m
[31m- * +----+      |[m
[31m- *             v   take[m
[31m- * +----+    +====+    +-----+[m
[31m- * | P2 |--->| Q1 |<---| EP1 |[m
[31m- * +----+    +====+    +-----+[m
[31m- *             ^[m
[31m- * +----+      |[m
[31m- * | P3 |------+[m
[31m- * +----+[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * P2  - Publisher 2[m
[31m- * P3  - Publisher 3[m
[31m- * Q1  - Queue 1[m
[31m- * EP1 - EventProcessor 1[m
[31m- *[m
[31m- * </pre>[m
[31m- */[m
[31m-public final class ThreeToOneQueueThroughputTest extends AbstractPerfTestQueue[m
[31m-{[m
[31m-    private static final int NUM_PUBLISHERS = 3;[m
[31m-    private static final int BUFFER_SIZE = 1024 * 64;[m
[31m-    private static final long ITERATIONS = 1000L * 1000L * 20L;[m
[31m-    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_PUBLISHERS + 1, DaemonThreadFactory.INSTANCE);[m
[31m-    private final CyclicBarrier cyclicBarrier = new CyclicBarrier(NUM_PUBLISHERS + 1);[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    private final BlockingQueue<Long> blockingQueue = new ArrayBlockingQueue<>(BUFFER_SIZE);[m
[31m-    private final ValueAdditionQueueProcessor queueProcessor =[m
[31m-        new ValueAdditionQueueProcessor(blockingQueue, ((ITERATIONS / NUM_PUBLISHERS) * NUM_PUBLISHERS) - 1L);[m
[31m-    private final ValueQueuePublisher[] valueQueuePublishers = new ValueQueuePublisher[NUM_PUBLISHERS];[m
[31m-[m
[31m-    {[m
[31m-        for (int i = 0; i < NUM_PUBLISHERS; i++)[m
[31m-        {[m
[31m-            valueQueuePublishers[i] =[m
[31m-                new ValueQueuePublisher(cyclicBarrier, blockingQueue, ITERATIONS / NUM_PUBLISHERS);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 4;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected long runQueuePass() throws Exception[m
[31m-    {[m
[31m-        final CountDownLatch latch = new CountDownLatch(1);[m
[31m-        queueProcessor.reset(latch);[m
[31m-[m
[31m-        Future<?>[] futures = new Future[NUM_PUBLISHERS];[m
[31m-        for (int i = 0; i < NUM_PUBLISHERS; i++)[m
[31m-        {[m
[31m-            futures[i] = executor.submit(valueQueuePublishers[i]);[m
[31m-        }[m
[31m-        Future<?> processorFuture = executor.submit(queueProcessor);[m
[31m-[m
[31m-        long start = System.currentTimeMillis();[m
[31m-        cyclicBarrier.await();[m
[31m-[m
[31m-        for (int i = 0; i < NUM_PUBLISHERS; i++)[m
[31m-        {[m
[31m-            futures[i].get();[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-[m
[31m-        long opsPerSecond = (ITERATIONS * 1000L) / (System.currentTimeMillis() - start);[m
[31m-        queueProcessor.halt();[m
[31m-        processorFuture.cancel(true);[m
[31m-[m
[31m-        return opsPerSecond;[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        new ThreeToOneQueueThroughputTest().testImplementations();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/raw/OneToOneRawBatchThroughputTest.java b/src/perftest/java/com/lmax/disruptor/raw/OneToOneRawBatchThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex cc281de..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/raw/OneToOneRawBatchThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,174 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.raw;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-[m
[31m-import com.lmax.disruptor.*;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- * UniCast a series of items between 1 publisher and 1 event processor.[m
[31m- *[m
[31m- * +----+    +-----+[m
[31m- * | P1 |--->| EP1 |[m
[31m- * +----+    +-----+[m
[31m- *[m
[31m- *[m
[31m- * Queue Based:[m
[31m- * ============[m
[31m- *[m
[31m- *        put      take[m
[31m- * +----+    +====+    +-----+[m
[31m- * | P1 |--->| Q1 |<---| EP1 |[m
[31m- * +----+    +====+    +-----+[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * Q1  - Queue 1[m
[31m- * EP1 - EventProcessor 1[m
[31m- *[m
[31m- *[m
[31m- * Disruptor:[m
[31m- * ==========[m
[31m- *              track to prevent wrap[m
[31m- *              +------------------+[m
[31m- *              |                  |[m
[31m- *              |                  v[m
[31m- * +----+    +====+    +====+   +-----+[m
[31m- * | P1 |--->| RB |<---| SB |   | EP1 |[m
[31m- * +----+    +====+    +====+   +-----+[m
[31m- *      claim      get    ^        |[m
[31m- *                        |        |[m
[31m- *                        +--------+[m
[31m- *                          waitFor[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * RB  - RingBuffer[m
[31m- * SB  - SequenceBarrier[m
[31m- * EP1 - EventProcessor 1[m
[31m- *[m
[31m- * </pre>[m
[31m- */[m
[31m-public final class OneToOneRawBatchThroughputTest extends AbstractPerfTestDisruptor[m
[31m-{[m
[31m-    private static final int BUFFER_SIZE = 1024 * 64;[m
[31m-    private static final long ITERATIONS = 1000L * 1000L * 200L;[m
[31m-    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    private final Sequencer sequencer = new SingleProducerSequencer(BUFFER_SIZE, new YieldingWaitStrategy());[m
[31m-    private final MyRunnable myRunnable = new MyRunnable(sequencer);[m
[31m-[m
[31m-    {[m
[31m-        sequencer.addGatingSequences(myRunnable.sequence);[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 2;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected PerfTestContext runDisruptorPass() throws InterruptedException[m
[31m-    {[m
[31m-        PerfTestContext perfTestContext = new PerfTestContext();[m
[31m-        int batchSize = 10;[m
[31m-        final CountDownLatch latch = new CountDownLatch(1);[m
[31m-        long expectedCount = myRunnable.sequence.get() + (ITERATIONS * batchSize);[m
[31m-        myRunnable.reset(latch, expectedCount);[m
[31m-        executor.submit(myRunnable);[m
[31m-        long start = System.currentTimeMillis();[m
[31m-[m
[31m-        final Sequenced sequencer = this.sequencer;[m
[31m-[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            long next = sequencer.next(batchSize);[m
[31m-            sequencer.publish((next - (batchSize - 1)), next);[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-        long end = System.currentTimeMillis();[m
[31m-        perfTestContext.setDisruptorOps((ITERATIONS * 1000L * batchSize) / (end - start));[m
[31m-        waitForEventProcessorSequence(expectedCount);[m
[31m-[m
[31m-        return perfTestContext;[m
[31m-    }[m
[31m-[m
[31m-    private void waitForEventProcessorSequence(long expectedCount) throws InterruptedException[m
[31m-    {[m
[31m-        while (myRunnable.sequence.get() != expectedCount)[m
[31m-        {[m
[31m-            Thread.sleep(1);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class MyRunnable implements Runnable[m
[31m-    {[m
[31m-        private CountDownLatch latch;[m
[31m-        private long expectedCount;[m
[31m-        Sequence sequence = new Sequence(-1);[m
[31m-        private final SequenceBarrier barrier;[m
[31m-[m
[31m-        MyRunnable(Sequencer sequencer)[m
[31m-        {[m
[31m-            this.barrier = sequencer.newBarrier();[m
[31m-        }[m
[31m-[m
[31m-        public void reset(CountDownLatch latch, long expectedCount)[m
[31m-        {[m
[31m-            this.latch = latch;[m
[31m-            this.expectedCount = expectedCount;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void run()[m
[31m-        {[m
[31m-            long expected = expectedCount;[m
[31m-            long processed = -1;[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                do[m
[31m-                {[m
[31m-                    processed = barrier.waitFor(sequence.get() + 1);[m
[31m-                    sequence.set(processed);[m
[31m-                }[m
[31m-                while (processed < expected);[m
[31m-[m
[31m-                latch.countDown();[m
[31m-                sequence.set(processed);[m
[31m-            }[m
[31m-            catch (Exception e)[m
[31m-            {[m
[31m-                e.printStackTrace();[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        OneToOneRawBatchThroughputTest test = new OneToOneRawBatchThroughputTest();[m
[31m-        test.testImplementations();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/raw/OneToOneRawThroughputTest.java b/src/perftest/java/com/lmax/disruptor/raw/OneToOneRawThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex 5b0861d..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/raw/OneToOneRawThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,172 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.raw;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-[m
[31m-import com.lmax.disruptor.*;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- * UniCast a series of items between 1 publisher and 1 event processor.[m
[31m- *[m
[31m- * +----+    +-----+[m
[31m- * | P1 |--->| EP1 |[m
[31m- * +----+    +-----+[m
[31m- *[m
[31m- *[m
[31m- * Queue Based:[m
[31m- * ============[m
[31m- *[m
[31m- *        put      take[m
[31m- * +----+    +====+    +-----+[m
[31m- * | P1 |--->| Q1 |<---| EP1 |[m
[31m- * +----+    +====+    +-----+[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * Q1  - Queue 1[m
[31m- * EP1 - EventProcessor 1[m
[31m- *[m
[31m- *[m
[31m- * Disruptor:[m
[31m- * ==========[m
[31m- *              track to prevent wrap[m
[31m- *              +------------------+[m
[31m- *              |                  |[m
[31m- *              |                  v[m
[31m- * +----+    +====+    +====+   +-----+[m
[31m- * | P1 |--->| RB |<---| SB |   | EP1 |[m
[31m- * +----+    +====+    +====+   +-----+[m
[31m- *      claim      get    ^        |[m
[31m- *                        |        |[m
[31m- *                        +--------+[m
[31m- *                          waitFor[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * RB  - RingBuffer[m
[31m- * SB  - SequenceBarrier[m
[31m- * EP1 - EventProcessor 1[m
[31m- *[m
[31m- * </pre>[m
[31m- */[m
[31m-public final class OneToOneRawThroughputTest extends AbstractPerfTestDisruptor[m
[31m-{[m
[31m-    private static final int BUFFER_SIZE = 1024 * 64;[m
[31m-    private static final long ITERATIONS = 1000L * 1000L * 200L;[m
[31m-    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    private final Sequencer sequencer = new SingleProducerSequencer(BUFFER_SIZE, new YieldingWaitStrategy());[m
[31m-    private final MyRunnable myRunnable = new MyRunnable(sequencer);[m
[31m-[m
[31m-    {[m
[31m-        sequencer.addGatingSequences(myRunnable.sequence);[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 2;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected PerfTestContext runDisruptorPass() throws InterruptedException[m
[31m-    {[m
[31m-        PerfTestContext perfTestContext = new PerfTestContext();[m
[31m-        final CountDownLatch latch = new CountDownLatch(1);[m
[31m-        long expectedCount = myRunnable.sequence.get() + ITERATIONS;[m
[31m-        myRunnable.reset(latch, expectedCount);[m
[31m-        executor.submit(myRunnable);[m
[31m-        long start = System.currentTimeMillis();[m
[31m-[m
[31m-        final Sequenced sequencer = this.sequencer;[m
[31m-[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            long next = sequencer.next();[m
[31m-            sequencer.publish(next);[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-        perfTestContext.setDisruptorOps((ITERATIONS * 1000L) / (System.currentTimeMillis() - start));[m
[31m-        waitForEventProcessorSequence(expectedCount);[m
[31m-[m
[31m-        return perfTestContext;[m
[31m-    }[m
[31m-[m
[31m-    private void waitForEventProcessorSequence(long expectedCount) throws InterruptedException[m
[31m-    {[m
[31m-        while (myRunnable.sequence.get() != expectedCount)[m
[31m-        {[m
[31m-            Thread.sleep(1);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class MyRunnable implements Runnable[m
[31m-    {[m
[31m-        private CountDownLatch latch;[m
[31m-        private long expectedCount;[m
[31m-        Sequence sequence = new Sequence(-1);[m
[31m-        private final SequenceBarrier barrier;[m
[31m-[m
[31m-        MyRunnable(Sequencer sequencer)[m
[31m-        {[m
[31m-            this.barrier = sequencer.newBarrier();[m
[31m-        }[m
[31m-[m
[31m-        public void reset(CountDownLatch latch, long expectedCount)[m
[31m-        {[m
[31m-            this.latch = latch;[m
[31m-            this.expectedCount = expectedCount;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void run()[m
[31m-        {[m
[31m-            long expected = expectedCount;[m
[31m-            long processed = -1;[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                do[m
[31m-                {[m
[31m-                    processed = barrier.waitFor(sequence.get() + 1);[m
[31m-                    sequence.set(processed);[m
[31m-                }[m
[31m-                while (processed < expected);[m
[31m-[m
[31m-                latch.countDown();[m
[31m-                sequence.setVolatile(processed);[m
[31m-            }[m
[31m-            catch (Exception e)[m
[31m-            {[m
[31m-                e.printStackTrace();[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        OneToOneRawThroughputTest test = new OneToOneRawThroughputTest();[m
[31m-        test.testImplementations();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedBatchThroughputTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedBatchThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex 8fe6360..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedBatchThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,136 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.sequenced;[m
[31m-[m
[31m-import static com.lmax.disruptor.RingBuffer.createSingleProducer;[m
[31m-import static com.lmax.disruptor.support.PerfTestUtil.failIfNot;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-[m
[31m-import com.lmax.disruptor.*;[m
[31m-import com.lmax.disruptor.support.PerfTestUtil;[m
[31m-import com.lmax.disruptor.support.ValueAdditionEventHandler;[m
[31m-import com.lmax.disruptor.support.ValueEvent;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- * UniCast a series of items between 1 publisher and 1 event processor.[m
[31m- *[m
[31m- * +----+    +-----+[m
[31m- * | P1 |--->| EP1 |[m
[31m- * +----+    +-----+[m
[31m- *[m
[31m- * Disruptor:[m
[31m- * ==========[m
[31m- *              track to prevent wrap[m
[31m- *              +------------------+[m
[31m- *              |                  |[m
[31m- *              |                  v[m
[31m- * +----+    +====+    +====+   +-----+[m
[31m- * | P1 |--->| RB |<---| SB |   | EP1 |[m
[31m- * +----+    +====+    +====+   +-----+[m
[31m- *      claim      get    ^        |[m
[31m- *                        |        |[m
[31m- *                        +--------+[m
[31m- *                          waitFor[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * RB  - RingBuffer[m
[31m- * SB  - SequenceBarrier[m
[31m- * EP1 - EventProcessor 1[m
[31m- *[m
[31m- * </pre>[m
[31m- */[m
[31m-public final class OneToOneSequencedBatchThroughputTest extends AbstractPerfTestDisruptor[m
[31m-{[m
[31m-    public static final int BATCH_SIZE = 10;[m
[31m-    private static final int BUFFER_SIZE = 1024 * 64;[m
[31m-    private static final long ITERATIONS = 1000L * 1000L * 100L;[m
[31m-    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);[m
[31m-    private final long expectedResult = PerfTestUtil.accumulatedAddition(ITERATIONS) * BATCH_SIZE;[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    private final RingBuffer<ValueEvent> ringBuffer =[m
[31m-        createSingleProducer(ValueEvent.EVENT_FACTORY, BUFFER_SIZE, new YieldingWaitStrategy());[m
[31m-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();[m
[31m-    private final ValueAdditionEventHandler handler = new ValueAdditionEventHandler();[m
[31m-    private final BatchEventProcessor<ValueEvent> batchEventProcessor =[m
[31m-            new BatchEventProcessor<>(ringBuffer, sequenceBarrier, handler);[m
[31m-[m
[31m-    {[m
[31m-        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 2;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected PerfTestContext runDisruptorPass() throws InterruptedException[m
[31m-    {[m
[31m-        PerfTestContext perfTestContext = new PerfTestContext();[m
[31m-        final CountDownLatch latch = new CountDownLatch(1);[m
[31m-        long expectedCount = batchEventProcessor.getSequence().get() + ITERATIONS * BATCH_SIZE;[m
[31m-        handler.reset(latch, expectedCount);[m
[31m-        executor.submit(batchEventProcessor);[m
[31m-        long start = System.currentTimeMillis();[m
[31m-[m
[31m-        final RingBuffer<ValueEvent> rb = ringBuffer;[m
[31m-[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            long hi = rb.next(BATCH_SIZE);[m
[31m-            long lo = hi - (BATCH_SIZE - 1);[m
[31m-            for (long l = lo; l <= hi; l++)[m
[31m-            {[m
[31m-                rb.get(l).setValue(i);[m
[31m-            }[m
[31m-            rb.publish(lo, hi);[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-        perfTestContext.setDisruptorOps((BATCH_SIZE * ITERATIONS * 1000L) / (System.currentTimeMillis() - start));[m
[31m-        perfTestContext.setBatchData(handler.getBatchesProcessed(), ITERATIONS * BATCH_SIZE);[m
[31m-        waitForEventProcessorSequence(expectedCount);[m
[31m-        batchEventProcessor.halt();[m
[31m-[m
[31m-        failIfNot(expectedResult, handler.getValue());[m
[31m-[m
[31m-        return perfTestContext;[m
[31m-    }[m
[31m-[m
[31m-    private void waitForEventProcessorSequence(long expectedCount) throws InterruptedException[m
[31m-    {[m
[31m-        while (batchEventProcessor.getSequence().get() != expectedCount)[m
[31m-        {[m
[31m-            Thread.sleep(1);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        OneToOneSequencedBatchThroughputTest test = new OneToOneSequencedBatchThroughputTest();[m
[31m-        test.testImplementations();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedLongArrayThroughputTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedLongArrayThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex 1e75679..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedLongArrayThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,134 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.sequenced;[m
[31m-[m
[31m-import static com.lmax.disruptor.RingBuffer.createSingleProducer;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-[m
[31m-import com.lmax.disruptor.*;[m
[31m-import com.lmax.disruptor.support.LongArrayEventHandler;[m
[31m-import com.lmax.disruptor.support.PerfTestUtil;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- * UniCast a series of items between 1 publisher and 1 event processor.[m
[31m- *[m
[31m- * +----+    +-----+[m
[31m- * | P1 |--->| EP1 |[m
[31m- * +----+    +-----+[m
[31m- *[m
[31m- * Disruptor:[m
[31m- * ==========[m
[31m- *              track to prevent wrap[m
[31m- *              +------------------+[m
[31m- *              |                  |[m
[31m- *              |                  v[m
[31m- * +----+    +====+    +====+   +-----+[m
[31m- * | P1 |--->| RB |<---| SB |   | EP1 |[m
[31m- * +----+    +====+    +====+   +-----+[m
[31m- *      claim      get    ^        |[m
[31m- *                        |        |[m
[31m- *                        +--------+[m
[31m- *                          waitFor[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * RB  - RingBuffer[m
[31m- * SB  - SequenceBarrier[m
[31m- * EP1 - EventProcessor 1[m
[31m- *[m
[31m- * </pre>[m
[31m- */[m
[31m-public final class OneToOneSequencedLongArrayThroughputTest extends AbstractPerfTestDisruptor[m
[31m-{[m
[31m-    private static final int BUFFER_SIZE = 1024 * 1;[m
[31m-    private static final long ITERATIONS = 1000L * 1000L * 1L;[m
[31m-    private static final int ARRAY_SIZE = 2 * 1024;[m
[31m-    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);[m
[31m-[m
[31m-    private static final EventFactory<long[]> FACTORY = () -> new long[ARRAY_SIZE];[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    private final RingBuffer<long[]> ringBuffer =[m
[31m-        createSingleProducer(FACTORY, BUFFER_SIZE, new YieldingWaitStrategy());[m
[31m-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();[m
[31m-    private final LongArrayEventHandler handler = new LongArrayEventHandler();[m
[31m-    private final BatchEventProcessor<long[]> batchEventProcessor =[m
[31m-            new BatchEventProcessor<>(ringBuffer, sequenceBarrier, handler);[m
[31m-[m
[31m-    {[m
[31m-        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 2;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected PerfTestContext runDisruptorPass() throws InterruptedException[m
[31m-    {[m
[31m-        PerfTestContext perfTestContext = new PerfTestContext();[m
[31m-        final CountDownLatch latch = new CountDownLatch(1);[m
[31m-        long expectedCount = batchEventProcessor.getSequence().get() + ITERATIONS;[m
[31m-        handler.reset(latch, ITERATIONS);[m
[31m-        executor.submit(batchEventProcessor);[m
[31m-        long start = System.currentTimeMillis();[m
[31m-[m
[31m-        final RingBuffer<long[]> rb = ringBuffer;[m
[31m-[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            long next = rb.next();[m
[31m-            long[] event = rb.get(next);[m
[31m-            for (int j = 0; j < event.length; j++)[m
[31m-            {[m
[31m-                event[j] = i;[m
[31m-            }[m
[31m-            rb.publish(next);[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-        perfTestContext.setDisruptorOps((ITERATIONS * ARRAY_SIZE * 1000L) / (System.currentTimeMillis() - start));[m
[31m-        perfTestContext.setBatchData(handler.getBatchesProcessed(), ITERATIONS);[m
[31m-        waitForEventProcessorSequence(expectedCount);[m
[31m-        batchEventProcessor.halt();[m
[31m-[m
[31m-        PerfTestUtil.failIf(0, handler.getValue());[m
[31m-[m
[31m-        return perfTestContext;[m
[31m-    }[m
[31m-[m
[31m-    private void waitForEventProcessorSequence(long expectedCount) throws InterruptedException[m
[31m-    {[m
[31m-        while (batchEventProcessor.getSequence().get() != expectedCount)[m
[31m-        {[m
[31m-            Thread.sleep(1);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        OneToOneSequencedLongArrayThroughputTest test = new OneToOneSequencedLongArrayThroughputTest();[m
[31m-        test.testImplementations();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedPollerThroughputTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedPollerThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex 966c5cd..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedPollerThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,208 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.sequenced;[m
[31m-[m
[31m-import static com.lmax.disruptor.RingBuffer.createSingleProducer;[m
[31m-import static com.lmax.disruptor.support.PerfTestUtil.failIfNot;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-[m
[31m-import com.lmax.disruptor.*;[m
[31m-import com.lmax.disruptor.EventPoller.PollState;[m
[31m-import com.lmax.disruptor.support.PerfTestUtil;[m
[31m-import com.lmax.disruptor.support.ValueEvent;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-import com.lmax.disruptor.util.PaddedLong;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- * UniCast a series of items between 1 publisher and 1 event processor.[m
[31m- *[m
[31m- * +----+    +-----+[m
[31m- * | P1 |--->| EP1 |[m
[31m- * +----+    +-----+[m
[31m- *[m
[31m- * Disruptor:[m
[31m- * ==========[m
[31m- *              track to prevent wrap[m
[31m- *              +------------------+[m
[31m- *              |                  |[m
[31m- *              |                  v[m
[31m- * +----+    +====+    +====+   +-----+[m
[31m- * | P1 |--->| RB |<---| SB |   | EP1 |[m
[31m- * +----+    +====+    +====+   +-----+[m
[31m- *      claim      get    ^        |[m
[31m- *                        |        |[m
[31m- *                        +--------+[m
[31m- *                          waitFor[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * RB  - RingBuffer[m
[31m- * SB  - SequenceBarrier[m
[31m- * EP1 - EventProcessor 1[m
[31m- *[m
[31m- * </pre>[m
[31m- */[m
[31m-public final class OneToOneSequencedPollerThroughputTest extends AbstractPerfTestDisruptor[m
[31m-{[m
[31m-    private static final int BUFFER_SIZE = 1024 * 64;[m
[31m-    private static final long ITERATIONS = 1000L * 1000L * 100L;[m
[31m-    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);[m
[31m-    private final long expectedResult = PerfTestUtil.accumulatedAddition(ITERATIONS);[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    private final RingBuffer<ValueEvent> ringBuffer =[m
[31m-        createSingleProducer(ValueEvent.EVENT_FACTORY, BUFFER_SIZE, new YieldingWaitStrategy());[m
[31m-[m
[31m-    private final EventPoller<ValueEvent> poller = ringBuffer.newPoller();[m
[31m-    private final PollRunnable pollRunnable = new PollRunnable(poller);[m
[31m-[m
[31m-    {[m
[31m-        ringBuffer.addGatingSequences(poller.getSequence());[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 2;[m
[31m-    }[m
[31m-[m
[31m-    private static class PollRunnable implements Runnable, EventPoller.Handler<ValueEvent>, BatchStartAware[m
[31m-    {[m
[31m-        private final EventPoller<ValueEvent> poller;[m
[31m-        private volatile boolean running = true;[m
[31m-        private final PaddedLong value = new PaddedLong();[m
[31m-        private final PaddedLong batchesProcessed = new PaddedLong();[m
[31m-        private CountDownLatch latch;[m
[31m-        private long count;[m
[31m-[m
[31m-        PollRunnable(EventPoller<ValueEvent> poller)[m
[31m-        {[m
[31m-            this.poller = poller;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void run()[m
[31m-        {[m
[31m-            try[m
[31m-            {[m
[31m-                while (running)[m
[31m-                {[m
[31m-                    if (PollState.PROCESSING != poller.poll(this))[m
[31m-                    {[m
[31m-                        Thread.yield();[m
[31m-                    }[m
[31m-                }[m
[31m-            }[m
[31m-            catch (Exception e)[m
[31m-            {[m
[31m-                e.printStackTrace();[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public boolean onEvent(ValueEvent event, long sequence, boolean endOfBatch)[m
[31m-        {[m
[31m-            value.set(value.get() + event.getValue());[m
[31m-[m
[31m-            if (count == sequence)[m
[31m-            {[m
[31m-                latch.countDown();[m
[31m-            }[m
[31m-[m
[31m-            return true;[m
[31m-        }[m
[31m-[m
[31m-        public void halt()[m
[31m-        {[m
[31m-            running = false;[m
[31m-        }[m
[31m-[m
[31m-        public void reset(final CountDownLatch latch, final long expectedCount)[m
[31m-        {[m
[31m-            value.set(0L);[m
[31m-            this.latch = latch;[m
[31m-            count = expectedCount;[m
[31m-            batchesProcessed.set(0);[m
[31m-            running = true;[m
[31m-        }[m
[31m-[m
[31m-        public long getValue()[m
[31m-        {[m
[31m-            return value.get();[m
[31m-        }[m
[31m-[m
[31m-        public long getBatchesProcessed()[m
[31m-        {[m
[31m-            return batchesProcessed.get();[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onBatchStart(long batchSize)[m
[31m-        {[m
[31m-            batchesProcessed.increment();[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected PerfTestContext runDisruptorPass() throws InterruptedException[m
[31m-    {[m
[31m-        PerfTestContext perfTestContext = new PerfTestContext();[m
[31m-        final CountDownLatch latch = new CountDownLatch(1);[m
[31m-        long expectedCount = poller.getSequence().get() + ITERATIONS;[m
[31m-        pollRunnable.reset(latch, expectedCount);[m
[31m-        executor.submit(pollRunnable);[m
[31m-        long start = System.currentTimeMillis();[m
[31m-[m
[31m-        final RingBuffer<ValueEvent> rb = ringBuffer;[m
[31m-[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            long next = rb.next();[m
[31m-            rb.get(next).setValue(i);[m
[31m-            rb.publish(next);[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-        perfTestContext.setDisruptorOps((ITERATIONS * 1000L) / (System.currentTimeMillis() - start));[m
[31m-        perfTestContext.setBatchData(pollRunnable.getBatchesProcessed(), ITERATIONS);[m
[31m-        waitForEventProcessorSequence(expectedCount);[m
[31m-        pollRunnable.halt();[m
[31m-[m
[31m-        failIfNot(expectedResult, pollRunnable.getValue());[m
[31m-[m
[31m-        return perfTestContext;[m
[31m-    }[m
[31m-[m
[31m-    private void waitForEventProcessorSequence(long expectedCount) throws InterruptedException[m
[31m-    {[m
[31m-        while (poller.getSequence().get() != expectedCount)[m
[31m-        {[m
[31m-            Thread.sleep(1);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        OneToOneSequencedPollerThroughputTest test = new OneToOneSequencedPollerThroughputTest();[m
[31m-        test.testImplementations();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedThroughputTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex 6c21f37..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,131 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.sequenced;[m
[31m-[m
[31m-import static com.lmax.disruptor.RingBuffer.createSingleProducer;[m
[31m-import static com.lmax.disruptor.support.PerfTestUtil.failIfNot;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-[m
[31m-import com.lmax.disruptor.*;[m
[31m-import com.lmax.disruptor.support.PerfTestUtil;[m
[31m-import com.lmax.disruptor.support.ValueAdditionEventHandler;[m
[31m-import com.lmax.disruptor.support.ValueEvent;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- * UniCast a series of items between 1 publisher and 1 event processor.[m
[31m- *[m
[31m- * +----+    +-----+[m
[31m- * | P1 |--->| EP1 |[m
[31m- * +----+    +-----+[m
[31m- *[m
[31m- * Disruptor:[m
[31m- * ==========[m
[31m- *              track to prevent wrap[m
[31m- *              +------------------+[m
[31m- *              |                  |[m
[31m- *              |                  v[m
[31m- * +----+    +====+    +====+   +-----+[m
[31m- * | P1 |--->| RB |<---| SB |   | EP1 |[m
[31m- * +----+    +====+    +====+   +-----+[m
[31m- *      claim      get    ^        |[m
[31m- *                        |        |[m
[31m- *                        +--------+[m
[31m- *                          waitFor[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * RB  - RingBuffer[m
[31m- * SB  - SequenceBarrier[m
[31m- * EP1 - EventProcessor 1[m
[31m- *[m
[31m- * </pre>[m
[31m- */[m
[31m-public final class OneToOneSequencedThroughputTest extends AbstractPerfTestDisruptor[m
[31m-{[m
[31m-    private static final int BUFFER_SIZE = 1024 * 64;[m
[31m-    private static final long ITERATIONS = 1000L * 1000L * 100L;[m
[31m-    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);[m
[31m-    private final long expectedResult = PerfTestUtil.accumulatedAddition(ITERATIONS);[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    private final RingBuffer<ValueEvent> ringBuffer =[m
[31m-        createSingleProducer(ValueEvent.EVENT_FACTORY, BUFFER_SIZE, new YieldingWaitStrategy());[m
[31m-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();[m
[31m-    private final ValueAdditionEventHandler handler = new ValueAdditionEventHandler();[m
[31m-    private final BatchEventProcessor<ValueEvent> batchEventProcessor =[m
[31m-            new BatchEventProcessor<>(ringBuffer, sequenceBarrier, handler);[m
[31m-[m
[31m-    {[m
[31m-        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 2;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected PerfTestContext runDisruptorPass() throws InterruptedException[m
[31m-    {[m
[31m-        PerfTestContext perfTestContext = new PerfTestContext();[m
[31m-        final CountDownLatch latch = new CountDownLatch(1);[m
[31m-        long expectedCount = batchEventProcessor.getSequence().get() + ITERATIONS;[m
[31m-        handler.reset(latch, expectedCount);[m
[31m-        executor.submit(batchEventProcessor);[m
[31m-        long start = System.currentTimeMillis();[m
[31m-[m
[31m-        final RingBuffer<ValueEvent> rb = ringBuffer;[m
[31m-[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            long next = rb.next();[m
[31m-            rb.get(next).setValue(i);[m
[31m-            rb.publish(next);[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-        perfTestContext.setDisruptorOps((ITERATIONS * 1000L) / (System.currentTimeMillis() - start));[m
[31m-        perfTestContext.setBatchData(handler.getBatchesProcessed(), ITERATIONS);[m
[31m-        waitForEventProcessorSequence(expectedCount);[m
[31m-        batchEventProcessor.halt();[m
[31m-[m
[31m-        failIfNot(expectedResult, handler.getValue());[m
[31m-[m
[31m-        return perfTestContext;[m
[31m-    }[m
[31m-[m
[31m-    private void waitForEventProcessorSequence(long expectedCount) throws InterruptedException[m
[31m-    {[m
[31m-        while (batchEventProcessor.getSequence().get() != expectedCount)[m
[31m-        {[m
[31m-            Thread.sleep(1);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        OneToOneSequencedThroughputTest test = new OneToOneSequencedThroughputTest();[m
[31m-        test.testImplementations();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/sequenced/OneToThreeDiamondSequencedThroughputTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/OneToThreeDiamondSequencedThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex 3e617d2..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/sequenced/OneToThreeDiamondSequencedThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,172 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.sequenced;[m
[31m-[m
[31m-import static com.lmax.disruptor.RingBuffer.createSingleProducer;[m
[31m-import static com.lmax.disruptor.support.PerfTestUtil.failIfNot;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-[m
[31m-import com.lmax.disruptor.*;[m
[31m-import com.lmax.disruptor.support.FizzBuzzEvent;[m
[31m-import com.lmax.disruptor.support.FizzBuzzEventHandler;[m
[31m-import com.lmax.disruptor.support.FizzBuzzStep;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- * Produce an event replicated to two event processors and fold back to a single third event processor.[m
[31m- *[m
[31m- *           +-----+[m
[31m- *    +----->| EP1 |------+[m
[31m- *    |      +-----+      |[m
[31m- *    |                   v[m
[31m- * +----+              +-----+[m
[31m- * | P1 |              | EP3 |[m
[31m- * +----+              +-----+[m
[31m- *    |                   ^[m
[31m- *    |      +-----+      |[m
[31m- *    +----->| EP2 |------+[m
[31m- *           +-----+[m
[31m- *[m
[31m- * Disruptor:[m
[31m- * ==========[m
[31m- *                    track to prevent wrap[m
[31m- *              +-------------------------------+[m
[31m- *              |                               |[m
[31m- *              |                               v[m
[31m- * +----+    +====+               +=====+    +-----+[m
[31m- * | P1 |--->| RB |<--------------| SB2 |<---| EP3 |[m
[31m- * +----+    +====+               +=====+    +-----+[m
[31m- *      claim   ^  get               |   waitFor[m
[31m- *              |                    |[m
[31m- *           +=====+    +-----+      |[m
[31m- *           | SB1 |<---| EP1 |<-----+[m
[31m- *           +=====+    +-----+      |[m
[31m- *              ^                    |[m
[31m- *              |       +-----+      |[m
[31m- *              +-------| EP2 |<-----+[m
[31m- *             waitFor  +-----+[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * RB  - RingBuffer[m
[31m- * SB1 - SequenceBarrier 1[m
[31m- * EP1 - EventProcessor 1[m
[31m- * EP2 - EventProcessor 2[m
[31m- * SB2 - SequenceBarrier 2[m
[31m- * EP3 - EventProcessor 3[m
[31m- *[m
[31m- * </pre>[m
[31m- */[m
[31m-public final class OneToThreeDiamondSequencedThroughputTest extends AbstractPerfTestDisruptor[m
[31m-{[m
[31m-    private static final int NUM_EVENT_PROCESSORS = 3;[m
[31m-    private static final int BUFFER_SIZE = 1024 * 8;[m
[31m-    private static final long ITERATIONS = 1000L * 1000L * 100L;[m
[31m-    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_EVENT_PROCESSORS, DaemonThreadFactory.INSTANCE);[m
[31m-[m
[31m-    private final long expectedResult;[m
[31m-[m
[31m-    {[m
[31m-        long temp = 0L;[m
[31m-[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            boolean fizz = 0 == (i % 3L);[m
[31m-            boolean buzz = 0 == (i % 5L);[m
[31m-[m
[31m-            if (fizz && buzz)[m
[31m-            {[m
[31m-                ++temp;[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        expectedResult = temp;[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    private final RingBuffer<FizzBuzzEvent> ringBuffer =[m
[31m-        createSingleProducer(FizzBuzzEvent.EVENT_FACTORY, BUFFER_SIZE, new YieldingWaitStrategy());[m
[31m-[m
[31m-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();[m
[31m-[m
[31m-    private final FizzBuzzEventHandler fizzHandler = new FizzBuzzEventHandler(FizzBuzzStep.FIZZ);[m
[31m-    private final BatchEventProcessor<FizzBuzzEvent> batchProcessorFizz =[m
[31m-            new BatchEventProcessor<>(ringBuffer, sequenceBarrier, fizzHandler);[m
[31m-[m
[31m-    private final FizzBuzzEventHandler buzzHandler = new FizzBuzzEventHandler(FizzBuzzStep.BUZZ);[m
[31m-    private final BatchEventProcessor<FizzBuzzEvent> batchProcessorBuzz =[m
[31m-            new BatchEventProcessor<>(ringBuffer, sequenceBarrier, buzzHandler);[m
[31m-[m
[31m-    private final SequenceBarrier sequenceBarrierFizzBuzz =[m
[31m-        ringBuffer.newBarrier(batchProcessorFizz.getSequence(), batchProcessorBuzz.getSequence());[m
[31m-[m
[31m-    private final FizzBuzzEventHandler fizzBuzzHandler = new FizzBuzzEventHandler(FizzBuzzStep.FIZZ_BUZZ);[m
[31m-    private final BatchEventProcessor<FizzBuzzEvent> batchProcessorFizzBuzz =[m
[31m-            new BatchEventProcessor<>(ringBuffer, sequenceBarrierFizzBuzz, fizzBuzzHandler);[m
[31m-[m
[31m-    {[m
[31m-        ringBuffer.addGatingSequences(batchProcessorFizzBuzz.getSequence());[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 4;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected PerfTestContext runDisruptorPass() throws Exception[m
[31m-    {[m
[31m-        PerfTestContext perfTestContext = new PerfTestContext();[m
[31m-        CountDownLatch latch = new CountDownLatch(1);[m
[31m-        fizzBuzzHandler.reset(latch, batchProcessorFizzBuzz.getSequence().get() + ITERATIONS);[m
[31m-[m
[31m-        executor.submit(batchProcessorFizz);[m
[31m-        executor.submit(batchProcessorBuzz);[m
[31m-        executor.submit(batchProcessorFizzBuzz);[m
[31m-[m
[31m-        long start = System.currentTimeMillis();[m
[31m-[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            long sequence = ringBuffer.next();[m
[31m-            ringBuffer.get(sequence).setValue(i);[m
[31m-            ringBuffer.publish(sequence);[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-        perfTestContext.setDisruptorOps((ITERATIONS * 1000L) / (System.currentTimeMillis() - start));[m
[31m-[m
[31m-        batchProcessorFizz.halt();[m
[31m-        batchProcessorBuzz.halt();[m
[31m-        batchProcessorFizzBuzz.halt();[m
[31m-[m
[31m-        failIfNot(expectedResult, fizzBuzzHandler.getFizzBuzzCounter());[m
[31m-[m
[31m-        return perfTestContext;[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        new OneToThreeDiamondSequencedThroughputTest().testImplementations();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/sequenced/OneToThreePipelineSequencedThroughputTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/OneToThreePipelineSequencedThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex f344fb5..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/sequenced/OneToThreePipelineSequencedThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,167 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.sequenced;[m
[31m-[m
[31m-import static com.lmax.disruptor.RingBuffer.createSingleProducer;[m
[31m-import static com.lmax.disruptor.support.PerfTestUtil.failIfNot;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-[m
[31m-import com.lmax.disruptor.*;[m
[31m-import com.lmax.disruptor.support.FunctionEvent;[m
[31m-import com.lmax.disruptor.support.FunctionEventHandler;[m
[31m-import com.lmax.disruptor.support.FunctionStep;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- *[m
[31m- * Pipeline a series of stages from a publisher to ultimate event processor.[m
[31m- * Each event processor depends on the output of the event processor.[m
[31m- *[m
[31m- * +----+    +-----+    +-----+    +-----+[m
[31m- * | P1 |--->| EP1 |--->| EP2 |--->| EP3 |[m
[31m- * +----+    +-----+    +-----+    +-----+[m
[31m- *[m
[31m- *[m
[31m- * Disruptor:[m
[31m- * ==========[m
[31m- *                           track to prevent wrap[m
[31m- *              +----------------------------------------------------------------+[m
[31m- *              |                                                                |[m
[31m- *              |                                                                v[m
[31m- * +----+    +====+    +=====+    +-----+    +=====+    +-----+    +=====+    +-----+[m
[31m- * | P1 |--->| RB |    | SB1 |<---| EP1 |<---| SB2 |<---| EP2 |<---| SB3 |<---| EP3 |[m
[31m- * +----+    +====+    +=====+    +-----+    +=====+    +-----+    +=====+    +-----+[m
[31m- *      claim   ^  get    |   waitFor           |   waitFor           |  waitFor[m
[31m- *              |         |                     |                     |[m
[31m- *              +---------+---------------------+---------------------+[m
[31m- *        </pre>[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * RB  - RingBuffer[m
[31m- * SB1 - SequenceBarrier 1[m
[31m- * EP1 - EventProcessor 1[m
[31m- * SB2 - SequenceBarrier 2[m
[31m- * EP2 - EventProcessor 2[m
[31m- * SB3 - SequenceBarrier 3[m
[31m- * EP3 - EventProcessor 3[m
[31m- *[m
[31m- * </pre>[m
[31m- */[m
[31m-public final class OneToThreePipelineSequencedThroughputTest extends AbstractPerfTestDisruptor[m
[31m-{[m
[31m-    private static final int NUM_EVENT_PROCESSORS = 3;[m
[31m-    private static final int BUFFER_SIZE = 1024 * 8;[m
[31m-    private static final long ITERATIONS = 1000L * 1000L * 100L;[m
[31m-    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_EVENT_PROCESSORS, DaemonThreadFactory.INSTANCE);[m
[31m-[m
[31m-    private static final long OPERAND_TWO_INITIAL_VALUE = 777L;[m
[31m-    private final long expectedResult;[m
[31m-[m
[31m-    {[m
[31m-        long temp = 0L;[m
[31m-        long operandTwo = OPERAND_TWO_INITIAL_VALUE;[m
[31m-[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            long stepOneResult = i + operandTwo--;[m
[31m-            long stepTwoResult = stepOneResult + 3;[m
[31m-[m
[31m-            if ((stepTwoResult & 4L) == 4L)[m
[31m-            {[m
[31m-                ++temp;[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        expectedResult = temp;[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    private final RingBuffer<FunctionEvent> ringBuffer =[m
[31m-        createSingleProducer(FunctionEvent.EVENT_FACTORY, BUFFER_SIZE, new YieldingWaitStrategy());[m
[31m-[m
[31m-    private final SequenceBarrier stepOneSequenceBarrier = ringBuffer.newBarrier();[m
[31m-    private final FunctionEventHandler stepOneFunctionHandler = new FunctionEventHandler(FunctionStep.ONE);[m
[31m-    private final BatchEventProcessor<FunctionEvent> stepOneBatchProcessor =[m
[31m-            new BatchEventProcessor<>(ringBuffer, stepOneSequenceBarrier, stepOneFunctionHandler);[m
[31m-[m
[31m-    private final SequenceBarrier stepTwoSequenceBarrier = ringBuffer.newBarrier(stepOneBatchProcessor.getSequence());[m
[31m-    private final FunctionEventHandler stepTwoFunctionHandler = new FunctionEventHandler(FunctionStep.TWO);[m
[31m-    private final BatchEventProcessor<FunctionEvent> stepTwoBatchProcessor =[m
[31m-            new BatchEventProcessor<>(ringBuffer, stepTwoSequenceBarrier, stepTwoFunctionHandler);[m
[31m-[m
[31m-    private final SequenceBarrier stepThreeSequenceBarrier = ringBuffer.newBarrier(stepTwoBatchProcessor.getSequence());[m
[31m-    private final FunctionEventHandler stepThreeFunctionHandler = new FunctionEventHandler(FunctionStep.THREE);[m
[31m-    private final BatchEventProcessor<FunctionEvent> stepThreeBatchProcessor =[m
[31m-            new BatchEventProcessor<>(ringBuffer, stepThreeSequenceBarrier, stepThreeFunctionHandler);[m
[31m-[m
[31m-    {[m
[31m-        ringBuffer.addGatingSequences(stepThreeBatchProcessor.getSequence());[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 4;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected PerfTestContext runDisruptorPass() throws InterruptedException[m
[31m-    {[m
[31m-        PerfTestContext perfTestContext = new PerfTestContext();[m
[31m-[m
[31m-        CountDownLatch latch = new CountDownLatch(1);[m
[31m-        stepThreeFunctionHandler.reset(latch, stepThreeBatchProcessor.getSequence().get() + ITERATIONS);[m
[31m-[m
[31m-        executor.submit(stepOneBatchProcessor);[m
[31m-        executor.submit(stepTwoBatchProcessor);[m
[31m-        executor.submit(stepThreeBatchProcessor);[m
[31m-[m
[31m-        long start = System.currentTimeMillis();[m
[31m-[m
[31m-        long operandTwo = OPERAND_TWO_INITIAL_VALUE;[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            long sequence = ringBuffer.next();[m
[31m-            FunctionEvent event = ringBuffer.get(sequence);[m
[31m-            event.setOperandOne(i);[m
[31m-            event.setOperandTwo(operandTwo--);[m
[31m-            ringBuffer.publish(sequence);[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-        perfTestContext.setDisruptorOps((ITERATIONS * 1000L) / (System.currentTimeMillis() - start));[m
[31m-[m
[31m-        stepOneBatchProcessor.halt();[m
[31m-        stepTwoBatchProcessor.halt();[m
[31m-        stepThreeBatchProcessor.halt();[m
[31m-[m
[31m-        failIfNot(expectedResult, stepThreeFunctionHandler.getStepThreeCounter());[m
[31m-[m
[31m-        return perfTestContext;[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        new OneToThreePipelineSequencedThroughputTest().testImplementations();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/sequenced/OneToThreeSequencedThroughputTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/OneToThreeSequencedThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex b7edd5c..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/sequenced/OneToThreeSequencedThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,171 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.sequenced;[m
[31m-[m
[31m-import static com.lmax.disruptor.RingBuffer.createSingleProducer;[m
[31m-import static com.lmax.disruptor.support.PerfTestUtil.failIfNot;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-[m
[31m-import com.lmax.disruptor.*;[m
[31m-import com.lmax.disruptor.support.Operation;[m
[31m-import com.lmax.disruptor.support.ValueEvent;[m
[31m-import com.lmax.disruptor.support.ValueMutationEventHandler;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- *[m
[31m- * MultiCast a series of items between 1 publisher and 3 event processors.[m
[31m- *[m
[31m- *           +-----+[m
[31m- *    +----->| EP1 |[m
[31m- *    |      +-----+[m
[31m- *    |[m
[31m- * +----+    +-----+[m
[31m- * | P1 |--->| EP2 |[m
[31m- * +----+    +-----+[m
[31m- *    |[m
[31m- *    |      +-----+[m
[31m- *    +----->| EP3 |[m
[31m- *           +-----+[m
[31m- *[m
[31m- * Disruptor:[m
[31m- * ==========[m
[31m- *                             track to prevent wrap[m
[31m- *             +--------------------+----------+----------+[m
[31m- *             |                    |          |          |[m
[31m- *             |                    v          v          v[m
[31m- * +----+    +====+    +====+    +-----+    +-----+    +-----+[m
[31m- * | P1 |--->| RB |<---| SB |    | EP1 |    | EP2 |    | EP3 |[m
[31m- * +----+    +====+    +====+    +-----+    +-----+    +-----+[m
[31m- *      claim      get    ^         |          |          |[m
[31m- *                        |         |          |          |[m
[31m- *                        +---------+----------+----------+[m
[31m- *                                      waitFor[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * RB  - RingBuffer[m
[31m- * SB  - SequenceBarrier[m
[31m- * EP1 - EventProcessor 1[m
[31m- * EP2 - EventProcessor 2[m
[31m- * EP3 - EventProcessor 3[m
[31m- *[m
[31m- * </pre>[m
[31m- */[m
[31m-public final class OneToThreeSequencedThroughputTest extends AbstractPerfTestDisruptor[m
[31m-{[m
[31m-    private static final int NUM_EVENT_PROCESSORS = 3;[m
[31m-    private static final int BUFFER_SIZE = 1024 * 8;[m
[31m-    private static final long ITERATIONS = 1000L * 1000L * 100L;[m
[31m-    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_EVENT_PROCESSORS, DaemonThreadFactory.INSTANCE);[m
[31m-[m
[31m-    private final long[] results = new long[NUM_EVENT_PROCESSORS];[m
[31m-[m
[31m-    {[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            results[0] = Operation.ADDITION.op(results[0], i);[m
[31m-            results[1] = Operation.SUBTRACTION.op(results[1], i);[m
[31m-            results[2] = Operation.AND.op(results[2], i);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    private final RingBuffer<ValueEvent> ringBuffer =[m
[31m-        createSingleProducer(ValueEvent.EVENT_FACTORY, BUFFER_SIZE, new YieldingWaitStrategy());[m
[31m-[m
[31m-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();[m
[31m-[m
[31m-    private final ValueMutationEventHandler[] handlers = new ValueMutationEventHandler[NUM_EVENT_PROCESSORS];[m
[31m-[m
[31m-    {[m
[31m-        handlers[0] = new ValueMutationEventHandler(Operation.ADDITION);[m
[31m-        handlers[1] = new ValueMutationEventHandler(Operation.SUBTRACTION);[m
[31m-        handlers[2] = new ValueMutationEventHandler(Operation.AND);[m
[31m-    }[m
[31m-[m
[31m-    private final BatchEventProcessor<?>[] batchEventProcessors = new BatchEventProcessor[NUM_EVENT_PROCESSORS];[m
[31m-[m
[31m-    {[m
[31m-        batchEventProcessors[0] = new BatchEventProcessor<>(ringBuffer, sequenceBarrier, handlers[0]);[m
[31m-        batchEventProcessors[1] = new BatchEventProcessor<>(ringBuffer, sequenceBarrier, handlers[1]);[m
[31m-        batchEventProcessors[2] = new BatchEventProcessor<>(ringBuffer, sequenceBarrier, handlers[2]);[m
[31m-[m
[31m-        ringBuffer.addGatingSequences([m
[31m-            batchEventProcessors[0].getSequence(),[m
[31m-            batchEventProcessors[1].getSequence(),[m
[31m-            batchEventProcessors[2].getSequence());[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 4;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected PerfTestContext runDisruptorPass() throws InterruptedException[m
[31m-    {[m
[31m-        PerfTestContext perfTestContext = new PerfTestContext();[m
[31m-        CountDownLatch latch = new CountDownLatch(NUM_EVENT_PROCESSORS);[m
[31m-        for (int i = 0; i < NUM_EVENT_PROCESSORS; i++)[m
[31m-        {[m
[31m-            handlers[i].reset(latch, batchEventProcessors[i].getSequence().get() + ITERATIONS);[m
[31m-            executor.submit(batchEventProcessors[i]);[m
[31m-        }[m
[31m-[m
[31m-        long start = System.currentTimeMillis();[m
[31m-[m
[31m-        for (long i = 0; i < ITERATIONS; i++)[m
[31m-        {[m
[31m-            long sequence = ringBuffer.next();[m
[31m-            ringBuffer.get(sequence).setValue(i);[m
[31m-            ringBuffer.publish(sequence);[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-        perfTestContext.setDisruptorOps((ITERATIONS * 1000L) / (System.currentTimeMillis() - start));[m
[31m-        perfTestContext.setBatchData(sumBatches(handlers), ITERATIONS * handlers.length);[m
[31m-        for (int i = 0; i < NUM_EVENT_PROCESSORS; i++)[m
[31m-        {[m
[31m-            batchEventProcessors[i].halt();[m
[31m-            failIfNot(results[i], handlers[i].getValue());[m
[31m-        }[m
[31m-[m
[31m-        return perfTestContext;[m
[31m-    }[m
[31m-[m
[31m-    private long sumBatches(ValueMutationEventHandler[] handlers)[m
[31m-    {[m
[31m-        long sum = 0;[m
[31m-        for (ValueMutationEventHandler handler : handlers)[m
[31m-        {[m
[31m-            sum += handler.getBatchesProcessed();[m
[31m-        }[m
[31m-        return sum;[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        new OneToThreeSequencedThroughputTest().testImplementations();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/sequenced/PingPongSequencedLatencyTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/PingPongSequencedLatencyTest.java[m
[1mdeleted file mode 100644[m
[1mindex 7c037ce..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/sequenced/PingPongSequencedLatencyTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,267 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.sequenced;[m
[31m-[m
[31m-import static com.lmax.disruptor.RingBuffer.createSingleProducer;[m
[31m-[m
[31m-import java.io.PrintStream;[m
[31m-import java.util.concurrent.BrokenBarrierException;[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.CyclicBarrier;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-[m
[31m-import com.lmax.disruptor.*;[m
[31m-import org.HdrHistogram.Histogram;[m
[31m-[m
[31m-import com.lmax.disruptor.support.ValueEvent;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- *[m
[31m- * Ping pongs between 2 event handlers and measures the latency of[m
[31m- * a round trip.[m
[31m- *[m
[31m- * Disruptor:[m
[31m- * ==========[m
[31m- *               +----------+[m
[31m- *               |          |[m
[31m- *               |   get    V[m
[31m- *  waitFor   +=====+    +=====+  claim[m
[31m- *    +------>| SB2 |    | RB2 |<------+[m
[31m- *    |       +=====+    +=====+       |[m
[31m- *    |                                |[m
[31m- * +-----+    +=====+    +=====+    +-----+[m
[31m- * | EP1 |--->| RB1 |    | SB1 |<---| EP2 |[m
[31m- * +-----+    +=====+    +=====+    +-----+[m
[31m- *       claim   ^   get    |  waitFor[m
[31m- *               |          |[m
[31m- *               +----------+[m
[31m- *[m
[31m- * EP1 - Pinger[m
[31m- * EP2 - Ponger[m
[31m- * RB1 - PingBuffer[m
[31m- * SB1 - PingBarrier[m
[31m- * RB2 - PongBuffer[m
[31m- * SB2 - PongBarrier[m
[31m- *[m
[31m- * </pre>[m
[31m- * <p>[m
[31m- * Note: <b>This test is only useful on a system using an invariant TSC in user space from the System.nanoTime() call.</b>[m
[31m- */[m
[31m-public final class PingPongSequencedLatencyTest[m
[31m-{[m
[31m-    private static final int BUFFER_SIZE = 1024;[m
[31m-    private static final long ITERATIONS = 100L * 1000L * 30L;[m
[31m-    private static final long PAUSE_NANOS = 1000L;[m
[31m-    private final ExecutorService executor = Executors.newCachedThreadPool(DaemonThreadFactory.INSTANCE);[m
[31m-[m
[31m-    private final Histogram histogram = new Histogram(10000000000L, 4);[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    private final RingBuffer<ValueEvent> pingBuffer =[m
[31m-        createSingleProducer(ValueEvent.EVENT_FACTORY, BUFFER_SIZE, new BlockingWaitStrategy());[m
[31m-    private final RingBuffer<ValueEvent> pongBuffer =[m
[31m-        createSingleProducer(ValueEvent.EVENT_FACTORY, BUFFER_SIZE, new BlockingWaitStrategy());[m
[31m-[m
[31m-    private final SequenceBarrier pongBarrier = pongBuffer.newBarrier();[m
[31m-    private final Pinger pinger = new Pinger(pingBuffer, ITERATIONS, PAUSE_NANOS);[m
[31m-    private final BatchEventProcessor<ValueEvent> pingProcessor =[m
[31m-            new BatchEventProcessor<>(pongBuffer, pongBarrier, pinger);[m
[31m-[m
[31m-    private final SequenceBarrier pingBarrier = pingBuffer.newBarrier();[m
[31m-    private final Ponger ponger = new Ponger(pongBuffer);[m
[31m-    private final BatchEventProcessor<ValueEvent> pongProcessor =[m
[31m-            new BatchEventProcessor<>(pingBuffer, pingBarrier, ponger);[m
[31m-[m
[31m-    {[m
[31m-        pingBuffer.addGatingSequences(pongProcessor.getSequence());[m
[31m-        pongBuffer.addGatingSequences(pingProcessor.getSequence());[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    public void shouldCompareDisruptorVsQueues() throws Exception[m
[31m-    {[m
[31m-        final int runs = 3;[m
[31m-[m
[31m-        for (int i = 0; i < runs; i++)[m
[31m-        {[m
[31m-            System.gc();[m
[31m-            histogram.reset();[m
[31m-[m
[31m-            runDisruptorPass();[m
[31m-[m
[31m-            System.out.format("%s run %d Disruptor %s\n", getClass().getSimpleName(), Long.valueOf(i), histogram);[m
[31m-            dumpHistogram(histogram, System.out);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static void dumpHistogram(final Histogram histogram, final PrintStream out)[m
[31m-    {[m
[31m-        histogram.outputPercentileDistribution(out, 1, 1000.0);[m
[31m-    }[m
[31m-[m
[31m-    private void runDisruptorPass() throws InterruptedException, BrokenBarrierException[m
[31m-    {[m
[31m-        final CountDownLatch latch = new CountDownLatch(1);[m
[31m-        final CyclicBarrier barrier = new CyclicBarrier(3);[m
[31m-        pinger.reset(barrier, latch, histogram);[m
[31m-        ponger.reset(barrier);[m
[31m-[m
[31m-        executor.submit(pongProcessor);[m
[31m-        executor.submit(pingProcessor);[m
[31m-[m
[31m-        barrier.await();[m
[31m-        latch.await();[m
[31m-[m
[31m-        pingProcessor.halt();[m
[31m-        pongProcessor.halt();[m
[31m-    }[m
[31m-[m
[31m-    public static void main(final String[] args) throws Exception[m
[31m-    {[m
[31m-        final PingPongSequencedLatencyTest test = new PingPongSequencedLatencyTest();[m
[31m-        test.shouldCompareDisruptorVsQueues();[m
[31m-    }[m
[31m-[m
[31m-    private static class Pinger implements EventHandler<ValueEvent>, LifecycleAware[m
[31m-    {[m
[31m-        private final RingBuffer<ValueEvent> buffer;[m
[31m-        private final long maxEvents;[m
[31m-        private final long pauseTimeNs;[m
[31m-[m
[31m-        private long counter = 0;[m
[31m-        private CyclicBarrier barrier;[m
[31m-        private CountDownLatch latch;[m
[31m-        private Histogram histogram;[m
[31m-        private long t0;[m
[31m-[m
[31m-        Pinger(final RingBuffer<ValueEvent> buffer, final long maxEvents, final long pauseTimeNs)[m
[31m-        {[m
[31m-            this.buffer = buffer;[m
[31m-            this.maxEvents = maxEvents;[m
[31m-            this.pauseTimeNs = pauseTimeNs;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onEvent(final ValueEvent event, final long sequence, final boolean endOfBatch) throws Exception[m
[31m-        {[m
[31m-            final long t1 = System.nanoTime();[m
[31m-[m
[31m-            histogram.recordValueWithExpectedInterval(t1 - t0, pauseTimeNs);[m
[31m-[m
[31m-            if (event.getValue() < maxEvents)[m
[31m-            {[m
[31m-                while (pauseTimeNs > (System.nanoTime() - t1))[m
[31m-                {[m
[31m-                    Thread.yield();[m
[31m-                }[m
[31m-[m
[31m-                send();[m
[31m-            }[m
[31m-            else[m
[31m-            {[m
[31m-                latch.countDown();[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        private void send()[m
[31m-        {[m
[31m-            t0 = System.nanoTime();[m
[31m-            final long next = buffer.next();[m
[31m-            buffer.get(next).setValue(counter);[m
[31m-            buffer.publish(next);[m
[31m-[m
[31m-            counter++;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onStart()[m
[31m-        {[m
[31m-            try[m
[31m-            {[m
[31m-                barrier.await();[m
[31m-[m
[31m-                Thread.sleep(1000);[m
[31m-                send();[m
[31m-            }[m
[31m-            catch (final Exception e)[m
[31m-            {[m
[31m-                throw new RuntimeException(e);[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onShutdown()[m
[31m-        {[m
[31m-        }[m
[31m-[m
[31m-        public void reset(final CyclicBarrier barrier, final CountDownLatch latch, final Histogram histogram)[m
[31m-        {[m
[31m-            this.histogram = histogram;[m
[31m-            this.barrier = barrier;[m
[31m-            this.latch = latch;[m
[31m-[m
[31m-            counter = 0;[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class Ponger implements EventHandler<ValueEvent>, LifecycleAware[m
[31m-    {[m
[31m-        private final RingBuffer<ValueEvent> buffer;[m
[31m-[m
[31m-        private CyclicBarrier barrier;[m
[31m-[m
[31m-        Ponger(final RingBuffer<ValueEvent> buffer)[m
[31m-        {[m
[31m-            this.buffer = buffer;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onEvent(final ValueEvent event, final long sequence, final boolean endOfBatch) throws Exception[m
[31m-        {[m
[31m-            final long next = buffer.next();[m
[31m-            buffer.get(next).setValue(event.getValue());[m
[31m-            buffer.publish(next);[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onStart()[m
[31m-        {[m
[31m-            try[m
[31m-            {[m
[31m-                barrier.await();[m
[31m-            }[m
[31m-            catch (final Exception e)[m
[31m-            {[m
[31m-                throw new RuntimeException(e);[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onShutdown()[m
[31m-        {[m
[31m-        }[m
[31m-[m
[31m-        public void reset(final CyclicBarrier barrier)[m
[31m-        {[m
[31m-            this.barrier = barrier;[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/sequenced/ThreeToOneSequencedBatchThroughputTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/ThreeToOneSequencedBatchThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex 82b46a2..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/sequenced/ThreeToOneSequencedBatchThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,149 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.sequenced;[m
[31m-[m
[31m-import static com.lmax.disruptor.RingBuffer.createMultiProducer;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.CyclicBarrier;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-import java.util.concurrent.Future;[m
[31m-[m
[31m-import com.lmax.disruptor.*;[m
[31m-import com.lmax.disruptor.support.ValueAdditionEventHandler;[m
[31m-import com.lmax.disruptor.support.ValueBatchPublisher;[m
[31m-import com.lmax.disruptor.support.ValueEvent;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- *[m
[31m- * Sequence a series of events from multiple publishers going to one event processor.[m
[31m- *[m
[31m- * +----+[m
[31m- * | P1 |------+[m
[31m- * +----+      |[m
[31m- *             v[m
[31m- * +----+    +-----+[m
[31m- * | P1 |--->| EP1 |[m
[31m- * +----+    +-----+[m
[31m- *             ^[m
[31m- * +----+      |[m
[31m- * | P3 |------+[m
[31m- * +----+[m
[31m- *[m
[31m- * Disruptor:[m
[31m- * ==========[m
[31m- *             track to prevent wrap[m
[31m- *             +--------------------+[m
[31m- *             |                    |[m
[31m- *             |                    v[m
[31m- * +----+    +====+    +====+    +-----+[m
[31m- * | P1 |--->| RB |<---| SB |    | EP1 |[m
[31m- * +----+    +====+    +====+    +-----+[m
[31m- *             ^   get    ^         |[m
[31m- * +----+      |          |         |[m
[31m- * | P2 |------+          +---------+[m
[31m- * +----+      |            waitFor[m
[31m- *             |[m
[31m- * +----+      |[m
[31m- * | P3 |------+[m
[31m- * +----+[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * P2  - Publisher 2[m
[31m- * P3  - Publisher 3[m
[31m- * RB  - RingBuffer[m
[31m- * SB  - SequenceBarrier[m
[31m- * EP1 - EventProcessor 1[m
[31m- *[m
[31m- * </pre>[m
[31m- *[m
[31m- * @author mikeb01[m
[31m- */[m
[31m-public final class ThreeToOneSequencedBatchThroughputTest extends AbstractPerfTestDisruptor[m
[31m-{[m
[31m-    private static final int NUM_PUBLISHERS = 3;[m
[31m-    private static final int BUFFER_SIZE = 1024 * 64;[m
[31m-    private static final long ITERATIONS = 1000L * 1000L * 100L;[m
[31m-    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_PUBLISHERS + 1, DaemonThreadFactory.INSTANCE);[m
[31m-    private final CyclicBarrier cyclicBarrier = new CyclicBarrier(NUM_PUBLISHERS + 1);[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    private final RingBuffer<ValueEvent> ringBuffer =[m
[31m-        createMultiProducer(ValueEvent.EVENT_FACTORY, BUFFER_SIZE, new BusySpinWaitStrategy());[m
[31m-[m
[31m-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();[m
[31m-    private final ValueAdditionEventHandler handler = new ValueAdditionEventHandler();[m
[31m-    private final BatchEventProcessor<ValueEvent> batchEventProcessor =[m
[31m-            new BatchEventProcessor<>(ringBuffer, sequenceBarrier, handler);[m
[31m-    private final ValueBatchPublisher[] valuePublishers = new ValueBatchPublisher[NUM_PUBLISHERS];[m
[31m-[m
[31m-    {[m
[31m-        for (int i = 0; i < NUM_PUBLISHERS; i++)[m
[31m-        {[m
[31m-            valuePublishers[i] = new ValueBatchPublisher(cyclicBarrier, ringBuffer, ITERATIONS / NUM_PUBLISHERS, 10);[m
[31m-        }[m
[31m-[m
[31m-        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 4;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected PerfTestContext runDisruptorPass() throws Exception[m
[31m-    {[m
[31m-        PerfTestContext perfTestContext = new PerfTestContext();[m
[31m-        final CountDownLatch latch = new CountDownLatch(1);[m
[31m-        handler.reset(latch, batchEventProcessor.getSequence().get() + ((ITERATIONS / NUM_PUBLISHERS) * NUM_PUBLISHERS));[m
[31m-[m
[31m-        Future<?>[] futures = new Future[NUM_PUBLISHERS];[m
[31m-        for (int i = 0; i < NUM_PUBLISHERS; i++)[m
[31m-        {[m
[31m-            futures[i] = executor.submit(valuePublishers[i]);[m
[31m-        }[m
[31m-        executor.submit(batchEventProcessor);[m
[31m-[m
[31m-        long start = System.currentTimeMillis();[m
[31m-        cyclicBarrier.await();[m
[31m-[m
[31m-        for (int i = 0; i < NUM_PUBLISHERS; i++)[m
[31m-        {[m
[31m-            futures[i].get();[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-[m
[31m-        perfTestContext.setDisruptorOps((ITERATIONS * 1000L) / (System.currentTimeMillis() - start));[m
[31m-        perfTestContext.setBatchData(handler.getBatchesProcessed(), ITERATIONS);[m
[31m-        batchEventProcessor.halt();[m
[31m-[m
[31m-        return perfTestContext;[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        new ThreeToOneSequencedBatchThroughputTest().testImplementations();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/sequenced/ThreeToOneSequencedThroughputTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/ThreeToOneSequencedThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex 16ea413..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/sequenced/ThreeToOneSequencedThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,150 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.sequenced;[m
[31m-[m
[31m-import static com.lmax.disruptor.RingBuffer.createMultiProducer;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.CyclicBarrier;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-import java.util.concurrent.Future;[m
[31m-[m
[31m-import com.lmax.disruptor.*;[m
[31m-import com.lmax.disruptor.support.ValueAdditionEventHandler;[m
[31m-import com.lmax.disruptor.support.ValueEvent;[m
[31m-import com.lmax.disruptor.support.ValuePublisher;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- *[m
[31m- * Sequence a series of events from multiple publishers going to one event processor.[m
[31m- *[m
[31m- * +----+[m
[31m- * | P1 |------+[m
[31m- * +----+      |[m
[31m- *             v[m
[31m- * +----+    +-----+[m
[31m- * | P1 |--->| EP1 |[m
[31m- * +----+    +-----+[m
[31m- *             ^[m
[31m- * +----+      |[m
[31m- * | P3 |------+[m
[31m- * +----+[m
[31m- *[m
[31m- *[m
[31m- * Disruptor:[m
[31m- * ==========[m
[31m- *             track to prevent wrap[m
[31m- *             +--------------------+[m
[31m- *             |                    |[m
[31m- *             |                    v[m
[31m- * +----+    +====+    +====+    +-----+[m
[31m- * | P1 |--->| RB |<---| SB |    | EP1 |[m
[31m- * +----+    +====+    +====+    +-----+[m
[31m- *             ^   get    ^         |[m
[31m- * +----+      |          |         |[m
[31m- * | P2 |------+          +---------+[m
[31m- * +----+      |            waitFor[m
[31m- *             |[m
[31m- * +----+      |[m
[31m- * | P3 |------+[m
[31m- * +----+[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * P2  - Publisher 2[m
[31m- * P3  - Publisher 3[m
[31m- * RB  - RingBuffer[m
[31m- * SB  - SequenceBarrier[m
[31m- * EP1 - EventProcessor 1[m
[31m- *[m
[31m- * </pre>[m
[31m- */[m
[31m-public final class ThreeToOneSequencedThroughputTest extends AbstractPerfTestDisruptor[m
[31m-{[m
[31m-    private static final int NUM_PUBLISHERS = 3;[m
[31m-    private static final int BUFFER_SIZE = 1024 * 64;[m
[31m-    private static final long ITERATIONS = 1000L * 1000L * 20L;[m
[31m-    private final ExecutorService executor =[m
[31m-        Executors.newFixedThreadPool(NUM_PUBLISHERS + 1, DaemonThreadFactory.INSTANCE);[m
[31m-    private final CyclicBarrier cyclicBarrier = new CyclicBarrier(NUM_PUBLISHERS + 1);[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    private final RingBuffer<ValueEvent> ringBuffer =[m
[31m-        createMultiProducer(ValueEvent.EVENT_FACTORY, BUFFER_SIZE, new BusySpinWaitStrategy());[m
[31m-[m
[31m-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();[m
[31m-    private final ValueAdditionEventHandler handler = new ValueAdditionEventHandler();[m
[31m-    private final BatchEventProcessor<ValueEvent> batchEventProcessor =[m
[31m-            new BatchEventProcessor<>(ringBuffer, sequenceBarrier, handler);[m
[31m-    private final ValuePublisher[] valuePublishers = new ValuePublisher[NUM_PUBLISHERS];[m
[31m-[m
[31m-    {[m
[31m-        for (int i = 0; i < NUM_PUBLISHERS; i++)[m
[31m-        {[m
[31m-            valuePublishers[i] = new ValuePublisher(cyclicBarrier, ringBuffer, ITERATIONS / NUM_PUBLISHERS);[m
[31m-        }[m
[31m-[m
[31m-        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 4;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected PerfTestContext runDisruptorPass() throws Exception[m
[31m-    {[m
[31m-        PerfTestContext perfTestContext = new PerfTestContext();[m
[31m-        final CountDownLatch latch = new CountDownLatch(1);[m
[31m-        handler[m
[31m-            .reset(latch, batchEventProcessor.getSequence().get() + ((ITERATIONS / NUM_PUBLISHERS) * NUM_PUBLISHERS));[m
[31m-[m
[31m-        Future<?>[] futures = new Future[NUM_PUBLISHERS];[m
[31m-        for (int i = 0; i < NUM_PUBLISHERS; i++)[m
[31m-        {[m
[31m-            futures[i] = executor.submit(valuePublishers[i]);[m
[31m-        }[m
[31m-        executor.submit(batchEventProcessor);[m
[31m-[m
[31m-        long start = System.currentTimeMillis();[m
[31m-        cyclicBarrier.await();[m
[31m-[m
[31m-        for (int i = 0; i < NUM_PUBLISHERS; i++)[m
[31m-        {[m
[31m-            futures[i].get();[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-[m
[31m-        perfTestContext.setDisruptorOps((ITERATIONS * 1000L) / (System.currentTimeMillis() - start));[m
[31m-        perfTestContext.setBatchData(handler.getBatchesProcessed(), ITERATIONS);[m
[31m-        batchEventProcessor.halt();[m
[31m-[m
[31m-        return perfTestContext;[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        new ThreeToOneSequencedThroughputTest().testImplementations();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/sequenced/ThreeToThreeSequencedThroughputTest.java b/src/perftest/java/com/lmax/disruptor/sequenced/ThreeToThreeSequencedThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex a9c86eb..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/sequenced/ThreeToThreeSequencedThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,147 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.sequenced;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.CyclicBarrier;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-import java.util.concurrent.Future;[m
[31m-[m
[31m-import com.lmax.disruptor.*;[m
[31m-import com.lmax.disruptor.support.LongArrayEventHandler;[m
[31m-import com.lmax.disruptor.support.LongArrayPublisher;[m
[31m-import com.lmax.disruptor.support.MultiBufferBatchEventProcessor;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- *[m
[31m- * Sequence a series of events from multiple publishers going to one event processor.[m
[31m- *[m
[31m- * Disruptor:[m
[31m- * ==========[m
[31m- *             track to prevent wrap[m
[31m- *             +--------------------+[m
[31m- *             |                    |[m
[31m- *             |                    |[m
[31m- * +----+    +====+    +====+       |[m
[31m- * | P1 |--->| RB |--->| SB |--+    |[m
[31m- * +----+    +====+    +====+  |    |[m
[31m- *                             |    v[m
[31m- * +----+    +====+    +====+  | +----+[m
[31m- * | P2 |--->| RB |--->| SB |--+>| EP |[m
[31m- * +----+    +====+    +====+  | +----+[m
[31m- *                             |[m
[31m- * +----+    +====+    +====+  |[m
[31m- * | P3 |--->| RB |--->| SB |--+[m
[31m- * +----+    +====+    +====+[m
[31m- *[m
[31m- * P1 - Publisher 1[m
[31m- * P2 - Publisher 2[m
[31m- * P3 - Publisher 3[m
[31m- * RB - RingBuffer[m
[31m- * SB - SequenceBarrier[m
[31m- * EP - EventProcessor[m
[31m- *[m
[31m- * </pre>[m
[31m- */[m
[31m-public final class ThreeToThreeSequencedThroughputTest extends AbstractPerfTestDisruptor[m
[31m-{[m
[31m-    private static final int NUM_PUBLISHERS = 3;[m
[31m-    private static final int ARRAY_SIZE = 3;[m
[31m-    private static final int BUFFER_SIZE = 1024 * 64;[m
[31m-    private static final long ITERATIONS = 1000L * 1000L * 180L;[m
[31m-    private final ExecutorService executor =[m
[31m-        Executors.newFixedThreadPool(NUM_PUBLISHERS + 1, DaemonThreadFactory.INSTANCE);[m
[31m-    private final CyclicBarrier cyclicBarrier = new CyclicBarrier(NUM_PUBLISHERS + 1);[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @SuppressWarnings("unchecked")[m
[31m-    private final RingBuffer<long[]>[] buffers = new RingBuffer[NUM_PUBLISHERS];[m
[31m-    private final SequenceBarrier[] barriers = new SequenceBarrier[NUM_PUBLISHERS];[m
[31m-    private final LongArrayPublisher[] valuePublishers = new LongArrayPublisher[NUM_PUBLISHERS];[m
[31m-[m
[31m-    private final LongArrayEventHandler handler = new LongArrayEventHandler();[m
[31m-    private final MultiBufferBatchEventProcessor<long[]> batchEventProcessor;[m
[31m-[m
[31m-    private static final EventFactory<long[]> FACTORY = () -> new long[ARRAY_SIZE];[m
[31m-[m
[31m-    {[m
[31m-        for (int i = 0; i < NUM_PUBLISHERS; i++)[m
[31m-        {[m
[31m-            buffers[i] = RingBuffer.createSingleProducer(FACTORY, BUFFER_SIZE, new YieldingWaitStrategy());[m
[31m-            barriers[i] = buffers[i].newBarrier();[m
[31m-            valuePublishers[i] = new LongArrayPublisher([m
[31m-                cyclicBarrier,[m
[31m-                buffers[i],[m
[31m-                ITERATIONS / NUM_PUBLISHERS,[m
[31m-                ARRAY_SIZE);[m
[31m-        }[m
[31m-[m
[31m-        batchEventProcessor = new MultiBufferBatchEventProcessor<>(buffers, barriers, handler);[m
[31m-[m
[31m-        for (int i = 0; i < NUM_PUBLISHERS; i++)[m
[31m-        {[m
[31m-            buffers[i].addGatingSequences(batchEventProcessor.getSequences()[i]);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 4;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected PerfTestContext runDisruptorPass() throws Exception[m
[31m-    {[m
[31m-        PerfTestContext perfTestContext = new PerfTestContext();[m
[31m-        final CountDownLatch latch = new CountDownLatch(1);[m
[31m-        handler.reset(latch, ITERATIONS);[m
[31m-[m
[31m-        Future<?>[] futures = new Future[NUM_PUBLISHERS];[m
[31m-        for (int i = 0; i < NUM_PUBLISHERS; i++)[m
[31m-        {[m
[31m-            futures[i] = executor.submit(valuePublishers[i]);[m
[31m-        }[m
[31m-        executor.submit(batchEventProcessor);[m
[31m-[m
[31m-        long start = System.currentTimeMillis();[m
[31m-        cyclicBarrier.await();[m
[31m-[m
[31m-        for (int i = 0; i < NUM_PUBLISHERS; i++)[m
[31m-        {[m
[31m-            futures[i].get();[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-[m
[31m-        perfTestContext.setDisruptorOps((ITERATIONS * 1000L * ARRAY_SIZE) / (System.currentTimeMillis() - start));[m
[31m-        perfTestContext.setBatchData(handler.getBatchesProcessed(), ITERATIONS * ARRAY_SIZE);[m
[31m-        batchEventProcessor.halt();[m
[31m-[m
[31m-        return perfTestContext;[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        new ThreeToThreeSequencedThroughputTest().testImplementations();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/EventCountingQueueProcessor.java b/src/perftest/java/com/lmax/disruptor/support/EventCountingQueueProcessor.java[m
[1mdeleted file mode 100644[m
[1mindex 091348d..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/EventCountingQueueProcessor.java[m
[1m+++ /dev/null[m
[36m@@ -1,59 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import com.lmax.disruptor.util.PaddedLong;[m
[31m-[m
[31m-import java.util.concurrent.BlockingQueue;[m
[31m-[m
[31m-public final class EventCountingQueueProcessor implements Runnable[m
[31m-{[m
[31m-    private volatile boolean running;[m
[31m-    private final BlockingQueue<Long> blockingQueue;[m
[31m-    private final PaddedLong[] counters;[m
[31m-    private final int index;[m
[31m-[m
[31m-    public EventCountingQueueProcessor([m
[31m-        final BlockingQueue<Long> blockingQueue, final PaddedLong[] counters, final int index)[m
[31m-    {[m
[31m-        this.blockingQueue = blockingQueue;[m
[31m-        this.counters = counters;[m
[31m-        this.index = index;[m
[31m-    }[m
[31m-[m
[31m-    public void halt()[m
[31m-    {[m
[31m-        running = false;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void run()[m
[31m-    {[m
[31m-        running = true;[m
[31m-        while (running)[m
[31m-        {[m
[31m-            try[m
[31m-            {[m
[31m-                blockingQueue.take();[m
[31m-                counters[index].set(counters[index].get() + 1L);[m
[31m-            }[m
[31m-            catch (InterruptedException ex)[m
[31m-            {[m
[31m-                break;[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/FizzBuzzEvent.java b/src/perftest/java/com/lmax/disruptor/support/FizzBuzzEvent.java[m
[1mdeleted file mode 100644[m
[1mindex d9efc0e..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/FizzBuzzEvent.java[m
[1m+++ /dev/null[m
[36m@@ -1,59 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import com.lmax.disruptor.EventFactory;[m
[31m-[m
[31m-public final class FizzBuzzEvent[m
[31m-{[m
[31m-    private boolean fizz = false;[m
[31m-    private boolean buzz = false;[m
[31m-    private long value = 0;[m
[31m-[m
[31m-    public long getValue()[m
[31m-    {[m
[31m-        return value;[m
[31m-    }[m
[31m-[m
[31m-    public void setValue(final long value)[m
[31m-    {[m
[31m-        fizz = false;[m
[31m-        buzz = false;[m
[31m-        this.value = value;[m
[31m-    }[m
[31m-[m
[31m-    public boolean isFizz()[m
[31m-    {[m
[31m-        return fizz;[m
[31m-    }[m
[31m-[m
[31m-    public void setFizz(final boolean fizz)[m
[31m-    {[m
[31m-        this.fizz = fizz;[m
[31m-    }[m
[31m-[m
[31m-    public boolean isBuzz()[m
[31m-    {[m
[31m-        return buzz;[m
[31m-    }[m
[31m-[m
[31m-    public void setBuzz(final boolean buzz)[m
[31m-    {[m
[31m-        this.buzz = buzz;[m
[31m-    }[m
[31m-[m
[31m-    public static final EventFactory<FizzBuzzEvent> EVENT_FACTORY = () -> new FizzBuzzEvent();[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/FizzBuzzEventHandler.java b/src/perftest/java/com/lmax/disruptor/support/FizzBuzzEventHandler.java[m
[1mdeleted file mode 100644[m
[1mindex cb0bdeb..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/FizzBuzzEventHandler.java[m
[1m+++ /dev/null[m
[36m@@ -1,79 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.util.PaddedLong;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-[m
[31m-public final class FizzBuzzEventHandler implements EventHandler<FizzBuzzEvent>[m
[31m-{[m
[31m-    private final FizzBuzzStep fizzBuzzStep;[m
[31m-    private final PaddedLong fizzBuzzCounter = new PaddedLong();[m
[31m-    private long count;[m
[31m-    private CountDownLatch latch;[m
[31m-[m
[31m-    public FizzBuzzEventHandler(final FizzBuzzStep fizzBuzzStep)[m
[31m-    {[m
[31m-        this.fizzBuzzStep = fizzBuzzStep;[m
[31m-    }[m
[31m-[m
[31m-    public void reset(final CountDownLatch latch, final long expectedCount)[m
[31m-    {[m
[31m-        fizzBuzzCounter.set(0L);[m
[31m-        this.latch = latch;[m
[31m-        count = expectedCount;[m
[31m-    }[m
[31m-[m
[31m-    public long getFizzBuzzCounter()[m
[31m-    {[m
[31m-        return fizzBuzzCounter.get();[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void onEvent(final FizzBuzzEvent event, final long sequence, final boolean endOfBatch) throws Exception[m
[31m-    {[m
[31m-        switch (fizzBuzzStep)[m
[31m-        {[m
[31m-            case FIZZ:[m
[31m-                if (0 == (event.getValue() % 3))[m
[31m-                {[m
[31m-                    event.setFizz(true);[m
[31m-                }[m
[31m-                break;[m
[31m-[m
[31m-            case BUZZ:[m
[31m-                if (0 == (event.getValue() % 5))[m
[31m-                {[m
[31m-                    event.setBuzz(true);[m
[31m-                }[m
[31m-                break;[m
[31m-[m
[31m-            case FIZZ_BUZZ:[m
[31m-                if (event.isFizz() && event.isBuzz())[m
[31m-                {[m
[31m-                    fizzBuzzCounter.set(fizzBuzzCounter.get() + 1L);[m
[31m-                }[m
[31m-                break;[m
[31m-        }[m
[31m-[m
[31m-        if (latch != null && count == sequence)[m
[31m-        {[m
[31m-            latch.countDown();[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/FizzBuzzQueueProcessor.java b/src/perftest/java/com/lmax/disruptor/support/FizzBuzzQueueProcessor.java[m
[1mdeleted file mode 100644[m
[1mindex 06ec3f7..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/FizzBuzzQueueProcessor.java[m
[1m+++ /dev/null[m
[36m@@ -1,118 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import java.util.concurrent.BlockingQueue;[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-[m
[31m-public final class FizzBuzzQueueProcessor implements Runnable[m
[31m-{[m
[31m-    private final FizzBuzzStep fizzBuzzStep;[m
[31m-    private final BlockingQueue<Long> fizzInputQueue;[m
[31m-    private final BlockingQueue<Long> buzzInputQueue;[m
[31m-    private final BlockingQueue<Boolean> fizzOutputQueue;[m
[31m-    private final BlockingQueue<Boolean> buzzOutputQueue;[m
[31m-    private final long count;[m
[31m-[m
[31m-    private volatile boolean running;[m
[31m-    private long fizzBuzzCounter = 0;[m
[31m-    private long sequence;[m
[31m-    private CountDownLatch latch = null;[m
[31m-[m
[31m-    public FizzBuzzQueueProcessor([m
[31m-        final FizzBuzzStep fizzBuzzStep,[m
[31m-        final BlockingQueue<Long> fizzInputQueue,[m
[31m-        final BlockingQueue<Long> buzzInputQueue,[m
[31m-        final BlockingQueue<Boolean> fizzOutputQueue,[m
[31m-        final BlockingQueue<Boolean> buzzOutputQueue, final long count)[m
[31m-    {[m
[31m-        this.fizzBuzzStep = fizzBuzzStep;[m
[31m-[m
[31m-        this.fizzInputQueue = fizzInputQueue;[m
[31m-        this.buzzInputQueue = buzzInputQueue;[m
[31m-        this.fizzOutputQueue = fizzOutputQueue;[m
[31m-        this.buzzOutputQueue = buzzOutputQueue;[m
[31m-        this.count = count;[m
[31m-    }[m
[31m-[m
[31m-    public long getFizzBuzzCounter()[m
[31m-    {[m
[31m-        return fizzBuzzCounter;[m
[31m-    }[m
[31m-[m
[31m-    public void reset(final CountDownLatch latch)[m
[31m-    {[m
[31m-        fizzBuzzCounter = 0L;[m
[31m-        sequence = 0L;[m
[31m-        this.latch = latch;[m
[31m-    }[m
[31m-[m
[31m-    public void halt()[m
[31m-    {[m
[31m-        running = false;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void run()[m
[31m-    {[m
[31m-        running = true;[m
[31m-        while (true)[m
[31m-        {[m
[31m-            try[m
[31m-            {[m
[31m-                switch (fizzBuzzStep)[m
[31m-                {[m
[31m-                    case FIZZ:[m
[31m-                    {[m
[31m-                        Long value = fizzInputQueue.take();[m
[31m-                        fizzOutputQueue.put(Boolean.valueOf(0 == (value.longValue() % 3)));[m
[31m-                        break;[m
[31m-                    }[m
[31m-[m
[31m-                    case BUZZ:[m
[31m-                    {[m
[31m-                        Long value = buzzInputQueue.take();[m
[31m-                        buzzOutputQueue.put(Boolean.valueOf(0 == (value.longValue() % 5)));[m
[31m-                        break;[m
[31m-                    }[m
[31m-[m
[31m-                    case FIZZ_BUZZ:[m
[31m-                    {[m
[31m-                        final boolean fizz = fizzOutputQueue.take().booleanValue();[m
[31m-                        final boolean buzz = buzzOutputQueue.take().booleanValue();[m
[31m-                        if (fizz && buzz)[m
[31m-                        {[m
[31m-                            ++fizzBuzzCounter;[m
[31m-                        }[m
[31m-                        break;[m
[31m-                    }[m
[31m-                }[m
[31m-[m
[31m-                if (null != latch && sequence++ == count)[m
[31m-                {[m
[31m-                    latch.countDown();[m
[31m-                }[m
[31m-            }[m
[31m-            catch (InterruptedException ex)[m
[31m-            {[m
[31m-                if (!running)[m
[31m-                {[m
[31m-                    break;[m
[31m-                }[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/FizzBuzzStep.java b/src/perftest/java/com/lmax/disruptor/support/FizzBuzzStep.java[m
[1mdeleted file mode 100644[m
[1mindex 04ce65a..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/FizzBuzzStep.java[m
[1m+++ /dev/null[m
[36m@@ -1,23 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-public enum FizzBuzzStep[m
[31m-{[m
[31m-    FIZZ,[m
[31m-    BUZZ,[m
[31m-    FIZZ_BUZZ,[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/FunctionEvent.java b/src/perftest/java/com/lmax/disruptor/support/FunctionEvent.java[m
[1mdeleted file mode 100644[m
[1mindex 1d8e0ac..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/FunctionEvent.java[m
[1m+++ /dev/null[m
[36m@@ -1,68 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import com.lmax.disruptor.EventFactory;[m
[31m-[m
[31m-public final class FunctionEvent[m
[31m-{[m
[31m-    private long operandOne;[m
[31m-    private long operandTwo;[m
[31m-    private long stepOneResult;[m
[31m-    private long stepTwoResult;[m
[31m-[m
[31m-    public long getOperandOne()[m
[31m-    {[m
[31m-        return operandOne;[m
[31m-    }[m
[31m-[m
[31m-    public void setOperandOne(final long operandOne)[m
[31m-    {[m
[31m-        this.operandOne = operandOne;[m
[31m-    }[m
[31m-[m
[31m-    public long getOperandTwo()[m
[31m-    {[m
[31m-        return operandTwo;[m
[31m-    }[m
[31m-[m
[31m-    public void setOperandTwo(final long operandTwo)[m
[31m-    {[m
[31m-        this.operandTwo = operandTwo;[m
[31m-    }[m
[31m-[m
[31m-    public long getStepOneResult()[m
[31m-    {[m
[31m-        return stepOneResult;[m
[31m-    }[m
[31m-[m
[31m-    public void setStepOneResult(final long stepOneResult)[m
[31m-    {[m
[31m-        this.stepOneResult = stepOneResult;[m
[31m-    }[m
[31m-[m
[31m-    public long getStepTwoResult()[m
[31m-    {[m
[31m-        return stepTwoResult;[m
[31m-    }[m
[31m-[m
[31m-    public void setStepTwoResult(final long stepTwoResult)[m
[31m-    {[m
[31m-        this.stepTwoResult = stepTwoResult;[m
[31m-    }[m
[31m-[m
[31m-    public static final EventFactory<FunctionEvent> EVENT_FACTORY = () -> new FunctionEvent();[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/FunctionEventHandler.java b/src/perftest/java/com/lmax/disruptor/support/FunctionEventHandler.java[m
[1mdeleted file mode 100644[m
[1mindex 0d636cf..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/FunctionEventHandler.java[m
[1m+++ /dev/null[m
[36m@@ -1,73 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.util.PaddedLong;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-[m
[31m-public final class FunctionEventHandler implements EventHandler<FunctionEvent>[m
[31m-{[m
[31m-    private final FunctionStep functionStep;[m
[31m-    private final PaddedLong stepThreeCounter = new PaddedLong();[m
[31m-    private long count;[m
[31m-    private CountDownLatch latch;[m
[31m-[m
[31m-    public FunctionEventHandler(final FunctionStep functionStep)[m
[31m-    {[m
[31m-        this.functionStep = functionStep;[m
[31m-    }[m
[31m-[m
[31m-    public long getStepThreeCounter()[m
[31m-    {[m
[31m-        return stepThreeCounter.get();[m
[31m-    }[m
[31m-[m
[31m-    public void reset(final CountDownLatch latch, final long expectedCount)[m
[31m-    {[m
[31m-        stepThreeCounter.set(0L);[m
[31m-        this.latch = latch;[m
[31m-        count = expectedCount;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void onEvent(final FunctionEvent event, final long sequence, final boolean endOfBatch) throws Exception[m
[31m-    {[m
[31m-        switch (functionStep)[m
[31m-        {[m
[31m-            case ONE:[m
[31m-                event.setStepOneResult(event.getOperandOne() + event.getOperandTwo());[m
[31m-                break;[m
[31m-[m
[31m-            case TWO:[m
[31m-                event.setStepTwoResult(event.getStepOneResult() + 3L);[m
[31m-                break;[m
[31m-[m
[31m-            case THREE:[m
[31m-                if ((event.getStepTwoResult() & 4L) == 4L)[m
[31m-                {[m
[31m-                    stepThreeCounter.set(stepThreeCounter.get() + 1L);[m
[31m-                }[m
[31m-                break;[m
[31m-        }[m
[31m-[m
[31m-        if (latch != null && count == sequence)[m
[31m-        {[m
[31m-            latch.countDown();[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/FunctionQueueProcessor.java b/src/perftest/java/com/lmax/disruptor/support/FunctionQueueProcessor.java[m
[1mdeleted file mode 100644[m
[1mindex e6af4d7..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/FunctionQueueProcessor.java[m
[1m+++ /dev/null[m
[36m@@ -1,115 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import java.util.concurrent.BlockingQueue;[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-[m
[31m-public final class FunctionQueueProcessor implements Runnable[m
[31m-{[m
[31m-    private final FunctionStep functionStep;[m
[31m-    private final BlockingQueue<long[]> stepOneQueue;[m
[31m-    private final BlockingQueue<Long> stepTwoQueue;[m
[31m-    private final BlockingQueue<Long> stepThreeQueue;[m
[31m-    private final long count;[m
[31m-[m
[31m-    private volatile boolean running;[m
[31m-    private long stepThreeCounter;[m
[31m-    private long sequence;[m
[31m-    private CountDownLatch latch;[m
[31m-[m
[31m-    public FunctionQueueProcessor([m
[31m-        final FunctionStep functionStep,[m
[31m-        final BlockingQueue<long[]> stepOneQueue,[m
[31m-        final BlockingQueue<Long> stepTwoQueue,[m
[31m-        final BlockingQueue<Long> stepThreeQueue,[m
[31m-        final long count)[m
[31m-    {[m
[31m-        this.functionStep = functionStep;[m
[31m-        this.stepOneQueue = stepOneQueue;[m
[31m-        this.stepTwoQueue = stepTwoQueue;[m
[31m-        this.stepThreeQueue = stepThreeQueue;[m
[31m-        this.count = count;[m
[31m-    }[m
[31m-[m
[31m-    public long getStepThreeCounter()[m
[31m-    {[m
[31m-        return stepThreeCounter;[m
[31m-    }[m
[31m-[m
[31m-    public void reset(final CountDownLatch latch)[m
[31m-    {[m
[31m-        stepThreeCounter = 0L;[m
[31m-        sequence = 0L;[m
[31m-        this.latch = latch;[m
[31m-    }[m
[31m-[m
[31m-    public void halt()[m
[31m-    {[m
[31m-        running = false;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void run()[m
[31m-    {[m
[31m-        running = true;[m
[31m-        while (true)[m
[31m-        {[m
[31m-            try[m
[31m-            {[m
[31m-                switch (functionStep)[m
[31m-                {[m
[31m-                    case ONE:[m
[31m-                    {[m
[31m-                        long[] values = stepOneQueue.take();[m
[31m-                        stepTwoQueue.put(Long.valueOf(values[0] + values[1]));[m
[31m-                        break;[m
[31m-                    }[m
[31m-[m
[31m-                    case TWO:[m
[31m-                    {[m
[31m-                        Long value = stepTwoQueue.take();[m
[31m-                        stepThreeQueue.put(Long.valueOf(value.longValue() + 3));[m
[31m-                        break;[m
[31m-                    }[m
[31m-[m
[31m-                    case THREE:[m
[31m-                    {[m
[31m-                        Long value = stepThreeQueue.take();[m
[31m-                        long testValue = value.longValue();[m
[31m-                        if ((testValue & 4L) == 4L)[m
[31m-                        {[m
[31m-                            ++stepThreeCounter;[m
[31m-                        }[m
[31m-                        break;[m
[31m-                    }[m
[31m-                }[m
[31m-[m
[31m-                if (null != latch && sequence++ == count)[m
[31m-                {[m
[31m-                    latch.countDown();[m
[31m-                }[m
[31m-            }[m
[31m-            catch (InterruptedException ex)[m
[31m-            {[m
[31m-                if (!running)[m
[31m-                {[m
[31m-                    break;[m
[31m-                }[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/FunctionStep.java b/src/perftest/java/com/lmax/disruptor/support/FunctionStep.java[m
[1mdeleted file mode 100644[m
[1mindex 3822172..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/FunctionStep.java[m
[1m+++ /dev/null[m
[36m@@ -1,23 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-public enum FunctionStep[m
[31m-{[m
[31m-    ONE,[m
[31m-    TWO,[m
[31m-    THREE[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/LongArrayEventHandler.java b/src/perftest/java/com/lmax/disruptor/support/LongArrayEventHandler.java[m
[1mdeleted file mode 100644[m
[1mindex 51984cc..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/LongArrayEventHandler.java[m
[1m+++ /dev/null[m
[36m@@ -1,68 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-[m
[31m-import com.lmax.disruptor.BatchStartAware;[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.util.PaddedLong;[m
[31m-[m
[31m-public final class LongArrayEventHandler implements EventHandler<long[]>, BatchStartAware[m
[31m-{[m
[31m-    private final PaddedLong value = new PaddedLong();[m
[31m-    private final PaddedLong batchesProcessed = new PaddedLong();[m
[31m-    private long count;[m
[31m-    private CountDownLatch latch;[m
[31m-[m
[31m-    public long getValue()[m
[31m-    {[m
[31m-        return value.get();[m
[31m-    }[m
[31m-[m
[31m-    public long getBatchesProcessed()[m
[31m-    {[m
[31m-        return batchesProcessed.get();[m
[31m-    }[m
[31m-[m
[31m-    public void reset(final CountDownLatch latch, final long expectedCount)[m
[31m-    {[m
[31m-        value.set(0L);[m
[31m-        this.latch = latch;[m
[31m-        count = expectedCount;[m
[31m-        batchesProcessed.set(0);[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void onEvent(final long[] event, final long sequence, final boolean endOfBatch) throws Exception[m
[31m-    {[m
[31m-        for (int i = 0; i < event.length; i++)[m
[31m-        {[m
[31m-            value.set(value.get() + event[i]);[m
[31m-        }[m
[31m-[m
[31m-        if (--count == 0)[m
[31m-        {[m
[31m-            latch.countDown();[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void onBatchStart(long batchSize)[m
[31m-    {[m
[31m-        batchesProcessed.increment();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/LongArrayPublisher.java b/src/perftest/java/com/lmax/disruptor/support/LongArrayPublisher.java[m
[1mdeleted file mode 100644[m
[1mindex 85cc66b..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/LongArrayPublisher.java[m
[1m+++ /dev/null[m
[36m@@ -1,64 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import java.util.concurrent.CyclicBarrier;[m
[31m-[m
[31m-import com.lmax.disruptor.RingBuffer;[m
[31m-[m
[31m-public final class LongArrayPublisher implements Runnable[m
[31m-{[m
[31m-    private final CyclicBarrier cyclicBarrier;[m
[31m-    private final RingBuffer<long[]> ringBuffer;[m
[31m-    private final long iterations;[m
[31m-    private final long arraySize;[m
[31m-[m
[31m-    public LongArrayPublisher([m
[31m-        final CyclicBarrier cyclicBarrier,[m
[31m-        final RingBuffer<long[]> ringBuffer,[m
[31m-        final long iterations,[m
[31m-        final long arraySize)[m
[31m-    {[m
[31m-        this.cyclicBarrier = cyclicBarrier;[m
[31m-        this.ringBuffer = ringBuffer;[m
[31m-        this.iterations = iterations;[m
[31m-        this.arraySize = arraySize;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void run()[m
[31m-    {[m
[31m-        try[m
[31m-        {[m
[31m-            cyclicBarrier.await();[m
[31m-[m
[31m-            for (long i = 0; i < iterations; i++)[m
[31m-            {[m
[31m-                long sequence = ringBuffer.next();[m
[31m-                long[] event = ringBuffer.get(sequence);[m
[31m-                for (int j = 0; j < arraySize; j++)[m
[31m-                {[m
[31m-                    event[j] = i + j;[m
[31m-                }[m
[31m-                ringBuffer.publish(sequence);[m
[31m-            }[m
[31m-        }[m
[31m-        catch (Exception ex)[m
[31m-        {[m
[31m-            throw new RuntimeException(ex);[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/MultiBufferBatchEventProcessor.java b/src/perftest/java/com/lmax/disruptor/support/MultiBufferBatchEventProcessor.java[m
[1mdeleted file mode 100644[m
[1mindex cc87eb2..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/MultiBufferBatchEventProcessor.java[m
[1m+++ /dev/null[m
[36m@@ -1,127 +0,0 @@[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import com.lmax.disruptor.*;[m
[31m-[m
[31m-import java.util.concurrent.atomic.AtomicBoolean;[m
[31m-[m
[31m-public class MultiBufferBatchEventProcessor<T>[m
[31m-    implements EventProcessor[m
[31m-{[m
[31m-    private final AtomicBoolean isRunning = new AtomicBoolean(false);[m
[31m-    private final DataProvider<T>[] providers;[m
[31m-    private final SequenceBarrier[] barriers;[m
[31m-    private final EventHandler<T> handler;[m
[31m-    private final Sequence[] sequences;[m
[31m-    private long count;[m
[31m-[m
[31m-    public MultiBufferBatchEventProcessor([m
[31m-        DataProvider<T>[] providers,[m
[31m-        SequenceBarrier[] barriers,[m
[31m-        EventHandler<T> handler)[m
[31m-    {[m
[31m-        if (providers.length != barriers.length)[m
[31m-        {[m
[31m-            throw new IllegalArgumentException();[m
[31m-        }[m
[31m-[m
[31m-        this.providers = providers;[m
[31m-        this.barriers = barriers;[m
[31m-        this.handler = handler;[m
[31m-[m
[31m-        this.sequences = new Sequence[providers.length];[m
[31m-        for (int i = 0; i < sequences.length; i++)[m
[31m-        {[m
[31m-            sequences[i] = new Sequence(-1);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void run()[m
[31m-    {[m
[31m-        if (!isRunning.compareAndSet(false, true))[m
[31m-        {[m
[31m-            throw new RuntimeException("Already running");[m
[31m-        }[m
[31m-[m
[31m-        for (SequenceBarrier barrier : barriers)[m
[31m-        {[m
[31m-            barrier.clearAlert();[m
[31m-        }[m
[31m-[m
[31m-        final int barrierLength = barriers.length;[m
[31m-[m
[31m-        while (true)[m
[31m-        {[m
[31m-            try[m
[31m-            {[m
[31m-                for (int i = 0; i < barrierLength; i++)[m
[31m-                {[m
[31m-                    long available = barriers[i].waitFor(-1);[m
[31m-                    Sequence sequence = sequences[i];[m
[31m-[m
[31m-                    long nextSequence = sequence.get() + 1;[m
[31m-[m
[31m-                    for (long l = nextSequence; l <= available; l++)[m
[31m-                    {[m
[31m-                        handler.onEvent(providers[i].get(l), l, nextSequence == available);[m
[31m-                    }[m
[31m-[m
[31m-                    sequence.set(available);[m
[31m-[m
[31m-                    count += available - nextSequence + 1;[m
[31m-                }[m
[31m-[m
[31m-                Thread.yield();[m
[31m-            }[m
[31m-            catch (AlertException e)[m
[31m-            {[m
[31m-                if (!isRunning())[m
[31m-                {[m
[31m-                    break;[m
[31m-                }[m
[31m-            }[m
[31m-            catch (InterruptedException e)[m
[31m-            {[m
[31m-                e.printStackTrace();[m
[31m-            }[m
[31m-            catch (TimeoutException e)[m
[31m-            {[m
[31m-                e.printStackTrace();[m
[31m-            }[m
[31m-            catch (Exception e)[m
[31m-            {[m
[31m-                e.printStackTrace();[m
[31m-                break;[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public Sequence getSequence()[m
[31m-    {[m
[31m-        throw new UnsupportedOperationException();[m
[31m-    }[m
[31m-[m
[31m-    public long getCount()[m
[31m-    {[m
[31m-        return count;[m
[31m-    }[m
[31m-[m
[31m-    public Sequence[] getSequences()[m
[31m-    {[m
[31m-        return sequences;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void halt()[m
[31m-    {[m
[31m-        isRunning.set(false);[m
[31m-        barriers[0].alert();[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public boolean isRunning()[m
[31m-    {[m
[31m-        return isRunning.get();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/Operation.java b/src/perftest/java/com/lmax/disruptor/support/Operation.java[m
[1mdeleted file mode 100644[m
[1mindex 5a9da99..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/Operation.java[m
[1m+++ /dev/null[m
[36m@@ -1,48 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-public enum Operation[m
[31m-{[m
[31m-    ADDITION[m
[31m-        {[m
[31m-            @Override[m
[31m-            public long op(final long lhs, final long rhs)[m
[31m-            {[m
[31m-                return lhs + rhs;[m
[31m-            }[m
[31m-        },[m
[31m-[m
[31m-    SUBTRACTION[m
[31m-        {[m
[31m-            @Override[m
[31m-            public long op(final long lhs, final long rhs)[m
[31m-            {[m
[31m-                return lhs - rhs;[m
[31m-            }[m
[31m-        },[m
[31m-[m
[31m-    AND[m
[31m-        {[m
[31m-            @Override[m
[31m-            public long op(final long lhs, final long rhs)[m
[31m-            {[m
[31m-                return lhs & rhs;[m
[31m-            }[m
[31m-        };[m
[31m-[m
[31m-    public abstract long op(long lhs, long rhs);[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/PerfTestUtil.java b/src/perftest/java/com/lmax/disruptor/support/PerfTestUtil.java[m
[1mdeleted file mode 100644[m
[1mindex d78472f..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/PerfTestUtil.java[m
[1m+++ /dev/null[m
[36m@@ -1,46 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-public final class PerfTestUtil[m
[31m-{[m
[31m-    public static long accumulatedAddition(final long iterations)[m
[31m-    {[m
[31m-        long temp = 0L;[m
[31m-        for (long i = 0L; i < iterations; i++)[m
[31m-        {[m
[31m-            temp += i;[m
[31m-        }[m
[31m-[m
[31m-        return temp;[m
[31m-    }[m
[31m-[m
[31m-    public static void failIf(long a, long b)[m
[31m-    {[m
[31m-        if (a == b)[m
[31m-        {[m
[31m-            throw new RuntimeException();[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static void failIfNot(long a, long b)[m
[31m-    {[m
[31m-        if (a != b)[m
[31m-        {[m
[31m-            throw new RuntimeException();[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/ValueAdditionBatchQueueProcessor.java b/src/perftest/java/com/lmax/disruptor/support/ValueAdditionBatchQueueProcessor.java[m
[1mdeleted file mode 100644[m
[1mindex a1ba043..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/ValueAdditionBatchQueueProcessor.java[m
[1m+++ /dev/null[m
[36m@@ -1,106 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import java.util.ArrayList;[m
[31m-import java.util.concurrent.BlockingQueue;[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-[m
[31m-public final class ValueAdditionBatchQueueProcessor implements Runnable[m
[31m-{[m
[31m-    private volatile boolean running;[m
[31m-    private long value;[m
[31m-    private long sequence;[m
[31m-    private CountDownLatch latch;[m
[31m-[m
[31m-    private final BlockingQueue<Long> blockingQueue;[m
[31m-    private final ArrayList<Long> batch = new ArrayList<>(100);[m
[31m-    private final long count;[m
[31m-[m
[31m-    public ValueAdditionBatchQueueProcessor(final BlockingQueue<Long> blockingQueue, final long count)[m
[31m-    {[m
[31m-        this.blockingQueue = blockingQueue;[m
[31m-        this.count = count;[m
[31m-    }[m
[31m-[m
[31m-    public long getValue()[m
[31m-    {[m
[31m-        return value;[m
[31m-    }[m
[31m-[m
[31m-    public void reset(final CountDownLatch latch)[m
[31m-    {[m
[31m-        value = 0L;[m
[31m-        sequence = 0L;[m
[31m-        this.latch = latch;[m
[31m-    }[m
[31m-[m
[31m-    public void halt()[m
[31m-    {[m
[31m-        running = false;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void run()[m
[31m-    {[m
[31m-        running = true;[m
[31m-        while (true)[m
[31m-        {[m
[31m-            try[m
[31m-            {[m
[31m-                long v = blockingQueue.take();[m
[31m-                sequence++;[m
[31m-[m
[31m-                this.value += v;[m
[31m-[m
[31m-                int c = blockingQueue.drainTo(batch, 100);[m
[31m-                sequence += c;[m
[31m-[m
[31m-                v = 0;[m
[31m-                for (int i = 0, n = batch.size(); i < n; i++)[m
[31m-                {[m
[31m-                    v += batch.get(i);[m
[31m-                }[m
[31m-[m
[31m-                this.value += v;[m
[31m-[m
[31m-                batch.clear();[m
[31m-[m
[31m-                if (sequence == count)[m
[31m-                {[m
[31m-                    latch.countDown();[m
[31m-                }[m
[31m-            }[m
[31m-            catch (InterruptedException ex)[m
[31m-            {[m
[31m-                if (!running)[m
[31m-                {[m
[31m-                    break;[m
[31m-                }[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public String toString()[m
[31m-    {[m
[31m-        return "ValueAdditionBatchQueueProcessor{" +[m
[31m-            "value=" + value +[m
[31m-            ", sequence=" + sequence +[m
[31m-            ", count=" + count +[m
[31m-            '}';[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/ValueAdditionEventHandler.java b/src/perftest/java/com/lmax/disruptor/support/ValueAdditionEventHandler.java[m
[1mdeleted file mode 100644[m
[1mindex 420f50b..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/ValueAdditionEventHandler.java[m
[1m+++ /dev/null[m
[36m@@ -1,65 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-[m
[31m-import com.lmax.disruptor.BatchStartAware;[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.util.PaddedLong;[m
[31m-[m
[31m-public final class ValueAdditionEventHandler implements EventHandler<ValueEvent>, BatchStartAware[m
[31m-{[m
[31m-    private final PaddedLong value = new PaddedLong();[m
[31m-    private final PaddedLong batchesProcessed = new PaddedLong();[m
[31m-    private long count;[m
[31m-    private CountDownLatch latch;[m
[31m-[m
[31m-    public long getValue()[m
[31m-    {[m
[31m-        return value.get();[m
[31m-    }[m
[31m-[m
[31m-    public long getBatchesProcessed()[m
[31m-    {[m
[31m-        return batchesProcessed.get();[m
[31m-    }[m
[31m-[m
[31m-    public void reset(final CountDownLatch latch, final long expectedCount)[m
[31m-    {[m
[31m-        value.set(0L);[m
[31m-        this.latch = latch;[m
[31m-        count = expectedCount;[m
[31m-        batchesProcessed.set(0);[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void onEvent(final ValueEvent event, final long sequence, final boolean endOfBatch) throws Exception[m
[31m-    {[m
[31m-        value.set(value.get() + event.getValue());[m
[31m-[m
[31m-        if (count == sequence)[m
[31m-        {[m
[31m-            latch.countDown();[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void onBatchStart(long batchSize)[m
[31m-    {[m
[31m-        batchesProcessed.increment();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/ValueAdditionQueueBatchProcessor.java b/src/perftest/java/com/lmax/disruptor/support/ValueAdditionQueueBatchProcessor.java[m
[1mdeleted file mode 100644[m
[1mindex 667ac08..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/ValueAdditionQueueBatchProcessor.java[m
[1m+++ /dev/null[m
[36m@@ -1,95 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import java.util.ArrayList;[m
[31m-import java.util.concurrent.BlockingQueue;[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-[m
[31m-public final class ValueAdditionQueueBatchProcessor implements Runnable[m
[31m-{[m
[31m-    private volatile boolean running;[m
[31m-    private long value;[m
[31m-    private long sequence;[m
[31m-    private CountDownLatch latch;[m
[31m-[m
[31m-    private final BlockingQueue<Long> blockingQueue;[m
[31m-    private final ArrayList<Long> buffer = new ArrayList<>();[m
[31m-    private final long count;[m
[31m-[m
[31m-    public ValueAdditionQueueBatchProcessor(final BlockingQueue<Long> blockingQueue, final long count)[m
[31m-    {[m
[31m-        this.blockingQueue = blockingQueue;[m
[31m-        this.count = count;[m
[31m-    }[m
[31m-[m
[31m-    public long getValue()[m
[31m-    {[m
[31m-        return value;[m
[31m-    }[m
[31m-[m
[31m-    public void reset(final CountDownLatch latch)[m
[31m-    {[m
[31m-        value = 0L;[m
[31m-        sequence = 0L;[m
[31m-        this.latch = latch;[m
[31m-    }[m
[31m-[m
[31m-    public void halt()[m
[31m-    {[m
[31m-        running = false;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void run()[m
[31m-    {[m
[31m-        running = true;[m
[31m-        while (true)[m
[31m-        {[m
[31m-            try[m
[31m-            {[m
[31m-                blockingQueue.drainTo(buffer);[m
[31m-                if (buffer.isEmpty())[m
[31m-                {[m
[31m-                    long value = blockingQueue.take().longValue();[m
[31m-                    this.value += value;[m
[31m-                    ++sequence;[m
[31m-                }[m
[31m-                else[m
[31m-                {[m
[31m-                    for (Long v : buffer)[m
[31m-                    {[m
[31m-                        this.value += v;[m
[31m-                    }[m
[31m-                    sequence += buffer.size();[m
[31m-                    buffer.clear();[m
[31m-                }[m
[31m-[m
[31m-                if (sequence >= count)[m
[31m-                {[m
[31m-                    latch.countDown();[m
[31m-                }[m
[31m-            }[m
[31m-            catch (InterruptedException ex)[m
[31m-            {[m
[31m-                if (!running)[m
[31m-                {[m
[31m-                    break;[m
[31m-                }[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/ValueAdditionQueueProcessor.java b/src/perftest/java/com/lmax/disruptor/support/ValueAdditionQueueProcessor.java[m
[1mdeleted file mode 100644[m
[1mindex 1a99505..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/ValueAdditionQueueProcessor.java[m
[1m+++ /dev/null[m
[36m@@ -1,79 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import java.util.concurrent.BlockingQueue;[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-[m
[31m-public final class ValueAdditionQueueProcessor implements Runnable[m
[31m-{[m
[31m-    private volatile boolean running;[m
[31m-    private long value;[m
[31m-    private long sequence;[m
[31m-    private CountDownLatch latch;[m
[31m-[m
[31m-    private final BlockingQueue<Long> blockingQueue;[m
[31m-    private final long count;[m
[31m-[m
[31m-    public ValueAdditionQueueProcessor(final BlockingQueue<Long> blockingQueue, final long count)[m
[31m-    {[m
[31m-        this.blockingQueue = blockingQueue;[m
[31m-        this.count = count;[m
[31m-    }[m
[31m-[m
[31m-    public long getValue()[m
[31m-    {[m
[31m-        return value;[m
[31m-    }[m
[31m-[m
[31m-    public void reset(final CountDownLatch latch)[m
[31m-    {[m
[31m-        value = 0L;[m
[31m-        sequence = 0L;[m
[31m-        this.latch = latch;[m
[31m-    }[m
[31m-[m
[31m-    public void halt()[m
[31m-    {[m
[31m-        running = false;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void run()[m
[31m-    {[m
[31m-        running = true;[m
[31m-        while (true)[m
[31m-        {[m
[31m-            try[m
[31m-            {[m
[31m-                long value = blockingQueue.take().longValue();[m
[31m-                this.value += value;[m
[31m-[m
[31m-                if (sequence++ == count)[m
[31m-                {[m
[31m-                    latch.countDown();[m
[31m-                }[m
[31m-            }[m
[31m-            catch (InterruptedException ex)[m
[31m-            {[m
[31m-                if (!running)[m
[31m-                {[m
[31m-                    break;[m
[31m-                }[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/ValueBatchPublisher.java b/src/perftest/java/com/lmax/disruptor/support/ValueBatchPublisher.java[m
[1mdeleted file mode 100644[m
[1mindex 1a06d76..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/ValueBatchPublisher.java[m
[1m+++ /dev/null[m
[36m@@ -1,65 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import java.util.concurrent.CyclicBarrier;[m
[31m-[m
[31m-import com.lmax.disruptor.RingBuffer;[m
[31m-[m
[31m-public final class ValueBatchPublisher implements Runnable[m
[31m-{[m
[31m-    private final CyclicBarrier cyclicBarrier;[m
[31m-    private final RingBuffer<ValueEvent> ringBuffer;[m
[31m-    private final long iterations;[m
[31m-    private final int batchSize;[m
[31m-[m
[31m-    public ValueBatchPublisher([m
[31m-        final CyclicBarrier cyclicBarrier,[m
[31m-        final RingBuffer<ValueEvent> ringBuffer,[m
[31m-        final long iterations,[m
[31m-        final int batchSize)[m
[31m-    {[m
[31m-        this.cyclicBarrier = cyclicBarrier;[m
[31m-        this.ringBuffer = ringBuffer;[m
[31m-        this.iterations = iterations;[m
[31m-        this.batchSize = batchSize;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void run()[m
[31m-    {[m
[31m-        try[m
[31m-        {[m
[31m-            cyclicBarrier.await();[m
[31m-[m
[31m-            for (long i = 0; i < iterations; i += batchSize)[m
[31m-            {[m
[31m-                long hi = ringBuffer.next(batchSize);[m
[31m-                long lo = hi - (batchSize - 1);[m
[31m-                for (long l = lo; l <= hi; l++)[m
[31m-                {[m
[31m-                    ValueEvent event = ringBuffer.get(l);[m
[31m-                    event.setValue(l);[m
[31m-                }[m
[31m-                ringBuffer.publish(lo, hi);[m
[31m-            }[m
[31m-        }[m
[31m-        catch (Exception ex)[m
[31m-        {[m
[31m-            throw new RuntimeException(ex);[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/ValueEvent.java b/src/perftest/java/com/lmax/disruptor/support/ValueEvent.java[m
[1mdeleted file mode 100644[m
[1mindex f3eda33..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/ValueEvent.java[m
[1m+++ /dev/null[m
[36m@@ -1,35 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import com.lmax.disruptor.EventFactory;[m
[31m-[m
[31m-public final class ValueEvent[m
[31m-{[m
[31m-    private long value;[m
[31m-[m
[31m-    public long getValue()[m
[31m-    {[m
[31m-        return value;[m
[31m-    }[m
[31m-[m
[31m-    public void setValue(final long value)[m
[31m-    {[m
[31m-        this.value = value;[m
[31m-    }[m
[31m-[m
[31m-    public static final EventFactory<ValueEvent> EVENT_FACTORY = ValueEvent::new;[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/ValueMutationEventHandler.java b/src/perftest/java/com/lmax/disruptor/support/ValueMutationEventHandler.java[m
[1mdeleted file mode 100644[m
[1mindex e4383b0..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/ValueMutationEventHandler.java[m
[1m+++ /dev/null[m
[36m@@ -1,71 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import com.lmax.disruptor.BatchStartAware;[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.util.PaddedLong;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-[m
[31m-public final class ValueMutationEventHandler implements EventHandler<ValueEvent>, BatchStartAware[m
[31m-{[m
[31m-    private final Operation operation;[m
[31m-    private final PaddedLong value = new PaddedLong();[m
[31m-    private final PaddedLong batchesProcessed = new PaddedLong();[m
[31m-    private long count;[m
[31m-    private CountDownLatch latch;[m
[31m-[m
[31m-    public ValueMutationEventHandler(final Operation operation)[m
[31m-    {[m
[31m-        this.operation = operation;[m
[31m-    }[m
[31m-[m
[31m-    public long getValue()[m
[31m-    {[m
[31m-        return value.get();[m
[31m-    }[m
[31m-[m
[31m-    public long getBatchesProcessed()[m
[31m-    {[m
[31m-        return batchesProcessed.get();[m
[31m-    }[m
[31m-[m
[31m-    public void reset(final CountDownLatch latch, final long expectedCount)[m
[31m-    {[m
[31m-        value.set(0L);[m
[31m-        this.latch = latch;[m
[31m-        count = expectedCount;[m
[31m-        batchesProcessed.set(0);[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void onEvent(final ValueEvent event, final long sequence, final boolean endOfBatch) throws Exception[m
[31m-    {[m
[31m-        value.set(operation.op(value.get(), event.getValue()));[m
[31m-[m
[31m-        if (count == sequence)[m
[31m-        {[m
[31m-            latch.countDown();[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void onBatchStart(long batchSize)[m
[31m-    {[m
[31m-        batchesProcessed.increment();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/ValueMutationQueueProcessor.java b/src/perftest/java/com/lmax/disruptor/support/ValueMutationQueueProcessor.java[m
[1mdeleted file mode 100644[m
[1mindex b76af8a..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/ValueMutationQueueProcessor.java[m
[1m+++ /dev/null[m
[36m@@ -1,82 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import java.util.concurrent.BlockingQueue;[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-[m
[31m-public final class ValueMutationQueueProcessor implements Runnable[m
[31m-{[m
[31m-    private volatile boolean running;[m
[31m-    private long value;[m
[31m-    private long sequence;[m
[31m-    private CountDownLatch latch;[m
[31m-[m
[31m-    private final BlockingQueue<Long> blockingQueue;[m
[31m-    private final Operation operation;[m
[31m-    private final long count;[m
[31m-[m
[31m-    public ValueMutationQueueProcessor([m
[31m-        final BlockingQueue<Long> blockingQueue, final Operation operation, final long count)[m
[31m-    {[m
[31m-        this.blockingQueue = blockingQueue;[m
[31m-        this.operation = operation;[m
[31m-        this.count = count;[m
[31m-    }[m
[31m-[m
[31m-    public long getValue()[m
[31m-    {[m
[31m-        return value;[m
[31m-    }[m
[31m-[m
[31m-    public void reset(final CountDownLatch latch)[m
[31m-    {[m
[31m-        value = 0L;[m
[31m-        sequence = 0L;[m
[31m-        this.latch = latch;[m
[31m-    }[m
[31m-[m
[31m-    public void halt()[m
[31m-    {[m
[31m-        running = false;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void run()[m
[31m-    {[m
[31m-        running = true;[m
[31m-        while (true)[m
[31m-        {[m
[31m-            try[m
[31m-            {[m
[31m-                long value = blockingQueue.take().longValue();[m
[31m-                this.value = operation.op(this.value, value);[m
[31m-[m
[31m-                if (sequence++ == count)[m
[31m-                {[m
[31m-                    latch.countDown();[m
[31m-                }[m
[31m-            }[m
[31m-            catch (InterruptedException ex)[m
[31m-            {[m
[31m-                if (!running)[m
[31m-                {[m
[31m-                    break;[m
[31m-                }[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/ValuePublisher.java b/src/perftest/java/com/lmax/disruptor/support/ValuePublisher.java[m
[1mdeleted file mode 100644[m
[1mindex a875402..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/ValuePublisher.java[m
[1m+++ /dev/null[m
[36m@@ -1,56 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import java.util.concurrent.CyclicBarrier;[m
[31m-[m
[31m-import com.lmax.disruptor.RingBuffer;[m
[31m-[m
[31m-public final class ValuePublisher implements Runnable[m
[31m-{[m
[31m-    private final CyclicBarrier cyclicBarrier;[m
[31m-    private final RingBuffer<ValueEvent> ringBuffer;[m
[31m-    private final long iterations;[m
[31m-[m
[31m-    public ValuePublisher([m
[31m-        final CyclicBarrier cyclicBarrier, final RingBuffer<ValueEvent> ringBuffer, final long iterations)[m
[31m-    {[m
[31m-        this.cyclicBarrier = cyclicBarrier;[m
[31m-        this.ringBuffer = ringBuffer;[m
[31m-        this.iterations = iterations;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void run()[m
[31m-    {[m
[31m-        try[m
[31m-        {[m
[31m-            cyclicBarrier.await();[m
[31m-[m
[31m-            for (long i = 0; i < iterations; i++)[m
[31m-            {[m
[31m-                long sequence = ringBuffer.next();[m
[31m-                ValueEvent event = ringBuffer.get(sequence);[m
[31m-                event.setValue(i);[m
[31m-                ringBuffer.publish(sequence);[m
[31m-            }[m
[31m-        }[m
[31m-        catch (Exception ex)[m
[31m-        {[m
[31m-            throw new RuntimeException(ex);[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/support/ValueQueuePublisher.java b/src/perftest/java/com/lmax/disruptor/support/ValueQueuePublisher.java[m
[1mdeleted file mode 100644[m
[1mindex 6693601..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/support/ValueQueuePublisher.java[m
[1m+++ /dev/null[m
[36m@@ -1,51 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import java.util.concurrent.BlockingQueue;[m
[31m-import java.util.concurrent.CyclicBarrier;[m
[31m-[m
[31m-public final class ValueQueuePublisher implements Runnable[m
[31m-{[m
[31m-    private final CyclicBarrier cyclicBarrier;[m
[31m-    private final BlockingQueue<Long> blockingQueue;[m
[31m-    private final long iterations;[m
[31m-[m
[31m-    public ValueQueuePublisher([m
[31m-        final CyclicBarrier cyclicBarrier, final BlockingQueue<Long> blockingQueue, final long iterations)[m
[31m-    {[m
[31m-        this.cyclicBarrier = cyclicBarrier;[m
[31m-        this.blockingQueue = blockingQueue;[m
[31m-        this.iterations = iterations;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void run()[m
[31m-    {[m
[31m-        try[m
[31m-        {[m
[31m-            cyclicBarrier.await();[m
[31m-            for (long i = 0; i < iterations; i++)[m
[31m-            {[m
[31m-                blockingQueue.put(Long.valueOf(i));[m
[31m-            }[m
[31m-        }[m
[31m-        catch (Exception ex)[m
[31m-        {[m
[31m-            throw new RuntimeException(ex);[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/perftest/java/com/lmax/disruptor/translator/OneToOneTranslatorThroughputTest.java b/src/perftest/java/com/lmax/disruptor/translator/OneToOneTranslatorThroughputTest.java[m
[1mdeleted file mode 100644[m
[1mindex b4d8e2c..0000000[m
[1m--- a/src/perftest/java/com/lmax/disruptor/translator/OneToOneTranslatorThroughputTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,146 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.translator;[m
[31m-[m
[31m-import com.lmax.disruptor.*;[m
[31m-import com.lmax.disruptor.dsl.Disruptor;[m
[31m-import com.lmax.disruptor.dsl.ProducerType;[m
[31m-import com.lmax.disruptor.support.PerfTestUtil;[m
[31m-import com.lmax.disruptor.support.ValueAdditionEventHandler;[m
[31m-import com.lmax.disruptor.support.ValueEvent;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-import com.lmax.disruptor.util.MutableLong;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-[m
[31m-import static com.lmax.disruptor.support.PerfTestUtil.failIfNot;[m
[31m-[m
[31m-/**[m
[31m- * <pre>[m
[31m- * UniCast a series of items between 1 publisher and 1 event processor using the EventTranslator API[m
[31m- *[m
[31m- * +----+    +-----+[m
[31m- * | P1 |--->| EP1 |[m
[31m- * +----+    +-----+[m
[31m- *[m
[31m- * Disruptor:[m
[31m- * ==========[m
[31m- *              track to prevent wrap[m
[31m- *              +------------------+[m
[31m- *              |                  |[m
[31m- *              |                  v[m
[31m- * +----+    +====+    +====+   +-----+[m
[31m- * | P1 |--->| RB |<---| SB |   | EP1 |[m
[31m- * +----+    +====+    +====+   +-----+[m
[31m- *      claim      get    ^        |[m
[31m- *                        |        |[m
[31m- *                        +--------+[m
[31m- *                          waitFor[m
[31m- *[m
[31m- * P1  - Publisher 1[m
[31m- * RB  - RingBuffer[m
[31m- * SB  - SequenceBarrier[m
[31m- * EP1 - EventProcessor 1[m
[31m- *[m
[31m- * </pre>[m
[31m- */[m
[31m-public final class OneToOneTranslatorThroughputTest extends AbstractPerfTestDisruptor[m
[31m-{[m
[31m-    private static final int BUFFER_SIZE = 1024 * 64;[m
[31m-    private static final long ITERATIONS = 1000L * 1000L * 100L;[m
[31m-    private final long expectedResult = PerfTestUtil.accumulatedAddition(ITERATIONS);[m
[31m-    private final ValueAdditionEventHandler handler = new ValueAdditionEventHandler();[m
[31m-    private final RingBuffer<ValueEvent> ringBuffer;[m
[31m-    private final MutableLong value = new MutableLong(0);[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @SuppressWarnings("unchecked")[m
[31m-    public OneToOneTranslatorThroughputTest()[m
[31m-    {[m
[31m-        Disruptor<ValueEvent> disruptor =[m
[31m-                new Disruptor<>([m
[31m-                        ValueEvent.EVENT_FACTORY,[m
[31m-                        BUFFER_SIZE, DaemonThreadFactory.INSTANCE,[m
[31m-                        ProducerType.SINGLE,[m
[31m-                        new YieldingWaitStrategy());[m
[31m-        disruptor.handleEventsWith(handler);[m
[31m-        this.ringBuffer = disruptor.start();[m
[31m-    }[m
[31m-[m
[31m-    ///////////////////////////////////////////////////////////////////////////////////////////////[m
[31m-[m
[31m-    @Override[m
[31m-    protected int getRequiredProcessorCount()[m
[31m-    {[m
[31m-        return 2;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    protected PerfTestContext runDisruptorPass() throws InterruptedException[m
[31m-    {[m
[31m-        PerfTestContext perfTestContext = new PerfTestContext();[m
[31m-        MutableLong value = this.value;[m
[31m-[m
[31m-        final CountDownLatch latch = new CountDownLatch(1);[m
[31m-        long expectedCount = ringBuffer.getMinimumGatingSequence() + ITERATIONS;[m
[31m-[m
[31m-        handler.reset(latch, expectedCount);[m
[31m-        long start = System.currentTimeMillis();[m
[31m-[m
[31m-        final RingBuffer<ValueEvent> rb = ringBuffer;[m
[31m-[m
[31m-        for (long l = 0; l < ITERATIONS; l++)[m
[31m-        {[m
[31m-            value.set(l);[m
[31m-            rb.publishEvent(Translator.INSTANCE, value);[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-        perfTestContext.setDisruptorOps((ITERATIONS * 1000L) / (System.currentTimeMillis() - start));[m
[31m-        perfTestContext.setBatchData(handler.getBatchesProcessed(), ITERATIONS);[m
[31m-        waitForEventProcessorSequence(expectedCount);[m
[31m-[m
[31m-        failIfNot(expectedResult, handler.getValue());[m
[31m-[m
[31m-        return perfTestContext;[m
[31m-    }[m
[31m-[m
[31m-    private static class Translator implements EventTranslatorOneArg<ValueEvent, MutableLong>[m
[31m-    {[m
[31m-        private static final Translator INSTANCE = new Translator();[m
[31m-[m
[31m-        @Override[m
[31m-        public void translateTo(ValueEvent event, long sequence, MutableLong arg0)[m
[31m-        {[m
[31m-            event.setValue(arg0.get());[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private void waitForEventProcessorSequence(long expectedCount) throws InterruptedException[m
[31m-    {[m
[31m-        while (ringBuffer.getMinimumGatingSequence() != expectedCount)[m
[31m-        {[m
[31m-            Thread.sleep(1);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public static void main(String[] args) throws Exception[m
[31m-    {[m
[31m-        OneToOneTranslatorThroughputTest test = new OneToOneTranslatorThroughputTest();[m
[31m-        test.testImplementations();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/AggregateEventHandlerTest.java b/src/test/java/com/lmax/disruptor/AggregateEventHandlerTest.java[m
[1mdeleted file mode 100644[m
[1mindex 9074632..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/AggregateEventHandlerTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,101 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import com.lmax.disruptor.support.DummyEventHandler;[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import static org.hamcrest.MatcherAssert.assertThat;[m
[31m-import static org.hamcrest.core.Is.is;[m
[31m-[m
[31m-@SuppressWarnings("unchecked")[m
[31m-public final class AggregateEventHandlerTest[m
[31m-{[m
[31m-    private final DummyEventHandler<int[]> eh1 = new DummyEventHandler<>();[m
[31m-    private final DummyEventHandler<int[]> eh2 = new DummyEventHandler<>();[m
[31m-    private final DummyEventHandler<int[]> eh3 = new DummyEventHandler<>();[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldCallOnEventInSequence()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        final int[] event = {7};[m
[31m-        final long sequence = 3L;[m
[31m-        final boolean endOfBatch = true;[m
[31m-[m
[31m-        final AggregateEventHandler<int[]> aggregateEventHandler = new AggregateEventHandler<>(eh1, eh2, eh3);[m
[31m-[m
[31m-        aggregateEventHandler.onEvent(event, sequence, endOfBatch);[m
[31m-        assertLastEvent(event, sequence, eh1, eh2, eh3);[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldCallOnStartInSequence()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        final AggregateEventHandler<int[]> aggregateEventHandler = new AggregateEventHandler<>(eh1, eh2, eh3);[m
[31m-[m
[31m-        aggregateEventHandler.onStart();[m
[31m-[m
[31m-        assertStartCalls(1, eh1, eh2, eh3);[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldCallOnShutdownInSequence()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        final AggregateEventHandler<int[]> aggregateEventHandler = new AggregateEventHandler<>(eh1, eh2, eh3);[m
[31m-[m
[31m-        aggregateEventHandler.onShutdown();[m
[31m-[m
[31m-        assertShutoownCalls(1, eh1, eh2, eh3);[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldHandleEmptyListOfEventHandlers() throws Exception[m
[31m-    {[m
[31m-        final AggregateEventHandler<int[]> aggregateEventHandler = new AggregateEventHandler<>();[m
[31m-[m
[31m-        aggregateEventHandler.onEvent(new int[]{7}, 0L, true);[m
[31m-        aggregateEventHandler.onStart();[m
[31m-        aggregateEventHandler.onShutdown();[m
[31m-    }[m
[31m-[m
[31m-    private static void assertLastEvent(int[] event, long sequence, DummyEventHandler<int[]>... eh1)[m
[31m-    {[m
[31m-        for (DummyEventHandler<int[]> eh : eh1)[m
[31m-        {[m
[31m-            assertThat(eh.lastEvent, is(event));[m
[31m-            assertThat(eh.lastSequence, is(sequence));[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static void assertStartCalls(int startCalls, DummyEventHandler<int[]>... handlers)[m
[31m-    {[m
[31m-        for (DummyEventHandler<int[]> handler : handlers)[m
[31m-        {[m
[31m-            assertThat(handler.startCalls, is(startCalls));[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static void assertShutoownCalls(int startCalls, DummyEventHandler<int[]>... handlers)[m
[31m-    {[m
[31m-        for (DummyEventHandler<int[]> handler : handlers)[m
[31m-        {[m
[31m-            assertThat(handler.shutdownCalls, is(startCalls));[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/BatchEventProcessorTest.java b/src/test/java/com/lmax/disruptor/BatchEventProcessorTest.java[m
[1mdeleted file mode 100644[m
[1mindex 2beaddd..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/BatchEventProcessorTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,374 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import com.lmax.disruptor.support.StubEvent;[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import java.util.ArrayList;[m
[31m-import java.util.Arrays;[m
[31m-import java.util.HashMap;[m
[31m-import java.util.List;[m
[31m-import java.util.Map;[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.TimeUnit;[m
[31m-[m
[31m-import static com.lmax.disruptor.RingBuffer.createMultiProducer;[m
[31m-import static org.hamcrest.CoreMatchers.not;[m
[31m-import static org.hamcrest.CoreMatchers.nullValue;[m
[31m-import static org.hamcrest.MatcherAssert.assertThat;[m
[31m-import static org.junit.jupiter.api.Assertions.assertEquals;[m
[31m-import static org.junit.jupiter.api.Assertions.assertThrows;[m
[31m-import static org.junit.jupiter.api.Assertions.assertTrue;[m
[31m-[m
[31m-public final class BatchEventProcessorTest[m
[31m-{[m
[31m-    private final RingBuffer<StubEvent> ringBuffer = createMultiProducer(StubEvent.EVENT_FACTORY, 16);[m
[31m-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldThrowExceptionOnSettingNullExceptionHandler()[m
[31m-    {[m
[31m-        assertThrows(NullPointerException.class, () ->[m
[31m-        {[m
[31m-            final BatchEventProcessor<StubEvent> batchEventProcessor = new BatchEventProcessor<>([m
[31m-                    ringBuffer, sequenceBarrier, new ExceptionEventHandler());[m
[31m-            batchEventProcessor.setExceptionHandler(null);[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldCallMethodsInLifecycleOrderForBatch()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        CountDownLatch eventLatch = new CountDownLatch(3);[m
[31m-        LatchEventHandler eventHandler = new LatchEventHandler(eventLatch);[m
[31m-        final BatchEventProcessor<StubEvent> batchEventProcessor = new BatchEventProcessor<>([m
[31m-                ringBuffer, sequenceBarrier, eventHandler);[m
[31m-[m
[31m-        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());[m
[31m-[m
[31m-        ringBuffer.publish(ringBuffer.next());[m
[31m-        ringBuffer.publish(ringBuffer.next());[m
[31m-        ringBuffer.publish(ringBuffer.next());[m
[31m-[m
[31m-        Thread thread = new Thread(batchEventProcessor);[m
[31m-        thread.start();[m
[31m-[m
[31m-        assertTrue(eventLatch.await(2, TimeUnit.SECONDS));[m
[31m-[m
[31m-        batchEventProcessor.halt();[m
[31m-        thread.join();[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldCallExceptionHandlerOnUncaughtException()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        CountDownLatch exceptionLatch = new CountDownLatch(1);[m
[31m-        LatchExceptionHandler latchExceptionHandler = new LatchExceptionHandler(exceptionLatch);[m
[31m-        final BatchEventProcessor<StubEvent> batchEventProcessor = new BatchEventProcessor<>([m
[31m-                ringBuffer, sequenceBarrier, new ExceptionEventHandler());[m
[31m-        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());[m
[31m-[m
[31m-        batchEventProcessor.setExceptionHandler(latchExceptionHandler);[m
[31m-[m
[31m-        Thread thread = new Thread(batchEventProcessor);[m
[31m-        thread.start();[m
[31m-[m
[31m-        ringBuffer.publish(ringBuffer.next());[m
[31m-[m
[31m-        assertTrue(exceptionLatch.await(2, TimeUnit.SECONDS));[m
[31m-[m
[31m-        batchEventProcessor.halt();[m
[31m-        thread.join();[m
[31m-    }[m
[31m-[m
[31m-    private static class LatchEventHandler implements EventHandler<StubEvent>[m
[31m-    {[m
[31m-        private final CountDownLatch latch;[m
[31m-[m
[31m-        LatchEventHandler(CountDownLatch latch)[m
[31m-        {[m
[31m-            this.latch = latch;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onEvent(StubEvent event, long sequence, boolean endOfBatch) throws Exception[m
[31m-        {[m
[31m-            latch.countDown();[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class LatchExceptionHandler implements ExceptionHandler<StubEvent>[m
[31m-    {[m
[31m-        private final CountDownLatch latch;[m
[31m-[m
[31m-        LatchExceptionHandler(CountDownLatch latch)[m
[31m-        {[m
[31m-            this.latch = latch;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void handleEventException(Throwable ex, long sequence, StubEvent event)[m
[31m-        {[m
[31m-            latch.countDown();[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void handleOnStartException(Throwable ex)[m
[31m-        {[m
[31m-[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void handleOnShutdownException(Throwable ex)[m
[31m-        {[m
[31m-[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class ExceptionEventHandler implements EventHandler<StubEvent>[m
[31m-    {[m
[31m-        @Override[m
[31m-        public void onEvent(StubEvent event, long sequence, boolean endOfBatch) throws Exception[m
[31m-        {[m
[31m-            throw new NullPointerException(null);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void reportAccurateBatchSizesAtBatchStartTime()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        final List<Long> batchSizes = new ArrayList<>();[m
[31m-        final CountDownLatch eventLatch = new CountDownLatch(6);[m
[31m-[m
[31m-        final class LoopbackEventHandler[m
[31m-            implements EventHandler<StubEvent>, BatchStartAware[m
[31m-        {[m
[31m-[m
[31m-            @Override[m
[31m-            public void onBatchStart(long batchSize)[m
[31m-            {[m
[31m-                batchSizes.add(batchSize);[m
[31m-            }[m
[31m-[m
[31m-            @Override[m
[31m-            public void onEvent(StubEvent event, long sequence, boolean endOfBatch)[m
[31m-                throws Exception[m
[31m-            {[m
[31m-                if (!endOfBatch)[m
[31m-                {[m
[31m-                    ringBuffer.publish(ringBuffer.next());[m
[31m-                }[m
[31m-                eventLatch.countDown();[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        final BatchEventProcessor<StubEvent> batchEventProcessor =[m
[31m-                new BatchEventProcessor<>([m
[31m-                        ringBuffer, sequenceBarrier, new LoopbackEventHandler());[m
[31m-[m
[31m-        ringBuffer.publish(ringBuffer.next());[m
[31m-        ringBuffer.publish(ringBuffer.next());[m
[31m-        ringBuffer.publish(ringBuffer.next());[m
[31m-[m
[31m-        Thread thread = new Thread(batchEventProcessor);[m
[31m-        thread.start();[m
[31m-        eventLatch.await();[m
[31m-[m
[31m-        batchEventProcessor.halt();[m
[31m-        thread.join();[m
[31m-[m
[31m-        assertEquals(Arrays.asList(3L, 2L, 1L), batchSizes);[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldAlwaysHalt() throws InterruptedException[m
[31m-    {[m
[31m-        WaitStrategy waitStrategy = new BusySpinWaitStrategy();[m
[31m-        final SingleProducerSequencer sequencer = new SingleProducerSequencer(8, waitStrategy);[m
[31m-        final ProcessingSequenceBarrier barrier = new ProcessingSequenceBarrier([m
[31m-            sequencer, waitStrategy, new Sequence(-1), new Sequence[0]);[m
[31m-        DataProvider<Object> dp = sequence -> null;[m
[31m-[m
[31m-        final LatchLifeCycleHandler h1 = new LatchLifeCycleHandler();[m
[31m-        final BatchEventProcessor p1 = new BatchEventProcessor<>(dp, barrier, h1);[m
[31m-[m
[31m-        Thread t1 = new Thread(p1);[m
[31m-        p1.halt();[m
[31m-        t1.start();[m
[31m-[m
[31m-        assertTrue(h1.awaitStart(2, TimeUnit.SECONDS));[m
[31m-        assertTrue(h1.awaitStop(2, TimeUnit.SECONDS));[m
[31m-[m
[31m-        for (int i = 0; i < 1000; i++)[m
[31m-        {[m
[31m-            final LatchLifeCycleHandler h2 = new LatchLifeCycleHandler();[m
[31m-            final BatchEventProcessor p2 = new BatchEventProcessor<>(dp, barrier, h2);[m
[31m-            Thread t2 = new Thread(p2);[m
[31m-            t2.start();[m
[31m-            p2.halt();[m
[31m-[m
[31m-            assertTrue(h2.awaitStart(2, TimeUnit.SECONDS));[m
[31m-            assertTrue(h2.awaitStop(2, TimeUnit.SECONDS));[m
[31m-        }[m
[31m-[m
[31m-        for (int i = 0; i < 1000; i++)[m
[31m-        {[m
[31m-            final LatchLifeCycleHandler h2 = new LatchLifeCycleHandler();[m
[31m-            final BatchEventProcessor p2 = new BatchEventProcessor<>(dp, barrier, h2);[m
[31m-            Thread t2 = new Thread(p2);[m
[31m-            t2.start();[m
[31m-            Thread.yield();[m
[31m-            p2.halt();[m
[31m-[m
[31m-            assertTrue(h2.awaitStart(2, TimeUnit.SECONDS));[m
[31m-            assertTrue(h2.awaitStop(2, TimeUnit.SECONDS));[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class LatchLifeCycleHandler implements EventHandler<Object>, LifecycleAware[m
[31m-    {[m
[31m-        private final CountDownLatch startLatch = new CountDownLatch(1);[m
[31m-        private final CountDownLatch stopLatch = new CountDownLatch(1);[m
[31m-[m
[31m-        @Override[m
[31m-        public void onEvent(Object event, long sequence, boolean endOfBatch) throws Exception[m
[31m-        {[m
[31m-[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onStart()[m
[31m-        {[m
[31m-            startLatch.countDown();[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onShutdown()[m
[31m-        {[m
[31m-            stopLatch.countDown();[m
[31m-        }[m
[31m-[m
[31m-        public boolean awaitStart(long time, TimeUnit unit) throws InterruptedException[m
[31m-        {[m
[31m-            return startLatch.await(time, unit);[m
[31m-        }[m
[31m-[m
[31m-[m
[31m-        public boolean awaitStop(long time, TimeUnit unit) throws InterruptedException[m
[31m-        {[m
[31m-            return stopLatch.await(time, unit);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPassZeroSizeToBatchStartAware() throws Exception[m
[31m-    {[m
[31m-        final CountDownLatch latch = new CountDownLatch(3);[m
[31m-[m
[31m-        BatchAwareEventHandler eventHandler = new BatchAwareEventHandler(latch);[m
[31m-[m
[31m-        final BatchEventProcessor<StubEvent> batchEventProcessor = new BatchEventProcessor<>([m
[31m-                ringBuffer, new DelegatingSequenceBarrier(this.sequenceBarrier), eventHandler);[m
[31m-[m
[31m-        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());[m
[31m-[m
[31m-        Thread thread = new Thread(batchEventProcessor);[m
[31m-        thread.start();[m
[31m-        latch.await(2, TimeUnit.SECONDS);[m
[31m-[m
[31m-        ringBuffer.publish(ringBuffer.next());[m
[31m-        ringBuffer.publish(ringBuffer.next());[m
[31m-        ringBuffer.publish(ringBuffer.next());[m
[31m-[m
[31m-        batchEventProcessor.halt();[m
[31m-        thread.join();[m
[31m-[m
[31m-        assertThat(eventHandler.batchSizeToCountMap.size(), not(0));[m
[31m-        assertThat(eventHandler.batchSizeToCountMap.get(0L), nullValue());[m
[31m-    }[m
[31m-[m
[31m-    private static class DelegatingSequenceBarrier implements SequenceBarrier[m
[31m-    {[m
[31m-        private SequenceBarrier delegate;[m
[31m-        private boolean suppress = true;[m
[31m-[m
[31m-        DelegatingSequenceBarrier(SequenceBarrier delegate)[m
[31m-        {[m
[31m-            this.delegate = delegate;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public long waitFor(long sequence) throws AlertException, InterruptedException, TimeoutException[m
[31m-        {[m
[31m-            long result = suppress ? sequence - 1 : delegate.waitFor(sequence);[m
[31m-            suppress = !suppress;[m
[31m-            return result;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public long getCursor()[m
[31m-        {[m
[31m-            return delegate.getCursor();[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public boolean isAlerted()[m
[31m-        {[m
[31m-            return delegate.isAlerted();[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void alert()[m
[31m-        {[m
[31m-            delegate.alert();[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void clearAlert()[m
[31m-        {[m
[31m-            delegate.clearAlert();[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void checkAlert() throws AlertException[m
[31m-        {[m
[31m-            delegate.checkAlert();[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class BatchAwareEventHandler extends LatchEventHandler implements BatchStartAware[m
[31m-    {[m
[31m-        final Map<Long, Integer> batchSizeToCountMap = new HashMap<>();[m
[31m-[m
[31m-        BatchAwareEventHandler(CountDownLatch latch)[m
[31m-        {[m
[31m-            super(latch);[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onBatchStart(long batchSize)[m
[31m-        {[m
[31m-            final Integer currentCount = batchSizeToCountMap.get(batchSize);[m
[31m-            final int nextCount = null == currentCount ? 1 : currentCount + 1;[m
[31m-            batchSizeToCountMap.put(batchSize, nextCount);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/BatchingTest.java b/src/test/java/com/lmax/disruptor/BatchingTest.java[m
[1mdeleted file mode 100644[m
[1mindex 9e8a110..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/BatchingTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,101 +0,0 @@[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import com.lmax.disruptor.dsl.Disruptor;[m
[31m-import com.lmax.disruptor.dsl.ProducerType;[m
[31m-import com.lmax.disruptor.support.LongEvent;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-import org.hamcrest.CoreMatchers;[m
[31m-import org.junit.jupiter.params.ParameterizedTest;[m
[31m-import org.junit.jupiter.params.provider.Arguments;[m
[31m-import org.junit.jupiter.params.provider.MethodSource;[m
[31m-[m
[31m-import java.util.concurrent.locks.LockSupport;[m
[31m-import java.util.stream.Stream;[m
[31m-[m
[31m-import static org.hamcrest.MatcherAssert.assertThat;[m
[31m-import static org.junit.jupiter.params.provider.Arguments.arguments;[m
[31m-[m
[31m-public class BatchingTest[m
[31m-{[m
[31m-    public static Stream<Arguments> generateData()[m
[31m-    {[m
[31m-        return Stream.of(arguments(ProducerType.MULTI), arguments(ProducerType.SINGLE));[m
[31m-    }[m
[31m-[m
[31m-    private static class ParallelEventHandler implements EventHandler<LongEvent>[m
[31m-    {[m
[31m-        private final long mask;[m
[31m-        private final long ordinal;[m
[31m-        private final int batchSize = 10;[m
[31m-[m
[31m-        private long eventCount;[m
[31m-        private long batchCount;[m
[31m-        private long publishedValue;[m
[31m-        private long tempValue;[m
[31m-        private volatile long processed;[m
[31m-[m
[31m-        ParallelEventHandler(long mask, long ordinal)[m
[31m-        {[m
[31m-            this.mask = mask;[m
[31m-            this.ordinal = ordinal;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onEvent(LongEvent event, long sequence, boolean endOfBatch) throws Exception[m
[31m-        {[m
[31m-            if ((sequence & mask) == ordinal)[m
[31m-            {[m
[31m-                eventCount++;[m
[31m-                tempValue = event.get();[m
[31m-            }[m
[31m-[m
[31m-            if (endOfBatch || ++batchCount >= batchSize)[m
[31m-            {[m
[31m-                publishedValue = tempValue;[m
[31m-                batchCount = 0;[m
[31m-            }[m
[31m-            else[m
[31m-            {[m
[31m-                LockSupport.parkNanos(1);[m
[31m-            }[m
[31m-[m
[31m-            processed = sequence;[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @SuppressWarnings("unchecked")[m
[31m-    @ParameterizedTest[m
[31m-    @MethodSource("generateData")[m
[31m-    public void shouldBatch(ProducerType producerType) throws Exception[m
[31m-    {[m
[31m-        Disruptor<LongEvent> d = new Disruptor<>([m
[31m-                LongEvent.FACTORY, 2048, DaemonThreadFactory.INSTANCE,[m
[31m-                producerType, new SleepingWaitStrategy());[m
[31m-[m
[31m-        ParallelEventHandler handler1 = new ParallelEventHandler(1, 0);[m
[31m-        ParallelEventHandler handler2 = new ParallelEventHandler(1, 1);[m
[31m-[m
[31m-        d.handleEventsWith(handler1, handler2);[m
[31m-[m
[31m-        RingBuffer<LongEvent> buffer = d.start();[m
[31m-[m
[31m-        EventTranslator<LongEvent> translator = (event, sequence) -> event.set(sequence);[m
[31m-[m
[31m-        int eventCount = 10000;[m
[31m-        for (int i = 0; i < eventCount; i++)[m
[31m-        {[m
[31m-            buffer.publishEvent(translator);[m
[31m-        }[m
[31m-[m
[31m-        while (handler1.processed != eventCount - 1 ||[m
[31m-            handler2.processed != eventCount - 1)[m
[31m-        {[m
[31m-            Thread.sleep(1);[m
[31m-        }[m
[31m-[m
[31m-        assertThat(handler1.publishedValue, CoreMatchers.is((long) eventCount - 2));[m
[31m-        assertThat(handler1.eventCount, CoreMatchers.is((long) eventCount / 2));[m
[31m-        assertThat(handler2.publishedValue, CoreMatchers.is((long) eventCount - 1));[m
[31m-        assertThat(handler2.eventCount, CoreMatchers.is((long) eventCount / 2));[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/BusySpinWaitStrategyTest.java b/src/test/java/com/lmax/disruptor/BusySpinWaitStrategyTest.java[m
[1mdeleted file mode 100644[m
[1mindex b139584..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/BusySpinWaitStrategyTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,30 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2012 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import static com.lmax.disruptor.support.WaitStrategyTestUtil.assertWaitForWithDelayOf;[m
[31m-[m
[31m-public class BusySpinWaitStrategyTest[m
[31m-{[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldWaitForValue() throws Exception[m
[31m-    {[m
[31m-        assertWaitForWithDelayOf(50, new BusySpinWaitStrategy());[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/DisruptorStressTest.java b/src/test/java/com/lmax/disruptor/DisruptorStressTest.java[m
[1mdeleted file mode 100644[m
[1mindex de7c8df..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/DisruptorStressTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,180 +0,0 @@[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import com.lmax.disruptor.dsl.Disruptor;[m
[31m-import com.lmax.disruptor.dsl.ProducerType;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.CyclicBarrier;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-import java.util.concurrent.locks.LockSupport;[m
[31m-[m
[31m-import static java.lang.Math.max;[m
[31m-import static org.hamcrest.CoreMatchers.is;[m
[31m-import static org.hamcrest.CoreMatchers.not;[m
[31m-import static org.hamcrest.MatcherAssert.assertThat;[m
[31m-[m
[31m-public class DisruptorStressTest[m
[31m-{[m
[31m-    private final ExecutorService executor = Executors.newCachedThreadPool();[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldHandleLotsOfThreads() throws Exception[m
[31m-    {[m
[31m-        Disruptor<TestEvent> disruptor = new Disruptor<>([m
[31m-                TestEvent.FACTORY, 1 << 16, DaemonThreadFactory.INSTANCE,[m
[31m-                ProducerType.MULTI, new BusySpinWaitStrategy());[m
[31m-        RingBuffer<TestEvent> ringBuffer = disruptor.getRingBuffer();[m
[31m-        disruptor.setDefaultExceptionHandler(new FatalExceptionHandler());[m
[31m-[m
[31m-        int threads = max(1, Runtime.getRuntime().availableProcessors() / 2);[m
[31m-[m
[31m-        int iterations = 200000;[m
[31m-        int publisherCount = threads;[m
[31m-        int handlerCount = threads;[m
[31m-[m
[31m-        CyclicBarrier barrier = new CyclicBarrier(publisherCount);[m
[31m-        CountDownLatch latch = new CountDownLatch(publisherCount);[m
[31m-[m
[31m-        TestEventHandler[] handlers = initialise(disruptor, new TestEventHandler[handlerCount]);[m
[31m-        Publisher[] publishers = initialise(new Publisher[publisherCount], ringBuffer, iterations, barrier, latch);[m
[31m-[m
[31m-        disruptor.start();[m
[31m-[m
[31m-        for (Publisher publisher : publishers)[m
[31m-        {[m
[31m-            executor.execute(publisher);[m
[31m-        }[m
[31m-[m
[31m-        latch.await();[m
[31m-        while (ringBuffer.getCursor() < (iterations - 1))[m
[31m-        {[m
[31m-            LockSupport.parkNanos(1);[m
[31m-        }[m
[31m-[m
[31m-        disruptor.shutdown();[m
[31m-[m
[31m-        for (Publisher publisher : publishers)[m
[31m-        {[m
[31m-            assertThat(publisher.failed, is(false));[m
[31m-        }[m
[31m-[m
[31m-        for (TestEventHandler handler : handlers)[m
[31m-        {[m
[31m-            assertThat(handler.messagesSeen, is(not(0)));[m
[31m-            assertThat(handler.failureCount, is(0));[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private Publisher[] initialise([m
[31m-        Publisher[] publishers, RingBuffer<TestEvent> buffer,[m
[31m-        int messageCount, CyclicBarrier barrier, CountDownLatch latch)[m
[31m-    {[m
[31m-        for (int i = 0; i < publishers.length; i++)[m
[31m-        {[m
[31m-            publishers[i] = new Publisher(buffer, messageCount, barrier, latch);[m
[31m-        }[m
[31m-[m
[31m-        return publishers;[m
[31m-    }[m
[31m-[m
[31m-    @SuppressWarnings("unchecked")[m
[31m-    private TestEventHandler[] initialise(Disruptor<TestEvent> disruptor, TestEventHandler[] testEventHandlers)[m
[31m-    {[m
[31m-        for (int i = 0; i < testEventHandlers.length; i++)[m
[31m-        {[m
[31m-            TestEventHandler handler = new TestEventHandler();[m
[31m-            disruptor.handleEventsWith(handler);[m
[31m-            testEventHandlers[i] = handler;[m
[31m-        }[m
[31m-[m
[31m-        return testEventHandlers;[m
[31m-    }[m
[31m-[m
[31m-    private static class TestEventHandler implements EventHandler<TestEvent>[m
[31m-    {[m
[31m-        public int failureCount = 0;[m
[31m-        public int messagesSeen = 0;[m
[31m-[m
[31m-        TestEventHandler()[m
[31m-        {[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onEvent(TestEvent event, long sequence, boolean endOfBatch) throws Exception[m
[31m-        {[m
[31m-            if (event.sequence != sequence ||[m
[31m-                event.a != sequence + 13 ||[m
[31m-                event.b != sequence - 7 ||[m
[31m-                !("wibble-" + sequence).equals(event.s))[m
[31m-            {[m
[31m-                failureCount++;[m
[31m-            }[m
[31m-[m
[31m-            messagesSeen++;[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class Publisher implements Runnable[m
[31m-    {[m
[31m-        private final RingBuffer<TestEvent> ringBuffer;[m
[31m-        private final CyclicBarrier barrier;[m
[31m-        private final int iterations;[m
[31m-        private final CountDownLatch shutdownLatch;[m
[31m-[m
[31m-        public boolean failed = false;[m
[31m-[m
[31m-        Publisher([m
[31m-            RingBuffer<TestEvent> ringBuffer,[m
[31m-            int iterations,[m
[31m-            CyclicBarrier barrier,[m
[31m-            CountDownLatch shutdownLatch)[m
[31m-        {[m
[31m-            this.ringBuffer = ringBuffer;[m
[31m-            this.barrier = barrier;[m
[31m-            this.iterations = iterations;[m
[31m-            this.shutdownLatch = shutdownLatch;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void run()[m
[31m-        {[m
[31m-            try[m
[31m-            {[m
[31m-                barrier.await();[m
[31m-[m
[31m-                int i = iterations;[m
[31m-                while (--i != -1)[m
[31m-                {[m
[31m-                    long next = ringBuffer.next();[m
[31m-                    TestEvent testEvent = ringBuffer.get(next);[m
[31m-                    testEvent.sequence = next;[m
[31m-                    testEvent.a = next + 13;[m
[31m-                    testEvent.b = next - 7;[m
[31m-                    testEvent.s = "wibble-" + next;[m
[31m-                    ringBuffer.publish(next);[m
[31m-                }[m
[31m-            }[m
[31m-            catch (Exception e)[m
[31m-            {[m
[31m-                failed = true;[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                shutdownLatch.countDown();[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class TestEvent[m
[31m-    {[m
[31m-        public long sequence;[m
[31m-        public long a;[m
[31m-        public long b;[m
[31m-        public String s;[m
[31m-[m
[31m-        public static final EventFactory<TestEvent> FACTORY = () -> new TestEvent();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/EventPollerTest.java b/src/test/java/com/lmax/disruptor/EventPollerTest.java[m
[1mdeleted file mode 100644[m
[1mindex 062c16e..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/EventPollerTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,70 +0,0 @@[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import com.lmax.disruptor.EventPoller.PollState;[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import java.util.ArrayList;[m
[31m-[m
[31m-import static org.hamcrest.MatcherAssert.assertThat;[m
[31m-import static org.hamcrest.core.Is.is;[m
[31m-[m
[31m-public class EventPollerTest[m
[31m-{[m
[31m-    @Test[m
[31m-    @SuppressWarnings("unchecked")[m
[31m-    public void shouldPollForEvents() throws Exception[m
[31m-    {[m
[31m-        final Sequence gatingSequence = new Sequence();[m
[31m-        final SingleProducerSequencer sequencer = new SingleProducerSequencer(16, new BusySpinWaitStrategy());[m
[31m-        final EventPoller.Handler<Object> handler = (event, sequence, endOfBatch) -> false;[m
[31m-[m
[31m-        final Object[] data = new Object[16];[m
[31m-        final DataProvider<Object> provider = sequence -> data[(int) sequence];[m
[31m-[m
[31m-        final EventPoller<Object> poller = sequencer.newPoller(provider, gatingSequence);[m
[31m-        final Object event = new Object();[m
[31m-        data[0] = event;[m
[31m-[m
[31m-        assertThat(poller.poll(handler), is(PollState.IDLE));[m
[31m-[m
[31m-        // Publish Event.[m
[31m-        sequencer.publish(sequencer.next());[m
[31m-        assertThat(poller.poll(handler), is(PollState.GATING));[m
[31m-[m
[31m-        gatingSequence.incrementAndGet();[m
[31m-        assertThat(poller.poll(handler), is(PollState.PROCESSING));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldSuccessfullyPollWhenBufferIsFull() throws Exception[m
[31m-    {[m
[31m-        final ArrayList<byte[]> events = new ArrayList<>();[m
[31m-[m
[31m-        final EventPoller.Handler<byte[]> handler = (event, sequence, endOfBatch) ->[m
[31m-        {[m
[31m-            events.add(event);[m
[31m-            return !endOfBatch;[m
[31m-        };[m
[31m-[m
[31m-        EventFactory<byte[]> factory = () -> new byte[1];[m
[31m-[m
[31m-        final RingBuffer<byte[]> ringBuffer = RingBuffer.createMultiProducer(factory, 4, new SleepingWaitStrategy());[m
[31m-[m
[31m-        final EventPoller<byte[]> poller = ringBuffer.newPoller();[m
[31m-        ringBuffer.addGatingSequences(poller.getSequence());[m
[31m-[m
[31m-        int count = 4;[m
[31m-[m
[31m-        for (byte i = 1; i <= count; ++i)[m
[31m-        {[m
[31m-            long next = ringBuffer.next();[m
[31m-            ringBuffer.get(next)[0] = i;[m
[31m-            ringBuffer.publish(next);[m
[31m-        }[m
[31m-[m
[31m-        // think of another thread[m
[31m-        poller.poll(handler);[m
[31m-[m
[31m-        assertThat(events.size(), is(4));[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/EventPublisherTest.java b/src/test/java/com/lmax/disruptor/EventPublisherTest.java[m
[1mdeleted file mode 100644[m
[1mindex 5160fd4..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/EventPublisherTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,65 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import com.lmax.disruptor.support.LongEvent;[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import static com.lmax.disruptor.RingBuffer.createMultiProducer;[m
[31m-import static org.hamcrest.CoreMatchers.is;[m
[31m-import static org.hamcrest.MatcherAssert.assertThat;[m
[31m-[m
[31m-public class EventPublisherTest implements EventTranslator<LongEvent>[m
[31m-{[m
[31m-    private static final int BUFFER_SIZE = 32;[m
[31m-    private RingBuffer<LongEvent> ringBuffer = createMultiProducer(LongEvent.FACTORY, BUFFER_SIZE);[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldPublishEvent()[m
[31m-    {[m
[31m-        ringBuffer.addGatingSequences(new NoOpEventProcessor(ringBuffer).getSequence());[m
[31m-[m
[31m-        ringBuffer.publishEvent(this);[m
[31m-        ringBuffer.publishEvent(this);[m
[31m-[m
[31m-        assertThat(Long.valueOf(ringBuffer.get(0).get()), is(Long.valueOf(0 + 29L)));[m
[31m-        assertThat(Long.valueOf(ringBuffer.get(1).get()), is(Long.valueOf(1 + 29L)));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldTryPublishEvent() throws Exception[m
[31m-    {[m
[31m-        ringBuffer.addGatingSequences(new Sequence());[m
[31m-[m
[31m-        for (int i = 0; i < BUFFER_SIZE; i++)[m
[31m-        {[m
[31m-            assertThat(ringBuffer.tryPublishEvent(this), is(true));[m
[31m-        }[m
[31m-[m
[31m-        for (int i = 0; i < BUFFER_SIZE; i++)[m
[31m-        {[m
[31m-            assertThat(Long.valueOf(ringBuffer.get(i).get()), is(Long.valueOf(i + 29L)));[m
[31m-        }[m
[31m-[m
[31m-        assertThat(ringBuffer.tryPublishEvent(this), is(false));[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void translateTo(LongEvent event, long sequence)[m
[31m-    {[m
[31m-        event.set(sequence + 29);[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/EventTranslatorTest.java b/src/test/java/com/lmax/disruptor/EventTranslatorTest.java[m
[1mdeleted file mode 100644[m
[1mindex 55366b8..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/EventTranslatorTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,54 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import com.lmax.disruptor.support.StubEvent;[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import static org.junit.jupiter.api.Assertions.assertEquals;[m
[31m-[m
[31m-public final class EventTranslatorTest[m
[31m-{[m
[31m-    private static final String TEST_VALUE = "Wibble";[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldTranslateOtherDataIntoAnEvent()[m
[31m-    {[m
[31m-        StubEvent event = StubEvent.EVENT_FACTORY.newInstance();[m
[31m-        EventTranslator<StubEvent> eventTranslator = new ExampleEventTranslator(TEST_VALUE);[m
[31m-[m
[31m-        eventTranslator.translateTo(event, 0);[m
[31m-[m
[31m-        assertEquals(TEST_VALUE, event.getTestString());[m
[31m-    }[m
[31m-[m
[31m-    public static final class ExampleEventTranslator[m
[31m-        implements EventTranslator<StubEvent>[m
[31m-    {[m
[31m-        private final String testValue;[m
[31m-[m
[31m-        public ExampleEventTranslator(final String testValue)[m
[31m-        {[m
[31m-            this.testValue = testValue;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void translateTo(final StubEvent event, long sequence)[m
[31m-        {[m
[31m-            event.setTestString(testValue);[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/FatalExceptionHandlerTest.java b/src/test/java/com/lmax/disruptor/FatalExceptionHandlerTest.java[m
[1mdeleted file mode 100644[m
[1mindex 461d431..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/FatalExceptionHandlerTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,42 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import com.lmax.disruptor.support.TestEvent;[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import static org.junit.jupiter.api.Assertions.assertEquals;[m
[31m-[m
[31m-public final class FatalExceptionHandlerTest[m
[31m-{[m
[31m-    @Test[m
[31m-    public void shouldHandleFatalException()[m
[31m-    {[m
[31m-        final Exception causeException = new Exception();[m
[31m-        final TestEvent event = new TestEvent();[m
[31m-[m
[31m-        ExceptionHandler<Object> exceptionHandler = new FatalExceptionHandler();[m
[31m-[m
[31m-        try[m
[31m-        {[m
[31m-            exceptionHandler.handleEventException(causeException, 0L, event);[m
[31m-        }[m
[31m-        catch (RuntimeException ex)[m
[31m-        {[m
[31m-            assertEquals(causeException, ex.getCause());[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/FixedSequenceGroupTest.java b/src/test/java/com/lmax/disruptor/FixedSequenceGroupTest.java[m
[1mdeleted file mode 100644[m
[1mindex af70ee2..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/FixedSequenceGroupTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,40 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2012 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import static org.hamcrest.CoreMatchers.is;[m
[31m-import static org.hamcrest.MatcherAssert.assertThat;[m
[31m-[m
[31m-[m
[31m-public class FixedSequenceGroupTest[m
[31m-{[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldReturnMinimumOf2Sequences() throws Exception[m
[31m-    {[m
[31m-        Sequence sequence1 = new Sequence(34);[m
[31m-        Sequence sequnece2 = new Sequence(47);[m
[31m-        Sequence group = new FixedSequenceGroup(new Sequence[]{sequence1, sequnece2});[m
[31m-[m
[31m-        assertThat(group.get(), is(34L));[m
[31m-        sequence1.set(35);[m
[31m-        assertThat(group.get(), is(35L));[m
[31m-        sequence1.set(48);[m
[31m-        assertThat(group.get(), is(47L));[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/IgnoreExceptionHandlerTest.java b/src/test/java/com/lmax/disruptor/IgnoreExceptionHandlerTest.java[m
[1mdeleted file mode 100644[m
[1mindex d5430cb..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/IgnoreExceptionHandlerTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,32 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import com.lmax.disruptor.support.TestEvent;[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-public final class IgnoreExceptionHandlerTest[m
[31m-{[m
[31m-    @Test[m
[31m-    public void shouldHandleAndIgnoreException()[m
[31m-    {[m
[31m-        final Exception ex = new Exception();[m
[31m-        final TestEvent event = new TestEvent();[m
[31m-[m
[31m-        ExceptionHandler<Object> exceptionHandler = new IgnoreExceptionHandler();[m
[31m-        exceptionHandler.handleEventException(ex, 0L, event);[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/LifecycleAwareTest.java b/src/test/java/com/lmax/disruptor/LifecycleAwareTest.java[m
[1mdeleted file mode 100644[m
[1mindex 0da9bf3..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/LifecycleAwareTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,77 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import com.lmax.disruptor.support.StubEvent;[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-[m
[31m-import static com.lmax.disruptor.RingBuffer.createMultiProducer;[m
[31m-import static org.hamcrest.MatcherAssert.assertThat;[m
[31m-import static org.hamcrest.core.Is.is;[m
[31m-[m
[31m-public final class LifecycleAwareTest[m
[31m-{[m
[31m-    private final CountDownLatch startLatch = new CountDownLatch(1);[m
[31m-    private final CountDownLatch shutdownLatch = new CountDownLatch(1);[m
[31m-[m
[31m-[m
[31m-    private final RingBuffer<StubEvent> ringBuffer = createMultiProducer(StubEvent.EVENT_FACTORY, 16);[m
[31m-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();[m
[31m-    private final LifecycleAwareEventHandler handler = new LifecycleAwareEventHandler();[m
[31m-    private final BatchEventProcessor<StubEvent> batchEventProcessor =[m
[31m-            new BatchEventProcessor<>(ringBuffer, sequenceBarrier, handler);[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotifyOfBatchProcessorLifecycle() throws Exception[m
[31m-    {[m
[31m-        new Thread(batchEventProcessor).start();[m
[31m-[m
[31m-        startLatch.await();[m
[31m-        batchEventProcessor.halt();[m
[31m-[m
[31m-        shutdownLatch.await();[m
[31m-[m
[31m-        assertThat(Integer.valueOf(handler.startCounter), is(Integer.valueOf(1)));[m
[31m-        assertThat(Integer.valueOf(handler.shutdownCounter), is(Integer.valueOf(1)));[m
[31m-    }[m
[31m-[m
[31m-    private final class LifecycleAwareEventHandler implements EventHandler<StubEvent>, LifecycleAware[m
[31m-    {[m
[31m-        private int startCounter = 0;[m
[31m-        private int shutdownCounter = 0;[m
[31m-[m
[31m-        @Override[m
[31m-        public void onEvent(final StubEvent event, final long sequence, final boolean endOfBatch) throws Exception[m
[31m-        {[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onStart()[m
[31m-        {[m
[31m-            ++startCounter;[m
[31m-            startLatch.countDown();[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onShutdown()[m
[31m-        {[m
[31m-            ++shutdownCounter;[m
[31m-            shutdownLatch.countDown();[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/LiteTimeoutBlockingWaitStrategyTest.java b/src/test/java/com/lmax/disruptor/LiteTimeoutBlockingWaitStrategyTest.java[m
[1mdeleted file mode 100644[m
[1mindex 4eda988..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/LiteTimeoutBlockingWaitStrategyTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,40 +0,0 @@[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import com.lmax.disruptor.support.DummySequenceBarrier;[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import java.util.concurrent.TimeUnit;[m
[31m-[m
[31m-import static org.junit.jupiter.api.Assertions.assertTrue;[m
[31m-import static org.junit.jupiter.api.Assertions.fail;[m
[31m-[m
[31m-public class LiteTimeoutBlockingWaitStrategyTest[m
[31m-{[m
[31m-    @Test[m
[31m-    public void shouldTimeoutWaitFor() throws Exception[m
[31m-    {[m
[31m-        final SequenceBarrier sequenceBarrier = new DummySequenceBarrier();[m
[31m-[m
[31m-        long theTimeout = 500;[m
[31m-        LiteTimeoutBlockingWaitStrategy waitStrategy = new LiteTimeoutBlockingWaitStrategy(theTimeout, TimeUnit.MILLISECONDS);[m
[31m-        Sequence cursor = new Sequence(5);[m
[31m-        Sequence dependent = cursor;[m
[31m-[m
[31m-        long t0 = System.currentTimeMillis();[m
[31m-[m
[31m-        try[m
[31m-        {[m
[31m-            waitStrategy.waitFor(6, cursor, dependent, sequenceBarrier);[m
[31m-            fail("TimeoutException should have been thrown");[m
[31m-        }[m
[31m-        catch (TimeoutException e)[m
[31m-        {[m
[31m-        }[m
[31m-[m
[31m-        long t1 = System.currentTimeMillis();[m
[31m-[m
[31m-        long timeWaiting = t1 - t0;[m
[31m-[m
[31m-        assertTrue(timeWaiting >= theTimeout);[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/MultiProducerSequencerTest.java b/src/test/java/com/lmax/disruptor/MultiProducerSequencerTest.java[m
[1mdeleted file mode 100644[m
[1mindex 96b3e82..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/MultiProducerSequencerTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,41 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2012 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import static org.hamcrest.CoreMatchers.is;[m
[31m-import static org.hamcrest.MatcherAssert.assertThat;[m
[31m-[m
[31m-public class MultiProducerSequencerTest[m
[31m-{[m
[31m-    private final Sequencer publisher = new MultiProducerSequencer(1024, new BlockingWaitStrategy());[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldOnlyAllowMessagesToBeAvailableIfSpecificallyPublished() throws Exception[m
[31m-    {[m
[31m-        publisher.publish(3);[m
[31m-        publisher.publish(5);[m
[31m-[m
[31m-        assertThat(publisher.isAvailable(0), is(false));[m
[31m-        assertThat(publisher.isAvailable(1), is(false));[m
[31m-        assertThat(publisher.isAvailable(2), is(false));[m
[31m-        assertThat(publisher.isAvailable(3), is(true));[m
[31m-        assertThat(publisher.isAvailable(4), is(false));[m
[31m-        assertThat(publisher.isAvailable(5), is(true));[m
[31m-        assertThat(publisher.isAvailable(6), is(false));[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/PhasedBackoffWaitStrategyTest.java b/src/test/java/com/lmax/disruptor/PhasedBackoffWaitStrategyTest.java[m
[1mdeleted file mode 100644[m
[1mindex 4914626..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/PhasedBackoffWaitStrategyTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,53 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2012 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import static com.lmax.disruptor.support.WaitStrategyTestUtil.assertWaitForWithDelayOf;[m
[31m-import static java.util.concurrent.TimeUnit.MILLISECONDS;[m
[31m-[m
[31m-[m
[31m-public class PhasedBackoffWaitStrategyTest[m
[31m-{[m
[31m-    @Test[m
[31m-    public void shouldHandleImmediateSequenceChange() throws Exception[m
[31m-    {[m
[31m-        assertWaitForWithDelayOf(0, PhasedBackoffWaitStrategy.withLock(1, 1, MILLISECONDS));[m
[31m-        assertWaitForWithDelayOf(0, PhasedBackoffWaitStrategy.withSleep(1, 1, MILLISECONDS));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldHandleSequenceChangeWithOneMillisecondDelay() throws Exception[m
[31m-    {[m
[31m-        assertWaitForWithDelayOf(1, PhasedBackoffWaitStrategy.withLock(1, 1, MILLISECONDS));[m
[31m-        assertWaitForWithDelayOf(1, PhasedBackoffWaitStrategy.withSleep(1, 1, MILLISECONDS));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldHandleSequenceChangeWithTwoMillisecondDelay() throws Exception[m
[31m-    {[m
[31m-        assertWaitForWithDelayOf(2, PhasedBackoffWaitStrategy.withLock(1, 1, MILLISECONDS));[m
[31m-        assertWaitForWithDelayOf(2, PhasedBackoffWaitStrategy.withSleep(1, 1, MILLISECONDS));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldHandleSequenceChangeWithTenMillisecondDelay() throws Exception[m
[31m-    {[m
[31m-        assertWaitForWithDelayOf(10, PhasedBackoffWaitStrategy.withLock(1, 1, MILLISECONDS));[m
[31m-        assertWaitForWithDelayOf(10, PhasedBackoffWaitStrategy.withSleep(1, 1, MILLISECONDS));[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/RingBufferEventMatcher.java b/src/test/java/com/lmax/disruptor/RingBufferEventMatcher.java[m
[1mdeleted file mode 100644[m
[1mindex 5e086b9..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/RingBufferEventMatcher.java[m
[1m+++ /dev/null[m
[36m@@ -1,56 +0,0 @@[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import org.hamcrest.Description;[m
[31m-import org.hamcrest.Matcher;[m
[31m-import org.hamcrest.TypeSafeMatcher;[m
[31m-[m
[31m-import static org.hamcrest.CoreMatchers.is;[m
[31m-[m
[31m-final class RingBufferEventMatcher extends TypeSafeMatcher<RingBuffer<Object[]>>[m
[31m-{[m
[31m-    private final Matcher<?>[] expectedValueMatchers;[m
[31m-[m
[31m-    private RingBufferEventMatcher(final Matcher<?>[] expectedValueMatchers)[m
[31m-    {[m
[31m-        this.expectedValueMatchers = expectedValueMatchers;[m
[31m-    }[m
[31m-[m
[31m-    public static RingBufferEventMatcher ringBufferWithEvents(final Matcher<?>... valueMatchers)[m
[31m-    {[m
[31m-        return new RingBufferEventMatcher(valueMatchers);[m
[31m-    }[m
[31m-[m
[31m-    public static RingBufferEventMatcher ringBufferWithEvents(final Object... values)[m
[31m-    {[m
[31m-        Matcher<?>[] valueMatchers = new Matcher[values.length];[m
[31m-        for (int i = 0; i < values.length; i++)[m
[31m-        {[m
[31m-            final Object value = values[i];[m
[31m-            valueMatchers[i] = is(value);[m
[31m-        }[m
[31m-        return new RingBufferEventMatcher(valueMatchers);[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public boolean matchesSafely(final RingBuffer<Object[]> ringBuffer)[m
[31m-    {[m
[31m-        boolean matches = true;[m
[31m-        for (int i = 0; i < expectedValueMatchers.length; i++)[m
[31m-        {[m
[31m-            final Matcher<?> expectedValueMatcher = expectedValueMatchers[i];[m
[31m-            matches &= expectedValueMatcher.matches(ringBuffer.get(i)[0]);[m
[31m-        }[m
[31m-        return matches;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void describeTo(final Description description)[m
[31m-    {[m
[31m-        description.appendText("Expected ring buffer with events matching: ");[m
[31m-[m
[31m-        for (Matcher<?> expectedValueMatcher : expectedValueMatchers)[m
[31m-        {[m
[31m-            expectedValueMatcher.describeTo(description);[m
[31m-        }[m
[31m-    }[m
[31m-}[m
\ No newline at end of file[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/RingBufferTest.java b/src/test/java/com/lmax/disruptor/RingBufferTest.java[m
[1mdeleted file mode 100644[m
[1mindex d42f7a3..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/RingBufferTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,1615 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import com.lmax.disruptor.support.StubEvent;[m
[31m-import com.lmax.disruptor.support.TestWaiter;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import java.util.List;[m
[31m-import java.util.concurrent.BrokenBarrierException;[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.CyclicBarrier;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-import java.util.concurrent.Future;[m
[31m-import java.util.concurrent.atomic.AtomicBoolean;[m
[31m-[m
[31m-import static com.lmax.disruptor.RingBuffer.createMultiProducer;[m
[31m-import static com.lmax.disruptor.RingBufferEventMatcher.ringBufferWithEvents;[m
[31m-import static org.hamcrest.CoreMatchers.is;[m
[31m-import static org.hamcrest.CoreMatchers.nullValue;[m
[31m-import static org.hamcrest.MatcherAssert.assertThat;[m
[31m-import static org.junit.jupiter.api.Assertions.assertEquals;[m
[31m-import static org.junit.jupiter.api.Assertions.assertFalse;[m
[31m-import static org.junit.jupiter.api.Assertions.assertThrows;[m
[31m-import static org.junit.jupiter.api.Assertions.assertTrue;[m
[31m-import static org.junit.jupiter.api.Assertions.fail;[m
[31m-[m
[31m-public class RingBufferTest[m
[31m-{[m
[31m-    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);[m
[31m-    private final RingBuffer<StubEvent> ringBuffer = RingBuffer.createMultiProducer(StubEvent.EVENT_FACTORY, 32);[m
[31m-    private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();[m
[31m-[m
[31m-    {[m
[31m-        ringBuffer.addGatingSequences(new NoOpEventProcessor(ringBuffer).getSequence());[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldClaimAndGet() throws Exception[m
[31m-    {[m
[31m-        assertEquals(SingleProducerSequencer.INITIAL_CURSOR_VALUE, ringBuffer.getCursor());[m
[31m-[m
[31m-        StubEvent expectedEvent = new StubEvent(2701);[m
[31m-        ringBuffer.publishEvent(StubEvent.TRANSLATOR, expectedEvent.getValue(), expectedEvent.getTestString());[m
[31m-[m
[31m-        long sequence = sequenceBarrier.waitFor(0);[m
[31m-        assertEquals(0, sequence);[m
[31m-[m
[31m-        StubEvent event = ringBuffer.get(sequence);[m
[31m-        assertEquals(expectedEvent, event);[m
[31m-[m
[31m-        assertEquals(0L, ringBuffer.getCursor());[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldClaimAndGetInSeparateThread() throws Exception[m
[31m-    {[m
[31m-        Future<List<StubEvent>> messages = getMessages(0, 0);[m
[31m-[m
[31m-        StubEvent expectedEvent = new StubEvent(2701);[m
[31m-        ringBuffer.publishEvent(StubEvent.TRANSLATOR, expectedEvent.getValue(), expectedEvent.getTestString());[m
[31m-[m
[31m-        assertEquals(expectedEvent, messages.get().get(0));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldClaimAndGetMultipleMessages() throws Exception[m
[31m-    {[m
[31m-        int numMessages = ringBuffer.getBufferSize();[m
[31m-        for (int i = 0; i < numMessages; i++)[m
[31m-        {[m
[31m-            ringBuffer.publishEvent(StubEvent.TRANSLATOR, i, "");[m
[31m-        }[m
[31m-[m
[31m-        long expectedSequence = numMessages - 1;[m
[31m-        long available = sequenceBarrier.waitFor(expectedSequence);[m
[31m-        assertEquals(expectedSequence, available);[m
[31m-[m
[31m-        for (int i = 0; i < numMessages; i++)[m
[31m-        {[m
[31m-            assertEquals(i, ringBuffer.get(i).getValue());[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldWrap() throws Exception[m
[31m-    {[m
[31m-        int numMessages = ringBuffer.getBufferSize();[m
[31m-        int offset = 1000;[m
[31m-        for (int i = 0; i < numMessages + offset; i++)[m
[31m-        {[m
[31m-            ringBuffer.publishEvent(StubEvent.TRANSLATOR, i, "");[m
[31m-        }[m
[31m-[m
[31m-        long expectedSequence = numMessages + offset - 1;[m
[31m-        long available = sequenceBarrier.waitFor(expectedSequence);[m
[31m-        assertEquals(expectedSequence, available);[m
[31m-[m
[31m-        for (int i = offset; i < numMessages + offset; i++)[m
[31m-        {[m
[31m-            assertEquals(i, ringBuffer.get(i).getValue());[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldPreventWrapping() throws Exception[m
[31m-    {[m
[31m-        Sequence sequence = new Sequence(Sequencer.INITIAL_CURSOR_VALUE);[m
[31m-        final RingBuffer<StubEvent> ringBuffer = createMultiProducer(StubEvent.EVENT_FACTORY, 4);[m
[31m-        ringBuffer.addGatingSequences(sequence);[m
[31m-[m
[31m-        ringBuffer.publishEvent(StubEvent.TRANSLATOR, 0, "0");[m
[31m-        ringBuffer.publishEvent(StubEvent.TRANSLATOR, 1, "1");[m
[31m-        ringBuffer.publishEvent(StubEvent.TRANSLATOR, 2, "2");[m
[31m-        ringBuffer.publishEvent(StubEvent.TRANSLATOR, 3, "3");[m
[31m-[m
[31m-        assertFalse(ringBuffer.tryPublishEvent(StubEvent.TRANSLATOR, 3, "3"));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldThrowExceptionIfBufferIsFull() throws Exception[m
[31m-    {[m
[31m-        ringBuffer.addGatingSequences(new Sequence(ringBuffer.getBufferSize()));[m
[31m-[m
[31m-        try[m
[31m-        {[m
[31m-            for (int i = 0; i < ringBuffer.getBufferSize(); i++)[m
[31m-            {[m
[31m-                ringBuffer.publish(ringBuffer.tryNext());[m
[31m-            }[m
[31m-        }[m
[31m-        catch (Exception e)[m
[31m-        {[m
[31m-            fail("Should not of thrown exception");[m
[31m-        }[m
[31m-[m
[31m-        try[m
[31m-        {[m
[31m-            ringBuffer.tryNext();[m
[31m-            fail("Exception should have been thrown");[m
[31m-        }[m
[31m-        catch (InsufficientCapacityException e)[m
[31m-        {[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldPreventPublishersOvertakingEventProcessorWrapPoint() throws InterruptedException[m
[31m-    {[m
[31m-        final int ringBufferSize = 16;[m
[31m-        final CountDownLatch latch = new CountDownLatch(ringBufferSize);[m
[31m-        final AtomicBoolean publisherComplete = new AtomicBoolean(false);[m
[31m-        final RingBuffer<StubEvent> buffer2 = createMultiProducer(StubEvent.EVENT_FACTORY, ringBufferSize);[m
[31m-        final TestEventProcessor processor = new TestEventProcessor(buffer2.newBarrier());[m
[31m-        buffer2.addGatingSequences(processor.getSequence());[m
[31m-[m
[31m-        Thread thread = new Thread([m
[31m-                () ->[m
[31m-                {[m
[31m-                    for (int i = 0; i <= ringBufferSize; i++)[m
[31m-                    {[m
[31m-                        long sequence = buffer2.next();[m
[31m-                        StubEvent event = buffer2.get(sequence);[m
[31m-                        event.setValue(i);[m
[31m-                        buffer2.publish(sequence);[m
[31m-                        latch.countDown();[m
[31m-                    }[m
[31m-[m
[31m-                    publisherComplete.set(true);[m
[31m-                });[m
[31m-        thread.start();[m
[31m-[m
[31m-        latch.await();[m
[31m-        assertThat(Long.valueOf(buffer2.getCursor()), is(Long.valueOf(ringBufferSize - 1)));[m
[31m-        assertFalse(publisherComplete.get());[m
[31m-[m
[31m-        processor.run();[m
[31m-        thread.join();[m
[31m-[m
[31m-        assertTrue(publisherComplete.get());[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldPublishEvent() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-        final EventTranslator<Object[]> translator = new NoArgEventTranslator();[m
[31m-[m
[31m-        ringBuffer.publishEvent(translator);[m
[31m-        ringBuffer.tryPublishEvent(translator);[m
[31m-[m
[31m-        assertThat(ringBuffer, ringBufferWithEvents(0L, 1L));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldPublishEventOneArg() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();[m
[31m-[m
[31m-        ringBuffer.publishEvent(translator, "Foo");[m
[31m-        ringBuffer.tryPublishEvent(translator, "Foo");[m
[31m-[m
[31m-        assertThat(ringBuffer, ringBufferWithEvents("Foo-0", "Foo-1"));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldPublishEventTwoArg() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();[m
[31m-[m
[31m-        ringBuffer.publishEvent(translator, "Foo", "Bar");[m
[31m-        ringBuffer.tryPublishEvent(translator, "Foo", "Bar");[m
[31m-[m
[31m-        assertThat(ringBuffer, ringBufferWithEvents("FooBar-0", "FooBar-1"));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldPublishEventThreeArg() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();[m
[31m-[m
[31m-        ringBuffer.publishEvent(translator, "Foo", "Bar", "Baz");[m
[31m-        ringBuffer.tryPublishEvent(translator, "Foo", "Bar", "Baz");[m
[31m-[m
[31m-        assertThat(ringBuffer, ringBufferWithEvents("FooBarBaz-0", "FooBarBaz-1"));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldPublishEventVarArg() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-        EventTranslatorVararg<Object[]> translator = new VarArgEventTranslator();[m
[31m-[m
[31m-        ringBuffer.publishEvent(translator, "Foo", "Bar", "Baz", "Bam");[m
[31m-        ringBuffer.tryPublishEvent(translator, "Foo", "Bar", "Baz", "Bam");[m
[31m-[m
[31m-        assertThat(ringBuffer, ringBufferWithEvents("FooBarBazBam-0", "FooBarBazBam-1"));[m
[31m-    }[m
[31m-[m
[31m-    @SuppressWarnings("unchecked")[m
[31m-    @Test[m
[31m-    public void shouldPublishEvents() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-        final EventTranslator<Object[]> eventTranslator = new NoArgEventTranslator();[m
[31m-        final EventTranslator<Object[]>[] translators = new EventTranslator[]{eventTranslator, eventTranslator};[m
[31m-[m
[31m-        ringBuffer.publishEvents(translators);[m
[31m-        assertTrue(ringBuffer.tryPublishEvents(translators));[m
[31m-[m
[31m-        assertThat(ringBuffer, ringBufferWithEvents(0L, 1L, 2L, 3L));[m
[31m-    }[m
[31m-[m
[31m-    @SuppressWarnings("unchecked")[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsIfBatchIsLargerThanRingBuffer() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            final EventTranslator<Object[]> eventTranslator = new NoArgEventTranslator();[m
[31m-            final EventTranslator<Object[]>[] translators =[m
[31m-                    new EventTranslator[]{eventTranslator, eventTranslator, eventTranslator, eventTranslator, eventTranslator};[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents(translators);[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @SuppressWarnings("unchecked")[m
[31m-    @Test[m
[31m-    public void shouldPublishEventsWithBatchSizeOfOne() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-        final EventTranslator<Object[]> eventTranslator = new NoArgEventTranslator();[m
[31m-        final EventTranslator<Object[]>[] translators =[m
[31m-            new EventTranslator[]{eventTranslator, eventTranslator, eventTranslator};[m
[31m-[m
[31m-        ringBuffer.publishEvents(translators, 0, 1);[m
[31m-        assertTrue(ringBuffer.tryPublishEvents(translators, 0, 1));[m
[31m-[m
[31m-        assertThat([m
[31m-            ringBuffer, ringBufferWithEvents([m
[31m-                is((Object) 0L), is((Object) 1L), is(nullValue()), is([m
[31m-                    nullValue())));[m
[31m-    }[m
[31m-[m
[31m-    @SuppressWarnings("unchecked")[m
[31m-    @Test[m
[31m-    public void shouldPublishEventsWithinBatch() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-        final EventTranslator<Object[]> eventTranslator = new NoArgEventTranslator();[m
[31m-        final EventTranslator<Object[]>[] translators =[m
[31m-            new EventTranslator[]{eventTranslator, eventTranslator, eventTranslator};[m
[31m-[m
[31m-        ringBuffer.publishEvents(translators, 1, 2);[m
[31m-        assertTrue(ringBuffer.tryPublishEvents(translators, 1, 2));[m
[31m-[m
[31m-        assertThat(ringBuffer, ringBufferWithEvents(0L, 1L, 2L, 3L));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldPublishEventsOneArg() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();[m
[31m-[m
[31m-        ringBuffer.publishEvents(translator, new String[]{"Foo", "Foo"});[m
[31m-        assertTrue(ringBuffer.tryPublishEvents(translator, new String[]{"Foo", "Foo"}));[m
[31m-[m
[31m-        assertThat(ringBuffer, ringBufferWithEvents("Foo-0", "Foo-1", "Foo-2", "Foo-3"));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsOneArgIfBatchIsLargerThanRingBuffer() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents(translator, new String[]{"Foo", "Foo", "Foo", "Foo", "Foo"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldPublishEventsOneArgBatchSizeOfOne() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();[m
[31m-[m
[31m-        ringBuffer.publishEvents(translator, 0, 1, new String[]{"Foo", "Foo"});[m
[31m-        assertTrue(ringBuffer.tryPublishEvents(translator, 0, 1, new String[]{"Foo", "Foo"}));[m
[31m-[m
[31m-        assertThat([m
[31m-            ringBuffer, ringBufferWithEvents([m
[31m-                is((Object) "Foo-0"), is((Object) "Foo-1"), is(nullValue()), is([m
[31m-                    nullValue())));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldPublishEventsOneArgWithinBatch() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();[m
[31m-[m
[31m-        ringBuffer.publishEvents(translator, 1, 2, new String[]{"Foo", "Foo", "Foo"});[m
[31m-        assertTrue(ringBuffer.tryPublishEvents(translator, 1, 2, new String[]{"Foo", "Foo", "Foo"}));[m
[31m-[m
[31m-        assertThat(ringBuffer, ringBufferWithEvents("Foo-0", "Foo-1", "Foo-2", "Foo-3"));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldPublishEventsTwoArg() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();[m
[31m-[m
[31m-        ringBuffer.publishEvents(translator, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"});[m
[31m-        ringBuffer.tryPublishEvents(translator, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"});[m
[31m-[m
[31m-        assertThat(ringBuffer, ringBufferWithEvents("FooBar-0", "FooBar-1", "FooBar-2", "FooBar-3"));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsITwoArgIfBatchSizeIsBiggerThanRingBuffer() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents([m
[31m-                        translator,[m
[31m-                        new String[]{"Foo", "Foo", "Foo", "Foo", "Foo"},[m
[31m-                        new String[]{"Bar", "Bar", "Bar", "Bar", "Bar"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldPublishEventsTwoArgWithBatchSizeOfOne() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();[m
[31m-[m
[31m-        ringBuffer.publishEvents(translator, 0, 1, new String[]{"Foo0", "Foo1"}, new String[]{"Bar0", "Bar1"});[m
[31m-        ringBuffer.tryPublishEvents(translator, 0, 1, new String[]{"Foo2", "Foo3"}, new String[]{"Bar2", "Bar3"});[m
[31m-[m
[31m-        assertThat([m
[31m-            ringBuffer, ringBufferWithEvents([m
[31m-                is((Object) "Foo0Bar0-0"), is((Object) "Foo2Bar2-1"), is([m
[31m-                    nullValue()), is(nullValue())));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldPublishEventsTwoArgWithinBatch() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();[m
[31m-[m
[31m-        ringBuffer.publishEvents([m
[31m-            translator, 1, 2, new String[]{"Foo0", "Foo1", "Foo2"}, new String[]{"Bar0", "Bar1", "Bar2"});[m
[31m-        ringBuffer.tryPublishEvents([m
[31m-            translator, 1, 2, new String[]{"Foo3", "Foo4", "Foo5"}, new String[]{"Bar3", "Bar4", "Bar5"});[m
[31m-[m
[31m-        assertThat(ringBuffer, ringBufferWithEvents("Foo1Bar1-0", "Foo2Bar2-1", "Foo4Bar4-2", "Foo5Bar5-3"));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldPublishEventsThreeArg() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();[m
[31m-[m
[31m-        ringBuffer.publishEvents([m
[31m-            translator, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"}, new String[]{"Baz", "Baz"});[m
[31m-        ringBuffer.tryPublishEvents([m
[31m-            translator, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"}, new String[]{"Baz", "Baz"});[m
[31m-[m
[31m-        assertThat(ringBuffer, ringBufferWithEvents("FooBarBaz-0", "FooBarBaz-1", "FooBarBaz-2", "FooBarBaz-3"));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsThreeArgIfBatchIsLargerThanRingBuffer() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents([m
[31m-                        translator,[m
[31m-                        new String[]{"Foo", "Foo", "Foo", "Foo", "Foo"},[m
[31m-                        new String[]{"Bar", "Bar", "Bar", "Bar", "Bar"},[m
[31m-                        new String[]{"Baz", "Baz", "Baz", "Baz", "Baz"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldPublishEventsThreeArgBatchSizeOfOne() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();[m
[31m-[m
[31m-        ringBuffer.publishEvents([m
[31m-            translator, 0, 1, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"}, new String[]{"Baz", "Baz"});[m
[31m-        ringBuffer.tryPublishEvents([m
[31m-            translator, 0, 1, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"}, new String[]{"Baz", "Baz"});[m
[31m-[m
[31m-        assertThat([m
[31m-            ringBuffer, ringBufferWithEvents([m
[31m-                is((Object) "FooBarBaz-0"), is((Object) "FooBarBaz-1"), is([m
[31m-                    nullValue()), is(nullValue())));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldPublishEventsThreeArgWithinBatch() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();[m
[31m-[m
[31m-        ringBuffer.publishEvents([m
[31m-            translator, 1, 2, new String[]{"Foo0", "Foo1", "Foo2"}, new String[]{"Bar0", "Bar1", "Bar2"},[m
[31m-            new String[]{"Baz0", "Baz1", "Baz2"}[m
[31m-        );[m
[31m-        assertTrue([m
[31m-            ringBuffer.tryPublishEvents([m
[31m-                translator, 1, 2, new String[]{"Foo3", "Foo4", "Foo5"}, new String[]{"Bar3", "Bar4", "Bar5"},[m
[31m-                new String[]{"Baz3", "Baz4", "Baz5"}));[m
[31m-[m
[31m-        assertThat([m
[31m-            ringBuffer, ringBufferWithEvents([m
[31m-                "Foo1Bar1Baz1-0", "Foo2Bar2Baz2-1", "Foo4Bar4Baz4-2", "Foo5Bar5Baz5-3"));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldPublishEventsVarArg() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-        EventTranslatorVararg<Object[]> translator = new VarArgEventTranslator();[m
[31m-[m
[31m-        ringBuffer.publishEvents([m
[31m-            translator, new String[]{"Foo", "Bar", "Baz", "Bam"}, new String[]{"Foo", "Bar", "Baz", "Bam"});[m
[31m-        assertTrue([m
[31m-            ringBuffer.tryPublishEvents([m
[31m-                translator, new String[]{"Foo", "Bar", "Baz", "Bam"}, new String[]{"Foo", "Bar", "Baz", "Bam"}));[m
[31m-[m
[31m-        assertThat([m
[31m-            ringBuffer, ringBufferWithEvents([m
[31m-                "FooBarBazBam-0", "FooBarBazBam-1", "FooBarBazBam-2", "FooBarBazBam-3"));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsVarArgIfBatchIsLargerThanRingBuffer() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorVararg<Object[]> translator = new VarArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents([m
[31m-                        translator,[m
[31m-                        new String[]{"Foo", "Bar", "Baz", "Bam"},[m
[31m-                        new String[]{"Foo", "Bar", "Baz", "Bam"},[m
[31m-                        new String[]{"Foo", "Bar", "Baz", "Bam"},[m
[31m-                        new String[]{"Foo", "Bar", "Baz", "Bam"},[m
[31m-                        new String[]{"Foo", "Bar", "Baz", "Bam"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldPublishEventsVarArgBatchSizeOfOne() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-        EventTranslatorVararg<Object[]> translator = new VarArgEventTranslator();[m
[31m-[m
[31m-        ringBuffer.publishEvents([m
[31m-            translator, 0, 1, new String[]{"Foo", "Bar", "Baz", "Bam"}, new String[]{"Foo", "Bar", "Baz", "Bam"});[m
[31m-        assertTrue([m
[31m-            ringBuffer.tryPublishEvents([m
[31m-                translator, 0, 1, new String[]{"Foo", "Bar", "Baz", "Bam"}, new String[]{"Foo", "Bar", "Baz", "Bam"}));[m
[31m-[m
[31m-        assertThat([m
[31m-            ringBuffer, ringBufferWithEvents([m
[31m-                is((Object) "FooBarBazBam-0"), is((Object) "FooBarBazBam-1"), is([m
[31m-                    nullValue()), is(nullValue())));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldPublishEventsVarArgWithinBatch() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-        EventTranslatorVararg<Object[]> translator = new VarArgEventTranslator();[m
[31m-[m
[31m-        ringBuffer.publishEvents([m
[31m-            translator, 1, 2, new String[]{"Foo0", "Bar0", "Baz0", "Bam0"},[m
[31m-            new String[]{"Foo1", "Bar1", "Baz1", "Bam1"},[m
[31m-            new String[]{"Foo2", "Bar2", "Baz2", "Bam2"});[m
[31m-        assertTrue([m
[31m-            ringBuffer.tryPublishEvents([m
[31m-                translator, 1, 2, new String[]{"Foo3", "Bar3", "Baz3", "Bam3"},[m
[31m-                new String[]{"Foo4", "Bar4", "Baz4", "Bam4"},[m
[31m-                new String[]{"Foo5", "Bar5", "Baz5", "Bam5"}));[m
[31m-[m
[31m-        assertThat([m
[31m-            ringBuffer, ringBufferWithEvents([m
[31m-                "Foo1Bar1Baz1Bam1-0", "Foo2Bar2Baz2Bam2-1", "Foo4Bar4Baz4Bam4-2", "Foo5Bar5Baz5Bam5-3"));[m
[31m-    }[m
[31m-[m
[31m-    @SuppressWarnings("unchecked")[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsWhenBatchSizeIs0() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslator<Object[]> translator = new NoArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.publishEvents(new EventTranslator[]{translator, translator, translator, translator}, 1, 0);[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @SuppressWarnings("unchecked")[m
[31m-    @Test[m
[31m-    public void shouldNotTryPublishEventsWhenBatchSizeIs0() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslator<Object[]> translator = new NoArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents(new EventTranslator[]{translator, translator, translator, translator}, 1, 0);[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @SuppressWarnings("unchecked")[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsWhenBatchExtendsPastEndOfArray() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslator<Object[]> translator = new NoArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.publishEvents(new EventTranslator[]{translator, translator, translator}, 1, 3);[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @SuppressWarnings("unchecked")[m
[31m-    @Test[m
[31m-    public void shouldNotTryPublishEventsWhenBatchExtendsPastEndOfArray() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslator<Object[]> translator = new NoArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents(new EventTranslator[]{translator, translator, translator}, 1, 3);[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @SuppressWarnings("unchecked")[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsWhenBatchSizeIsNegative() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslator<Object[]> translator = new NoArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.publishEvents(new EventTranslator[]{translator, translator, translator, translator}, 1, -1);[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @SuppressWarnings("unchecked")[m
[31m-    @Test[m
[31m-    public void shouldNotTryPublishEventsWhenBatchSizeIsNegative() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslator<Object[]> translator = new NoArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents(new EventTranslator[]{translator, translator, translator, translator}, 1, -1);[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @SuppressWarnings("unchecked")[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsWhenBatchStartsAtIsNegative() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslator<Object[]> translator = new NoArgEventTranslator();[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.publishEvents(new EventTranslator[]{translator, translator, translator, translator}, -1, 2);[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @SuppressWarnings("unchecked")[m
[31m-    @Test[m
[31m-    public void shouldNotTryPublishEventsWhenBatchStartsAtIsNegative() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslator<Object[]> translator = new NoArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents(new EventTranslator[]{translator, translator, translator, translator}, -1, 2);[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsOneArgWhenBatchSizeIs0() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.publishEvents(translator, 1, 0, new String[]{"Foo", "Foo"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotTryPublishEventsOneArgWhenBatchSizeIs0() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents(translator, 1, 0, new String[]{"Foo", "Foo"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsOneArgWhenBatchExtendsPastEndOfArray() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.publishEvents(translator, 1, 3, new String[]{"Foo", "Foo"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsOneArgWhenBatchSizeIsNegative() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.publishEvents(translator, 1, -1, new String[]{"Foo", "Foo"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsOneArgWhenBatchStartsAtIsNegative() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.publishEvents(translator, -1, 2, new String[]{"Foo", "Foo"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotTryPublishEventsOneArgWhenBatchExtendsPastEndOfArray() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents(translator, 1, 3, new String[]{"Foo", "Foo"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotTryPublishEventsOneArgWhenBatchSizeIsNegative() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                assertFalse(ringBuffer.tryPublishEvents(translator, 1, -1, new String[]{"Foo", "Foo"}));[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotTryPublishEventsOneArgWhenBatchStartsAtIsNegative() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents(translator, -1, 2, new String[]{"Foo", "Foo"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsTwoArgWhenBatchSizeIs0() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.publishEvents(translator, 1, 0, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotTryPublishEventsTwoArgWhenBatchSizeIs0() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents(translator, 1, 0, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsTwoArgWhenBatchExtendsPastEndOfArray() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.publishEvents(translator, 1, 3, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsTwoArgWhenBatchSizeIsNegative() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.publishEvents(translator, 1, -1, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsTwoArgWhenBatchStartsAtIsNegative() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.publishEvents(translator, -1, 2, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotTryPublishEventsTwoArgWhenBatchExtendsPastEndOfArray() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents(translator, 1, 3, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotTryPublishEventsTwoArgWhenBatchSizeIsNegative() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents(translator, 1, -1, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotTryPublishEventsTwoArgWhenBatchStartsAtIsNegative() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents(translator, -1, 2, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsThreeArgWhenBatchSizeIs0() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.publishEvents([m
[31m-                        translator, 1, 0, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"},[m
[31m-                        new String[]{"Baz", "Baz"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotTryPublishEventsThreeArgWhenBatchSizeIs0() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents([m
[31m-                        translator, 1, 0, new String[]{"Foo", "Foo"},[m
[31m-                        new String[]{"Bar", "Bar"}, new String[]{"Baz", "Baz"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsThreeArgWhenBatchExtendsPastEndOfArray() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.publishEvents([m
[31m-                        translator, 1, 3, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"},[m
[31m-                        new String[]{"Baz", "Baz"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsThreeArgWhenBatchSizeIsNegative() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.publishEvents([m
[31m-                        translator, 1, -1, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"},[m
[31m-                        new String[]{"Baz", "Baz"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsThreeArgWhenBatchStartsAtIsNegative() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.publishEvents([m
[31m-                        translator, -1, 2, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"},[m
[31m-                        new String[]{"Baz", "Baz"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotTryPublishEventsThreeArgWhenBatchExtendsPastEndOfArray() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents([m
[31m-                        translator, 1, 3, new String[]{"Foo", "Foo"}, new String[]{"Bar", "Bar"},[m
[31m-                        new String[]{"Baz", "Baz"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotTryPublishEventsThreeArgWhenBatchSizeIsNegative() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents([m
[31m-                        translator, 1, -1, new String[]{"Foo", "Foo"},[m
[31m-                        new String[]{"Bar", "Bar"}, new String[]{"Baz", "Baz"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotTryPublishEventsThreeArgWhenBatchStartsAtIsNegative() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents([m
[31m-                        translator, -1, 2, new String[]{"Foo", "Foo"},[m
[31m-                        new String[]{"Bar", "Bar"}, new String[]{"Baz", "Baz"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsVarArgWhenBatchSizeIs0() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            VarArgEventTranslator translator = new VarArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.publishEvents([m
[31m-                        translator, 1, 0, new String[]{"Foo0", "Bar0", "Baz0", "Bam0"},[m
[31m-                        new String[]{"Foo1", "Bar1", "Baz1", "Bam1"}, new String[]{[m
[31m-                                "Foo2", "Bar2",[m
[31m-                                "Baz2", "Bam2"[m
[31m-                        });[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotTryPublishEventsVarArgWhenBatchSizeIs0() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            VarArgEventTranslator translator = new VarArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents([m
[31m-                        translator, 1, 0, new String[]{"Foo0", "Bar0", "Baz0", "Bam0"},[m
[31m-                        new String[]{"Foo1", "Bar1", "Baz1", "Bam1"},[m
[31m-                        new String[]{"Foo2", "Bar2", "Baz2", "Bam2"});[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsVarArgWhenBatchExtendsPastEndOfArray() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            VarArgEventTranslator translator = new VarArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.publishEvents([m
[31m-                        translator, 1, 3, new String[]{"Foo0", "Bar0", "Baz0", "Bam0"},[m
[31m-                        new String[]{"Foo1", "Bar1", "Baz1", "Bam1"}, new String[]{[m
[31m-                                "Foo2", "Bar2",[m
[31m-                                "Baz2", "Bam2"[m
[31m-                        });[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsVarArgWhenBatchSizeIsNegative() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            VarArgEventTranslator translator = new VarArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.publishEvents([m
[31m-                        translator, 1, -1, new String[]{"Foo0", "Bar0", "Baz0", "Bam0"},[m
[31m-                        new String[]{"Foo1", "Bar1", "Baz1", "Bam1"}, new String[]{[m
[31m-                                "Foo2", "Bar2",[m
[31m-                                "Baz2", "Bam2"[m
[31m-                        });[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotPublishEventsVarArgWhenBatchStartsAtIsNegative() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            VarArgEventTranslator translator = new VarArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.publishEvents([m
[31m-                        translator, -1, 2, new String[]{"Foo0", "Bar0", "Baz0", "Bam0"},[m
[31m-                        new String[]{"Foo1", "Bar1", "Baz1", "Bam1"}, new String[]{[m
[31m-                                "Foo2", "Bar2",[m
[31m-                                "Baz2", "Bam2"[m
[31m-                        });[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotTryPublishEventsVarArgWhenBatchExtendsPastEndOfArray() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            VarArgEventTranslator translator = new VarArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents([m
[31m-                        translator, 1, 3, new String[]{"Foo0", "Bar0", "Baz0", "Bam0"},[m
[31m-                        new String[]{"Foo1", "Bar1", "Baz1", "Bam1"}, new String[]{[m
[31m-                                "Foo2", "Bar2",[m
[31m-                                "Baz2", "Bam2"[m
[31m-                        });[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotTryPublishEventsVarArgWhenBatchSizeIsNegative() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            VarArgEventTranslator translator = new VarArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents([m
[31m-                        translator, 1, -1, new String[]{"Foo0", "Bar0", "Baz0", "Bam0"},[m
[31m-                        new String[]{"Foo1", "Bar1", "Baz1", "Bam1"}, new String[]{[m
[31m-                                "Foo2", "Bar2",[m
[31m-                                "Baz2", "Bam2"[m
[31m-                        });[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotTryPublishEventsVarArgWhenBatchStartsAtIsNegative() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);[m
[31m-            VarArgEventTranslator translator = new VarArgEventTranslator();[m
[31m-[m
[31m-            try[m
[31m-            {[m
[31m-                ringBuffer.tryPublishEvents([m
[31m-                        translator, -1, 2, new String[]{"Foo0", "Bar0", "Baz0", "Bam0"},[m
[31m-                        new String[]{"Foo1", "Bar1", "Baz1", "Bam1"}, new String[]{[m
[31m-                                "Foo2", "Bar2",[m
[31m-                                "Baz2", "Bam2"[m
[31m-                        });[m
[31m-            }[m
[31m-            finally[m
[31m-            {[m
[31m-                assertEmptyRingBuffer(ringBuffer);[m
[31m-            }[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldAddAndRemoveSequences() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 16);[m
[31m-[m
[31m-        Sequence sequenceThree = new Sequence(-1);[m
[31m-        Sequence sequenceSeven = new Sequence(-1);[m
[31m-        ringBuffer.addGatingSequences(sequenceThree, sequenceSeven);[m
[31m-[m
[31m-        for (int i = 0; i < 10; i++)[m
[31m-        {[m
[31m-            ringBuffer.publish(ringBuffer.next());[m
[31m-        }[m
[31m-[m
[31m-        sequenceThree.set(3);[m
[31m-        sequenceSeven.set(7);[m
[31m-[m
[31m-        assertThat(ringBuffer.getMinimumGatingSequence(), is(3L));[m
[31m-        assertTrue(ringBuffer.removeGatingSequence(sequenceThree));[m
[31m-        assertThat(ringBuffer.getMinimumGatingSequence(), is(7L));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldHandleResetToAndNotWrapUnnecessarilySingleProducer() throws Exception[m
[31m-    {[m
[31m-        assertHandleResetAndNotWrap(RingBuffer.createSingleProducer(StubEvent.EVENT_FACTORY, 4));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldHandleResetToAndNotWrapUnnecessarilyMultiProducer() throws Exception[m
[31m-    {[m
[31m-        assertHandleResetAndNotWrap(RingBuffer.createMultiProducer(StubEvent.EVENT_FACTORY, 4));[m
[31m-    }[m
[31m-[m
[31m-    @SuppressWarnings("deprecation")[m
[31m-    private void assertHandleResetAndNotWrap(RingBuffer<StubEvent> rb)[m
[31m-    {[m
[31m-        Sequence sequence = new Sequence();[m
[31m-        rb.addGatingSequences(sequence);[m
[31m-[m
[31m-        for (int i = 0; i < 128; i++)[m
[31m-        {[m
[31m-            rb.publish(rb.next());[m
[31m-            sequence.incrementAndGet();[m
[31m-        }[m
[31m-[m
[31m-        assertThat(rb.getCursor(), is(127L));[m
[31m-[m
[31m-        rb.resetTo(31);[m
[31m-        sequence.set(31);[m
[31m-[m
[31m-        for (int i = 0; i < 4; i++)[m
[31m-        {[m
[31m-            rb.publish(rb.next());[m
[31m-        }[m
[31m-[m
[31m-        assertThat(rb.hasAvailableCapacity(1), is(false));[m
[31m-    }[m
[31m-[m
[31m-    private Future<List<StubEvent>> getMessages(final long initial, final long toWaitFor) throws InterruptedException,[m
[31m-        BrokenBarrierException[m
[31m-    {[m
[31m-        final CyclicBarrier cyclicBarrier = new CyclicBarrier(2);[m
[31m-        final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();[m
[31m-[m
[31m-        final Future<List<StubEvent>> f = executor.submit([m
[31m-            new TestWaiter([m
[31m-                cyclicBarrier, sequenceBarrier, ringBuffer,[m
[31m-                initial, toWaitFor));[m
[31m-[m
[31m-        cyclicBarrier.await();[m
[31m-[m
[31m-        return f;[m
[31m-    }[m
[31m-[m
[31m-    private void assertEmptyRingBuffer(final RingBuffer<Object[]> ringBuffer)[m
[31m-    {[m
[31m-        assertThat(ringBuffer.get(0)[0], is(nullValue()));[m
[31m-        assertThat(ringBuffer.get(1)[0], is(nullValue()));[m
[31m-        assertThat(ringBuffer.get(2)[0], is(nullValue()));[m
[31m-        assertThat(ringBuffer.get(3)[0], is(nullValue()));[m
[31m-    }[m
[31m-[m
[31m-    private static final class TestEventProcessor implements EventProcessor[m
[31m-    {[m
[31m-        private final SequenceBarrier sequenceBarrier;[m
[31m-        private final Sequence sequence = new Sequence(SingleProducerSequencer.INITIAL_CURSOR_VALUE);[m
[31m-        private final AtomicBoolean running = new AtomicBoolean();[m
[31m-[m
[31m-[m
[31m-        TestEventProcessor(final SequenceBarrier sequenceBarrier)[m
[31m-        {[m
[31m-            this.sequenceBarrier = sequenceBarrier;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public Sequence getSequence()[m
[31m-        {[m
[31m-            return sequence;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void halt()[m
[31m-        {[m
[31m-            running.set(false);[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public boolean isRunning()[m
[31m-        {[m
[31m-            return running.get();[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void run()[m
[31m-        {[m
[31m-            if (!running.compareAndSet(false, true))[m
[31m-            {[m
[31m-                throw new IllegalStateException("Already running");[m
[31m-            }[m
[31m-            try[m
[31m-            {[m
[31m-                sequenceBarrier.waitFor(0L);[m
[31m-            }[m
[31m-            catch (Exception ex)[m
[31m-            {[m
[31m-                throw new RuntimeException(ex);[m
[31m-            }[m
[31m-[m
[31m-            sequence.set(sequence.get() + 1L);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class ArrayFactory implements EventFactory<Object[]>[m
[31m-    {[m
[31m-        private final int size;[m
[31m-[m
[31m-        ArrayFactory(int size)[m
[31m-        {[m
[31m-            this.size = size;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public Object[] newInstance()[m
[31m-        {[m
[31m-            return new Object[size];[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class NoArgEventTranslator implements EventTranslator<Object[]>[m
[31m-    {[m
[31m-        @Override[m
[31m-        public void translateTo(Object[] event, long sequence)[m
[31m-        {[m
[31m-            event[0] = sequence;[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class VarArgEventTranslator implements EventTranslatorVararg<Object[]>[m
[31m-    {[m
[31m-        @Override[m
[31m-        public void translateTo(Object[] event, long sequence, Object... args)[m
[31m-        {[m
[31m-            event[0] = (String) args[0] + args[1] + args[2] + args[3] + "-" + sequence;[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class ThreeArgEventTranslator implements EventTranslatorThreeArg<Object[], String, String, String>[m
[31m-    {[m
[31m-        @Override[m
[31m-        public void translateTo(Object[] event, long sequence, String arg0, String arg1, String arg2)[m
[31m-        {[m
[31m-            event[0] = arg0 + arg1 + arg2 + "-" + sequence;[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class TwoArgEventTranslator implements EventTranslatorTwoArg<Object[], String, String>[m
[31m-    {[m
[31m-        @Override[m
[31m-        public void translateTo(Object[] event, long sequence, String arg0, String arg1)[m
[31m-        {[m
[31m-            event[0] = arg0 + arg1 + "-" + sequence;[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class OneArgEventTranslator implements EventTranslatorOneArg<Object[], String>[m
[31m-    {[m
[31m-        @Override[m
[31m-        public void translateTo(Object[] event, long sequence, String arg0)[m
[31m-        {[m
[31m-            event[0] = arg0 + "-" + sequence;[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/RingBufferWithAssertingStubTest.java b/src/test/java/com/lmax/disruptor/RingBufferWithAssertingStubTest.java[m
[1mdeleted file mode 100644[m
[1mindex e081128..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/RingBufferWithAssertingStubTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,176 +0,0 @@[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import com.lmax.disruptor.support.StubEvent;[m
[31m-import org.junit.jupiter.api.BeforeEach;[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import java.util.concurrent.ThreadLocalRandom;[m
[31m-[m
[31m-import static org.hamcrest.MatcherAssert.assertThat;[m
[31m-import static org.hamcrest.core.Is.is;[m
[31m-[m
[31m-public class RingBufferWithAssertingStubTest[m
[31m-{[m
[31m-    private RingBuffer<StubEvent> ringBuffer;[m
[31m-    private Sequencer sequencer;[m
[31m-[m
[31m-    @BeforeEach[m
[31m-    public void setUp()[m
[31m-    {[m
[31m-        sequencer = new AssertingSequencer(16);[m
[31m-[m
[31m-        ringBuffer = new RingBuffer<>(StubEvent.EVENT_FACTORY, sequencer);[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldDelegateNextAndPublish()[m
[31m-    {[m
[31m-        ringBuffer.publish(ringBuffer.next());[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldDelegateTryNextAndPublish() throws Exception[m
[31m-    {[m
[31m-        ringBuffer.publish(ringBuffer.tryNext());[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldDelegateNextNAndPublish() throws Exception[m
[31m-    {[m
[31m-        long hi = ringBuffer.next(10);[m
[31m-        ringBuffer.publish(hi - 9, hi);[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldDelegateTryNextNAndPublish() throws Exception[m
[31m-    {[m
[31m-        long hi = ringBuffer.tryNext(10);[m
[31m-        ringBuffer.publish(hi - 9, hi);[m
[31m-    }[m
[31m-[m
[31m-    private static final class AssertingSequencer implements Sequencer[m
[31m-    {[m
[31m-        private final int size;[m
[31m-        private long lastBatchSize = -1;[m
[31m-        private long lastValue = -1;[m
[31m-[m
[31m-        private AssertingSequencer(int size)[m
[31m-        {[m
[31m-            this.size = size;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public int getBufferSize()[m
[31m-        {[m
[31m-            return size;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public boolean hasAvailableCapacity(int requiredCapacity)[m
[31m-        {[m
[31m-            return requiredCapacity <= size;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public long remainingCapacity()[m
[31m-        {[m
[31m-            return size;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public long next()[m
[31m-        {[m
[31m-            lastValue = ThreadLocalRandom.current().nextLong(0, 1000000);[m
[31m-            lastBatchSize = 1;[m
[31m-            return lastValue;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public long next(int n)[m
[31m-        {[m
[31m-            lastValue = ThreadLocalRandom.current().nextLong(n, 1000000);[m
[31m-            lastBatchSize = n;[m
[31m-            return lastValue;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public long tryNext() throws InsufficientCapacityException[m
[31m-        {[m
[31m-            return next();[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public long tryNext(int n) throws InsufficientCapacityException[m
[31m-        {[m
[31m-            return next(n);[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void publish(long sequence)[m
[31m-        {[m
[31m-            assertThat(sequence, is(lastValue));[m
[31m-            assertThat(lastBatchSize, is(1L));[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void publish(long lo, long hi)[m
[31m-        {[m
[31m-            assertThat(hi, is(lastValue));[m
[31m-            assertThat((hi - lo) + 1, is(lastBatchSize));[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public long getCursor()[m
[31m-        {[m
[31m-            return lastValue;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void claim(long sequence)[m
[31m-        {[m
[31m-[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public boolean isAvailable(long sequence)[m
[31m-        {[m
[31m-            return false;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void addGatingSequences(Sequence... gatingSequences)[m
[31m-        {[m
[31m-[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public boolean removeGatingSequence(Sequence sequence)[m
[31m-        {[m
[31m-            return false;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public SequenceBarrier newBarrier(Sequence... sequencesToTrack)[m
[31m-        {[m
[31m-            return null;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public long getMinimumSequence()[m
[31m-        {[m
[31m-            return 0;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public long getHighestPublishedSequence(long nextSequence, long availableSequence)[m
[31m-        {[m
[31m-            return 0;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public <T> EventPoller<T> newPoller(DataProvider<T> provider, Sequence... gatingSequences)[m
[31m-        {[m
[31m-            return null;[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/SequenceBarrierTest.java b/src/test/java/com/lmax/disruptor/SequenceBarrierTest.java[m
[1mdeleted file mode 100644[m
[1mindex a74891a..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/SequenceBarrierTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,206 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import com.lmax.disruptor.support.DummyEventProcessor;[m
[31m-import com.lmax.disruptor.support.StubEvent;[m
[31m-import com.lmax.disruptor.util.Util;[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.TimeUnit;[m
[31m-[m
[31m-import static com.lmax.disruptor.RingBuffer.createMultiProducer;[m
[31m-import static org.junit.jupiter.api.Assertions.assertFalse;[m
[31m-import static org.junit.jupiter.api.Assertions.assertTrue;[m
[31m-[m
[31m-[m
[31m-public final class SequenceBarrierTest[m
[31m-{[m
[31m-    private final RingBuffer<StubEvent> ringBuffer = createMultiProducer(StubEvent.EVENT_FACTORY, 64);[m
[31m-[m
[31m-    public SequenceBarrierTest()[m
[31m-    {[m
[31m-        ringBuffer.addGatingSequences(new NoOpEventProcessor(ringBuffer).getSequence());[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldWaitForWorkCompleteWhereCompleteWorkThresholdIsAhead() throws Exception[m
[31m-    {[m
[31m-        final long expectedNumberMessages = 10;[m
[31m-        final long expectedWorkSequence = 9;[m
[31m-        fillRingBuffer(expectedNumberMessages);[m
[31m-[m
[31m-        final Sequence sequence1 = new Sequence(expectedNumberMessages);[m
[31m-        final Sequence sequence2 = new Sequence(expectedWorkSequence);[m
[31m-        final Sequence sequence3 = new Sequence(expectedNumberMessages);[m
[31m-[m
[31m-        final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier(sequence1, sequence2, sequence3);[m
[31m-[m
[31m-        long completedWorkSequence = sequenceBarrier.waitFor(expectedWorkSequence);[m
[31m-        assertTrue(completedWorkSequence >= expectedWorkSequence);[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldWaitForWorkCompleteWhereAllWorkersAreBlockedOnRingBuffer() throws Exception[m
[31m-    {[m
[31m-        long expectedNumberMessages = 10;[m
[31m-        fillRingBuffer(expectedNumberMessages);[m
[31m-[m
[31m-        final DummyEventProcessor[] workers = new DummyEventProcessor[3];[m
[31m-        for (int i = 0, size = workers.length; i < size; i++)[m
[31m-        {[m
[31m-            workers[i] = new DummyEventProcessor();[m
[31m-            workers[i].setSequence(expectedNumberMessages - 1);[m
[31m-        }[m
[31m-[m
[31m-        final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier(Util.getSequencesFor(workers));[m
[31m-[m
[31m-        Runnable runnable = () ->[m
[31m-        {[m
[31m-            long sequence = ringBuffer.next();[m
[31m-            StubEvent event = ringBuffer.get(sequence);[m
[31m-            event.setValue((int) sequence);[m
[31m-            ringBuffer.publish(sequence);[m
[31m-[m
[31m-            for (DummyEventProcessor stubWorker : workers)[m
[31m-            {[m
[31m-                stubWorker.setSequence(sequence);[m
[31m-            }[m
[31m-        };[m
[31m-[m
[31m-        new Thread(runnable).start();[m
[31m-[m
[31m-        long expectedWorkSequence = expectedNumberMessages;[m
[31m-        long completedWorkSequence = sequenceBarrier.waitFor(expectedNumberMessages);[m
[31m-        assertTrue(completedWorkSequence >= expectedWorkSequence);[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldInterruptDuringBusySpin() throws Exception[m
[31m-    {[m
[31m-        final long expectedNumberMessages = 10;[m
[31m-        fillRingBuffer(expectedNumberMessages);[m
[31m-[m
[31m-        final CountDownLatch latch = new CountDownLatch(3);[m
[31m-        final Sequence sequence1 = new CountDownLatchSequence(8L, latch);[m
[31m-        final Sequence sequence2 = new CountDownLatchSequence(8L, latch);[m
[31m-        final Sequence sequence3 = new CountDownLatchSequence(8L, latch);[m
[31m-[m
[31m-        final SequenceBarrier sequenceBarrier =[m
[31m-            ringBuffer.newBarrier(sequence1, sequence2, sequence3);[m
[31m-[m
[31m-        final boolean[] alerted = {false};[m
[31m-        Thread t = new Thread([m
[31m-                () ->[m
[31m-                {[m
[31m-                    try[m
[31m-                    {[m
[31m-                        sequenceBarrier.waitFor(expectedNumberMessages - 1);[m
[31m-                    }[m
[31m-                    catch (AlertException e)[m
[31m-                    {[m
[31m-                        alerted[0] = true;[m
[31m-                    }[m
[31m-                    catch (Exception e)[m
[31m-                    {[m
[31m-                        // don't care[m
[31m-                    }[m
[31m-                });[m
[31m-[m
[31m-        t.start();[m
[31m-        latch.await(3, TimeUnit.SECONDS);[m
[31m-        sequenceBarrier.alert();[m
[31m-        t.join();[m
[31m-[m
[31m-        assertTrue(alerted[0], "Thread was not interrupted");[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldWaitForWorkCompleteWhereCompleteWorkThresholdIsBehind() throws Exception[m
[31m-    {[m
[31m-        long expectedNumberMessages = 10;[m
[31m-        fillRingBuffer(expectedNumberMessages);[m
[31m-[m
[31m-        final DummyEventProcessor[] eventProcessors = new DummyEventProcessor[3];[m
[31m-        for (int i = 0, size = eventProcessors.length; i < size; i++)[m
[31m-        {[m
[31m-            eventProcessors[i] = new DummyEventProcessor();[m
[31m-            eventProcessors[i].setSequence(expectedNumberMessages - 2);[m
[31m-        }[m
[31m-[m
[31m-        final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier(Util.getSequencesFor(eventProcessors));[m
[31m-[m
[31m-        Runnable runnable = () ->[m
[31m-        {[m
[31m-            for (DummyEventProcessor stubWorker : eventProcessors)[m
[31m-            {[m
[31m-                stubWorker.setSequence(stubWorker.getSequence().get() + 1L);[m
[31m-            }[m
[31m-        };[m
[31m-[m
[31m-        Thread thread = new Thread(runnable);[m
[31m-        thread.start();[m
[31m-        thread.join();[m
[31m-[m
[31m-        long expectedWorkSequence = expectedNumberMessages - 1;[m
[31m-        long completedWorkSequence = sequenceBarrier.waitFor(expectedWorkSequence);[m
[31m-        assertTrue(completedWorkSequence >= expectedWorkSequence);[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldSetAndClearAlertStatus()[m
[31m-    {[m
[31m-        SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();[m
[31m-[m
[31m-        assertFalse(sequenceBarrier.isAlerted());[m
[31m-[m
[31m-        sequenceBarrier.alert();[m
[31m-        assertTrue(sequenceBarrier.isAlerted());[m
[31m-[m
[31m-        sequenceBarrier.clearAlert();[m
[31m-        assertFalse(sequenceBarrier.isAlerted());[m
[31m-    }[m
[31m-[m
[31m-    private void fillRingBuffer(long expectedNumberMessages) throws InterruptedException[m
[31m-    {[m
[31m-        for (long i = 0; i < expectedNumberMessages; i++)[m
[31m-        {[m
[31m-            long sequence = ringBuffer.next();[m
[31m-            StubEvent event = ringBuffer.get(sequence);[m
[31m-            event.setValue((int) i);[m
[31m-            ringBuffer.publish(sequence);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static final class CountDownLatchSequence extends Sequence[m
[31m-    {[m
[31m-        private final CountDownLatch latch;[m
[31m-[m
[31m-        private CountDownLatchSequence(final long initialValue, final CountDownLatch latch)[m
[31m-        {[m
[31m-            super(initialValue);[m
[31m-            this.latch = latch;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public long get()[m
[31m-        {[m
[31m-            latch.countDown();[m
[31m-            return super.get();[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/SequenceGroupTest.java b/src/test/java/com/lmax/disruptor/SequenceGroupTest.java[m
[1mdeleted file mode 100644[m
[1mindex de307c7..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/SequenceGroupTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,148 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import com.lmax.disruptor.support.TestEvent;[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import static org.hamcrest.CoreMatchers.is;[m
[31m-import static org.hamcrest.MatcherAssert.assertThat;[m
[31m-import static org.junit.jupiter.api.Assertions.assertEquals;[m
[31m-import static org.junit.jupiter.api.Assertions.assertTrue;[m
[31m-[m
[31m-public final class SequenceGroupTest[m
[31m-{[m
[31m-    @Test[m
[31m-    public void shouldReturnMaxSequenceWhenEmptyGroup()[m
[31m-    {[m
[31m-        final SequenceGroup sequenceGroup = new SequenceGroup();[m
[31m-        assertEquals(Long.MAX_VALUE, sequenceGroup.get());[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldAddOneSequenceToGroup()[m
[31m-    {[m
[31m-        final Sequence sequence = new Sequence(7L);[m
[31m-        final SequenceGroup sequenceGroup = new SequenceGroup();[m
[31m-[m
[31m-        sequenceGroup.add(sequence);[m
[31m-[m
[31m-        assertEquals(sequence.get(), sequenceGroup.get());[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldNotFailIfTryingToRemoveNotExistingSequence() throws Exception[m
[31m-    {[m
[31m-        SequenceGroup group = new SequenceGroup();[m
[31m-        group.add(new Sequence());[m
[31m-        group.add(new Sequence());[m
[31m-        group.remove(new Sequence());[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldReportTheMinimumSequenceForGroupOfTwo()[m
[31m-    {[m
[31m-        final Sequence sequenceThree = new Sequence(3L);[m
[31m-        final Sequence sequenceSeven = new Sequence(7L);[m
[31m-        final SequenceGroup sequenceGroup = new SequenceGroup();[m
[31m-[m
[31m-        sequenceGroup.add(sequenceSeven);[m
[31m-        sequenceGroup.add(sequenceThree);[m
[31m-[m
[31m-        assertEquals(sequenceThree.get(), sequenceGroup.get());[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldReportSizeOfGroup()[m
[31m-    {[m
[31m-        final SequenceGroup sequenceGroup = new SequenceGroup();[m
[31m-        sequenceGroup.add(new Sequence());[m
[31m-        sequenceGroup.add(new Sequence());[m
[31m-        sequenceGroup.add(new Sequence());[m
[31m-[m
[31m-        assertEquals(3, sequenceGroup.size());[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldRemoveSequenceFromGroup()[m
[31m-    {[m
[31m-        final Sequence sequenceThree = new Sequence(3L);[m
[31m-        final Sequence sequenceSeven = new Sequence(7L);[m
[31m-        final SequenceGroup sequenceGroup = new SequenceGroup();[m
[31m-[m
[31m-        sequenceGroup.add(sequenceSeven);[m
[31m-        sequenceGroup.add(sequenceThree);[m
[31m-[m
[31m-        assertEquals(sequenceThree.get(), sequenceGroup.get());[m
[31m-[m
[31m-        assertTrue(sequenceGroup.remove(sequenceThree));[m
[31m-        assertEquals(sequenceSeven.get(), sequenceGroup.get());[m
[31m-        assertEquals(1, sequenceGroup.size());[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldRemoveSequenceFromGroupWhereItBeenAddedMultipleTimes()[m
[31m-    {[m
[31m-        final Sequence sequenceThree = new Sequence(3L);[m
[31m-        final Sequence sequenceSeven = new Sequence(7L);[m
[31m-        final SequenceGroup sequenceGroup = new SequenceGroup();[m
[31m-[m
[31m-        sequenceGroup.add(sequenceThree);[m
[31m-        sequenceGroup.add(sequenceSeven);[m
[31m-        sequenceGroup.add(sequenceThree);[m
[31m-[m
[31m-        assertEquals(sequenceThree.get(), sequenceGroup.get());[m
[31m-[m
[31m-        assertTrue(sequenceGroup.remove(sequenceThree));[m
[31m-        assertEquals(sequenceSeven.get(), sequenceGroup.get());[m
[31m-        assertEquals(1, sequenceGroup.size());[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldSetGroupSequenceToSameValue()[m
[31m-    {[m
[31m-        final Sequence sequenceThree = new Sequence(3L);[m
[31m-        final Sequence sequenceSeven = new Sequence(7L);[m
[31m-        final SequenceGroup sequenceGroup = new SequenceGroup();[m
[31m-[m
[31m-        sequenceGroup.add(sequenceSeven);[m
[31m-        sequenceGroup.add(sequenceThree);[m
[31m-[m
[31m-        final long expectedSequence = 11L;[m
[31m-        sequenceGroup.set(expectedSequence);[m
[31m-[m
[31m-        assertEquals(expectedSequence, sequenceThree.get());[m
[31m-        assertEquals(expectedSequence, sequenceSeven.get());[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldAddWhileRunning() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<TestEvent> ringBuffer = RingBuffer.createSingleProducer(TestEvent.EVENT_FACTORY, 32);[m
[31m-        final Sequence sequenceThree = new Sequence(3L);[m
[31m-        final Sequence sequenceSeven = new Sequence(7L);[m
[31m-        final SequenceGroup sequenceGroup = new SequenceGroup();[m
[31m-        sequenceGroup.add(sequenceSeven);[m
[31m-[m
[31m-        for (int i = 0; i < 11; i++)[m
[31m-        {[m
[31m-            ringBuffer.publish(ringBuffer.next());[m
[31m-        }[m
[31m-[m
[31m-        sequenceGroup.addWhileRunning(ringBuffer, sequenceThree);[m
[31m-        assertThat(sequenceThree.get(), is(10L));[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/SequenceReportingCallbackTest.java b/src/test/java/com/lmax/disruptor/SequenceReportingCallbackTest.java[m
[1mdeleted file mode 100644[m
[1mindex d5577b8..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/SequenceReportingCallbackTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,81 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import com.lmax.disruptor.support.StubEvent;[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-[m
[31m-import static com.lmax.disruptor.RingBuffer.createMultiProducer;[m
[31m-import static org.junit.jupiter.api.Assertions.assertEquals;[m
[31m-[m
[31m-public class SequenceReportingCallbackTest[m
[31m-{[m
[31m-    private final CountDownLatch callbackLatch = new CountDownLatch(1);[m
[31m-    private final CountDownLatch onEndOfBatchLatch = new CountDownLatch(1);[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldReportProgressByUpdatingSequenceViaCallback()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        final RingBuffer<StubEvent> ringBuffer = createMultiProducer(StubEvent.EVENT_FACTORY, 16);[m
[31m-        final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();[m
[31m-        final SequenceReportingEventHandler<StubEvent> handler = new TestSequenceReportingEventHandler();[m
[31m-        final BatchEventProcessor<StubEvent> batchEventProcessor = new BatchEventProcessor<>([m
[31m-                ringBuffer, sequenceBarrier, handler);[m
[31m-        ringBuffer.addGatingSequences(batchEventProcessor.getSequence());[m
[31m-[m
[31m-        Thread thread = new Thread(batchEventProcessor);[m
[31m-        thread.setDaemon(true);[m
[31m-        thread.start();[m
[31m-[m
[31m-        assertEquals(-1L, batchEventProcessor.getSequence().get());[m
[31m-        ringBuffer.publish(ringBuffer.next());[m
[31m-[m
[31m-        callbackLatch.await();[m
[31m-        assertEquals(0L, batchEventProcessor.getSequence().get());[m
[31m-[m
[31m-        onEndOfBatchLatch.countDown();[m
[31m-        assertEquals(0L, batchEventProcessor.getSequence().get());[m
[31m-[m
[31m-        batchEventProcessor.halt();[m
[31m-        thread.join();[m
[31m-    }[m
[31m-[m
[31m-    private class TestSequenceReportingEventHandler implements SequenceReportingEventHandler<StubEvent>[m
[31m-    {[m
[31m-        private Sequence sequenceCallback;[m
[31m-[m
[31m-        @Override[m
[31m-        public void setSequenceCallback(final Sequence sequenceTrackerCallback)[m
[31m-        {[m
[31m-            this.sequenceCallback = sequenceTrackerCallback;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void onEvent(final StubEvent event, final long sequence, final boolean endOfBatch) throws Exception[m
[31m-        {[m
[31m-            sequenceCallback.set(sequence);[m
[31m-            callbackLatch.countDown();[m
[31m-[m
[31m-            if (endOfBatch)[m
[31m-            {[m
[31m-                onEndOfBatchLatch.await();[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/SequencerTest.java b/src/test/java/com/lmax/disruptor/SequencerTest.java[m
[1mdeleted file mode 100644[m
[1mindex fb26e62..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/SequencerTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,293 +0,0 @@[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import com.lmax.disruptor.dsl.ProducerType;[m
[31m-import com.lmax.disruptor.support.DummyWaitStrategy;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-import org.junit.jupiter.params.ParameterizedTest;[m
[31m-import org.junit.jupiter.params.provider.Arguments;[m
[31m-import org.junit.jupiter.params.provider.MethodSource;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-import java.util.stream.Stream;[m
[31m-[m
[31m-import static org.hamcrest.CoreMatchers.is;[m
[31m-import static org.hamcrest.MatcherAssert.assertThat;[m
[31m-import static org.junit.jupiter.api.Assertions.assertEquals;[m
[31m-import static org.junit.jupiter.api.Assertions.assertFalse;[m
[31m-import static org.junit.jupiter.api.Assertions.assertThrows;[m
[31m-import static org.junit.jupiter.api.Assertions.assertTrue;[m
[31m-import static org.junit.jupiter.api.Assertions.fail;[m
[31m-import static org.junit.jupiter.params.provider.Arguments.arguments;[m
[31m-[m
[31m-public class SequencerTest[m
[31m-{[m
[31m-    private static final int BUFFER_SIZE = 16;[m
[31m-    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);[m
[31m-    private final Sequence gatingSequence = new Sequence();[m
[31m-[m
[31m-    private static Stream<Arguments> sequencerGenerator()[m
[31m-    {[m
[31m-        return Stream.of([m
[31m-                arguments(newProducer(ProducerType.SINGLE, new BlockingWaitStrategy())),[m
[31m-                arguments(newProducer(ProducerType.MULTI, new BlockingWaitStrategy()))[m
[31m-        );[m
[31m-    }[m
[31m-[m
[31m-    private static Stream<Arguments> producerTypeGenerator()[m
[31m-    {[m
[31m-        return Stream.of(arguments(ProducerType.SINGLE), arguments(ProducerType.MULTI));[m
[31m-    }[m
[31m-[m
[31m-    private static Sequencer newProducer(ProducerType producerType, WaitStrategy waitStrategy)[m
[31m-    {[m
[31m-        switch (producerType)[m
[31m-        {[m
[31m-            case SINGLE:[m
[31m-                return new SingleProducerSequencer(BUFFER_SIZE, waitStrategy);[m
[31m-            case MULTI:[m
[31m-                return new MultiProducerSequencer(BUFFER_SIZE, waitStrategy);[m
[31m-            default:[m
[31m-                throw new IllegalStateException(producerType.toString());[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @ParameterizedTest[m
[31m-    @MethodSource("sequencerGenerator")[m
[31m-    public void shouldStartWithInitialValue(Sequencer sequencer)[m
[31m-    {[m
[31m-        assertEquals(0, sequencer.next());[m
[31m-    }[m
[31m-[m
[31m-    @ParameterizedTest[m
[31m-    @MethodSource("sequencerGenerator")[m
[31m-    public void shouldBatchClaim(Sequencer sequencer)[m
[31m-    {[m
[31m-        assertEquals(3, sequencer.next(4));[m
[31m-    }[m
[31m-[m
[31m-    @ParameterizedTest[m
[31m-    @MethodSource("sequencerGenerator")[m
[31m-    public void shouldIndicateHasAvailableCapacity(Sequencer sequencer)[m
[31m-    {[m
[31m-        sequencer.addGatingSequences(gatingSequence);[m
[31m-[m
[31m-        assertTrue(sequencer.hasAvailableCapacity(1));[m
[31m-        assertTrue(sequencer.hasAvailableCapacity(BUFFER_SIZE));[m
[31m-        assertFalse(sequencer.hasAvailableCapacity(BUFFER_SIZE + 1));[m
[31m-[m
[31m-        sequencer.publish(sequencer.next());[m
[31m-[m
[31m-        assertTrue(sequencer.hasAvailableCapacity(BUFFER_SIZE - 1));[m
[31m-        assertFalse(sequencer.hasAvailableCapacity(BUFFER_SIZE));[m
[31m-    }[m
[31m-[m
[31m-    @ParameterizedTest[m
[31m-    @MethodSource("sequencerGenerator")[m
[31m-    public void shouldIndicateNoAvailableCapacity(Sequencer sequencer)[m
[31m-    {[m
[31m-        sequencer.addGatingSequences(gatingSequence);[m
[31m-        long sequence = sequencer.next(BUFFER_SIZE);[m
[31m-        sequencer.publish(sequence - (BUFFER_SIZE - 1), sequence);[m
[31m-[m
[31m-        assertFalse(sequencer.hasAvailableCapacity(1));[m
[31m-    }[m
[31m-[m
[31m-    @ParameterizedTest[m
[31m-    @MethodSource("sequencerGenerator")[m
[31m-    public void shouldHoldUpPublisherWhenBufferIsFull(Sequencer sequencer)[m
[31m-        throws InterruptedException[m
[31m-    {[m
[31m-        sequencer.addGatingSequences(gatingSequence);[m
[31m-        long sequence = sequencer.next(BUFFER_SIZE);[m
[31m-        sequencer.publish(sequence - (BUFFER_SIZE - 1), sequence);[m
[31m-[m
[31m-        final CountDownLatch waitingLatch = new CountDownLatch(1);[m
[31m-        final CountDownLatch doneLatch = new CountDownLatch(1);[m
[31m-[m
[31m-        final long expectedFullSequence = Sequencer.INITIAL_CURSOR_VALUE + sequencer.getBufferSize();[m
[31m-        assertThat(sequencer.getCursor(), is(expectedFullSequence));[m
[31m-[m
[31m-        executor.submit([m
[31m-                () ->[m
[31m-                {[m
[31m-                    waitingLatch.countDown();[m
[31m-[m
[31m-                    long next = sequencer.next();[m
[31m-                    sequencer.publish(next);[m
[31m-[m
[31m-                    doneLatch.countDown();[m
[31m-                });[m
[31m-[m
[31m-        waitingLatch.await();[m
[31m-        assertThat(sequencer.getCursor(), is(expectedFullSequence));[m
[31m-[m
[31m-        gatingSequence.set(Sequencer.INITIAL_CURSOR_VALUE + 1L);[m
[31m-[m
[31m-        doneLatch.await();[m
[31m-        assertThat(sequencer.getCursor(), is(expectedFullSequence + 1L));[m
[31m-    }[m
[31m-[m
[31m-    @ParameterizedTest[m
[31m-    @MethodSource("sequencerGenerator")[m
[31m-    public void shouldThrowInsufficientCapacityExceptionWhenSequencerIsFull(Sequencer sequencer) throws Exception[m
[31m-    {[m
[31m-        assertThrows(InsufficientCapacityException.class, () ->[m
[31m-        {[m
[31m-            sequencer.addGatingSequences(gatingSequence);[m
[31m-            for (int i = 0; i < BUFFER_SIZE; i++)[m
[31m-            {[m
[31m-                sequencer.next();[m
[31m-            }[m
[31m-            sequencer.tryNext();[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @ParameterizedTest[m
[31m-    @MethodSource("sequencerGenerator")[m
[31m-    public void shouldCalculateRemainingCapacity(Sequencer sequencer) throws Exception[m
[31m-    {[m
[31m-        sequencer.addGatingSequences(gatingSequence);[m
[31m-[m
[31m-        assertThat(sequencer.remainingCapacity(), is((long) BUFFER_SIZE));[m
[31m-        for (int i = 1; i < BUFFER_SIZE; i++)[m
[31m-        {[m
[31m-            sequencer.next();[m
[31m-            assertThat(sequencer.remainingCapacity(), is((long) BUFFER_SIZE - i));[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @ParameterizedTest[m
[31m-    @MethodSource("sequencerGenerator")[m
[31m-    public void shouldNotBeAvailableUntilPublished(Sequencer sequencer) throws Exception[m
[31m-    {[m
[31m-        long next = sequencer.next(6);[m
[31m-[m
[31m-        for (int i = 0; i <= 5; i++)[m
[31m-        {[m
[31m-            assertThat(sequencer.isAvailable(i), is(false));[m
[31m-        }[m
[31m-[m
[31m-        sequencer.publish(next - (6 - 1), next);[m
[31m-[m
[31m-        for (int i = 0; i <= 5; i++)[m
[31m-        {[m
[31m-            assertThat(sequencer.isAvailable(i), is(true));[m
[31m-        }[m
[31m-[m
[31m-        assertThat(sequencer.isAvailable(6), is(false));[m
[31m-    }[m
[31m-[m
[31m-    @ParameterizedTest[m
[31m-    @MethodSource("producerTypeGenerator")[m
[31m-    public void shouldNotifyWaitStrategyOnPublish(ProducerType producerType) throws Exception[m
[31m-    {[m
[31m-        final DummyWaitStrategy waitStrategy = new DummyWaitStrategy();[m
[31m-        final Sequenced sequencer = newProducer(producerType, waitStrategy);[m
[31m-[m
[31m-        sequencer.publish(sequencer.next());[m
[31m-[m
[31m-        assertThat(waitStrategy.signalAllWhenBlockingCalls, is(1));[m
[31m-    }[m
[31m-[m
[31m-    @ParameterizedTest[m
[31m-    @MethodSource("producerTypeGenerator")[m
[31m-    public void shouldNotifyWaitStrategyOnPublishBatch(ProducerType producerType) throws Exception[m
[31m-    {[m
[31m-        final DummyWaitStrategy waitStrategy = new DummyWaitStrategy();[m
[31m-        final Sequenced sequencer = newProducer(producerType, waitStrategy);[m
[31m-[m
[31m-        long next = sequencer.next(4);[m
[31m-        sequencer.publish(next - (4 - 1), next);[m
[31m-[m
[31m-        assertThat(waitStrategy.signalAllWhenBlockingCalls, is(1));[m
[31m-    }[m
[31m-[m
[31m-[m
[31m-    @ParameterizedTest[m
[31m-    @MethodSource("sequencerGenerator")[m
[31m-    public void shouldWaitOnPublication(Sequencer sequencer) throws Exception[m
[31m-    {[m
[31m-        SequenceBarrier barrier = sequencer.newBarrier();[m
[31m-[m
[31m-        long next = sequencer.next(10);[m
[31m-        long lo = next - (10 - 1);[m
[31m-        long mid = next - 5;[m
[31m-[m
[31m-        for (long l = lo; l < mid; l++)[m
[31m-        {[m
[31m-            sequencer.publish(l);[m
[31m-        }[m
[31m-[m
[31m-        assertThat(barrier.waitFor(-1), is(mid - 1));[m
[31m-[m
[31m-        for (long l = mid; l <= next; l++)[m
[31m-        {[m
[31m-            sequencer.publish(l);[m
[31m-        }[m
[31m-[m
[31m-        assertThat(barrier.waitFor(-1), is(next));[m
[31m-    }[m
[31m-[m
[31m-    @ParameterizedTest[m
[31m-    @MethodSource("sequencerGenerator")[m
[31m-    public void shouldTryNext(Sequencer sequencer) throws Exception[m
[31m-    {[m
[31m-        sequencer.addGatingSequences(gatingSequence);[m
[31m-[m
[31m-        for (int i = 0; i < BUFFER_SIZE; i++)[m
[31m-        {[m
[31m-            sequencer.publish(sequencer.tryNext());[m
[31m-        }[m
[31m-[m
[31m-        try[m
[31m-        {[m
[31m-            sequencer.tryNext();[m
[31m-            fail("Should of thrown: " + InsufficientCapacityException.class.getSimpleName());[m
[31m-        }[m
[31m-        catch (InsufficientCapacityException e)[m
[31m-        {[m
[31m-            // No-op[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @ParameterizedTest[m
[31m-    @MethodSource("sequencerGenerator")[m
[31m-    public void shouldClaimSpecificSequence(Sequencer sequencer) throws Exception[m
[31m-    {[m
[31m-        long sequence = 14L;[m
[31m-[m
[31m-        sequencer.claim(sequence);[m
[31m-        sequencer.publish(sequence);[m
[31m-        assertThat(sequencer.next(), is(sequence + 1));[m
[31m-    }[m
[31m-[m
[31m-    @ParameterizedTest[m
[31m-    @MethodSource("sequencerGenerator")[m
[31m-    public void shouldNotAllowBulkNextLessThanZero(Sequencer sequencer) throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () -> sequencer.next(-1));[m
[31m-    }[m
[31m-[m
[31m-    @ParameterizedTest[m
[31m-    @MethodSource("sequencerGenerator")[m
[31m-    public void shouldNotAllowBulkNextOfZero(Sequencer sequencer) throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () -> sequencer.next(0));[m
[31m-    }[m
[31m-[m
[31m-    @ParameterizedTest[m
[31m-    @MethodSource("sequencerGenerator")[m
[31m-    public void shouldNotAllowBulkTryNextLessThanZero(Sequencer sequencer) throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () -> sequencer.tryNext(-1));[m
[31m-    }[m
[31m-[m
[31m-    @ParameterizedTest[m
[31m-    @MethodSource("sequencerGenerator")[m
[31m-    public void shouldNotAllowBulkTryNextOfZero(Sequencer sequencer) throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () -> sequencer.tryNext(0));[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/ShutdownOnFatalExceptionTest.java b/src/test/java/com/lmax/disruptor/ShutdownOnFatalExceptionTest.java[m
[1mdeleted file mode 100644[m
[1mindex 0e64fac..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/ShutdownOnFatalExceptionTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,103 +0,0 @@[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import com.lmax.disruptor.dsl.Disruptor;[m
[31m-import com.lmax.disruptor.dsl.ProducerType;[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-import org.junit.jupiter.api.AfterEach;[m
[31m-import org.junit.jupiter.api.BeforeEach;[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-import org.junit.jupiter.api.Timeout;[m
[31m-[m
[31m-import java.util.Random;[m
[31m-import java.util.concurrent.TimeUnit;[m
[31m-[m
[31m-public class ShutdownOnFatalExceptionTest[m
[31m-{[m
[31m-[m
[31m-    private final Random random = new Random();[m
[31m-[m
[31m-    private final FailingEventHandler eventHandler = new FailingEventHandler();[m
[31m-[m
[31m-    private Disruptor<byte[]> disruptor;[m
[31m-[m
[31m-    @SuppressWarnings("unchecked")[m
[31m-    @BeforeEach[m
[31m-    public void setUp()[m
[31m-    {[m
[31m-        disruptor = new Disruptor<>([m
[31m-                new ByteArrayFactory(256), 1024, DaemonThreadFactory.INSTANCE, ProducerType.SINGLE,[m
[31m-                new BlockingWaitStrategy());[m
[31m-        disruptor.handleEventsWith(eventHandler);[m
[31m-        disruptor.setDefaultExceptionHandler(new FatalExceptionHandler());[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    @Timeout(value = 1000, unit = TimeUnit.MILLISECONDS)[m
[31m-    public void shouldShutdownGracefulEvenWithFatalExceptionHandler()[m
[31m-    {[m
[31m-        disruptor.start();[m
[31m-[m
[31m-        byte[] bytes;[m
[31m-        for (int i = 1; i < 10; i++)[m
[31m-        {[m
[31m-            bytes = new byte[32];[m
[31m-            random.nextBytes(bytes);[m
[31m-            disruptor.publishEvent(new ByteArrayTranslator(bytes));[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @AfterEach[m
[31m-    public void tearDown()[m
[31m-    {[m
[31m-        disruptor.shutdown();[m
[31m-    }[m
[31m-[m
[31m-    private static class ByteArrayTranslator implements EventTranslator<byte[]>[m
[31m-    {[m
[31m-[m
[31m-        private final byte[] bytes;[m
[31m-[m
[31m-        ByteArrayTranslator(byte[] bytes)[m
[31m-        {[m
[31m-            this.bytes = bytes;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void translateTo(byte[] event, long sequence)[m
[31m-        {[m
[31m-            System.arraycopy(bytes, 0, event, 0, bytes.length);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class FailingEventHandler implements EventHandler<byte[]>[m
[31m-    {[m
[31m-        private int count = 0;[m
[31m-[m
[31m-        @Override[m
[31m-        public void onEvent(byte[] event, long sequence, boolean endOfBatch) throws Exception[m
[31m-        {[m
[31m-            // some logging[m
[31m-            count++;[m
[31m-            if (count == 3)[m
[31m-            {[m
[31m-                throw new IllegalStateException();[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static class ByteArrayFactory implements EventFactory<byte[]>[m
[31m-    {[m
[31m-        private int eventSize;[m
[31m-[m
[31m-        ByteArrayFactory(int eventSize)[m
[31m-        {[m
[31m-            this.eventSize = eventSize;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public byte[] newInstance()[m
[31m-        {[m
[31m-            return new byte[eventSize];[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/SingleProducerSequencerTest.java b/src/test/java/com/lmax/disruptor/SingleProducerSequencerTest.java[m
[1mdeleted file mode 100644[m
[1mindex e4c13b8..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/SingleProducerSequencerTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,26 +0,0 @@[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import static org.hamcrest.MatcherAssert.assertThat;[m
[31m-import static org.hamcrest.core.IsNot.not;[m
[31m-[m
[31m-public class SingleProducerSequencerTest[m
[31m-{[m
[31m-    @Test[m
[31m-    public void shouldNotUpdateCursorDuringHasAvailableCapacity() throws Exception[m
[31m-    {[m
[31m-        SingleProducerSequencer sequencer = new SingleProducerSequencer(16, new BusySpinWaitStrategy());[m
[31m-[m
[31m-        for (int i = 0; i < 32; i++)[m
[31m-        {[m
[31m-            long next = sequencer.next();[m
[31m-            assertThat(sequencer.cursor.get(), not(next));[m
[31m-[m
[31m-            sequencer.hasAvailableCapacity(13);[m
[31m-            assertThat(sequencer.cursor.get(), not(next));[m
[31m-[m
[31m-            sequencer.publish(next);[m
[31m-        }[m
[31m-    }[m
[31m-}[m
\ No newline at end of file[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/SleepingWaitStrategyTest.java b/src/test/java/com/lmax/disruptor/SleepingWaitStrategyTest.java[m
[1mdeleted file mode 100644[m
[1mindex b9aa09b..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/SleepingWaitStrategyTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,30 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2012 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import static com.lmax.disruptor.support.WaitStrategyTestUtil.assertWaitForWithDelayOf;[m
[31m-[m
[31m-[m
[31m-public class SleepingWaitStrategyTest[m
[31m-{[m
[31m-    @Test[m
[31m-    public void shouldWaitForValue() throws Exception[m
[31m-    {[m
[31m-        assertWaitForWithDelayOf(50, new SleepingWaitStrategy());[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/TimeoutBlockingWaitStrategyTest.java b/src/test/java/com/lmax/disruptor/TimeoutBlockingWaitStrategyTest.java[m
[1mdeleted file mode 100644[m
[1mindex 8c3d97e..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/TimeoutBlockingWaitStrategyTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,41 +0,0 @@[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import com.lmax.disruptor.support.DummySequenceBarrier;[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import java.util.concurrent.TimeUnit;[m
[31m-[m
[31m-import static org.junit.jupiter.api.Assertions.assertTrue;[m
[31m-import static org.junit.jupiter.api.Assertions.fail;[m
[31m-[m
[31m-[m
[31m-public class TimeoutBlockingWaitStrategyTest[m
[31m-{[m
[31m-    @Test[m
[31m-    public void shouldTimeoutWaitFor() throws Exception[m
[31m-    {[m
[31m-        final SequenceBarrier sequenceBarrier = new DummySequenceBarrier();[m
[31m-[m
[31m-        long theTimeout = 500;[m
[31m-        TimeoutBlockingWaitStrategy waitStrategy = new TimeoutBlockingWaitStrategy(theTimeout, TimeUnit.MILLISECONDS);[m
[31m-        Sequence cursor = new Sequence(5);[m
[31m-        Sequence dependent = cursor;[m
[31m-[m
[31m-        long t0 = System.currentTimeMillis();[m
[31m-[m
[31m-        try[m
[31m-        {[m
[31m-            waitStrategy.waitFor(6, cursor, dependent, sequenceBarrier);[m
[31m-            fail("TimeoutException should have been thrown");[m
[31m-        }[m
[31m-        catch (TimeoutException e)[m
[31m-        {[m
[31m-        }[m
[31m-[m
[31m-        long t1 = System.currentTimeMillis();[m
[31m-[m
[31m-        long timeWaiting = t1 - t0;[m
[31m-[m
[31m-        assertTrue(timeWaiting >= theTimeout);[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/YieldingWaitStrategyTest.java b/src/test/java/com/lmax/disruptor/YieldingWaitStrategyTest.java[m
[1mdeleted file mode 100644[m
[1mindex 6038a2a..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/YieldingWaitStrategyTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,30 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2012 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor;[m
[31m-[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import static com.lmax.disruptor.support.WaitStrategyTestUtil.assertWaitForWithDelayOf;[m
[31m-[m
[31m-public class YieldingWaitStrategyTest[m
[31m-{[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldWaitForValue() throws Exception[m
[31m-    {[m
[31m-        assertWaitForWithDelayOf(50, new YieldingWaitStrategy());[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/dsl/ConsumerRepositoryTest.java b/src/test/java/com/lmax/disruptor/dsl/ConsumerRepositoryTest.java[m
[1mdeleted file mode 100644[m
[1mindex 2b403e8..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/dsl/ConsumerRepositoryTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,138 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.dsl;[m
[31m-[m
[31m-import com.lmax.disruptor.EventProcessor;[m
[31m-import com.lmax.disruptor.Sequence;[m
[31m-import com.lmax.disruptor.SequenceBarrier;[m
[31m-import com.lmax.disruptor.dsl.stubs.SleepingEventHandler;[m
[31m-import com.lmax.disruptor.support.DummyEventProcessor;[m
[31m-import com.lmax.disruptor.support.DummySequenceBarrier;[m
[31m-import com.lmax.disruptor.support.TestEvent;[m
[31m-import org.junit.jupiter.api.BeforeEach;[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import static org.hamcrest.CoreMatchers.equalTo;[m
[31m-import static org.hamcrest.CoreMatchers.is;[m
[31m-import static org.hamcrest.CoreMatchers.nullValue;[m
[31m-import static org.hamcrest.CoreMatchers.sameInstance;[m
[31m-import static org.hamcrest.MatcherAssert.assertThat;[m
[31m-import static org.junit.jupiter.api.Assertions.assertThrows;[m
[31m-import static org.junit.jupiter.api.Assertions.assertTrue;[m
[31m-import static org.junit.jupiter.api.Assertions.fail;[m
[31m-[m
[31m-public class ConsumerRepositoryTest[m
[31m-{[m
[31m-    private ConsumerRepository<TestEvent> consumerRepository;[m
[31m-    private EventProcessor eventProcessor1;[m
[31m-    private EventProcessor eventProcessor2;[m
[31m-    private SleepingEventHandler handler1;[m
[31m-    private SleepingEventHandler handler2;[m
[31m-    private SequenceBarrier barrier1;[m
[31m-    private SequenceBarrier barrier2;[m
[31m-[m
[31m-    @BeforeEach[m
[31m-    public void setUp() throws Exception[m
[31m-    {[m
[31m-        consumerRepository = new ConsumerRepository<>();[m
[31m-        eventProcessor1 = new DummyEventProcessor(new Sequence());[m
[31m-        eventProcessor2 = new DummyEventProcessor(new Sequence());[m
[31m-[m
[31m-        eventProcessor1.run();[m
[31m-        eventProcessor2.run();[m
[31m-[m
[31m-        handler1 = new SleepingEventHandler();[m
[31m-        handler2 = new SleepingEventHandler();[m
[31m-[m
[31m-        barrier1 = new DummySequenceBarrier();[m
[31m-        barrier2 = new DummySequenceBarrier();[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldGetBarrierByHandler() throws Exception[m
[31m-    {[m
[31m-        consumerRepository.add(eventProcessor1, handler1, barrier1);[m
[31m-[m
[31m-        assertThat(consumerRepository.getBarrierFor(handler1), sameInstance(barrier1));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldReturnNullForBarrierWhenHandlerIsNotRegistered() throws Exception[m
[31m-    {[m
[31m-        assertThat(consumerRepository.getBarrierFor(handler1), is(nullValue()));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldGetLastEventProcessorsInChain() throws Exception[m
[31m-    {[m
[31m-        consumerRepository.add(eventProcessor1, handler1, barrier1);[m
[31m-        consumerRepository.add(eventProcessor2, handler2, barrier2);[m
[31m-[m
[31m-        consumerRepository.unMarkEventProcessorsAsEndOfChain(eventProcessor2.getSequence());[m
[31m-[m
[31m-[m
[31m-        final Sequence[] lastEventProcessorsInChain = consumerRepository.getLastSequenceInChain(true);[m
[31m-        assertThat(lastEventProcessorsInChain.length, equalTo(1));[m
[31m-        assertThat(lastEventProcessorsInChain[0], sameInstance(eventProcessor1.getSequence()));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldRetrieveEventProcessorForHandler() throws Exception[m
[31m-    {[m
[31m-        consumerRepository.add(eventProcessor1, handler1, barrier1);[m
[31m-[m
[31m-        assertThat(consumerRepository.getEventProcessorFor(handler1), sameInstance(eventProcessor1));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldThrowExceptionWhenHandlerIsNotRegistered() throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-                consumerRepository.getEventProcessorFor(new SleepingEventHandler())[m
[31m-        );[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldIterateAllEventProcessors() throws Exception[m
[31m-    {[m
[31m-        consumerRepository.add(eventProcessor1, handler1, barrier1);[m
[31m-        consumerRepository.add(eventProcessor2, handler2, barrier2);[m
[31m-[m
[31m-        boolean seen1 = false;[m
[31m-        boolean seen2 = false;[m
[31m-        for (ConsumerInfo testEntryEventProcessorInfo : consumerRepository)[m
[31m-        {[m
[31m-            final EventProcessorInfo<?> eventProcessorInfo = (EventProcessorInfo<?>) testEntryEventProcessorInfo;[m
[31m-            if (!seen1 && eventProcessorInfo.getEventProcessor() == eventProcessor1 &&[m
[31m-                eventProcessorInfo.getHandler() == handler1)[m
[31m-            {[m
[31m-                seen1 = true;[m
[31m-            }[m
[31m-            else if (!seen2 && eventProcessorInfo.getEventProcessor() == eventProcessor2 &&[m
[31m-                eventProcessorInfo.getHandler() == handler2)[m
[31m-            {[m
[31m-                seen2 = true;[m
[31m-            }[m
[31m-            else[m
[31m-            {[m
[31m-                fail("Unexpected eventProcessor info: " + testEntryEventProcessorInfo);[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        assertTrue(seen1, "Included eventProcessor 1");[m
[31m-        assertTrue(seen2, "Included eventProcessor 2");[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/dsl/DisruptorTest.java b/src/test/java/com/lmax/disruptor/dsl/DisruptorTest.java[m
[1mdeleted file mode 100644[m
[1mindex 56c5a85..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/dsl/DisruptorTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,730 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.dsl;[m
[31m-[m
[31m-import com.lmax.disruptor.BatchEventProcessor;[m
[31m-import com.lmax.disruptor.BlockingWaitStrategy;[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.ExceptionHandler;[m
[31m-import com.lmax.disruptor.FatalExceptionHandler;[m
[31m-import com.lmax.disruptor.RingBuffer;[m
[31m-import com.lmax.disruptor.SequenceBarrier;[m
[31m-import com.lmax.disruptor.TimeoutException;[m
[31m-import com.lmax.disruptor.dsl.stubs.DelayedEventHandler;[m
[31m-import com.lmax.disruptor.dsl.stubs.EventHandlerStub;[m
[31m-import com.lmax.disruptor.dsl.stubs.EvilEqualsEventHandler;[m
[31m-import com.lmax.disruptor.dsl.stubs.ExceptionThrowingEventHandler;[m
[31m-import com.lmax.disruptor.dsl.stubs.SleepingEventHandler;[m
[31m-import com.lmax.disruptor.dsl.stubs.StubExceptionHandler;[m
[31m-import com.lmax.disruptor.dsl.stubs.StubPublisher;[m
[31m-import com.lmax.disruptor.dsl.stubs.StubThreadFactory;[m
[31m-import com.lmax.disruptor.support.TestEvent;[m
[31m-import org.junit.jupiter.api.AfterEach;[m
[31m-import org.junit.jupiter.api.BeforeEach;[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-import org.junit.jupiter.api.Timeout;[m
[31m-[m
[31m-import java.util.ArrayList;[m
[31m-import java.util.Collection;[m
[31m-import java.util.concurrent.BrokenBarrierException;[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-import java.util.concurrent.TimeUnit;[m
[31m-import java.util.concurrent.atomic.AtomicReference;[m
[31m-[m
[31m-import static java.lang.Thread.yield;[m
[31m-import static java.util.concurrent.TimeUnit.SECONDS;[m
[31m-import static org.hamcrest.CoreMatchers.equalTo;[m
[31m-import static org.hamcrest.CoreMatchers.is;[m
[31m-import static org.hamcrest.MatcherAssert.assertThat;[m
[31m-import static org.junit.jupiter.api.Assertions.assertEquals;[m
[31m-import static org.junit.jupiter.api.Assertions.assertNotNull;[m
[31m-import static org.junit.jupiter.api.Assertions.assertSame;[m
[31m-import static org.junit.jupiter.api.Assertions.assertThrows;[m
[31m-import static org.junit.jupiter.api.Assertions.assertTrue;[m
[31m-import static org.junit.jupiter.api.Assertions.fail;[m
[31m-[m
[31m-@SuppressWarnings(value = {"unchecked"})[m
[31m-public class DisruptorTest[m
[31m-{[m
[31m-    private static final int TIMEOUT_IN_SECONDS = 2;[m
[31m-[m
[31m-    public final StubThreadFactory executor = new StubThreadFactory();[m
[31m-[m
[31m-    private final Collection<DelayedEventHandler> delayedEventHandlers = new ArrayList<>();[m
[31m-    private Disruptor<TestEvent> disruptor;[m
[31m-    private RingBuffer<TestEvent> ringBuffer;[m
[31m-    private TestEvent lastPublishedEvent;[m
[31m-[m
[31m-    @BeforeEach[m
[31m-    public void setUp() throws Exception[m
[31m-    {[m
[31m-        createDisruptor();[m
[31m-    }[m
[31m-[m
[31m-    @AfterEach[m
[31m-    public void tearDown() throws Exception[m
[31m-    {[m
[31m-        for (DelayedEventHandler delayedEventHandler : delayedEventHandlers)[m
[31m-        {[m
[31m-            delayedEventHandler.stopWaiting();[m
[31m-        }[m
[31m-[m
[31m-        disruptor.halt();[m
[31m-        executor.joinAllThreads();[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldProcessMessagesPublishedBeforeStartIsCalled() throws Exception[m
[31m-    {[m
[31m-        final CountDownLatch eventCounter = new CountDownLatch(2);[m
[31m-        disruptor.handleEventsWith((event, sequence, endOfBatch) -> eventCounter.countDown());[m
[31m-[m
[31m-        disruptor.publishEvent((event, sequence) -> lastPublishedEvent = event);[m
[31m-[m
[31m-        disruptor.start();[m
[31m-[m
[31m-        disruptor.publishEvent((event, sequence) -> lastPublishedEvent = event);[m
[31m-[m
[31m-        if (!eventCounter.await(5, TimeUnit.SECONDS))[m
[31m-        {[m
[31m-            fail("Did not process event published before start was called. Missed events: " + eventCounter.getCount());[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldBatchOfEvents() throws Exception[m
[31m-    {[m
[31m-        final CountDownLatch eventCounter = new CountDownLatch(2);[m
[31m-        disruptor.handleEventsWith((event, sequence, endOfBatch) -> eventCounter.countDown());[m
[31m-[m
[31m-        disruptor.start();[m
[31m-[m
[31m-        disruptor.publishEvents((event, sequence, arg) -> lastPublishedEvent = event, new Object[] { "a", "b" });[m
[31m-[m
[31m-        if (!eventCounter.await(5, TimeUnit.SECONDS))[m
[31m-        {[m
[31m-            fail("Did not process event published before start was called. Missed events: " + eventCounter.getCount());[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldAddEventProcessorsAfterPublishing() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<TestEvent> rb = disruptor.getRingBuffer();[m
[31m-        BatchEventProcessor<TestEvent> b1 = new BatchEventProcessor<>([m
[31m-                rb, rb.newBarrier(), new SleepingEventHandler());[m
[31m-        BatchEventProcessor<TestEvent> b2 = new BatchEventProcessor<>([m
[31m-                rb, rb.newBarrier(b1.getSequence()), new SleepingEventHandler());[m
[31m-        BatchEventProcessor<TestEvent> b3 = new BatchEventProcessor<>([m
[31m-                rb, rb.newBarrier(b2.getSequence()), new SleepingEventHandler());[m
[31m-[m
[31m-        assertThat(b1.getSequence().get(), is(-1L));[m
[31m-        assertThat(b2.getSequence().get(), is(-1L));[m
[31m-        assertThat(b3.getSequence().get(), is(-1L));[m
[31m-[m
[31m-        rb.publish(rb.next());[m
[31m-        rb.publish(rb.next());[m
[31m-        rb.publish(rb.next());[m
[31m-        rb.publish(rb.next());[m
[31m-        rb.publish(rb.next());[m
[31m-        rb.publish(rb.next());[m
[31m-[m
[31m-        disruptor.handleEventsWith(b1, b2, b3);[m
[31m-[m
[31m-        assertThat(b1.getSequence().get(), is(5L));[m
[31m-        assertThat(b2.getSequence().get(), is(5L));[m
[31m-        assertThat(b3.getSequence().get(), is(5L));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldSetSequenceForHandlerIfAddedAfterPublish() throws Exception[m
[31m-    {[m
[31m-        RingBuffer<TestEvent> rb = disruptor.getRingBuffer();[m
[31m-        EventHandler<TestEvent> b1 = new SleepingEventHandler();[m
[31m-        EventHandler<TestEvent> b2 = new SleepingEventHandler();[m
[31m-        EventHandler<TestEvent> b3 = new SleepingEventHandler();[m
[31m-[m
[31m-        rb.publish(rb.next());[m
[31m-        rb.publish(rb.next());[m
[31m-        rb.publish(rb.next());[m
[31m-        rb.publish(rb.next());[m
[31m-        rb.publish(rb.next());[m
[31m-        rb.publish(rb.next());[m
[31m-[m
[31m-        disruptor.handleEventsWith(b1, b2, b3);[m
[31m-[m
[31m-        assertThat(disruptor.getSequenceValueFor(b1), is(5L));[m
[31m-        assertThat(disruptor.getSequenceValueFor(b2), is(5L));[m
[31m-        assertThat(disruptor.getSequenceValueFor(b3), is(5L));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldCreateEventProcessorGroupForFirstEventProcessors()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        executor.ignoreExecutions();[m
[31m-        final EventHandler<TestEvent> eventHandler1 = new SleepingEventHandler();[m
[31m-        EventHandler<TestEvent> eventHandler2 = new SleepingEventHandler();[m
[31m-[m
[31m-        final EventHandlerGroup<TestEvent> eventHandlerGroup =[m
[31m-            disruptor.handleEventsWith(eventHandler1, eventHandler2);[m
[31m-        disruptor.start();[m
[31m-[m
[31m-        assertNotNull(eventHandlerGroup);[m
[31m-        assertThat(executor.getExecutionCount(), equalTo(2));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldMakeEntriesAvailableToFirstHandlersImmediately() throws Exception[m
[31m-    {[m
[31m-        CountDownLatch countDownLatch = new CountDownLatch(2);[m
[31m-        EventHandler<TestEvent> eventHandler = new EventHandlerStub<>(countDownLatch);[m
[31m-[m
[31m-        disruptor.handleEventsWith(createDelayedEventHandler(), eventHandler);[m
[31m-[m
[31m-        ensureTwoEventsProcessedAccordingToDependencies(countDownLatch);[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldWaitUntilAllFirstEventProcessorsProcessEventBeforeMakingItAvailableToDependentEventProcessors()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        DelayedEventHandler eventHandler1 = createDelayedEventHandler();[m
[31m-[m
[31m-        CountDownLatch countDownLatch = new CountDownLatch(2);[m
[31m-        EventHandler<TestEvent> eventHandler2 = new EventHandlerStub<>(countDownLatch);[m
[31m-[m
[31m-        disruptor.handleEventsWith(eventHandler1).then(eventHandler2);[m
[31m-[m
[31m-        ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, eventHandler1);[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldSupportAddingCustomEventProcessorWithFactory()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        RingBuffer<TestEvent> rb = disruptor.getRingBuffer();[m
[31m-        BatchEventProcessor<TestEvent> b1 = new BatchEventProcessor<>([m
[31m-                rb, rb.newBarrier(), new SleepingEventHandler());[m
[31m-        EventProcessorFactory<TestEvent> b2 = (ringBuffer, barrierSequences) -> new BatchEventProcessor<>([m
[31m-                ringBuffer, ringBuffer.newBarrier(barrierSequences), new SleepingEventHandler());[m
[31m-[m
[31m-        disruptor.handleEventsWith(b1).then(b2);[m
[31m-[m
[31m-        disruptor.start();[m
[31m-[m
[31m-        assertThat(executor.getExecutionCount(), equalTo(2));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldAllowSpecifyingSpecificEventProcessorsToWaitFor()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        DelayedEventHandler handler1 = createDelayedEventHandler();[m
[31m-        DelayedEventHandler handler2 = createDelayedEventHandler();[m
[31m-[m
[31m-        CountDownLatch countDownLatch = new CountDownLatch(2);[m
[31m-        EventHandler<TestEvent> handlerWithBarrier = new EventHandlerStub<>(countDownLatch);[m
[31m-[m
[31m-        disruptor.handleEventsWith(handler1, handler2);[m
[31m-        disruptor.after(handler1, handler2).handleEventsWith(handlerWithBarrier);[m
[31m-[m
[31m-        ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, handler1, handler2);[m
[31m-[m
[31m-        assertThat(executor.getExecutionCount(), equalTo(3));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldWaitOnAllProducersJoinedByAnd()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        DelayedEventHandler handler1 = createDelayedEventHandler();[m
[31m-        DelayedEventHandler handler2 = createDelayedEventHandler();[m
[31m-[m
[31m-        CountDownLatch countDownLatch = new CountDownLatch(2);[m
[31m-        EventHandler<TestEvent> handlerWithBarrier = new EventHandlerStub<>(countDownLatch);[m
[31m-[m
[31m-        disruptor.handleEventsWith(handler1);[m
[31m-        final EventHandlerGroup<TestEvent> handler2Group = disruptor.handleEventsWith(handler2);[m
[31m-        disruptor.after(handler1).and(handler2Group).handleEventsWith(handlerWithBarrier);[m
[31m-[m
[31m-        ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, handler1, handler2);[m
[31m-[m
[31m-        assertThat(executor.getExecutionCount(), equalTo(3));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldThrowExceptionIfHandlerIsNotAlreadyConsuming()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-                disruptor.after(createDelayedEventHandler()).handleEventsWith(createDelayedEventHandler()));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldTrackEventHandlersByIdentityNotEquality()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalArgumentException.class, () ->[m
[31m-        {[m
[31m-            EvilEqualsEventHandler handler1 = new EvilEqualsEventHandler();[m
[31m-            EvilEqualsEventHandler handler2 = new EvilEqualsEventHandler();[m
[31m-[m
[31m-            disruptor.handleEventsWith(handler1);[m
[31m-[m
[31m-            // handler2.equals(handler1) but it hasn't yet been registered so should throw exception.[m
[31m-            disruptor.after(handler2);[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @SuppressWarnings("deprecation")[m
[31m-    @Test[m
[31m-    public void shouldSupportSpecifyingAExceptionHandlerForEventProcessors()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        AtomicReference<Throwable> eventHandled = new AtomicReference<>();[m
[31m-        ExceptionHandler exceptionHandler = new StubExceptionHandler(eventHandled);[m
[31m-        RuntimeException testException = new RuntimeException();[m
[31m-        ExceptionThrowingEventHandler handler = new ExceptionThrowingEventHandler(testException);[m
[31m-[m
[31m-        disruptor.handleExceptionsWith(exceptionHandler);[m
[31m-        disruptor.handleEventsWith(handler);[m
[31m-[m
[31m-        publishEvent();[m
[31m-[m
[31m-        final Throwable actualException = waitFor(eventHandled);[m
[31m-        assertSame(testException, actualException);[m
[31m-    }[m
[31m-[m
[31m-    @SuppressWarnings("deprecation")[m
[31m-    @Test[m
[31m-    public void shouldOnlyApplyExceptionsHandlersSpecifiedViaHandleExceptionsWithOnNewEventProcessors()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        AtomicReference<Throwable> eventHandled = new AtomicReference<>();[m
[31m-        ExceptionHandler exceptionHandler = new StubExceptionHandler(eventHandled);[m
[31m-        RuntimeException testException = new RuntimeException();[m
[31m-        ExceptionThrowingEventHandler handler = new ExceptionThrowingEventHandler(testException);[m
[31m-[m
[31m-        disruptor.handleExceptionsWith(exceptionHandler);[m
[31m-        disruptor.handleEventsWith(handler);[m
[31m-        disruptor.handleExceptionsWith(new FatalExceptionHandler());[m
[31m-[m
[31m-        publishEvent();[m
[31m-[m
[31m-        final Throwable actualException = waitFor(eventHandled);[m
[31m-        assertSame(testException, actualException);[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldSupportSpecifyingADefaultExceptionHandlerForEventProcessors()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        AtomicReference<Throwable> eventHandled = new AtomicReference<>();[m
[31m-        ExceptionHandler exceptionHandler = new StubExceptionHandler(eventHandled);[m
[31m-        RuntimeException testException = new RuntimeException();[m
[31m-        ExceptionThrowingEventHandler handler = new ExceptionThrowingEventHandler(testException);[m
[31m-[m
[31m-        disruptor.setDefaultExceptionHandler(exceptionHandler);[m
[31m-        disruptor.handleEventsWith(handler);[m
[31m-[m
[31m-        publishEvent();[m
[31m-[m
[31m-        final Throwable actualException = waitFor(eventHandled);[m
[31m-        assertSame(testException, actualException);[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldApplyDefaultExceptionHandlerToExistingEventProcessors()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        AtomicReference<Throwable> eventHandled = new AtomicReference<>();[m
[31m-        ExceptionHandler exceptionHandler = new StubExceptionHandler(eventHandled);[m
[31m-        RuntimeException testException = new RuntimeException();[m
[31m-        ExceptionThrowingEventHandler handler = new ExceptionThrowingEventHandler(testException);[m
[31m-[m
[31m-        disruptor.handleEventsWith(handler);[m
[31m-        disruptor.setDefaultExceptionHandler(exceptionHandler);[m
[31m-[m
[31m-        publishEvent();[m
[31m-[m
[31m-        final Throwable actualException = waitFor(eventHandled);[m
[31m-        assertSame(testException, actualException);[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldBlockProducerUntilAllEventProcessorsHaveAdvanced()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        final DelayedEventHandler delayedEventHandler = createDelayedEventHandler();[m
[31m-        disruptor.handleEventsWith(delayedEventHandler);[m
[31m-[m
[31m-        final RingBuffer<TestEvent> ringBuffer = disruptor.start();[m
[31m-        delayedEventHandler.awaitStart();[m
[31m-[m
[31m-        final StubPublisher stubPublisher = new StubPublisher(ringBuffer);[m
[31m-        try[m
[31m-        {[m
[31m-            executor.newThread(stubPublisher).start();[m
[31m-[m
[31m-            assertProducerReaches(stubPublisher, 4, true);[m
[31m-[m
[31m-            delayedEventHandler.processEvent();[m
[31m-            delayedEventHandler.processEvent();[m
[31m-            delayedEventHandler.processEvent();[m
[31m-            delayedEventHandler.processEvent();[m
[31m-            delayedEventHandler.processEvent();[m
[31m-[m
[31m-            assertProducerReaches(stubPublisher, 5, false);[m
[31m-        }[m
[31m-        finally[m
[31m-        {[m
[31m-            stubPublisher.halt();[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldBeAbleToOverrideTheExceptionHandlerForAEventProcessor()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        final RuntimeException testException = new RuntimeException();[m
[31m-        final ExceptionThrowingEventHandler eventHandler = new ExceptionThrowingEventHandler(testException);[m
[31m-        disruptor.handleEventsWith(eventHandler);[m
[31m-[m
[31m-        AtomicReference<Throwable> reference = new AtomicReference<>();[m
[31m-        StubExceptionHandler exceptionHandler = new StubExceptionHandler(reference);[m
[31m-        disruptor.handleExceptionsFor(eventHandler).with(exceptionHandler);[m
[31m-[m
[31m-        publishEvent();[m
[31m-[m
[31m-        waitFor(reference);[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldThrowExceptionWhenAddingEventProcessorsAfterTheProducerBarrierHasBeenCreated()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalStateException.class, () ->[m
[31m-        {[m
[31m-            executor.ignoreExecutions();[m
[31m-            disruptor.handleEventsWith(new SleepingEventHandler());[m
[31m-            disruptor.start();[m
[31m-            disruptor.handleEventsWith(new SleepingEventHandler());[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldThrowExceptionIfStartIsCalledTwice()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        assertThrows(IllegalStateException.class, () ->[m
[31m-        {[m
[31m-            executor.ignoreExecutions();[m
[31m-            disruptor.handleEventsWith(new SleepingEventHandler());[m
[31m-            disruptor.start();[m
[31m-            disruptor.start();[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldSupportCustomProcessorsAsDependencies()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        RingBuffer<TestEvent> ringBuffer = disruptor.getRingBuffer();[m
[31m-[m
[31m-        final DelayedEventHandler delayedEventHandler = createDelayedEventHandler();[m
[31m-[m
[31m-        CountDownLatch countDownLatch = new CountDownLatch(2);[m
[31m-        EventHandler<TestEvent> handlerWithBarrier = new EventHandlerStub<>(countDownLatch);[m
[31m-[m
[31m-        final BatchEventProcessor<TestEvent> processor =[m
[31m-                new BatchEventProcessor<>(ringBuffer, ringBuffer.newBarrier(), delayedEventHandler);[m
[31m-[m
[31m-        disruptor.handleEventsWith(processor).then(handlerWithBarrier);[m
[31m-[m
[31m-        ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, delayedEventHandler);[m
[31m-[m
[31m-        assertThat(executor.getExecutionCount(), equalTo(2));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldSupportHandlersAsDependenciesToCustomProcessors()[m
[31m-        throws Exception[m
[31m-    {[m
[31m-        final DelayedEventHandler delayedEventHandler = createDelayedEventHandler();[m
[31m-        disruptor.handleEventsWith(delayedEventHandler);[m
[31m-[m
[31m-[m
[31m-        RingBuffer<TestEvent> ringBuffer = disruptor.getRingBuffer();[m
[31m-        CountDownLatch countDownLatch = new CountDownLatch(2);[m
[31m-        EventHandler<TestEvent> handlerWithBarrier = new EventHandlerStub<>(countDownLatch);[m
[31m-[m
[31m-        final SequenceBarrier sequenceBarrier = disruptor.after(delayedEventHandler).asSequenceBarrier();[m
[31m-        final BatchEventProcessor<TestEvent> processor =[m
[31m-                new BatchEventProcessor<>(ringBuffer, sequenceBarrier, handlerWithBarrier);[m
[31m-        disruptor.handleEventsWith(processor);[m
[31m-[m
[31m-        ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, delayedEventHandler);[m
[31m-[m
[31m-        assertThat(executor.getExecutionCount(), equalTo(2));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldSupportCustomProcessorsAndHandlersAsDependencies() throws Exception[m
[31m-    {[m
[31m-        final DelayedEventHandler delayedEventHandler1 = createDelayedEventHandler();[m
[31m-        final DelayedEventHandler delayedEventHandler2 = createDelayedEventHandler();[m
[31m-        disruptor.handleEventsWith(delayedEventHandler1);[m
[31m-[m
[31m-[m
[31m-        RingBuffer<TestEvent> ringBuffer = disruptor.getRingBuffer();[m
[31m-        CountDownLatch countDownLatch = new CountDownLatch(2);[m
[31m-        EventHandler<TestEvent> handlerWithBarrier = new EventHandlerStub<>(countDownLatch);[m
[31m-[m
[31m-        final SequenceBarrier sequenceBarrier = disruptor.after(delayedEventHandler1).asSequenceBarrier();[m
[31m-        final BatchEventProcessor<TestEvent> processor =[m
[31m-                new BatchEventProcessor<>(ringBuffer, sequenceBarrier, delayedEventHandler2);[m
[31m-[m
[31m-        disruptor.after(delayedEventHandler1).and(processor).handleEventsWith(handlerWithBarrier);[m
[31m-[m
[31m-        ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, delayedEventHandler1, delayedEventHandler2);[m
[31m-[m
[31m-        assertThat(executor.getExecutionCount(), equalTo(3));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldSupportMultipleCustomProcessorsAsDependencies() throws Exception[m
[31m-    {[m
[31m-        final RingBuffer<TestEvent> ringBuffer = disruptor.getRingBuffer();[m
[31m-        final CountDownLatch countDownLatch = new CountDownLatch(2);[m
[31m-        final EventHandler<TestEvent> handlerWithBarrier = new EventHandlerStub<>(countDownLatch);[m
[31m-[m
[31m-        final DelayedEventHandler delayedEventHandler1 = createDelayedEventHandler();[m
[31m-        final BatchEventProcessor<TestEvent> processor1 =[m
[31m-                new BatchEventProcessor<>(ringBuffer, ringBuffer.newBarrier(), delayedEventHandler1);[m
[31m-[m
[31m-        final DelayedEventHandler delayedEventHandler2 = createDelayedEventHandler();[m
[31m-        final BatchEventProcessor<TestEvent> processor2 =[m
[31m-                new BatchEventProcessor<>(ringBuffer, ringBuffer.newBarrier(), delayedEventHandler2);[m
[31m-[m
[31m-        disruptor.handleEventsWith(processor1, processor2);[m
[31m-        disruptor.after(processor1, processor2).handleEventsWith(handlerWithBarrier);[m
[31m-[m
[31m-        ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, delayedEventHandler1, delayedEventHandler2);[m
[31m-        assertThat(executor.getExecutionCount(), equalTo(3));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    @Timeout(value = 2000, unit = TimeUnit.MILLISECONDS)[m
[31m-    public void shouldThrowTimeoutExceptionIfShutdownDoesNotCompleteNormally() throws Exception[m
[31m-    {[m
[31m-        assertThrows(TimeoutException.class, () ->[m
[31m-        {[m
[31m-            //Given[m
[31m-            final DelayedEventHandler delayedEventHandler = createDelayedEventHandler();[m
[31m-            disruptor.handleEventsWith(delayedEventHandler);[m
[31m-            publishEvent();[m
[31m-            //Then[m
[31m-            disruptor.shutdown(1, SECONDS);[m
[31m-        });[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    @Timeout(value = 1000, unit = TimeUnit.MILLISECONDS)[m
[31m-    public void shouldTrackRemainingCapacity() throws Exception[m
[31m-    {[m
[31m-        final long[] remainingCapacity = {-1};[m
[31m-        //Given[m
[31m-        final EventHandler<TestEvent> eventHandler = (event, sequence, endOfBatch) ->[m
[31m-                remainingCapacity[0] = disruptor.getRingBuffer().remainingCapacity();[m
[31m-[m
[31m-        disruptor.handleEventsWith(eventHandler);[m
[31m-[m
[31m-        //When[m
[31m-        publishEvent();[m
[31m-[m
[31m-        //Then[m
[31m-        while (remainingCapacity[0] == -1)[m
[31m-        {[m
[31m-            Thread.sleep(100);[m
[31m-        }[m
[31m-        assertThat(remainingCapacity[0], is(ringBuffer.getBufferSize() - 1L));[m
[31m-        assertThat(disruptor.getRingBuffer().remainingCapacity(), is(ringBuffer.getBufferSize() - 0L));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldAllowEventHandlerWithSuperType() throws Exception[m
[31m-    {[m
[31m-        final CountDownLatch latch = new CountDownLatch(2);[m
[31m-        final EventHandler<Object> objectHandler = new EventHandlerStub<>(latch);[m
[31m-[m
[31m-        disruptor.handleEventsWith(objectHandler);[m
[31m-[m
[31m-        ensureTwoEventsProcessedAccordingToDependencies(latch);[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldAllowChainingEventHandlersWithSuperType() throws Exception[m
[31m-    {[m
[31m-        final CountDownLatch latch = new CountDownLatch(2);[m
[31m-        final DelayedEventHandler delayedEventHandler = createDelayedEventHandler();[m
[31m-        final EventHandler<Object> objectHandler = new EventHandlerStub<>(latch);[m
[31m-[m
[31m-        disruptor.handleEventsWith(delayedEventHandler).then(objectHandler);[m
[31m-[m
[31m-        ensureTwoEventsProcessedAccordingToDependencies(latch, delayedEventHandler);[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldMakeEntriesAvailableToFirstCustomProcessorsImmediately() throws Exception[m
[31m-    {[m
[31m-        final CountDownLatch countDownLatch = new CountDownLatch(2);[m
[31m-        final EventHandler<TestEvent> eventHandler = new EventHandlerStub<>(countDownLatch);[m
[31m-[m
[31m-        disruptor.handleEventsWith([m
[31m-                (ringBuffer, barrierSequences) ->[m
[31m-                {[m
[31m-                    assertEquals(0, barrierSequences.length,[m
[31m-                            "Should not have had any barrier sequences");[m
[31m-                    return new BatchEventProcessor<>([m
[31m-                            disruptor.getRingBuffer(), ringBuffer.newBarrier([m
[31m-                            barrierSequences), eventHandler);[m
[31m-                });[m
[31m-[m
[31m-        ensureTwoEventsProcessedAccordingToDependencies(countDownLatch);[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldHonourDependenciesForCustomProcessors() throws Exception[m
[31m-    {[m
[31m-        final CountDownLatch countDownLatch = new CountDownLatch(2);[m
[31m-        final EventHandler<TestEvent> eventHandler = new EventHandlerStub<>(countDownLatch);[m
[31m-        final DelayedEventHandler delayedEventHandler = createDelayedEventHandler();[m
[31m-[m
[31m-        disruptor.handleEventsWith(delayedEventHandler).then([m
[31m-                (ringBuffer, barrierSequences) ->[m
[31m-                {[m
[31m-                    assertSame(1, barrierSequences.length, "Should have had a barrier sequence");[m
[31m-                    return new BatchEventProcessor<>([m
[31m-                            disruptor.getRingBuffer(), ringBuffer.newBarrier([m
[31m-                            barrierSequences), eventHandler);[m
[31m-                });[m
[31m-[m
[31m-        ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, delayedEventHandler);[m
[31m-    }[m
[31m-[m
[31m-    private void ensureTwoEventsProcessedAccordingToDependencies([m
[31m-        final CountDownLatch countDownLatch,[m
[31m-        final DelayedEventHandler... dependencies)[m
[31m-        throws InterruptedException, BrokenBarrierException[m
[31m-    {[m
[31m-        publishEvent();[m
[31m-        publishEvent();[m
[31m-[m
[31m-        for (DelayedEventHandler dependency : dependencies)[m
[31m-        {[m
[31m-            assertThatCountDownLatchEquals(countDownLatch, 2L);[m
[31m-            dependency.processEvent();[m
[31m-            dependency.processEvent();[m
[31m-        }[m
[31m-[m
[31m-        assertThatCountDownLatchIsZero(countDownLatch);[m
[31m-    }[m
[31m-[m
[31m-    private void assertProducerReaches([m
[31m-        final StubPublisher stubPublisher,[m
[31m-        final int expectedPublicationCount,[m
[31m-        boolean strict)[m
[31m-    {[m
[31m-        long loopStart = System.currentTimeMillis();[m
[31m-        while (stubPublisher.getPublicationCount() < expectedPublicationCount && System[m
[31m-            .currentTimeMillis() - loopStart < 5000)[m
[31m-        {[m
[31m-            yield();[m
[31m-        }[m
[31m-[m
[31m-        if (strict)[m
[31m-        {[m
[31m-            assertThat(stubPublisher.getPublicationCount(), equalTo(expectedPublicationCount));[m
[31m-        }[m
[31m-        else[m
[31m-        {[m
[31m-            final int actualPublicationCount = stubPublisher.getPublicationCount();[m
[31m-            final String msg = "Producer reached unexpected count. Expected at least " + expectedPublicationCount +[m
[31m-                    " but only reached " + actualPublicationCount;[m
[31m-            assertTrue(actualPublicationCount >= expectedPublicationCount, msg);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private void createDisruptor()[m
[31m-    {[m
[31m-        disruptor = new Disruptor<>([m
[31m-                TestEvent.EVENT_FACTORY,[m
[31m-                4,[m
[31m-                executor,[m
[31m-                ProducerType.SINGLE,[m
[31m-                new BlockingWaitStrategy());[m
[31m-    }[m
[31m-[m
[31m-    private TestEvent publishEvent() throws InterruptedException, BrokenBarrierException[m
[31m-    {[m
[31m-        if (ringBuffer == null)[m
[31m-        {[m
[31m-            ringBuffer = disruptor.start();[m
[31m-[m
[31m-            for (DelayedEventHandler eventHandler : delayedEventHandlers)[m
[31m-            {[m
[31m-                eventHandler.awaitStart();[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        disruptor.publishEvent((event, sequence) -> lastPublishedEvent = event);[m
[31m-[m
[31m-        return lastPublishedEvent;[m
[31m-    }[m
[31m-[m
[31m-    private Throwable waitFor(final AtomicReference<Throwable> reference)[m
[31m-    {[m
[31m-        while (reference.get() == null)[m
[31m-        {[m
[31m-            yield();[m
[31m-        }[m
[31m-[m
[31m-        return reference.get();[m
[31m-    }[m
[31m-[m
[31m-    private DelayedEventHandler createDelayedEventHandler()[m
[31m-    {[m
[31m-        final DelayedEventHandler delayedEventHandler = new DelayedEventHandler();[m
[31m-        delayedEventHandlers.add(delayedEventHandler);[m
[31m-        return delayedEventHandler;[m
[31m-    }[m
[31m-[m
[31m-    private void assertThatCountDownLatchEquals([m
[31m-        final CountDownLatch countDownLatch,[m
[31m-        final long expectedCountDownValue)[m
[31m-    {[m
[31m-        assertThat(Long.valueOf(countDownLatch.getCount()), equalTo(Long.valueOf(expectedCountDownValue)));[m
[31m-    }[m
[31m-[m
[31m-    private void assertThatCountDownLatchIsZero(final CountDownLatch countDownLatch)[m
[31m-        throws InterruptedException[m
[31m-    {[m
[31m-        boolean released = countDownLatch.await(TIMEOUT_IN_SECONDS, SECONDS);[m
[31m-        assertTrue(released, "Batch handler did not receive entries: " + countDownLatch.getCount());[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/dsl/stubs/DelayedEventHandler.java b/src/test/java/com/lmax/disruptor/dsl/stubs/DelayedEventHandler.java[m
[1mdeleted file mode 100644[m
[1mindex aae7443..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/dsl/stubs/DelayedEventHandler.java[m
[1m+++ /dev/null[m
[36m@@ -1,93 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.dsl.stubs;[m
[31m-[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.LifecycleAware;[m
[31m-import com.lmax.disruptor.support.TestEvent;[m
[31m-[m
[31m-import java.util.concurrent.BrokenBarrierException;[m
[31m-import java.util.concurrent.CyclicBarrier;[m
[31m-import java.util.concurrent.atomic.AtomicBoolean;[m
[31m-[m
[31m-public class DelayedEventHandler implements EventHandler<TestEvent>, LifecycleAware[m
[31m-{[m
[31m-    private final AtomicBoolean readyToProcessEvent = new AtomicBoolean(false);[m
[31m-    private volatile boolean stopped = false;[m
[31m-    private final CyclicBarrier barrier;[m
[31m-[m
[31m-    public DelayedEventHandler(CyclicBarrier barrier)[m
[31m-    {[m
[31m-        this.barrier = barrier;[m
[31m-    }[m
[31m-[m
[31m-    public DelayedEventHandler()[m
[31m-    {[m
[31m-        this(new CyclicBarrier(2));[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void onEvent(final TestEvent entry, final long sequence, final boolean endOfBatch) throws Exception[m
[31m-    {[m
[31m-        waitForAndSetFlag(false);[m
[31m-    }[m
[31m-[m
[31m-    public void processEvent()[m
[31m-    {[m
[31m-        waitForAndSetFlag(true);[m
[31m-    }[m
[31m-[m
[31m-    public void stopWaiting()[m
[31m-    {[m
[31m-        stopped = true;[m
[31m-    }[m
[31m-[m
[31m-    private void waitForAndSetFlag(final boolean newValue)[m
[31m-    {[m
[31m-        while (!stopped && !Thread.currentThread().isInterrupted() &&[m
[31m-            !readyToProcessEvent.compareAndSet(!newValue, newValue))[m
[31m-        {[m
[31m-            Thread.yield();[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void onStart()[m
[31m-    {[m
[31m-        try[m
[31m-        {[m
[31m-            barrier.await();[m
[31m-        }[m
[31m-        catch (InterruptedException e)[m
[31m-        {[m
[31m-            throw new RuntimeException(e);[m
[31m-        }[m
[31m-        catch (BrokenBarrierException e)[m
[31m-        {[m
[31m-            throw new RuntimeException(e);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void onShutdown()[m
[31m-    {[m
[31m-    }[m
[31m-[m
[31m-    public void awaitStart() throws InterruptedException, BrokenBarrierException[m
[31m-    {[m
[31m-        barrier.await();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/dsl/stubs/EventHandlerStub.java b/src/test/java/com/lmax/disruptor/dsl/stubs/EventHandlerStub.java[m
[1mdeleted file mode 100644[m
[1mindex 152eb38..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/dsl/stubs/EventHandlerStub.java[m
[1m+++ /dev/null[m
[36m@@ -1,36 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.dsl.stubs;[m
[31m-[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-[m
[31m-import java.util.concurrent.CountDownLatch;[m
[31m-[m
[31m-public class EventHandlerStub<T> implements EventHandler<T>[m
[31m-{[m
[31m-    private final CountDownLatch countDownLatch;[m
[31m-[m
[31m-    public EventHandlerStub(final CountDownLatch countDownLatch)[m
[31m-    {[m
[31m-        this.countDownLatch = countDownLatch;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void onEvent(final T entry, final long sequence, final boolean endOfBatch) throws Exception[m
[31m-    {[m
[31m-        countDownLatch.countDown();[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/dsl/stubs/EvilEqualsEventHandler.java b/src/test/java/com/lmax/disruptor/dsl/stubs/EvilEqualsEventHandler.java[m
[1mdeleted file mode 100644[m
[1mindex d24715a..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/dsl/stubs/EvilEqualsEventHandler.java[m
[1m+++ /dev/null[m
[36m@@ -1,38 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.dsl.stubs;[m
[31m-[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.support.TestEvent;[m
[31m-[m
[31m-public class EvilEqualsEventHandler implements EventHandler<TestEvent>[m
[31m-{[m
[31m-    @Override[m
[31m-    public void onEvent(final TestEvent entry, final long sequence, boolean endOfBatch) throws Exception[m
[31m-    {[m
[31m-    }[m
[31m-[m
[31m-    @SuppressWarnings({"EqualsWhichDoesntCheckParameterClass"})[m
[31m-    public boolean equals(Object o)[m
[31m-    {[m
[31m-        return true;[m
[31m-    }[m
[31m-[m
[31m-    public int hashCode()[m
[31m-    {[m
[31m-        return 1;[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/dsl/stubs/ExceptionThrowingEventHandler.java b/src/test/java/com/lmax/disruptor/dsl/stubs/ExceptionThrowingEventHandler.java[m
[1mdeleted file mode 100644[m
[1mindex 219cca1..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/dsl/stubs/ExceptionThrowingEventHandler.java[m
[1m+++ /dev/null[m
[36m@@ -1,35 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.dsl.stubs;[m
[31m-[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.support.TestEvent;[m
[31m-[m
[31m-public class ExceptionThrowingEventHandler implements EventHandler<TestEvent>[m
[31m-{[m
[31m-    private final RuntimeException testException;[m
[31m-[m
[31m-    public ExceptionThrowingEventHandler(final RuntimeException testException)[m
[31m-    {[m
[31m-        this.testException = testException;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void onEvent(final TestEvent entry, final long sequence, final boolean endOfBatch) throws Exception[m
[31m-    {[m
[31m-        throw testException;[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/dsl/stubs/SleepingEventHandler.java b/src/test/java/com/lmax/disruptor/dsl/stubs/SleepingEventHandler.java[m
[1mdeleted file mode 100644[m
[1mindex d6da3e0..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/dsl/stubs/SleepingEventHandler.java[m
[1m+++ /dev/null[m
[36m@@ -1,28 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.dsl.stubs;[m
[31m-[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.support.TestEvent;[m
[31m-[m
[31m-public class SleepingEventHandler implements EventHandler<TestEvent>[m
[31m-{[m
[31m-    @Override[m
[31m-    public void onEvent(final TestEvent entry, final long sequence, final boolean endOfBatch) throws Exception[m
[31m-    {[m
[31m-        Thread.sleep(1000);[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/dsl/stubs/StubExceptionHandler.java b/src/test/java/com/lmax/disruptor/dsl/stubs/StubExceptionHandler.java[m
[1mdeleted file mode 100644[m
[1mindex c8f6264..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/dsl/stubs/StubExceptionHandler.java[m
[1m+++ /dev/null[m
[36m@@ -1,47 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.dsl.stubs;[m
[31m-[m
[31m-import com.lmax.disruptor.ExceptionHandler;[m
[31m-[m
[31m-import java.util.concurrent.atomic.AtomicReference;[m
[31m-[m
[31m-public class StubExceptionHandler implements ExceptionHandler<Object>[m
[31m-{[m
[31m-    private final AtomicReference<Throwable> exceptionHandled;[m
[31m-[m
[31m-    public StubExceptionHandler(final AtomicReference<Throwable> exceptionHandled)[m
[31m-    {[m
[31m-        this.exceptionHandled = exceptionHandled;[m
[31m-    }[m
[31m-[m
[31m-    public void handleEventException(final Throwable ex, final long sequence, final Object event)[m
[31m-    {[m
[31m-        exceptionHandled.set(ex);[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void handleOnStartException(final Throwable ex)[m
[31m-    {[m
[31m-        exceptionHandled.set(ex);[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void handleOnShutdownException(final Throwable ex)[m
[31m-    {[m
[31m-        exceptionHandled.set(ex);[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/dsl/stubs/StubPublisher.java b/src/test/java/com/lmax/disruptor/dsl/stubs/StubPublisher.java[m
[1mdeleted file mode 100644[m
[1mindex f27434a..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/dsl/stubs/StubPublisher.java[m
[1m+++ /dev/null[m
[36m@@ -1,53 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.dsl.stubs;[m
[31m-[m
[31m-import com.lmax.disruptor.RingBuffer;[m
[31m-import com.lmax.disruptor.support.TestEvent;[m
[31m-[m
[31m-public class StubPublisher implements Runnable[m
[31m-{[m
[31m-    private volatile boolean running = true;[m
[31m-    private volatile int publicationCount = 0;[m
[31m-[m
[31m-    private final RingBuffer<TestEvent> ringBuffer;[m
[31m-[m
[31m-    public StubPublisher(final RingBuffer<TestEvent> ringBuffer)[m
[31m-    {[m
[31m-        this.ringBuffer = ringBuffer;[m
[31m-    }[m
[31m-[m
[31m-    public void run()[m
[31m-    {[m
[31m-        while (running)[m
[31m-        {[m
[31m-            final long sequence = ringBuffer.next();[m
[31m-            //final TestEvent entry = ringBuffer.get(sequence);[m
[31m-            ringBuffer.publish(sequence);[m
[31m-            publicationCount++;[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public int getPublicationCount()[m
[31m-    {[m
[31m-        return publicationCount;[m
[31m-    }[m
[31m-[m
[31m-    public void halt()[m
[31m-    {[m
[31m-        running = false;[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/dsl/stubs/StubThreadFactory.java b/src/test/java/com/lmax/disruptor/dsl/stubs/StubThreadFactory.java[m
[1mdeleted file mode 100644[m
[1mindex 0b17269..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/dsl/stubs/StubThreadFactory.java[m
[1m+++ /dev/null[m
[36m@@ -1,148 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.dsl.stubs;[m
[31m-[m
[31m-import com.lmax.disruptor.util.DaemonThreadFactory;[m
[31m-import org.junit.jupiter.api.extension.AfterEachCallback;[m
[31m-import org.junit.jupiter.api.extension.ExtensionContext;[m
[31m-[m
[31m-import java.util.ArrayList;[m
[31m-import java.util.Collection;[m
[31m-import java.util.Collections;[m
[31m-import java.util.List;[m
[31m-import java.util.concurrent.CopyOnWriteArrayList;[m
[31m-import java.util.concurrent.ThreadFactory;[m
[31m-import java.util.concurrent.atomic.AtomicBoolean;[m
[31m-import java.util.concurrent.atomic.AtomicInteger;[m
[31m-import java.util.logging.Logger;[m
[31m-[m
[31m-import static org.junit.jupiter.api.Assertions.assertFalse;[m
[31m-[m
[31m-public final class StubThreadFactory implements ThreadFactory, AfterEachCallback[m
[31m-{[m
[31m-    private static final Logger LOGGER = Logger.getLogger(StubThreadFactory.class.getName());[m
[31m-[m
[31m-    private final DaemonThreadFactory threadFactory = DaemonThreadFactory.INSTANCE;[m
[31m-    private final Collection<Thread> threads = new CopyOnWriteArrayList<>();[m
[31m-    private final AtomicBoolean ignoreExecutions = new AtomicBoolean(false);[m
[31m-    private final AtomicInteger executionCount = new AtomicInteger(0);[m
[31m-    private final List<Throwable> threadErrors = Collections.synchronizedList(new ArrayList<>());[m
[31m-    private final List<IgnoredException> ignoredExceptions = new ArrayList<>();[m
[31m-[m
[31m-    @Override[m
[31m-    public Thread newThread(final Runnable command)[m
[31m-    {[m
[31m-        executionCount.getAndIncrement();[m
[31m-        Runnable toExecute = () ->[m
[31m-        {[m
[31m-            try[m
[31m-            {[m
[31m-                command.run();[m
[31m-            }[m
[31m-            catch (Throwable t)[m
[31m-            {[m
[31m-                threadErrors.add(t);[m
[31m-            }[m
[31m-        };[m
[31m-        if(ignoreExecutions.get())[m
[31m-        {[m
[31m-            toExecute = new NoOpRunnable();[m
[31m-        }[m
[31m-        final Thread thread = threadFactory.newThread(toExecute);[m
[31m-        thread.setName(command.toString());[m
[31m-        threads.add(thread);[m
[31m-        return thread;[m
[31m-    }[m
[31m-[m
[31m-    public void joinAllThreads()[m
[31m-    {[m
[31m-        for (Thread thread : threads)[m
[31m-        {[m
[31m-            if (thread.isAlive())[m
[31m-            {[m
[31m-                try[m
[31m-                {[m
[31m-                    thread.interrupt();[m
[31m-                    thread.join(5000);[m
[31m-                }[m
[31m-                catch (InterruptedException e)[m
[31m-                {[m
[31m-                    e.printStackTrace();[m
[31m-                }[m
[31m-            }[m
[31m-[m
[31m-            assertFalse(thread.isAlive(), "Failed to stop thread: " + thread);[m
[31m-        }[m
[31m-[m
[31m-        threads.clear();[m
[31m-    }[m
[31m-[m
[31m-    public void ignoreExecutions()[m
[31m-    {[m
[31m-        ignoreExecutions.set(true);[m
[31m-    }[m
[31m-[m
[31m-    public int getExecutionCount()[m
[31m-    {[m
[31m-        return executionCount.get();[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void afterEach(final ExtensionContext context) throws Exception[m
[31m-    {[m
[31m-        if (!threadErrors.isEmpty())[m
[31m-        {[m
[31m-            for (final Throwable threadError : threadErrors)[m
[31m-            {[m
[31m-                boolean ignored = false;[m
[31m-                for (final IgnoredException ignoredException : ignoredExceptions)[m
[31m-                {[m
[31m-                    if (threadError.getMessage().equalsIgnoreCase(ignoredException.exceptionMessage))[m
[31m-                    {[m
[31m-                        LOGGER.info("Ignoring '" + threadError.getMessage() + "' " +[m
[31m-                                "because: " + ignoredException.reason);[m
[31m-                        ignored = true;[m
[31m-                        break;[m
[31m-                    }[m
[31m-                }[m
[31m-                if (!ignored)[m
[31m-                {[m
[31m-                    throw new Exception(threadError);[m
[31m-                }[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static final class IgnoredException[m
[31m-    {[m
[31m-        final String exceptionMessage;[m
[31m-        final String reason;[m
[31m-[m
[31m-        IgnoredException(final String exceptionMessage, final String reason)[m
[31m-        {[m
[31m-            this.exceptionMessage = exceptionMessage;[m
[31m-            this.reason = reason;[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private static final class NoOpRunnable implements Runnable[m
[31m-    {[m
[31m-        @Override[m
[31m-        public void run()[m
[31m-        {[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/support/DummyEventHandler.java b/src/test/java/com/lmax/disruptor/support/DummyEventHandler.java[m
[1mdeleted file mode 100644[m
[1mindex 82a4b7a..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/support/DummyEventHandler.java[m
[1m+++ /dev/null[m
[36m@@ -1,31 +0,0 @@[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import com.lmax.disruptor.EventHandler;[m
[31m-import com.lmax.disruptor.LifecycleAware;[m
[31m-[m
[31m-public class DummyEventHandler<T> implements EventHandler<T>, LifecycleAware[m
[31m-{[m
[31m-    public int startCalls = 0;[m
[31m-    public int shutdownCalls = 0;[m
[31m-    public T lastEvent;[m
[31m-    public long lastSequence;[m
[31m-[m
[31m-    @Override[m
[31m-    public void onStart()[m
[31m-    {[m
[31m-        startCalls++;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void onShutdown()[m
[31m-    {[m
[31m-        shutdownCalls++;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void onEvent(T event, long sequence, boolean endOfBatch) throws Exception[m
[31m-    {[m
[31m-        lastEvent = event;[m
[31m-        lastSequence = sequence;[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/support/DummyEventProcessor.java b/src/test/java/com/lmax/disruptor/support/DummyEventProcessor.java[m
[1mdeleted file mode 100644[m
[1mindex edc3201..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/support/DummyEventProcessor.java[m
[1m+++ /dev/null[m
[36m@@ -1,55 +0,0 @@[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import com.lmax.disruptor.EventProcessor;[m
[31m-import com.lmax.disruptor.Sequence;[m
[31m-import com.lmax.disruptor.SingleProducerSequencer;[m
[31m-[m
[31m-import java.util.concurrent.atomic.AtomicBoolean;[m
[31m-[m
[31m-public class DummyEventProcessor implements EventProcessor[m
[31m-{[m
[31m-    private final Sequence sequence;[m
[31m-    private final AtomicBoolean running = new AtomicBoolean(false);[m
[31m-[m
[31m-    public DummyEventProcessor(Sequence sequence)[m
[31m-    {[m
[31m-        this.sequence = sequence;[m
[31m-    }[m
[31m-[m
[31m-    public DummyEventProcessor()[m
[31m-    {[m
[31m-        this(new Sequence(SingleProducerSequencer.INITIAL_CURSOR_VALUE));[m
[31m-    }[m
[31m-[m
[31m-    public void setSequence(long sequence)[m
[31m-    {[m
[31m-        this.sequence.set(sequence);[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public Sequence getSequence()[m
[31m-    {[m
[31m-        return sequence;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void halt()[m
[31m-    {[m
[31m-        running.set(false);[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public boolean isRunning()[m
[31m-    {[m
[31m-        return running.get();[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void run()[m
[31m-    {[m
[31m-        if (!running.compareAndSet(false, true))[m
[31m-        {[m
[31m-            throw new IllegalStateException("Already running");[m
[31m-        }[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/support/DummySequenceBarrier.java b/src/test/java/com/lmax/disruptor/support/DummySequenceBarrier.java[m
[1mdeleted file mode 100644[m
[1mindex 586619b..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/support/DummySequenceBarrier.java[m
[1m+++ /dev/null[m
[36m@@ -1,56 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2012 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-[m
[31m-import com.lmax.disruptor.AlertException;[m
[31m-import com.lmax.disruptor.SequenceBarrier;[m
[31m-[m
[31m-public class DummySequenceBarrier implements SequenceBarrier[m
[31m-{[m
[31m-    @Override[m
[31m-    public long waitFor(long sequence) throws AlertException, InterruptedException[m
[31m-    {[m
[31m-        return 0;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public long getCursor()[m
[31m-    {[m
[31m-        return 0;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public boolean isAlerted()[m
[31m-    {[m
[31m-        return false;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void alert()[m
[31m-    {[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void clearAlert()[m
[31m-    {[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void checkAlert() throws AlertException[m
[31m-    {[m
[31m-    }[m
[31m-}[m
\ No newline at end of file[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/support/DummyWaitStrategy.java b/src/test/java/com/lmax/disruptor/support/DummyWaitStrategy.java[m
[1mdeleted file mode 100644[m
[1mindex a627eb3..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/support/DummyWaitStrategy.java[m
[1m+++ /dev/null[m
[36m@@ -1,22 +0,0 @@[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import com.lmax.disruptor.*;[m
[31m-[m
[31m-public class DummyWaitStrategy implements WaitStrategy[m
[31m-{[m
[31m-    public int signalAllWhenBlockingCalls = 0;[m
[31m-[m
[31m-    @Override[m
[31m-    public long waitFor([m
[31m-        long sequence, Sequence cursor, Sequence dependentSequence, SequenceBarrier barrier)[m
[31m-        throws AlertException, InterruptedException, TimeoutException[m
[31m-    {[m
[31m-        return 0;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void signalAllWhenBlocking()[m
[31m-    {[m
[31m-        signalAllWhenBlockingCalls++;[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/support/LongEvent.java b/src/test/java/com/lmax/disruptor/support/LongEvent.java[m
[1mdeleted file mode 100644[m
[1mindex 9b53390..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/support/LongEvent.java[m
[1m+++ /dev/null[m
[36m@@ -1,35 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import com.lmax.disruptor.EventFactory;[m
[31m-[m
[31m-public class LongEvent[m
[31m-{[m
[31m-    private long value;[m
[31m-[m
[31m-    public void set(long value)[m
[31m-    {[m
[31m-        this.value = value;[m
[31m-    }[m
[31m-[m
[31m-    public long get()[m
[31m-    {[m
[31m-        return value;[m
[31m-    }[m
[31m-[m
[31m-    public static final EventFactory<LongEvent> FACTORY = () -> new LongEvent();[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/support/SequenceUpdater.java b/src/test/java/com/lmax/disruptor/support/SequenceUpdater.java[m
[1mdeleted file mode 100644[m
[1mindex 7bda478..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/support/SequenceUpdater.java[m
[1m+++ /dev/null[m
[36m@@ -1,60 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2012 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import com.lmax.disruptor.Sequence;[m
[31m-import com.lmax.disruptor.WaitStrategy;[m
[31m-[m
[31m-import java.util.concurrent.BrokenBarrierException;[m
[31m-import java.util.concurrent.CyclicBarrier;[m
[31m-[m
[31m-class SequenceUpdater implements Runnable[m
[31m-{[m
[31m-    public final Sequence sequence = new Sequence();[m
[31m-    private final CyclicBarrier barrier = new CyclicBarrier(2);[m
[31m-    private final long sleepTime;[m
[31m-    private WaitStrategy waitStrategy;[m
[31m-[m
[31m-    SequenceUpdater(long sleepTime, WaitStrategy waitStrategy)[m
[31m-    {[m
[31m-        this.sleepTime = sleepTime;[m
[31m-        this.waitStrategy = waitStrategy;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public void run()[m
[31m-    {[m
[31m-        try[m
[31m-        {[m
[31m-            barrier.await();[m
[31m-            if (0 != sleepTime)[m
[31m-            {[m
[31m-                Thread.sleep(sleepTime);[m
[31m-            }[m
[31m-            sequence.incrementAndGet();[m
[31m-            waitStrategy.signalAllWhenBlocking();[m
[31m-        }[m
[31m-        catch (Exception e)[m
[31m-        {[m
[31m-            e.printStackTrace();[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public void waitForStartup() throws InterruptedException, BrokenBarrierException[m
[31m-    {[m
[31m-        barrier.await();[m
[31m-    }[m
[31m-}[m
\ No newline at end of file[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/support/StubEvent.java b/src/test/java/com/lmax/disruptor/support/StubEvent.java[m
[1mdeleted file mode 100644[m
[1mindex a16f7bf..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/support/StubEvent.java[m
[1m+++ /dev/null[m
[36m@@ -1,91 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import com.lmax.disruptor.EventFactory;[m
[31m-import com.lmax.disruptor.EventTranslatorTwoArg;[m
[31m-[m
[31m-public final class StubEvent[m
[31m-{[m
[31m-    private int value;[m
[31m-    private String testString;[m
[31m-    public static final EventTranslatorTwoArg<StubEvent, Integer, String> TRANSLATOR = (event, sequence, arg0, arg1) ->[m
[31m-            {[m
[31m-                event.setValue(arg0);[m
[31m-                event.setTestString(arg1);[m
[31m-            };[m
[31m-[m
[31m-    public StubEvent(int i)[m
[31m-    {[m
[31m-        this.value = i;[m
[31m-    }[m
[31m-[m
[31m-    public void copy(StubEvent event)[m
[31m-    {[m
[31m-        value = event.value;[m
[31m-    }[m
[31m-[m
[31m-    public int getValue()[m
[31m-    {[m
[31m-        return value;[m
[31m-    }[m
[31m-[m
[31m-    public void setValue(int value)[m
[31m-    {[m
[31m-        this.value = value;[m
[31m-    }[m
[31m-[m
[31m-    public String getTestString()[m
[31m-    {[m
[31m-        return testString;[m
[31m-    }[m
[31m-[m
[31m-    public void setTestString(final String testString)[m
[31m-    {[m
[31m-        this.testString = testString;[m
[31m-    }[m
[31m-[m
[31m-    public static final EventFactory<StubEvent> EVENT_FACTORY = () -> new StubEvent(-1);[m
[31m-[m
[31m-    @Override[m
[31m-    public int hashCode()[m
[31m-    {[m
[31m-        final int prime = 31;[m
[31m-        int result = 1;[m
[31m-        result = prime * result + value;[m
[31m-        return result;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public boolean equals(Object obj)[m
[31m-    {[m
[31m-        if (this == obj)[m
[31m-        {[m
[31m-            return true;[m
[31m-        }[m
[31m-        if (obj == null)[m
[31m-        {[m
[31m-            return false;[m
[31m-        }[m
[31m-        if (getClass() != obj.getClass())[m
[31m-        {[m
[31m-            return false;[m
[31m-        }[m
[31m-        StubEvent other = (StubEvent) obj;[m
[31m-[m
[31m-        return value == other.value;[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/support/TestEvent.java b/src/test/java/com/lmax/disruptor/support/TestEvent.java[m
[1mdeleted file mode 100644[m
[1mindex 6985db2..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/support/TestEvent.java[m
[1m+++ /dev/null[m
[36m@@ -1,29 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import com.lmax.disruptor.EventFactory;[m
[31m-[m
[31m-public final class TestEvent[m
[31m-{[m
[31m-    @Override[m
[31m-    public String toString()[m
[31m-    {[m
[31m-        return "Test Event";[m
[31m-    }[m
[31m-[m
[31m-    public static final EventFactory<TestEvent> EVENT_FACTORY = TestEvent::new;[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/support/TestWaiter.java b/src/test/java/com/lmax/disruptor/support/TestWaiter.java[m
[1mdeleted file mode 100644[m
[1mindex 6a57d7c..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/support/TestWaiter.java[m
[1m+++ /dev/null[m
[36m@@ -1,62 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import java.util.ArrayList;[m
[31m-import java.util.List;[m
[31m-import java.util.concurrent.Callable;[m
[31m-import java.util.concurrent.CyclicBarrier;[m
[31m-[m
[31m-import com.lmax.disruptor.RingBuffer;[m
[31m-import com.lmax.disruptor.SequenceBarrier;[m
[31m-[m
[31m-public final class TestWaiter implements Callable<List<StubEvent>>[m
[31m-{[m
[31m-    private final long toWaitForSequence;[m
[31m-    private final long initialSequence;[m
[31m-    private final CyclicBarrier cyclicBarrier;[m
[31m-    private final SequenceBarrier sequenceBarrier;[m
[31m-    private final RingBuffer<StubEvent> ringBuffer;[m
[31m-[m
[31m-    public TestWaiter([m
[31m-        final CyclicBarrier cyclicBarrier,[m
[31m-        final SequenceBarrier sequenceBarrier,[m
[31m-        final RingBuffer<StubEvent> ringBuffer,[m
[31m-        final long initialSequence,[m
[31m-        final long toWaitForSequence)[m
[31m-    {[m
[31m-        this.cyclicBarrier = cyclicBarrier;[m
[31m-        this.initialSequence = initialSequence;[m
[31m-        this.ringBuffer = ringBuffer;[m
[31m-        this.toWaitForSequence = toWaitForSequence;[m
[31m-        this.sequenceBarrier = sequenceBarrier;[m
[31m-    }[m
[31m-[m
[31m-    @Override[m
[31m-    public List<StubEvent> call() throws Exception[m
[31m-    {[m
[31m-        cyclicBarrier.await();[m
[31m-        sequenceBarrier.waitFor(toWaitForSequence);[m
[31m-[m
[31m-        final List<StubEvent> messages = new ArrayList<>();[m
[31m-        for (long l = initialSequence; l <= toWaitForSequence; l++)[m
[31m-        {[m
[31m-            messages.add(ringBuffer.get(l));[m
[31m-        }[m
[31m-[m
[31m-        return messages;[m
[31m-    }[m
[31m-}[m
\ No newline at end of file[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/support/WaitStrategyTestUtil.java b/src/test/java/com/lmax/disruptor/support/WaitStrategyTestUtil.java[m
[1mdeleted file mode 100644[m
[1mindex 002ce0b..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/support/WaitStrategyTestUtil.java[m
[1m+++ /dev/null[m
[36m@@ -1,45 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2012 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.support;[m
[31m-[m
[31m-import com.lmax.disruptor.AlertException;[m
[31m-import com.lmax.disruptor.Sequence;[m
[31m-import com.lmax.disruptor.TimeoutException;[m
[31m-import com.lmax.disruptor.WaitStrategy;[m
[31m-[m
[31m-import java.util.concurrent.BrokenBarrierException;[m
[31m-import java.util.concurrent.ExecutorService;[m
[31m-import java.util.concurrent.Executors;[m
[31m-[m
[31m-import static org.hamcrest.CoreMatchers.is;[m
[31m-import static org.hamcrest.MatcherAssert.assertThat;[m
[31m-[m
[31m-public class WaitStrategyTestUtil[m
[31m-{[m
[31m-    private static final ExecutorService EXECUTOR = Executors.newCachedThreadPool();[m
[31m-[m
[31m-    public static void assertWaitForWithDelayOf(long sleepTimeMillis, WaitStrategy waitStrategy)[m
[31m-        throws InterruptedException, BrokenBarrierException, AlertException, TimeoutException[m
[31m-    {[m
[31m-        SequenceUpdater sequenceUpdater = new SequenceUpdater(sleepTimeMillis, waitStrategy);[m
[31m-        EXECUTOR.execute(sequenceUpdater);[m
[31m-        sequenceUpdater.waitForStartup();[m
[31m-        Sequence cursor = new Sequence(0);[m
[31m-        long sequence = waitStrategy.waitFor(0, cursor, sequenceUpdater.sequence, new DummySequenceBarrier());[m
[31m-[m
[31m-        assertThat(sequence, is(0L));[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/util/MutableLong.java b/src/test/java/com/lmax/disruptor/util/MutableLong.java[m
[1mdeleted file mode 100644[m
[1mindex 61c988e..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/util/MutableLong.java[m
[1m+++ /dev/null[m
[36m@@ -1,69 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.util;[m
[31m-[m
[31m-/**[m
[31m- * Holder class for a long value.[m
[31m- */[m
[31m-public class MutableLong[m
[31m-{[m
[31m-    private long value = 0L;[m
[31m-[m
[31m-    /**[m
[31m-     * Default constructor[m
[31m-     */[m
[31m-    public MutableLong()[m
[31m-    {[m
[31m-    }[m
[31m-[m
[31m-    /**[m
[31m-     * Construct the holder with initial value.[m
[31m-     *[m
[31m-     * @param initialValue to be initially set.[m
[31m-     */[m
[31m-    public MutableLong(final long initialValue)[m
[31m-    {[m
[31m-        this.value = initialValue;[m
[31m-    }[m
[31m-[m
[31m-    /**[m
[31m-     * Get the long value.[m
[31m-     *[m
[31m-     * @return the long value.[m
[31m-     */[m
[31m-    public long get()[m
[31m-    {[m
[31m-        return value;[m
[31m-    }[m
[31m-[m
[31m-    /**[m
[31m-     * Set the long value.[m
[31m-     *[m
[31m-     * @param value to set.[m
[31m-     */[m
[31m-    public void set(final long value)[m
[31m-    {[m
[31m-        this.value = value;[m
[31m-    }[m
[31m-[m
[31m-    /**[m
[31m-     * Increments the value[m
[31m-     */[m
[31m-    public void increment()[m
[31m-    {[m
[31m-        value++;[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/util/PaddedLong.java b/src/test/java/com/lmax/disruptor/util/PaddedLong.java[m
[1mdeleted file mode 100644[m
[1mindex 118cbb2..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/util/PaddedLong.java[m
[1m+++ /dev/null[m
[36m@@ -1,46 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.util;[m
[31m-[m
[31m-/**[m
[31m- * Cache line padded long variable to be used when false sharing maybe an issue.[m
[31m- */[m
[31m-public final class PaddedLong extends MutableLong[m
[31m-{[m
[31m-    public volatile long p1, p2, p3, p4, p5, p6 = 7L;[m
[31m-[m
[31m-    /**[m
[31m-     * Default constructor[m
[31m-     */[m
[31m-    public PaddedLong()[m
[31m-    {[m
[31m-    }[m
[31m-[m
[31m-    /**[m
[31m-     * Construct with an initial value.[m
[31m-     *[m
[31m-     * @param initialValue for construction[m
[31m-     */[m
[31m-    public PaddedLong(final long initialValue)[m
[31m-    {[m
[31m-        super(initialValue);[m
[31m-    }[m
[31m-[m
[31m-    public long sumPaddingToPreventOptimisation()[m
[31m-    {[m
[31m-        return p1 + p2 + p3 + p4 + p5 + p6;[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/test/java/com/lmax/disruptor/util/UtilTest.java b/src/test/java/com/lmax/disruptor/util/UtilTest.java[m
[1mdeleted file mode 100644[m
[1mindex ca9e2b6..0000000[m
[1m--- a/src/test/java/com/lmax/disruptor/util/UtilTest.java[m
[1m+++ /dev/null[m
[36m@@ -1,55 +0,0 @@[m
[31m-/*[m
[31m- * Copyright 2011 LMAX Ltd.[m
[31m- *[m
[31m- * Licensed under the Apache License, Version 2.0 (the "License");[m
[31m- * you may not use this file except in compliance with the License.[m
[31m- * You may obtain a copy of the License at[m
[31m- *[m
[31m- * http://www.apache.org/licenses/LICENSE-2.0[m
[31m- *[m
[31m- * Unless required by applicable law or agreed to in writing, software[m
[31m- * distributed under the License is distributed on an "AS IS" BASIS,[m
[31m- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m- * See the License for the specific language governing permissions and[m
[31m- * limitations under the License.[m
[31m- */[m
[31m-package com.lmax.disruptor.util;[m
[31m-[m
[31m-import com.lmax.disruptor.Sequence;[m
[31m-import org.junit.jupiter.api.Test;[m
[31m-[m
[31m-import static org.junit.jupiter.api.Assertions.assertEquals;[m
[31m-[m
[31m-public final class UtilTest[m
[31m-{[m
[31m-    @Test[m
[31m-    public void shouldReturnNextPowerOfTwo()[m
[31m-    {[m
[31m-        int powerOfTwo = Util.ceilingNextPowerOfTwo(1000);[m
[31m-[m
[31m-        assertEquals(1024, powerOfTwo);[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldReturnExactPowerOfTwo()[m
[31m-    {[m
[31m-        int powerOfTwo = Util.ceilingNextPowerOfTwo(1024);[m
[31m-[m
[31m-        assertEquals(1024, powerOfTwo);[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldReturnMinimumSequence()[m
[31m-    {[m
[31m-        final Sequence[] sequences = {new Sequence(7L), new Sequence(3L), new Sequence(12L)};[m
[31m-        assertEquals(3L, Util.getMinimumSequence(sequences));[m
[31m-    }[m
[31m-[m
[31m-    @Test[m
[31m-    public void shouldReturnLongMaxWhenNoEventProcessors()[m
[31m-    {[m
[31m-        final Sequence[] sequences = new Sequence[0];[m
[31m-[m
[31m-        assertEquals(Long.MAX_VALUE, Util.getMinimumSequence(sequences));[m
[31m-    }[m
[31m-}[m
