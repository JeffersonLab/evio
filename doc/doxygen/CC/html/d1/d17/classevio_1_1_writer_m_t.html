<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>evio: evio::WriterMT Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">evio
   &#160;<span id="projectnumber">6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d1/d17/classevio_1_1_writer_m_t.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../dd/d8b/classevio_1_1_writer_m_t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">evio::WriterMT Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to write Evio/HIPO files only (not to buffers).  
 <a href="../../d1/d17/classevio_1_1_writer_m_t.html#details">More...</a></p>

<p><code>#include &lt;WriterMT.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1c4aa6ec4d7e32a2177fc972634755b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a1c4aa6ec4d7e32a2177fc972634755b2">WriterMT</a> ()</td></tr>
<tr class="memdesc:a1c4aa6ec4d7e32a2177fc972634755b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#a1c4aa6ec4d7e32a2177fc972634755b2">More...</a><br /></td></tr>
<tr class="separator:a1c4aa6ec4d7e32a2177fc972634755b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0006bbaee6c193371b30a8dfc208430e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a0006bbaee6c193371b30a8dfc208430e">WriterMT</a> (const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;order, uint32_t maxEventCount, uint32_t maxBufferSize, <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747">Compressor::CompressionType</a> compType, uint32_t compressionThreads)</td></tr>
<tr class="memdesc:a0006bbaee6c193371b30a8dfc208430e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with byte order.  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#a0006bbaee6c193371b30a8dfc208430e">More...</a><br /></td></tr>
<tr class="separator:a0006bbaee6c193371b30a8dfc208430e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756450758e08def3dcc61fb7a2e085b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a756450758e08def3dcc61fb7a2e085b3">WriterMT</a> (const <a class="el" href="../../df/dd8/classevio_1_1_header_type.html">HeaderType</a> &amp;hType, const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;order=<a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#ae70d8b2df728e3776bb6bb843260bb71">ByteOrder::ENDIAN_LITTLE</a>, uint32_t maxEventCount=0, uint32_t maxBufferSize=0, const std::string &amp;dictionary=&quot;&quot;, uint8_t *firstEvent=nullptr, uint32_t firstEventLen=0, <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747">Compressor::CompressionType</a> compressionType=<a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747a056585718cbf5c7808c0e37b1f88dbb9">Compressor::UNCOMPRESSED</a>, uint32_t compressionThreads=1, bool addTrailerIndex=false, uint32_t ringSize=16)</td></tr>
<tr class="memdesc:a756450758e08def3dcc61fb7a2e085b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with byte order.  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#a756450758e08def3dcc61fb7a2e085b3">More...</a><br /></td></tr>
<tr class="separator:a756450758e08def3dcc61fb7a2e085b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d41af0c23a70a4275baac708184c333"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a6d41af0c23a70a4275baac708184c333">WriterMT</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a6d41af0c23a70a4275baac708184c333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with filename.  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#a6d41af0c23a70a4275baac708184c333">More...</a><br /></td></tr>
<tr class="separator:a6d41af0c23a70a4275baac708184c333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87e7c1c6f3f488b5baff39fa6762679"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#ac87e7c1c6f3f488b5baff39fa6762679">WriterMT</a> (const std::string &amp;filename, const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;order, uint32_t maxEventCount, uint32_t maxBufferSize, <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747">Compressor::CompressionType</a> compressionType, uint32_t compressionThreads)</td></tr>
<tr class="memdesc:ac87e7c1c6f3f488b5baff39fa6762679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with filename &amp; byte order.  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#ac87e7c1c6f3f488b5baff39fa6762679">More...</a><br /></td></tr>
<tr class="separator:ac87e7c1c6f3f488b5baff39fa6762679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e17694d785f9cb315fbb8bb45dd98e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a19e17694d785f9cb315fbb8bb45dd98e">~WriterMT</a> ()=default</td></tr>
<tr class="separator:a19e17694d785f9cb315fbb8bb45dd98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca66655847ba07efaa2c9d68e5757fb5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#aca66655847ba07efaa2c9d68e5757fb5">getByteOrder</a> () const</td></tr>
<tr class="memdesc:aca66655847ba07efaa2c9d68e5757fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file's byte order.  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#aca66655847ba07efaa2c9d68e5757fb5">More...</a><br /></td></tr>
<tr class="separator:aca66655847ba07efaa2c9d68e5757fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b05c4f9a45ec56f9c5594d513da6d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da6/classevio_1_1_file_header.html">FileHeader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a68b05c4f9a45ec56f9c5594d513da6d1">getFileHeader</a> ()</td></tr>
<tr class="memdesc:a68b05c4f9a45ec56f9c5594d513da6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file header.  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#a68b05c4f9a45ec56f9c5594d513da6d1">More...</a><br /></td></tr>
<tr class="separator:a68b05c4f9a45ec56f9c5594d513da6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507b0794073feaba80658f006e3f8103"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747">Compressor::CompressionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a507b0794073feaba80658f006e3f8103">getCompressionType</a> ()</td></tr>
<tr class="memdesc:a507b0794073feaba80658f006e3f8103"><td class="mdescLeft">&#160;</td><td class="mdescRight">&zwj;**  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#a507b0794073feaba80658f006e3f8103">More...</a><br /></td></tr>
<tr class="separator:a507b0794073feaba80658f006e3f8103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602ade27297bb163f4c85452d7b3d0ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a602ade27297bb163f4c85452d7b3d0ec">addTrailer</a> () const</td></tr>
<tr class="memdesc:a602ade27297bb163f4c85452d7b3d0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this writer add a trailer to the end of the file/buffer?  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#a602ade27297bb163f4c85452d7b3d0ec">More...</a><br /></td></tr>
<tr class="separator:a602ade27297bb163f4c85452d7b3d0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f6fb10f2b791d56a2a86356e404b25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#af9f6fb10f2b791d56a2a86356e404b25">addTrailer</a> (bool add)</td></tr>
<tr class="memdesc:af9f6fb10f2b791d56a2a86356e404b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether this writer adds a trailer to the end of the file/buffer.  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#af9f6fb10f2b791d56a2a86356e404b25">More...</a><br /></td></tr>
<tr class="separator:af9f6fb10f2b791d56a2a86356e404b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af121e05d362ecaef240c67a3dd7fd33d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#af121e05d362ecaef240c67a3dd7fd33d">addTrailerWithIndex</a> ()</td></tr>
<tr class="memdesc:af121e05d362ecaef240c67a3dd7fd33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this writer add a trailer with a record index to the end of the file? Or, if writing to a buffer, is a trailer added with no index?  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#af121e05d362ecaef240c67a3dd7fd33d">More...</a><br /></td></tr>
<tr class="separator:af121e05d362ecaef240c67a3dd7fd33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0363d26c10365ac6bb115298c137d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a5b0363d26c10365ac6bb115298c137d0">addTrailerWithIndex</a> (bool addTrailingIndex)</td></tr>
<tr class="memdesc:a5b0363d26c10365ac6bb115298c137d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether this writer adds a trailer with a record index to the end of the file.  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#a5b0363d26c10365ac6bb115298c137d0">More...</a><br /></td></tr>
<tr class="separator:a5b0363d26c10365ac6bb115298c137d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f585f15aa1b56884dc8612eb5072e0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a1f585f15aa1b56884dc8612eb5072e0d">open</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a1f585f15aa1b56884dc8612eb5072e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a new file and write file header with no user header.  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#a1f585f15aa1b56884dc8612eb5072e0d">More...</a><br /></td></tr>
<tr class="separator:a1f585f15aa1b56884dc8612eb5072e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3974c139f38b0a73bf8f7dc51367a2d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a3974c139f38b0a73bf8f7dc51367a2d1">open</a> (const std::string &amp;filename, uint8_t *userHdr, uint32_t userLen)</td></tr>
<tr class="memdesc:a3974c139f38b0a73bf8f7dc51367a2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file and write file header with given user header.  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#a3974c139f38b0a73bf8f7dc51367a2d1">More...</a><br /></td></tr>
<tr class="separator:a3974c139f38b0a73bf8f7dc51367a2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4a6ab09bc138dbd08057262b87d77b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#abe4a6ab09bc138dbd08057262b87d77b">createHeader</a> (uint8_t *userHdr, uint32_t userLen)</td></tr>
<tr class="memdesc:abe4a6ab09bc138dbd08057262b87d77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a buffer containing a general file header followed by the user header given in the argument.  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#abe4a6ab09bc138dbd08057262b87d77b">More...</a><br /></td></tr>
<tr class="separator:abe4a6ab09bc138dbd08057262b87d77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8524b1765b4c4f8ac7ed7eff80b56af7"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a8524b1765b4c4f8ac7ed7eff80b56af7">createHeader</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;userHdr)</td></tr>
<tr class="memdesc:a8524b1765b4c4f8ac7ed7eff80b56af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a buffer with a general file header followed by the given user header (userHdr).  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#a8524b1765b4c4f8ac7ed7eff80b56af7">More...</a><br /></td></tr>
<tr class="separator:a8524b1765b4c4f8ac7ed7eff80b56af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9185ec115b3b04111345b53c7fa64190"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a9185ec115b3b04111345b53c7fa64190">writeRecord</a> (<a class="el" href="../../d2/d7a/classevio_1_1_record_output.html">RecordOutput</a> &amp;record)</td></tr>
<tr class="memdesc:a9185ec115b3b04111345b53c7fa64190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the record to the file.  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#a9185ec115b3b04111345b53c7fa64190">More...</a><br /></td></tr>
<tr class="separator:a9185ec115b3b04111345b53c7fa64190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78421457d086cf500d64150da99c6505"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a78421457d086cf500d64150da99c6505">addEvent</a> (uint8_t *buffer, uint32_t offset, uint32_t length)</td></tr>
<tr class="memdesc:a78421457d086cf500d64150da99c6505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a byte array to the current internal record.  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#a78421457d086cf500d64150da99c6505">More...</a><br /></td></tr>
<tr class="separator:a78421457d086cf500d64150da99c6505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904111fb56c2dad2141173754827994b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a904111fb56c2dad2141173754827994b">addEvent</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;buffer)</td></tr>
<tr class="memdesc:a904111fb56c2dad2141173754827994b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> to the internal record.  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#a904111fb56c2dad2141173754827994b">More...</a><br /></td></tr>
<tr class="separator:a904111fb56c2dad2141173754827994b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329d5fd7ee27378b2d532e715742bd87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a329d5fd7ee27378b2d532e715742bd87">addEvent</a> (<a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &amp;node)</td></tr>
<tr class="memdesc:a329d5fd7ee27378b2d532e715742bd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html" title="This class is used to store relevant info about an evio container (bank, segment, or tag segment),...">EvioNode</a> to the internal record.  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#a329d5fd7ee27378b2d532e715742bd87">More...</a><br /></td></tr>
<tr class="separator:a329d5fd7ee27378b2d532e715742bd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebafad3524a67dae57ff4a50c991229"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#adebafad3524a67dae57ff4a50c991229">reset</a> ()</td></tr>
<tr class="memdesc:adebafad3524a67dae57ff4a50c991229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this object ready for re-use.  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#adebafad3524a67dae57ff4a50c991229">More...</a><br /></td></tr>
<tr class="separator:adebafad3524a67dae57ff4a50c991229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0647993716e981fbedd6040f80114048"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a0647993716e981fbedd6040f80114048">close</a> ()</td></tr>
<tr class="memdesc:a0647993716e981fbedd6040f80114048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close opened file.  <a href="../../d1/d17/classevio_1_1_writer_m_t.html#a0647993716e981fbedd6040f80114048">More...</a><br /></td></tr>
<tr class="separator:a0647993716e981fbedd6040f80114048"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to write Evio/HIPO files only (not to buffers). </p>
<p>Able to multithread the compression of data.</p>
<dl class="section version"><dt>Version</dt><dd>6.0 </dd></dl>
<dl class="section since"><dt>Since</dt><dd>6.0 5/13/19 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>timmer </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1c4aa6ec4d7e32a2177fc972634755b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4aa6ec4d7e32a2177fc972634755b2">&#9670;&nbsp;</a></span>WriterMT() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">evio::WriterMT::WriterMT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Compression is single-threaded, LZ4. Little endian. <b>No</b> file is opened. Any file will have little endian byte order. 1M max event count and 8M max buffer size. </p>

</div>
</div>
<a id="a0006bbaee6c193371b30a8dfc208430e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0006bbaee6c193371b30a8dfc208430e">&#9670;&nbsp;</a></span>WriterMT() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">evio::WriterMT::WriterMT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxEventCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747">Compressor::CompressionType</a>&#160;</td>
          <td class="paramname"><em>compType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>compressionThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor with byte order. </p>
<p><b>No</b> file is opened. File header type is evio file (<a class="el" href="../../df/dd8/classevio_1_1_header_type.html#a3d8831bdc7439f38987e017528f87462">HeaderType#EVIO_FILE</a>). Any dictionary will be placed in the user header which will create a conflict if user tries to call <a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a3974c139f38b0a73bf8f7dc51367a2d1">open(const std::string &amp;, uint8_t *, uint32_t)</a> with another user header array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>byte order of written file. </td></tr>
    <tr><td class="paramname">maxEventCount</td><td>max number of events a record can hold. Value of O means use default (1M). </td></tr>
    <tr><td class="paramname">maxBufferSize</td><td>max number of uncompressed data bytes a record can hold. Value of &lt; 8MB results in default of 8MB. </td></tr>
    <tr><td class="paramname">compType</td><td>type of data compression to do (one, lz4 fast, lz4 best, gzip). </td></tr>
    <tr><td class="paramname">compressionThreads</td><td>number of threads doing compression simultaneously. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a756450758e08def3dcc61fb7a2e085b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756450758e08def3dcc61fb7a2e085b3">&#9670;&nbsp;</a></span>WriterMT() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">evio::WriterMT::WriterMT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/dd8/classevio_1_1_header_type.html">HeaderType</a> &amp;&#160;</td>
          <td class="paramname"><em>hType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#ae70d8b2df728e3776bb6bb843260bb71">ByteOrder::ENDIAN_LITTLE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxEventCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxBufferSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dictionary</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>firstEvent</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstEventLen</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747">Compressor::CompressionType</a>&#160;</td>
          <td class="paramname"><em>compType</em> = <code><a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747a056585718cbf5c7808c0e37b1f88dbb9">Compressor::UNCOMPRESSED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>compressionThreads</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addTrailerIndex</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ringSize</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with byte order. </p>
<p>The given file is opened so any subsequent call to open will fail. This method places the dictionary and first event into the file header's user header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hType</td><td>the type of the file. If set to <a class="el" href="../../df/dd8/classevio_1_1_header_type.html#a7f4853d824b7a00c226afb9146fa9927">HeaderType#HIPO_FILE</a>, the header will be written with the first 4 bytes set to HIPO. </td></tr>
    <tr><td class="paramname">order</td><td>byte order of written file. </td></tr>
    <tr><td class="paramname">maxEventCount</td><td>max number of events a record can hold. Value of O means use default (1M). </td></tr>
    <tr><td class="paramname">maxBufferSize</td><td>max number of uncompressed data bytes a record can hold. Value of &lt; 8MB results in default of 8MB. </td></tr>
    <tr><td class="paramname">dictionary</td><td>string holding an evio format dictionary to be placed in userHeader. </td></tr>
    <tr><td class="paramname">firstEvent</td><td>byte array containing an evio event to be included in userHeader. It must be in the same byte order as the order argument. </td></tr>
    <tr><td class="paramname">firstEventLen</td><td>number of valid bytes in firstEvent. </td></tr>
    <tr><td class="paramname">compType</td><td>type of data compression to do (one, lz4 fast, lz4 best, gzip) </td></tr>
    <tr><td class="paramname">compressionThreads</td><td>number of threads doing compression simultaneously </td></tr>
    <tr><td class="paramname">addTrailerIndex</td><td>if true, we add a record index to the trailer. </td></tr>
    <tr><td class="paramname">ringSize</td><td>number of records in supply ring, must be multiple of 2 and &gt;= compressionThreads. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a0e09d731589bcfe2705d0c606192f6eb">evio::RecordHeader::HEADER_SIZE_BYTES</a>, and <a class="el" href="../../df/dd8/classevio_1_1_header_type.html#a7f4853d824b7a00c226afb9146fa9927">evio::HeaderType::HIPO_FILE</a>.</p>

</div>
</div>
<a id="a6d41af0c23a70a4275baac708184c333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d41af0c23a70a4275baac708184c333">&#9670;&nbsp;</a></span>WriterMT() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">evio::WriterMT::WriterMT </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with filename. </p>
<p>The output file will be created with no user header. File byte order is little endian. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>output file name </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a1f585f15aa1b56884dc8612eb5072e0d">open()</a>.</p>

</div>
</div>
<a id="ac87e7c1c6f3f488b5baff39fa6762679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87e7c1c6f3f488b5baff39fa6762679">&#9670;&nbsp;</a></span>WriterMT() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">evio::WriterMT::WriterMT </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxEventCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747">Compressor::CompressionType</a>&#160;</td>
          <td class="paramname"><em>compType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>compressionThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor with filename &amp; byte order. </p>
<p>The output file will be created with no user header. Ring size is 16.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>output file name </td></tr>
    <tr><td class="paramname">order</td><td>byte order of written file or null for default (little endian) </td></tr>
    <tr><td class="paramname">maxEventCount</td><td>max number of events a record can hold. Value of O means use default (1M). </td></tr>
    <tr><td class="paramname">maxBufferSize</td><td>max number of uncompressed data bytes a record can hold. Value of &lt; 8MB results in default of 8MB. </td></tr>
    <tr><td class="paramname">compType</td><td>type of data compression to do (0=none, 1=lz4 fast, 2=lz4 best, 3=gzip) </td></tr>
    <tr><td class="paramname">compressionThreads</td><td>number of threads doing compression simultaneously </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a1f585f15aa1b56884dc8612eb5072e0d">open()</a>.</p>

</div>
</div>
<a id="a19e17694d785f9cb315fbb8bb45dd98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e17694d785f9cb315fbb8bb45dd98e">&#9670;&nbsp;</a></span>~WriterMT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">evio::WriterMT::~WriterMT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a904111fb56c2dad2141173754827994b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904111fb56c2dad2141173754827994b">&#9670;&nbsp;</a></span>addEvent() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::WriterMT::addEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> to the internal record. </p>
<p>If the length of the buffer exceeds the maximum size of the record, the record will be written to the file (compressed if the flag is set). Internal record will be reset to receive new buffers. Using this method in conjunction with <a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a9185ec115b3b04111345b53c7fa64190" title="Appends the record to the file.">writeRecord()</a> is not thread-safe. <b>The byte order of event's data must match the byte order given in constructor!</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>array to add to the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if cannot write to file or buffer arg's byte order is wrong. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a3d5f0120189717ffc8d2d480d89cb91a">evio::ByteBuffer::order()</a>.</p>

</div>
</div>
<a id="a329d5fd7ee27378b2d532e715742bd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329d5fd7ee27378b2d532e715742bd87">&#9670;&nbsp;</a></span>addEvent() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::WriterMT::addEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html" title="This class is used to store relevant info about an evio container (bank, segment, or tag segment),...">EvioNode</a> to the internal record. </p>
<p>If the length of the data exceeds the maximum size of the record, the record will be written to the file (compressed if the flag is set). Internal record will be reset to receive new buffers. Using this method in conjunction with <a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a9185ec115b3b04111345b53c7fa64190" title="Appends the record to the file.">writeRecord()</a> is not thread-safe. <b>The byte order of node's data must match the byte order given in constructor!</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>node to add to the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if cannot write to file or node arg's byte order is wrong. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html#a62277033890518669c730a7b41296ec6">evio::EvioNode::getBuffer()</a>.</p>

</div>
</div>
<a id="a78421457d086cf500d64150da99c6505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78421457d086cf500d64150da99c6505">&#9670;&nbsp;</a></span>addEvent() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::WriterMT::addEvent </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a byte array to the current internal record. </p>
<p>If the length of the buffer exceeds the maximum size of the record, the record will be written to the file (compressed if the flag is set). And another record will be obtained from the supply to receive the buffer. Using this method in conjunction with <a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a9185ec115b3b04111345b53c7fa64190">writeRecord(RecordOutput &amp;)</a> is not thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>array to add to the file. </td></tr>
    <tr><td class="paramname">offset</td><td>offset into array from which to start writing data. </td></tr>
    <tr><td class="paramname">length</td><td>number of bytes to write from array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a602ade27297bb163f4c85452d7b3d0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602ade27297bb163f4c85452d7b3d0ec">&#9670;&nbsp;</a></span>addTrailer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::WriterMT::addTrailer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this writer add a trailer to the end of the file/buffer? </p>
<dl class="section return"><dt>Returns</dt><dd>true if this writer adds a trailer to the end of the file/buffer, else false. </dd></dl>

</div>
</div>
<a id="af9f6fb10f2b791d56a2a86356e404b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f6fb10f2b791d56a2a86356e404b25">&#9670;&nbsp;</a></span>addTrailer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::WriterMT::addTrailer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether this writer adds a trailer to the end of the file/buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">add</td><td>if true, at the end of file/buffer, add an ending header (trailer) with no index of records and no following data. Update the file header to contain a file offset to the trailer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af121e05d362ecaef240c67a3dd7fd33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af121e05d362ecaef240c67a3dd7fd33d">&#9670;&nbsp;</a></span>addTrailerWithIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::WriterMT::addTrailerWithIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this writer add a trailer with a record index to the end of the file? Or, if writing to a buffer, is a trailer added with no index? </p>
<dl class="section return"><dt>Returns</dt><dd>if writing to a file: true if this writer adds a trailer with a record index to the end of the file, else false. If writing to a buffer, true if this writer adds a traile to the end of the buffer, else false. </dd></dl>

</div>
</div>
<a id="a5b0363d26c10365ac6bb115298c137d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0363d26c10365ac6bb115298c137d0">&#9670;&nbsp;</a></span>addTrailerWithIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::WriterMT::addTrailerWithIndex </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addTrailingIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether this writer adds a trailer with a record index to the end of the file. </p>
<p>Or, if writing to a buffer, set whether a trailer is added with no index. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addTrailingIndex</td><td>if true, at the end of file, add an ending header (trailer) with an index of all records but with no following data. Update the file header to contain a file offset to the trailer. If true, and writing to a buffer, add a trailer with no index to the end of the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0647993716e981fbedd6040f80114048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0647993716e981fbedd6040f80114048">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::WriterMT::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close opened file. </p>
<p>If the output record contains events, they will be flushed to file. Trailer and its optional index written if requested.</p>
<p><b>The addEvent or addRecord methods must no longer be called.</b> </p>

<p class="reference">References <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#ae4055f708921d4e6540ab4662d27147c">evio::ByteOrder::ENDIAN_LOCAL</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a13a655d1b16e70688ec555e1f6cd7f5b">evio::FileHeader::RECORD_COUNT_OFFSET</a>, and <a class="el" href="../../d1/d02/_byte_order_8h.html#a700fb30611761c46a674a45cc28ff561">SWAP_32</a>.</p>

</div>
</div>
<a id="a8524b1765b4c4f8ac7ed7eff80b56af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8524b1765b4c4f8ac7ed7eff80b56af7">&#9670;&nbsp;</a></span>createHeader() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; evio::WriterMT::createHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>userHdr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a buffer with a general file header followed by the given user header (userHdr). </p>
<p>The buffer is cleared and set to desired byte order prior to writing. If user header is not padded to 4-byte boundary, it's done here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userHdr</td><td>buffer containing a user-defined header which must be READY-TO-READ! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer containing a file header followed by the user-defined header. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if writing to buffer, not file. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#aa0e335238a57eaa0bffee8f968e5995f">evio::ByteBuffer::array()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#abf7abf99aa7544601997f40eba298648">evio::ByteBuffer::arrayOffset()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a01c1f92000c5a0f3b2f11b0c0e5e3a74">evio::FileHeader::getLength()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a60a8eab054b6f02e84d8975e3aa436b9">evio::FileHeader::HEADER_SIZE_BYTES</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a88f84e6b1757db70542eac13294fc80e">evio::ByteBuffer::position()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a32b043081cd3a62187f2577ce2966e7d">evio::ByteBuffer::remaining()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#af318676a4ffce0023d1bf669bb44cf31">evio::FileHeader::reset()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#ade550a2cc97d77fe89f81941a3e92fcc">evio::FileHeader::setBitInfo()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a5d19dfdbc256c2bf9025795442cb59ff">evio::FileHeader::setUserHeaderLength()</a>, and <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#aabd952c177a47ed7875b6c9d988bff8e">evio::FileHeader::writeHeader()</a>.</p>

</div>
</div>
<a id="abe4a6ab09bc138dbd08057262b87d77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4a6ab09bc138dbd08057262b87d77b">&#9670;&nbsp;</a></span>createHeader() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; evio::WriterMT::createHeader </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>userHdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>userLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return a buffer containing a general file header followed by the user header given in the argument. </p>
<p>If user header is not padded to 4-byte boundary, it's done here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userHdr</td><td>byte array containing a user-defined header, may be null. </td></tr>
    <tr><td class="paramname">userLen</td><td>array length in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> containing a file header followed by the user-defined header </dd></dl>

<p class="reference">References <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a01c1f92000c5a0f3b2f11b0c0e5e3a74">evio::FileHeader::getLength()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a60a8eab054b6f02e84d8975e3aa436b9">evio::FileHeader::HEADER_SIZE_BYTES</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#af318676a4ffce0023d1bf669bb44cf31">evio::FileHeader::reset()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#ade550a2cc97d77fe89f81941a3e92fcc">evio::FileHeader::setBitInfo()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a5d19dfdbc256c2bf9025795442cb59ff">evio::FileHeader::setUserHeaderLength()</a>, and <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#aabd952c177a47ed7875b6c9d988bff8e">evio::FileHeader::writeHeader()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a3974c139f38b0a73bf8f7dc51367a2d1">open()</a>.</p>

</div>
</div>
<a id="aca66655847ba07efaa2c9d68e5757fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca66655847ba07efaa2c9d68e5757fb5">&#9670;&nbsp;</a></span>getByteOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp; evio::WriterMT::getByteOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the file's byte order. </p>
<dl class="section return"><dt>Returns</dt><dd>file's byte order. </dd></dl>

</div>
</div>
<a id="a507b0794073feaba80658f006e3f8103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507b0794073feaba80658f006e3f8103">&#9670;&nbsp;</a></span>getCompressionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747">Compressor::CompressionType</a> evio::WriterMT::getCompressionType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&zwj;** </p>
<p>&zwj;** Convenience method that gets compression type for the file being written. </p><dl class="section return"><dt>Returns</dt><dd>compression type for the file being written. </dd></dl>

</div>
</div>
<a id="a68b05c4f9a45ec56f9c5594d513da6d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b05c4f9a45ec56f9c5594d513da6d1">&#9670;&nbsp;</a></span>getFileHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da6/classevio_1_1_file_header.html">FileHeader</a> &amp; evio::WriterMT::getFileHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the file header. </p>
<dl class="section return"><dt>Returns</dt><dd>file header. </dd></dl>

</div>
</div>
<a id="a1f585f15aa1b56884dc8612eb5072e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f585f15aa1b56884dc8612eb5072e0d">&#9670;&nbsp;</a></span>open() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::WriterMT::open </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a new file and write file header with no user header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>output file name </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if open already called without being followed by calling close. </td></tr>
    <tr><td class="paramname">IOException</td><td>if file cannot be found or IO error writing to file </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a6d41af0c23a70a4275baac708184c333">WriterMT()</a>.</p>

</div>
</div>
<a id="a3974c139f38b0a73bf8f7dc51367a2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3974c139f38b0a73bf8f7dc51367a2d1">&#9670;&nbsp;</a></span>open() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::WriterMT::open </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>userHdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>userLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file and write file header with given user header. </p>
<p>User header is automatically padded when written. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>name of file to write to. </td></tr>
    <tr><td class="paramname">userHdr</td><td>byte array representing the optional user's header. If this is null AND dictionary and/or first event are given, the dictionary and/or first event will be placed in its own record and written as the user header. </td></tr>
    <tr><td class="paramname">userLen</td><td>length of userHdr in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if filename arg is bad, or if <a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a1f585f15aa1b56884dc8612eb5072e0d" title="Open a new file and write file header with no user header.">open()</a> was already called without being followed by <a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#adebafad3524a67dae57ff4a50c991229" title="Get this object ready for re-use.">reset()</a>. </td></tr>
    <tr><td class="paramname">IOException</td><td>if file cannot be found or IO error writing to file </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#abe4a6ab09bc138dbd08057262b87d77b">createHeader()</a>, and <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a01c1f92000c5a0f3b2f11b0c0e5e3a74">evio::FileHeader::getLength()</a>.</p>

</div>
</div>
<a id="adebafad3524a67dae57ff4a50c991229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adebafad3524a67dae57ff4a50c991229">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::WriterMT::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get this object ready for re-use. </p>
<p>Follow calling this with call to <a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a1f585f15aa1b56884dc8612eb5072e0d">open(const std::string &amp;)</a>. </p>

<p class="reference">References <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#af318676a4ffce0023d1bf669bb44cf31">evio::FileHeader::reset()</a>.</p>

</div>
</div>
<a id="a9185ec115b3b04111345b53c7fa64190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9185ec115b3b04111345b53c7fa64190">&#9670;&nbsp;</a></span>writeRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::WriterMT::writeRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d7a/classevio_1_1_record_output.html">RecordOutput</a> &amp;&#160;</td>
          <td class="paramname"><em>rec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the record to the file. </p>
<p>Using this method in conjunction with <a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html#a78421457d086cf500d64150da99c6505">addEvent()</a> is not thread-safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>record object </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if record's byte order is opposite to output endian. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d2/d7a/classevio_1_1_record_output.html#a7d31fb593c433d6c5be6961a5b43d1da">evio::RecordOutput::getByteOrder()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="../../dd/db4/_writer_m_t_8h.html">WriterMT.h</a></li>
<li><a class="el" href="../../d9/d77/_writer_m_t_8cpp.html">WriterMT.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d9/deb/namespaceevio.html">evio</a></li><li class="navelem"><a class="el" href="../../d1/d17/classevio_1_1_writer_m_t.html">WriterMT</a></li>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
