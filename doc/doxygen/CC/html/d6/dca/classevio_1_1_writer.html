<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>evio: evio::Writer Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">evio
   &#160;<span id="projectnumber">6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d6/dca/classevio_1_1_writer.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="../../d5/d52/classevio_1_1_writer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">evio::Writer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to write Evio-6.0/HIPO files.  
 <a href="../../d6/dca/classevio_1_1_writer.html#details">More...</a></p>

<p><code>#include &lt;Writer.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad828f46b2331b87aab0574c78c082a91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#ad828f46b2331b87aab0574c78c082a91">Writer</a> ()</td></tr>
<tr class="memdesc:ad828f46b2331b87aab0574c78c082a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="../../d6/dca/classevio_1_1_writer.html#ad828f46b2331b87aab0574c78c082a91">More...</a><br /></td></tr>
<tr class="separator:ad828f46b2331b87aab0574c78c082a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c367e6ba0f85d3af97248bdc1073d17"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a2c367e6ba0f85d3af97248bdc1073d17">Writer</a> (const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;order, uint32_t maxEventCount=0, uint32_t maxBufferSize=0)</td></tr>
<tr class="memdesc:a2c367e6ba0f85d3af97248bdc1073d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with byte order.  <a href="../../d6/dca/classevio_1_1_writer.html#a2c367e6ba0f85d3af97248bdc1073d17">More...</a><br /></td></tr>
<tr class="separator:a2c367e6ba0f85d3af97248bdc1073d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534f719986ce36c188092faec39c2c27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a534f719986ce36c188092faec39c2c27">Writer</a> (const std::string &amp;filename, const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;order, uint32_t maxEventCount=0, uint32_t maxBufferSize=0)</td></tr>
<tr class="memdesc:a534f719986ce36c188092faec39c2c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with filename &amp; byte order.  <a href="../../d6/dca/classevio_1_1_writer.html#a534f719986ce36c188092faec39c2c27">More...</a><br /></td></tr>
<tr class="separator:a534f719986ce36c188092faec39c2c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314152ebeaa8d198bfc59206a73b457e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a314152ebeaa8d198bfc59206a73b457e">Writer</a> (const <a class="el" href="../../df/dd8/classevio_1_1_header_type.html">HeaderType</a> &amp;hType, const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;order=<a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#ae4055f708921d4e6540ab4662d27147c">ByteOrder::ENDIAN_LOCAL</a>, uint32_t maxEventCount=0, uint32_t maxBufferSize=0, const std::string &amp;dictionary=std::string(&quot;&quot;), uint8_t *firstEvent=nullptr, uint32_t firstEventLength=0, const <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747">Compressor::CompressionType</a> &amp;compressionType=<a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747a056585718cbf5c7808c0e37b1f88dbb9">Compressor::UNCOMPRESSED</a>, bool addTrailerIndex=false)</td></tr>
<tr class="memdesc:a314152ebeaa8d198bfc59206a73b457e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with byte order.  <a href="../../d6/dca/classevio_1_1_writer.html#a314152ebeaa8d198bfc59206a73b457e">More...</a><br /></td></tr>
<tr class="separator:a314152ebeaa8d198bfc59206a73b457e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27adfed8319c149db4b3449e63388dc4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a27adfed8319c149db4b3449e63388dc4">Writer</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buf)</td></tr>
<tr class="memdesc:a27adfed8319c149db4b3449e63388dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for writing to a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a>.  <a href="../../d6/dca/classevio_1_1_writer.html#a27adfed8319c149db4b3449e63388dc4">More...</a><br /></td></tr>
<tr class="separator:a27adfed8319c149db4b3449e63388dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb308f6970fdf9a68bf3fd5141e3e9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a6fb308f6970fdf9a68bf3fd5141e3e9d">Writer</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buf, uint8_t *userHdr, uint32_t len)</td></tr>
<tr class="memdesc:a6fb308f6970fdf9a68bf3fd5141e3e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with user header.  <a href="../../d6/dca/classevio_1_1_writer.html#a6fb308f6970fdf9a68bf3fd5141e3e9d">More...</a><br /></td></tr>
<tr class="separator:a6fb308f6970fdf9a68bf3fd5141e3e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae083beacbd2abb831e6a5503d9aaaf6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#ae083beacbd2abb831e6a5503d9aaaf6e">Writer</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buf, uint32_t maxEventCount, uint32_t maxBufferSize, const std::string &amp;dictionary, uint8_t *firstEvent, uint32_t firstEventLength)</td></tr>
<tr class="memdesc:ae083beacbd2abb831e6a5503d9aaaf6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with byte order.  <a href="../../d6/dca/classevio_1_1_writer.html#ae083beacbd2abb831e6a5503d9aaaf6e">More...</a><br /></td></tr>
<tr class="separator:ae083beacbd2abb831e6a5503d9aaaf6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e500bdfd12a357a6f443def5187b675"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a1e500bdfd12a357a6f443def5187b675">~Writer</a> ()=default</td></tr>
<tr class="separator:a1e500bdfd12a357a6f443def5187b675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08c22b469bb85b6065876ad2f9482a3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#aa08c22b469bb85b6065876ad2f9482a3">getByteOrder</a> () const</td></tr>
<tr class="memdesc:aa08c22b469bb85b6065876ad2f9482a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file's byte order.  <a href="../../d6/dca/classevio_1_1_writer.html#aa08c22b469bb85b6065876ad2f9482a3">More...</a><br /></td></tr>
<tr class="separator:aa08c22b469bb85b6065876ad2f9482a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7584e8ce135dbed869f4e247e371ee75"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a7584e8ce135dbed869f4e247e371ee75">getBuffer</a> ()</td></tr>
<tr class="memdesc:a7584e8ce135dbed869f4e247e371ee75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer being written to.  <a href="../../d6/dca/classevio_1_1_writer.html#a7584e8ce135dbed869f4e247e371ee75">More...</a><br /></td></tr>
<tr class="separator:a7584e8ce135dbed869f4e247e371ee75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8675f4a700a8b0a65fad0c2b7a192940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da6/classevio_1_1_file_header.html">FileHeader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a8675f4a700a8b0a65fad0c2b7a192940">getFileHeader</a> ()</td></tr>
<tr class="memdesc:a8675f4a700a8b0a65fad0c2b7a192940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file header.  <a href="../../d6/dca/classevio_1_1_writer.html#a8675f4a700a8b0a65fad0c2b7a192940">More...</a><br /></td></tr>
<tr class="separator:a8675f4a700a8b0a65fad0c2b7a192940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b693782520a223345fcafead7b4b5c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747">Compressor::CompressionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a4b693782520a223345fcafead7b4b5c0">getCompressionType</a> ()</td></tr>
<tr class="memdesc:a4b693782520a223345fcafead7b4b5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">&zwj;**  <a href="../../d6/dca/classevio_1_1_writer.html#a4b693782520a223345fcafead7b4b5c0">More...</a><br /></td></tr>
<tr class="separator:a4b693782520a223345fcafead7b4b5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278331c3a1a91c7a7584fea9f4910d5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a278331c3a1a91c7a7584fea9f4910d5d">setCompressionType</a> (<a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747">Compressor::CompressionType</a> compression)</td></tr>
<tr class="memdesc:a278331c3a1a91c7a7584fea9f4910d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method that sets compression type for the file.  <a href="../../d6/dca/classevio_1_1_writer.html#a278331c3a1a91c7a7584fea9f4910d5d">More...</a><br /></td></tr>
<tr class="separator:a278331c3a1a91c7a7584fea9f4910d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab328948eb2cb9e6297ef750977696073"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#ab328948eb2cb9e6297ef750977696073">addTrailer</a> () const</td></tr>
<tr class="memdesc:ab328948eb2cb9e6297ef750977696073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this writer add a trailer to the end of the file/buffer?  <a href="../../d6/dca/classevio_1_1_writer.html#ab328948eb2cb9e6297ef750977696073">More...</a><br /></td></tr>
<tr class="separator:ab328948eb2cb9e6297ef750977696073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ebda27c326a58279d963f609112299"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a43ebda27c326a58279d963f609112299">addTrailer</a> (bool add)</td></tr>
<tr class="memdesc:a43ebda27c326a58279d963f609112299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether this writer adds a trailer to the end of the file/buffer.  <a href="../../d6/dca/classevio_1_1_writer.html#a43ebda27c326a58279d963f609112299">More...</a><br /></td></tr>
<tr class="separator:a43ebda27c326a58279d963f609112299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c8c23225cf435c9f78f58f8149c4b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#af5c8c23225cf435c9f78f58f8149c4b7">addTrailerWithIndex</a> ()</td></tr>
<tr class="memdesc:af5c8c23225cf435c9f78f58f8149c4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this writer add a trailer with a record index to the end of the file? Or, if writing to a buffer, is a trailer added with no index?  <a href="../../d6/dca/classevio_1_1_writer.html#af5c8c23225cf435c9f78f58f8149c4b7">More...</a><br /></td></tr>
<tr class="separator:af5c8c23225cf435c9f78f58f8149c4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5ad142e4aa10f4cbdd3b0191a964db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#afe5ad142e4aa10f4cbdd3b0191a964db">addTrailerWithIndex</a> (bool addTrailingIndex)</td></tr>
<tr class="memdesc:afe5ad142e4aa10f4cbdd3b0191a964db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether this writer adds a trailer with a record index to the end of the file.  <a href="../../d6/dca/classevio_1_1_writer.html#afe5ad142e4aa10f4cbdd3b0191a964db">More...</a><br /></td></tr>
<tr class="separator:afe5ad142e4aa10f4cbdd3b0191a964db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f64043951e4d8ff7f186fced75052fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a1f64043951e4d8ff7f186fced75052fb">open</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a1f64043951e4d8ff7f186fced75052fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a new file and write file header with no user header.  <a href="../../d6/dca/classevio_1_1_writer.html#a1f64043951e4d8ff7f186fced75052fb">More...</a><br /></td></tr>
<tr class="separator:a1f64043951e4d8ff7f186fced75052fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec66f6f92fa30daa2f9546d2920dbbfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#aec66f6f92fa30daa2f9546d2920dbbfe">open</a> (const std::string &amp;filename, uint8_t *userHdr, uint32_t len)</td></tr>
<tr class="memdesc:aec66f6f92fa30daa2f9546d2920dbbfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file and write file header with given user header.  <a href="../../d6/dca/classevio_1_1_writer.html#aec66f6f92fa30daa2f9546d2920dbbfe">More...</a><br /></td></tr>
<tr class="separator:aec66f6f92fa30daa2f9546d2920dbbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ed6382f82d976aef36ac78d6a001fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a04ed6382f82d976aef36ac78d6a001fc">open</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buf, uint8_t *userHdr, uint32_t len)</td></tr>
<tr class="memdesc:a04ed6382f82d976aef36ac78d6a001fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a buffer and write first record header with given user header.  <a href="../../d6/dca/classevio_1_1_writer.html#a04ed6382f82d976aef36ac78d6a001fc">More...</a><br /></td></tr>
<tr class="separator:a04ed6382f82d976aef36ac78d6a001fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f50661587a8f13e7729183b2203299"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a32f50661587a8f13e7729183b2203299">createHeader</a> (uint8_t *userHdr, uint32_t userLen)</td></tr>
<tr class="memdesc:a32f50661587a8f13e7729183b2203299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a buffer containing a general file header followed by the user header given in the argument.  <a href="../../d6/dca/classevio_1_1_writer.html#a32f50661587a8f13e7729183b2203299">More...</a><br /></td></tr>
<tr class="separator:a32f50661587a8f13e7729183b2203299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26490309dbaa26d08de3c2151f9d0391"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a26490309dbaa26d08de3c2151f9d0391">createHeader</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;userHdr)</td></tr>
<tr class="memdesc:a26490309dbaa26d08de3c2151f9d0391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a buffer containing a general file header followed by the user header given in the argument.  <a href="../../d6/dca/classevio_1_1_writer.html#a26490309dbaa26d08de3c2151f9d0391">More...</a><br /></td></tr>
<tr class="separator:a26490309dbaa26d08de3c2151f9d0391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade85d05f573c665b7221bc62e56b1524"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#ade85d05f573c665b7221bc62e56b1524">createHeader</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;buf, uint8_t *userHdr, uint32_t userLen)</td></tr>
<tr class="memdesc:ade85d05f573c665b7221bc62e56b1524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill given buffer with a general file header followed by the given user header.  <a href="../../d6/dca/classevio_1_1_writer.html#ade85d05f573c665b7221bc62e56b1524">More...</a><br /></td></tr>
<tr class="separator:ade85d05f573c665b7221bc62e56b1524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b3407887a26d5c2d78d3e3cdfbad55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a84b3407887a26d5c2d78d3e3cdfbad55">createHeader</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;buf, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;userHdr)</td></tr>
<tr class="memdesc:a84b3407887a26d5c2d78d3e3cdfbad55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill given buffer (buf) with a general file header followed by the given user header (userHdr).  <a href="../../d6/dca/classevio_1_1_writer.html#a84b3407887a26d5c2d78d3e3cdfbad55">More...</a><br /></td></tr>
<tr class="separator:a84b3407887a26d5c2d78d3e3cdfbad55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0f549a6ceaae794eca73130957a23d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a0d0f549a6ceaae794eca73130957a23d">writeRecord</a> (<a class="el" href="../../d2/d7a/classevio_1_1_record_output.html">RecordOutput</a> &amp;record)</td></tr>
<tr class="memdesc:a0d0f549a6ceaae794eca73130957a23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the record to the file/buffer.  <a href="../../d6/dca/classevio_1_1_writer.html#a0d0f549a6ceaae794eca73130957a23d">More...</a><br /></td></tr>
<tr class="separator:a0d0f549a6ceaae794eca73130957a23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4737e1b27c07329fbb869fbead1f56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a3f4737e1b27c07329fbb869fbead1f56">addEvent</a> (uint8_t *buffer, uint32_t length)</td></tr>
<tr class="memdesc:a3f4737e1b27c07329fbb869fbead1f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a byte array to the internal record.  <a href="../../d6/dca/classevio_1_1_writer.html#a3f4737e1b27c07329fbb869fbead1f56">More...</a><br /></td></tr>
<tr class="separator:a3f4737e1b27c07329fbb869fbead1f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b5464a56d40798b28ac0781e82f8e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a49b5464a56d40798b28ac0781e82f8e2">addEvent</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buffer)</td></tr>
<tr class="memdesc:a49b5464a56d40798b28ac0781e82f8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> to the internal record.  <a href="../../d6/dca/classevio_1_1_writer.html#a49b5464a56d40798b28ac0781e82f8e2">More...</a><br /></td></tr>
<tr class="separator:a49b5464a56d40798b28ac0781e82f8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ffba4ec1fb3578d67bf23ebeeabff3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#ad0ffba4ec1fb3578d67bf23ebeeabff3">addEvent</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;buffer)</td></tr>
<tr class="memdesc:ad0ffba4ec1fb3578d67bf23ebeeabff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> to the internal record.  <a href="../../d6/dca/classevio_1_1_writer.html#ad0ffba4ec1fb3578d67bf23ebeeabff3">More...</a><br /></td></tr>
<tr class="separator:ad0ffba4ec1fb3578d67bf23ebeeabff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e58e3e003459f38dbaafb3cbf82238b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a0e58e3e003459f38dbaafb3cbf82238b">addEvent</a> (std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt; &amp;bank)</td></tr>
<tr class="memdesc:a0e58e3e003459f38dbaafb3cbf82238b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html" title="This holds a CODA Bank structure.">EvioBank</a> to the internal record.  <a href="../../d6/dca/classevio_1_1_writer.html#a0e58e3e003459f38dbaafb3cbf82238b">More...</a><br /></td></tr>
<tr class="separator:a0e58e3e003459f38dbaafb3cbf82238b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad1f6131e62b255f7aac6873087740e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a1ad1f6131e62b255f7aac6873087740e">addEvent</a> (std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; &amp;node)</td></tr>
<tr class="memdesc:a1ad1f6131e62b255f7aac6873087740e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html" title="This class is used to store relevant info about an evio container (bank, segment, or tag segment),...">EvioNode</a> to the internal record.  <a href="../../d6/dca/classevio_1_1_writer.html#a1ad1f6131e62b255f7aac6873087740e">More...</a><br /></td></tr>
<tr class="separator:a1ad1f6131e62b255f7aac6873087740e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d7e291d85d61a6343ac6a40e7902cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a39d7e291d85d61a6343ac6a40e7902cf">addEvent</a> (<a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &amp;node)</td></tr>
<tr class="memdesc:a39d7e291d85d61a6343ac6a40e7902cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html" title="This class is used to store relevant info about an evio container (bank, segment, or tag segment),...">EvioNode</a> to the internal record.  <a href="../../d6/dca/classevio_1_1_writer.html#a39d7e291d85d61a6343ac6a40e7902cf">More...</a><br /></td></tr>
<tr class="separator:a39d7e291d85d61a6343ac6a40e7902cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cd4aa42143d1f6578422f6ef36151a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a17cd4aa42143d1f6578422f6ef36151a">reset</a> ()</td></tr>
<tr class="memdesc:a17cd4aa42143d1f6578422f6ef36151a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this object ready for re-use.  <a href="../../d6/dca/classevio_1_1_writer.html#a17cd4aa42143d1f6578422f6ef36151a">More...</a><br /></td></tr>
<tr class="separator:a17cd4aa42143d1f6578422f6ef36151a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f01bf28c0d2910947fca9a841a1fc7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#a8f01bf28c0d2910947fca9a841a1fc7b">close</a> ()</td></tr>
<tr class="memdesc:a8f01bf28c0d2910947fca9a841a1fc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close opened file.  <a href="../../d6/dca/classevio_1_1_writer.html#a8f01bf28c0d2910947fca9a841a1fc7b">More...</a><br /></td></tr>
<tr class="separator:a8f01bf28c0d2910947fca9a841a1fc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acaf968c34f10e8004994a91175e5a829"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dca/classevio_1_1_writer.html#acaf968c34f10e8004994a91175e5a829">createRecord</a> (const std::string &amp;dictionary, uint8_t *firstEvent, uint32_t firstEventLen, const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;byteOrder, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html">FileHeader</a> *fileHeader, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html">RecordHeader</a> *recordHeader)</td></tr>
<tr class="memdesc:acaf968c34f10e8004994a91175e5a829"><td class="mdescLeft">&#160;</td><td class="mdescRight">STATIC.  <a href="../../d6/dca/classevio_1_1_writer.html#acaf968c34f10e8004994a91175e5a829">More...</a><br /></td></tr>
<tr class="separator:acaf968c34f10e8004994a91175e5a829"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to write Evio-6.0/HIPO files. </p>
<dl class="section version"><dt>Version</dt><dd>6.0 </dd></dl>
<dl class="section since"><dt>Since</dt><dd>6.0 8/10/17 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>timmer </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad828f46b2331b87aab0574c78c082a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad828f46b2331b87aab0574c78c082a91">&#9670;&nbsp;</a></span>Writer() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">evio::Writer::Writer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p><b>No</b> file is opened. Any file will have little endian byte order. </p>

</div>
</div>
<a id="a2c367e6ba0f85d3af97248bdc1073d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c367e6ba0f85d3af97248bdc1073d17">&#9670;&nbsp;</a></span>Writer() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">evio::Writer::Writer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxEventCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxBufferSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with byte order. </p>
<p><b>No</b> file is opened. File header type is evio file (<a class="el" href="../../df/dd8/classevio_1_1_header_type.html#a3d8831bdc7439f38987e017528f87462">HeaderType#EVIO_FILE</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>byte order of written file. </td></tr>
    <tr><td class="paramname">maxEventCount</td><td>max number of events a record can hold. Value of O means use default (1M). </td></tr>
    <tr><td class="paramname">maxBufferSize</td><td>max number of uncompressed data bytes a record can hold. Value of &lt; 8MB results in default of 8MB. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a534f719986ce36c188092faec39c2c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534f719986ce36c188092faec39c2c27">&#9670;&nbsp;</a></span>Writer() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">evio::Writer::Writer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxEventCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxBufferSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor with filename &amp; byte order. </p>
<p>The output file will be created with no user header. No compression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>output file name </td></tr>
    <tr><td class="paramname">order</td><td>byte order of written file; </td></tr>
    <tr><td class="paramname">maxEventCount</td><td>max number of events a record can hold. Value of O means use default (1M). </td></tr>
    <tr><td class="paramname">maxBufferSize</td><td>max number of uncompressed data bytes a record can hold. Value of &lt; 8MB results in default of 8MB. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if file cannot be found or IO error writing to file </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d6/dca/classevio_1_1_writer.html#a1f64043951e4d8ff7f186fced75052fb">open()</a>.</p>

</div>
</div>
<a id="a314152ebeaa8d198bfc59206a73b457e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a314152ebeaa8d198bfc59206a73b457e">&#9670;&nbsp;</a></span>Writer() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">evio::Writer::Writer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/dd8/classevio_1_1_header_type.html">HeaderType</a> &amp;&#160;</td>
          <td class="paramname"><em>hType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#ae4055f708921d4e6540ab4662d27147c">ByteOrder::ENDIAN_LOCAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxEventCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxBufferSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dictionary</em> = <code>std::string(&quot;&quot;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>firstEvent</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstEventLen</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747">Compressor::CompressionType</a> &amp;&#160;</td>
          <td class="paramname"><em>compType</em> = <code><a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747a056585718cbf5c7808c0e37b1f88dbb9">Compressor::UNCOMPRESSED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addTrailerIndex</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with byte order. </p>
<p>The given file is opened so any subsequent call to open will fail. This method places the dictionary and first event into the file header's user header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hType</td><td>the type of the file. If set to <a class="el" href="../../df/dd8/classevio_1_1_header_type.html#a7f4853d824b7a00c226afb9146fa9927">HeaderType#HIPO_FILE</a>, the header will be written with the first 4 bytes set to HIPO. </td></tr>
    <tr><td class="paramname">order</td><td>byte order of written file. </td></tr>
    <tr><td class="paramname">maxEventCount</td><td>max number of events a record can hold. Value of O means use default (1M). </td></tr>
    <tr><td class="paramname">maxBufferSize</td><td>max number of uncompressed data bytes a record can hold. Value of &lt; 8MB results in default of 8MB. </td></tr>
    <tr><td class="paramname">dictionary</td><td>string holding an evio format dictionary to be placed in userHeader. </td></tr>
    <tr><td class="paramname">firstEvent</td><td>byte array containing an evio event to be included in userHeader. It must be in the same byte order as the order argument. </td></tr>
    <tr><td class="paramname">firstEventLen</td><td>number of bytes in firstEvent. </td></tr>
    <tr><td class="paramname">compType</td><td>type of data compression to do (one, lz4 fast, lz4 best, gzip) </td></tr>
    <tr><td class="paramname">addTrailerIndex</td><td>if true, we add a record index to the trailer. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a0e09d731589bcfe2705d0c606192f6eb">evio::RecordHeader::HEADER_SIZE_BYTES</a>, and <a class="el" href="../../df/dd8/classevio_1_1_header_type.html#a7f4853d824b7a00c226afb9146fa9927">evio::HeaderType::HIPO_FILE</a>.</p>

</div>
</div>
<a id="a27adfed8319c149db4b3449e63388dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27adfed8319c149db4b3449e63388dc4">&#9670;&nbsp;</a></span>Writer() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">evio::Writer::Writer </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for writing to a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a>. </p>
<p>Byte order is taken from the buffer. No compression. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer in to which to write events and/or records. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fb308f6970fdf9a68bf3fd5141e3e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb308f6970fdf9a68bf3fd5141e3e9d">&#9670;&nbsp;</a></span>Writer() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">evio::Writer::Writer </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>userHdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor with user header. </p>
<p>No compression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer in to which to write events and/or records. </td></tr>
    <tr><td class="paramname">userHdr</td><td>byte array representing the optional user's header. <b>Warning: this will not be used until first record is written! So don't go changing it in the meantime!</b> </td></tr>
    <tr><td class="paramname">len</td><td>length of valid data (bytes) in userHdr (starting at off). </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d6/dca/classevio_1_1_writer.html#a1f64043951e4d8ff7f186fced75052fb">open()</a>.</p>

</div>
</div>
<a id="ae083beacbd2abb831e6a5503d9aaaf6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae083beacbd2abb831e6a5503d9aaaf6e">&#9670;&nbsp;</a></span>Writer() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">evio::Writer::Writer </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxEventCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>firstEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstEventLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor with byte order. </p>
<p>This method places the dictionary and first event into the file header's user header. No compression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer in to which to write events and/or records. </td></tr>
    <tr><td class="paramname">maxEventCount</td><td>max number of events a record can hold. Value of O means use default (1M). </td></tr>
    <tr><td class="paramname">maxBufferSize</td><td>max number of uncompressed data bytes a record can hold. Value of &lt; 8MB results in default of 8MB. </td></tr>
    <tr><td class="paramname">dictionary</td><td>string holding an evio format dictionary to be placed in userHeader. </td></tr>
    <tr><td class="paramname">firstEvent</td><td>byte array containing an evio event to be included in userHeader. It must be in the same byte order as the order argument. </td></tr>
    <tr><td class="paramname">firstEventLen</td><td>number of bytes in firstEvent. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a0e09d731589bcfe2705d0c606192f6eb">evio::RecordHeader::HEADER_SIZE_BYTES</a>, and <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747a056585718cbf5c7808c0e37b1f88dbb9">evio::Compressor::UNCOMPRESSED</a>.</p>

</div>
</div>
<a id="a1e500bdfd12a357a6f443def5187b675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e500bdfd12a357a6f443def5187b675">&#9670;&nbsp;</a></span>~Writer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">evio::Writer::~Writer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad0ffba4ec1fb3578d67bf23ebeeabff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ffba4ec1fb3578d67bf23ebeeabff3">&#9670;&nbsp;</a></span>addEvent() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Writer::addEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> to the internal record. </p>
<p>If the length of the buffer exceeds the maximum size of the record, the record will be written to the file (compressed if the flag is set). Internal record will be reset to receive new buffers. Using this method in conjunction with <a class="el" href="../../d6/dca/classevio_1_1_writer.html#a0d0f549a6ceaae794eca73130957a23d" title="Appends the record to the file/buffer.">writeRecord()</a> is not thread-safe. <b>The byte order of event's data must match the byte order given in constructor!</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer to add to the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if cannot write to file or buf arg's byte order is wrong. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a3d5f0120189717ffc8d2d480d89cb91a">evio::ByteBuffer::order()</a>.</p>

</div>
</div>
<a id="a39d7e291d85d61a6343ac6a40e7902cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d7e291d85d61a6343ac6a40e7902cf">&#9670;&nbsp;</a></span>addEvent() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Writer::addEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html" title="This class is used to store relevant info about an evio container (bank, segment, or tag segment),...">EvioNode</a> to the internal record. </p>
<p>If the length of the data exceeds the maximum size of the record, the record will be written to the file (compressed if the flag is set). Internal record will be reset to receive new buffers. Using this method in conjunction with <a class="el" href="../../d6/dca/classevio_1_1_writer.html#a0d0f549a6ceaae794eca73130957a23d" title="Appends the record to the file/buffer.">writeRecord()</a> is not thread-safe. <b>The byte order of node's data must match the byte order given in constructor!</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>node to add to the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if node does not correspond to a bank. </td></tr>
    <tr><td class="paramname">IOException</td><td>if cannot write to file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49b5464a56d40798b28ac0781e82f8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b5464a56d40798b28ac0781e82f8e2">&#9670;&nbsp;</a></span>addEvent() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Writer::addEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> to the internal record. </p>
<p>If the length of the buffer exceeds the maximum size of the record, the record will be written to the file (compressed if the flag is set). Internal record will be reset to receive new buffers. Using this method in conjunction with <a class="el" href="../../d6/dca/classevio_1_1_writer.html#a0d0f549a6ceaae794eca73130957a23d" title="Appends the record to the file/buffer.">writeRecord()</a> is not thread-safe. <b>The byte order of event's data must match the byte order given in constructor!</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer to add to the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if cannot write to file or buf arg's byte order is wrong. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d6/dca/classevio_1_1_writer.html#a3f4737e1b27c07329fbb869fbead1f56">addEvent()</a>.</p>

</div>
</div>
<a id="a0e58e3e003459f38dbaafb3cbf82238b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e58e3e003459f38dbaafb3cbf82238b">&#9670;&nbsp;</a></span>addEvent() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Writer::addEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html" title="This holds a CODA Bank structure.">EvioBank</a> to the internal record. </p>
<p>If the length of the bank exceeds the maximum size of the record, the record will be written to the file (compressed if the flag is set). Internal record will be reset to receive new buffers. Using this method in conjunction with <a class="el" href="../../d6/dca/classevio_1_1_writer.html#a0d0f549a6ceaae794eca73130957a23d" title="Appends the record to the file/buffer.">writeRecord()</a> is not thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>event to add to the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if cannot write to file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ad1f6131e62b255f7aac6873087740e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad1f6131e62b255f7aac6873087740e">&#9670;&nbsp;</a></span>addEvent() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Writer::addEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html" title="This class is used to store relevant info about an evio container (bank, segment, or tag segment),...">EvioNode</a> to the internal record. </p>
<p>If the length of the data exceeds the maximum size of the record, the record will be written to the file (compressed if the flag is set). Internal record will be reset to receive new buffers. Using this method in conjunction with <a class="el" href="../../d6/dca/classevio_1_1_writer.html#a0d0f549a6ceaae794eca73130957a23d" title="Appends the record to the file/buffer.">writeRecord()</a> is not thread-safe. <b>The byte order of node's data must match the byte order given in constructor!</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>node to add to the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if node does not correspond to a bank. </td></tr>
    <tr><td class="paramname">IOException</td><td>if cannot write to file. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d6/dca/classevio_1_1_writer.html#a3f4737e1b27c07329fbb869fbead1f56">addEvent()</a>.</p>

</div>
</div>
<a id="a3f4737e1b27c07329fbb869fbead1f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4737e1b27c07329fbb869fbead1f56">&#9670;&nbsp;</a></span>addEvent() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Writer::addEvent </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a byte array to the internal record. </p>
<p>If the length of the buffer exceeds the maximum size of the record, the record will be written to the file (compressed if the flag is set). Internal record will be reset to receive new buffers. Using this method in conjunction with <a class="el" href="../../d6/dca/classevio_1_1_writer.html#a0d0f549a6ceaae794eca73130957a23d" title="Appends the record to the file/buffer.">writeRecord()</a> is not thread-safe. <b>The byte order of event's byte array must match the byte order given in constructor!</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer to add to the file. </td></tr>
    <tr><td class="paramname">length</td><td>number of bytes to write from buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if cannot write to file. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="../../d6/dca/classevio_1_1_writer.html#a49b5464a56d40798b28ac0781e82f8e2">addEvent()</a>.</p>

</div>
</div>
<a id="ab328948eb2cb9e6297ef750977696073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab328948eb2cb9e6297ef750977696073">&#9670;&nbsp;</a></span>addTrailer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::Writer::addTrailer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this writer add a trailer to the end of the file/buffer? </p>
<dl class="section return"><dt>Returns</dt><dd>true if this writer adds a trailer to the end of the file/buffer, else false. </dd></dl>

</div>
</div>
<a id="a43ebda27c326a58279d963f609112299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ebda27c326a58279d963f609112299">&#9670;&nbsp;</a></span>addTrailer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Writer::addTrailer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether this writer adds a trailer to the end of the file/buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">add</td><td>if true, at the end of file/buffer, add an ending header (trailer) with no index of records and no following data. Update the file header to contain a file offset to the trailer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5c8c23225cf435c9f78f58f8149c4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c8c23225cf435c9f78f58f8149c4b7">&#9670;&nbsp;</a></span>addTrailerWithIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::Writer::addTrailerWithIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this writer add a trailer with a record index to the end of the file? Or, if writing to a buffer, is a trailer added with no index? </p>
<dl class="section return"><dt>Returns</dt><dd>if writing to a file: true if this writer adds a trailer with a record index to the end of the file, else false. If writing to a buffer, true if this writer adds a traile to the end of the buffer, else false. </dd></dl>

</div>
</div>
<a id="afe5ad142e4aa10f4cbdd3b0191a964db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe5ad142e4aa10f4cbdd3b0191a964db">&#9670;&nbsp;</a></span>addTrailerWithIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Writer::addTrailerWithIndex </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addTrailingIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether this writer adds a trailer with a record index to the end of the file. </p>
<p>Or, if writing to a buffer, set whether a trailer is added with no index. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addTrailingIndex</td><td>if true, at the end of file, add an ending header (trailer) with an index of all records but with no following data. Update the file header to contain a file offset to the trailer. If true, and writing to a buffer, add a trailer with no index to the end of the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f01bf28c0d2910947fca9a841a1fc7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f01bf28c0d2910947fca9a841a1fc7b">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Writer::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close opened file. </p>
<p>If the output record contains events, they will be flushed to file/buffer. Trailer and its optional index written if requested. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if error writing to file </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#ac420593fe475899308138f3bd98e5f38">evio::RecordHeader::BIT_INFO_OFFSET</a>, <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#ae4055f708921d4e6540ab4662d27147c">evio::ByteOrder::ENDIAN_LOCAL</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a893b59302d5f0b77733da2deb85e15b8">evio::FileHeader::hasTrailerWithIndex()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a13a655d1b16e70688ec555e1f6cd7f5b">evio::FileHeader::RECORD_COUNT_OFFSET</a>, <a class="el" href="../../d1/d02/_byte_order_8h.html#a700fb30611761c46a674a45cc28ff561">SWAP_32</a>, <a class="el" href="../../d1/d02/_byte_order_8h.html#a8021644ad809413f98b4093a341b2041">SWAP_64</a>, and <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#ac89e616aa3a757d6f32bee153048983f">evio::FileHeader::TRAILER_POSITION_OFFSET</a>.</p>

</div>
</div>
<a id="a84b3407887a26d5c2d78d3e3cdfbad55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b3407887a26d5c2d78d3e3cdfbad55">&#9670;&nbsp;</a></span>createHeader() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Writer::createHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>userHdr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill given buffer (buf) with a general file header followed by the given user header (userHdr). </p>
<p>The buffer is cleared and set to desired byte order prior to writing. If user header is not padded to 4-byte boundary, it's done here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer to contain the file header followed by the user-defined header. </td></tr>
    <tr><td class="paramname">userHdr</td><td>buffer containing a user-defined header which must be READY-TO-READ! </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if writing to buffer, or buf too small (needs to be userHdr.remaining() + <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a60a8eab054b6f02e84d8975e3aa436b9" title="Number of bytes in a normal sized header.">FileHeader::HEADER_SIZE_BYTES</a> bytes). </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#aa0e335238a57eaa0bffee8f968e5995f">evio::ByteBuffer::array()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#abf7abf99aa7544601997f40eba298648">evio::ByteBuffer::arrayOffset()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a6496a99b06b5ed67b8c93b148fd87323">evio::ByteBuffer::capacity()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a11a85b28fd30c969f567c8c7f5848275">evio::ByteBuffer::clear()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a01c1f92000c5a0f3b2f11b0c0e5e3a74">evio::FileHeader::getLength()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a60a8eab054b6f02e84d8975e3aa436b9">evio::FileHeader::HEADER_SIZE_BYTES</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#afb08d1dbc5fbf780afd27617a67eb750">evio::ByteBuffer::limit()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a3d5f0120189717ffc8d2d480d89cb91a">evio::ByteBuffer::order()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a88f84e6b1757db70542eac13294fc80e">evio::ByteBuffer::position()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a32b043081cd3a62187f2577ce2966e7d">evio::ByteBuffer::remaining()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#af318676a4ffce0023d1bf669bb44cf31">evio::FileHeader::reset()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#ade550a2cc97d77fe89f81941a3e92fcc">evio::FileHeader::setBitInfo()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a5d19dfdbc256c2bf9025795442cb59ff">evio::FileHeader::setUserHeaderLength()</a>, and <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#aabd952c177a47ed7875b6c9d988bff8e">evio::FileHeader::writeHeader()</a>.</p>

</div>
</div>
<a id="ade85d05f573c665b7221bc62e56b1524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade85d05f573c665b7221bc62e56b1524">&#9670;&nbsp;</a></span>createHeader() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Writer::createHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>userHdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>userLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill given buffer with a general file header followed by the given user header. </p>
<p>The buffer is cleared and set to desired byte order prior to writing. If user header is not padded to 4-byte boundary, it's done here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer to contain the file header followed by the user-defined header. </td></tr>
    <tr><td class="paramname">userHdr</td><td>byte array containing a user-defined header, may be null. </td></tr>
    <tr><td class="paramname">userLen</td><td>array length in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if writing to buffer, or buf too small (needs to be userLen + <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a60a8eab054b6f02e84d8975e3aa436b9" title="Number of bytes in a normal sized header.">FileHeader::HEADER_SIZE_BYTES</a> bytes). </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#aa0e335238a57eaa0bffee8f968e5995f">evio::ByteBuffer::array()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#abf7abf99aa7544601997f40eba298648">evio::ByteBuffer::arrayOffset()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a6496a99b06b5ed67b8c93b148fd87323">evio::ByteBuffer::capacity()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a11a85b28fd30c969f567c8c7f5848275">evio::ByteBuffer::clear()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a01c1f92000c5a0f3b2f11b0c0e5e3a74">evio::FileHeader::getLength()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a60a8eab054b6f02e84d8975e3aa436b9">evio::FileHeader::HEADER_SIZE_BYTES</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#afb08d1dbc5fbf780afd27617a67eb750">evio::ByteBuffer::limit()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a3d5f0120189717ffc8d2d480d89cb91a">evio::ByteBuffer::order()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#af318676a4ffce0023d1bf669bb44cf31">evio::FileHeader::reset()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#ade550a2cc97d77fe89f81941a3e92fcc">evio::FileHeader::setBitInfo()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a5d19dfdbc256c2bf9025795442cb59ff">evio::FileHeader::setUserHeaderLength()</a>, and <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#aabd952c177a47ed7875b6c9d988bff8e">evio::FileHeader::writeHeader()</a>.</p>

</div>
</div>
<a id="a26490309dbaa26d08de3c2151f9d0391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26490309dbaa26d08de3c2151f9d0391">&#9670;&nbsp;</a></span>createHeader() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; evio::Writer::createHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>userHdr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return a buffer containing a general file header followed by the user header given in the argument. </p>
<p>If user header is not padded to 4-byte boundary, it's done here. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userHdr</td><td>buffer containing a user-defined header which must be READY-TO-READ! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer containing a file header followed by the user-defined header. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if writing to buffer, not file. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#aa0e335238a57eaa0bffee8f968e5995f">evio::ByteBuffer::array()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#abf7abf99aa7544601997f40eba298648">evio::ByteBuffer::arrayOffset()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a01c1f92000c5a0f3b2f11b0c0e5e3a74">evio::FileHeader::getLength()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a60a8eab054b6f02e84d8975e3aa436b9">evio::FileHeader::HEADER_SIZE_BYTES</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a88f84e6b1757db70542eac13294fc80e">evio::ByteBuffer::position()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a32b043081cd3a62187f2577ce2966e7d">evio::ByteBuffer::remaining()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#af318676a4ffce0023d1bf669bb44cf31">evio::FileHeader::reset()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#ade550a2cc97d77fe89f81941a3e92fcc">evio::FileHeader::setBitInfo()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a5d19dfdbc256c2bf9025795442cb59ff">evio::FileHeader::setUserHeaderLength()</a>, and <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#aabd952c177a47ed7875b6c9d988bff8e">evio::FileHeader::writeHeader()</a>.</p>

</div>
</div>
<a id="a32f50661587a8f13e7729183b2203299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f50661587a8f13e7729183b2203299">&#9670;&nbsp;</a></span>createHeader() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; evio::Writer::createHeader </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>userHdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>userLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return a buffer containing a general file header followed by the user header given in the argument. </p>
<p>If user header is not padded to 4-byte boundary, it's done here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userHdr</td><td>byte array containing a user-defined header, may be null. </td></tr>
    <tr><td class="paramname">userLen</td><td>array length in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer (same as buf arg). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if writing to buffer, not file. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a01c1f92000c5a0f3b2f11b0c0e5e3a74">evio::FileHeader::getLength()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a60a8eab054b6f02e84d8975e3aa436b9">evio::FileHeader::HEADER_SIZE_BYTES</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#af318676a4ffce0023d1bf669bb44cf31">evio::FileHeader::reset()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#ade550a2cc97d77fe89f81941a3e92fcc">evio::FileHeader::setBitInfo()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a5d19dfdbc256c2bf9025795442cb59ff">evio::FileHeader::setUserHeaderLength()</a>, and <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#aabd952c177a47ed7875b6c9d988bff8e">evio::FileHeader::writeHeader()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d6/dca/classevio_1_1_writer.html#aec66f6f92fa30daa2f9546d2920dbbfe">open()</a>.</p>

</div>
</div>
<a id="acaf968c34f10e8004994a91175e5a829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf968c34f10e8004994a91175e5a829">&#9670;&nbsp;</a></span>createRecord()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; evio::Writer::createRecord </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>firstEv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstEvLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/da6/classevio_1_1_file_header.html">FileHeader</a> *&#160;</td>
          <td class="paramname"><em>fileHdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d64/classevio_1_1_record_header.html">RecordHeader</a> *&#160;</td>
          <td class="paramname"><em>recordHdr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STATIC. </p>
<p>Create a buffer representation of a record containing dictionary and/or first event. No compression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dict</td><td>dictionary xml string </td></tr>
    <tr><td class="paramname">firstEv</td><td>bytes representing evio event </td></tr>
    <tr><td class="paramname">firstEvLen</td><td>number of bytes in firstEv </td></tr>
    <tr><td class="paramname">order</td><td>byte order of returned byte array </td></tr>
    <tr><td class="paramname">fileHdr</td><td>file header to update with dictionary/first-event info (may be null). </td></tr>
    <tr><td class="paramname">recordHdr</td><td>record header to update with dictionary/first-event info (may be null). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer representation of record containing dictionary and/or first event. Null pointer if both are empty/null. </dd></dl>

<p class="reference">References <a class="el" href="../../d2/d7a/classevio_1_1_record_output.html#a5430397efd27db0815892cd7c61c08a2">evio::RecordOutput::addEvent()</a>, <a class="el" href="../../d2/d7a/classevio_1_1_record_output.html#a7c7cbf0f2bcc362662eea1fc4ff5d7ad">evio::RecordOutput::build()</a>, <a class="el" href="../../d2/d7a/classevio_1_1_record_output.html#a95a914b8d9c2e5dce9764be14002d8b6">evio::RecordOutput::getBinaryBuffer()</a>, <a class="el" href="../../d2/d7a/classevio_1_1_record_output.html#acbb92327f0cf806b7b87b0b20336b05f">evio::RecordOutput::getInternalBufferCapacity()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a9267f205919e107f08d268e4ffc92e1e">evio::FileHeader::hasDictionary()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#aeb2283945519b97d1f33b32cf7fcdaa7">evio::RecordHeader::hasDictionary()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a55417ae68a5f938e25bac2673c88e36c">evio::FileHeader::hasFirstEvent()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a13c64348c2dd2f25aed34ead5c9ca74b">evio::RecordHeader::hasFirstEvent()</a>, and <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747a056585718cbf5c7808c0e37b1f88dbb9">evio::Compressor::UNCOMPRESSED</a>.</p>

</div>
</div>
<a id="a7584e8ce135dbed869f4e247e371ee75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7584e8ce135dbed869f4e247e371ee75">&#9670;&nbsp;</a></span>getBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; evio::Writer::getBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer being written to. </p>
<p>This should only be called after calling <a class="el" href="../../d6/dca/classevio_1_1_writer.html#a8f01bf28c0d2910947fca9a841a1fc7b" title="Close opened file.">close()</a> so data is complete. </p><dl class="section return"><dt>Returns</dt><dd>buffer being written to. </dd></dl>

</div>
</div>
<a id="aa08c22b469bb85b6065876ad2f9482a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08c22b469bb85b6065876ad2f9482a3">&#9670;&nbsp;</a></span>getByteOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp; evio::Writer::getByteOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the file's byte order. </p>
<dl class="section return"><dt>Returns</dt><dd>file's byte order. </dd></dl>

</div>
</div>
<a id="a4b693782520a223345fcafead7b4b5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b693782520a223345fcafead7b4b5c0">&#9670;&nbsp;</a></span>getCompressionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747">Compressor::CompressionType</a> evio::Writer::getCompressionType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&zwj;** </p>
<p>&zwj;** Convenience method that gets compression type for the file being written. </p><dl class="section return"><dt>Returns</dt><dd>compression type for the file being written. </dd></dl>

</div>
</div>
<a id="a8675f4a700a8b0a65fad0c2b7a192940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8675f4a700a8b0a65fad0c2b7a192940">&#9670;&nbsp;</a></span>getFileHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da6/classevio_1_1_file_header.html">FileHeader</a> &amp; evio::Writer::getFileHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the file header. </p>
<dl class="section return"><dt>Returns</dt><dd>file header. </dd></dl>

</div>
</div>
<a id="a1f64043951e4d8ff7f186fced75052fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f64043951e4d8ff7f186fced75052fb">&#9670;&nbsp;</a></span>open() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Writer::open </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a new file and write file header with no user header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>output file name </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if open already called without being followed by calling close. </td></tr>
    <tr><td class="paramname">IOException</td><td>if file cannot be found or IO error writing to file </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="../../d6/dca/classevio_1_1_writer.html#a534f719986ce36c188092faec39c2c27">Writer()</a>.</p>

</div>
</div>
<a id="aec66f6f92fa30daa2f9546d2920dbbfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec66f6f92fa30daa2f9546d2920dbbfe">&#9670;&nbsp;</a></span>open() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Writer::open </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>userHdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>userLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file and write file header with given user header. </p>
<p>User header is automatically padded when written. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>name of file to write to. </td></tr>
    <tr><td class="paramname">userHdr</td><td>byte array representing the optional user's header. If this is null AND dictionary and/or first event are given, the dictionary and/or first event will be placed in its own record and written as the user header. </td></tr>
    <tr><td class="paramname">userLen</td><td>length of valid data (bytes) in userHdr (starting at off). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>filename arg is null, if constructor specified writing to a buffer, if <a class="el" href="../../d6/dca/classevio_1_1_writer.html#a1f64043951e4d8ff7f186fced75052fb" title="Open a new file and write file header with no user header.">open()</a> was already called without being followed by <a class="el" href="../../d6/dca/classevio_1_1_writer.html#a17cd4aa42143d1f6578422f6ef36151a" title="Get this object ready for re-use.">reset()</a>, if file cannot be found, if IO error writing to file, or if filename is empty. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d6/dca/classevio_1_1_writer.html#a32f50661587a8f13e7729183b2203299">createHeader()</a>, and <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a01c1f92000c5a0f3b2f11b0c0e5e3a74">evio::FileHeader::getLength()</a>.</p>

</div>
</div>
<a id="a04ed6382f82d976aef36ac78d6a001fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ed6382f82d976aef36ac78d6a001fc">&#9670;&nbsp;</a></span>open() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Writer::open </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>userHdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a buffer and write first record header with given user header. </p>
<p>User header is automatically padded when written. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer to writer to. </td></tr>
    <tr><td class="paramname">userHdr</td><td>byte array representing the optional user's header. <b>Warning: this data will be copied!</b> If this is null AND dictionary and/or first event are given, the dictionary and/or first event will be placed in its own record and written as the user header of the first record's header. </td></tr>
    <tr><td class="paramname">len</td><td>length of valid data (bytes) in userHdr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if constructor specified writing to a file, or if <a class="el" href="../../d6/dca/classevio_1_1_writer.html#a1f64043951e4d8ff7f186fced75052fb" title="Open a new file and write file header with no user header.">open()</a> was already called without being followed by <a class="el" href="../../d6/dca/classevio_1_1_writer.html#a17cd4aa42143d1f6578422f6ef36151a" title="Get this object ready for re-use.">reset()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17cd4aa42143d1f6578422f6ef36151a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17cd4aa42143d1f6578422f6ef36151a">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Writer::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get this object ready for re-use. </p>
<p>Follow calling this with call to <a class="el" href="../../d6/dca/classevio_1_1_writer.html#a1f64043951e4d8ff7f186fced75052fb">open(const std::string &amp;)</a>. </p>

<p class="reference">References <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#af318676a4ffce0023d1bf669bb44cf31">evio::FileHeader::reset()</a>.</p>

</div>
</div>
<a id="a278331c3a1a91c7a7584fea9f4910d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278331c3a1a91c7a7584fea9f4910d5d">&#9670;&nbsp;</a></span>setCompressionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Writer::setCompressionType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747">Compressor::CompressionType</a>&#160;</td>
          <td class="paramname"><em>compression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method that sets compression type for the file. </p>
<p>The compression type is also set for internal record. When writing to the file, record data will be compressed according to the given type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compression</td><td>compression type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d0f549a6ceaae794eca73130957a23d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0f549a6ceaae794eca73130957a23d">&#9670;&nbsp;</a></span>writeRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Writer::writeRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d7a/classevio_1_1_record_output.html">RecordOutput</a> &amp;&#160;</td>
          <td class="paramname"><em>rec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the record to the file/buffer. </p>
<p>When writing to a file, using this method in conjunction with <a class="el" href="../../d6/dca/classevio_1_1_writer.html#a3f4737e1b27c07329fbb869fbead1f56" title="Add a byte array to the internal record.">addEvent()</a> is <b>NOT</b> thread-safe. For that reason, this write is done synchronously, to avoid interference with the normal, asynchronous file writes. Thus, writing using this method will not be quite as efficient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>record object </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if error writing to file or record's byte order is opposite to output endian. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d2/d7a/classevio_1_1_record_output.html#a7c7cbf0f2bcc362662eea1fc4ff5d7ad">evio::RecordOutput::build()</a>, <a class="el" href="../../d2/d7a/classevio_1_1_record_output.html#a95a914b8d9c2e5dce9764be14002d8b6">evio::RecordOutput::getBinaryBuffer()</a>, <a class="el" href="../../d2/d7a/classevio_1_1_record_output.html#a7d31fb593c433d6c5be6961a5b43d1da">evio::RecordOutput::getByteOrder()</a>, and <a class="el" href="../../d2/d7a/classevio_1_1_record_output.html#a3644f5817bd565b0b6a07617da013f27">evio::RecordOutput::getHeader()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="../../de/d9e/_writer_8h.html">Writer.h</a></li>
<li><a class="el" href="../../dc/d0e/_writer_8cpp.html">Writer.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d9/deb/namespaceevio.html">evio</a></li><li class="navelem"><a class="el" href="../../d6/dca/classevio_1_1_writer.html">Writer</a></li>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
