<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>evio: evio::EvioReaderV4 Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">evio
   &#160;<span id="projectnumber">6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('dd/db3/classevio_1_1_evio_reader_v4.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="../../d6/d36/classevio_1_1_evio_reader_v4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">evio::EvioReaderV4 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is a class of interest to the user.  
 <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#details">More...</a></p>

<p><code>#include &lt;EvioReaderV4.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for evio::EvioReaderV4:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../dd/db3/classevio_1_1_evio_reader_v4.png" usemap="#evio::EvioReaderV4_map" alt=""/>
  <map id="evio::EvioReaderV4_map" name="evio::EvioReaderV4_map">
<area href="../../de/d97/classevio_1_1_i_evio_reader.html" title="This pure, virtual class is meant to encapsulate the operation of reading both 2 differently formatte..." alt="evio::IEvioReader" shape="rect" coords="0,0,124,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aeb9b24a83d7fc38eacf3f6b3b329f926"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#aeb9b24a83d7fc38eacf3f6b3b329f926">ReadWriteStatus</a> { <br />
&#160;&#160;<a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#aeb9b24a83d7fc38eacf3f6b3b329f926ab14e3269cc4f96bf7a442d278fc51009">SUCCESS</a> = 0, 
<a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#aeb9b24a83d7fc38eacf3f6b3b329f926a6413574a07e897b7be4800fa6921e2e7">END_OF_FILE</a>, 
<a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#aeb9b24a83d7fc38eacf3f6b3b329f926ae0ddb8ce05a096046ff47cf917969b50">CANNOT_OPEN_FILE</a>, 
<a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#aeb9b24a83d7fc38eacf3f6b3b329f926ae3b4a070ccd53865afcc4bc2ad91ed47">EVIO_EXCEPTION</a>, 
<br />
&#160;&#160;<a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#aeb9b24a83d7fc38eacf3f6b3b329f926a0c4ce2651b53b53a2e628c80bf3db456">UNKNOWN_ERROR</a>
<br />
 }</td></tr>
<tr class="memdesc:aeb9b24a83d7fc38eacf3f6b3b329f926"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <code>enum</code> denotes the status of a read/write.  <a href="../../de/d97/classevio_1_1_i_evio_reader.html#aeb9b24a83d7fc38eacf3f6b3b329f926">More...</a><br /></td></tr>
<tr class="separator:aeb9b24a83d7fc38eacf3f6b3b329f926"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaceaf45be3fe4156a280ab9f78f8697e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#aaceaf45be3fe4156a280ab9f78f8697e">EvioReaderV4</a> (std::string const &amp;path, bool checkBlkNumSeq=false, bool synced=false)</td></tr>
<tr class="memdesc:aaceaf45be3fe4156a280ab9f78f8697e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for reading an event file.  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#aaceaf45be3fe4156a280ab9f78f8697e">More...</a><br /></td></tr>
<tr class="separator:aaceaf45be3fe4156a280ab9f78f8697e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0fe4bdc542167bcaaccf7c220c0f44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ada0fe4bdc542167bcaaccf7c220c0f44">EvioReaderV4</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;byteBuffer, bool checkBlkNumSeq=false, bool synced=false)</td></tr>
<tr class="memdesc:ada0fe4bdc542167bcaaccf7c220c0f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for reading a buffer.  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ada0fe4bdc542167bcaaccf7c220c0f44">More...</a><br /></td></tr>
<tr class="separator:ada0fe4bdc542167bcaaccf7c220c0f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e9531e9f836cec9980ba88296f8ea6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ad8e9531e9f836cec9980ba88296f8ea6">setBuffer</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buf) override</td></tr>
<tr class="memdesc:ad8e9531e9f836cec9980ba88296f8ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method can be used to avoid creating additional <a class="el" href="../../df/dbd/classevio_1_1_evio_reader.html" title="This is a class of interest to the user.">EvioReader</a> objects by reusing this one with another buffer.The method <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#abfcc831176f6b4b0c402838b2fa09e6f">close()</a> is called before anything else.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> to be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">underflow_error</td><td>if not enough data in buffer. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if buf is null; buf not in proper format; if first record/block number != 1 when checkRecNumSeq arg is true.</td></tr>
  </table>
  </dd>
</dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ad8e9531e9f836cec9980ba88296f8ea6">More...</a><br /></td></tr>
<tr class="separator:ad8e9531e9f836cec9980ba88296f8ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697baee61837fc5a935083d1b45a2e1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a697baee61837fc5a935083d1b45a2e1b">isClosed</a> () override</td></tr>
<tr class="memdesc:a697baee61837fc5a935083d1b45a2e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#abfcc831176f6b4b0c402838b2fa09e6f">close()</a> been called (without reopening by calling <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a1018ab2d476c0638970ef40a7fb5e45f">setBuffer(std::shared_ptr&lt;ByteBuffer&gt; &amp;)</a>)?<dl class="section return"><dt>Returns</dt><dd><div class="fragment"><div class="line"><span class="keyword">true</span> </div>
</div><!-- fragment --> if this object closed, else<div class="fragment"><div class="line"><span class="keyword">false</span> </div>
</div><!-- fragment --> .</dd></dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a697baee61837fc5a935083d1b45a2e1b">More...</a><br /></td></tr>
<tr class="separator:a697baee61837fc5a935083d1b45a2e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063a318617679c6456802a2f5a840915"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a063a318617679c6456802a2f5a840915">checkBlockNumberSequence</a> () override</td></tr>
<tr class="memdesc:a063a318617679c6456802a2f5a840915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this reader checking the block number sequence and throwing an exception if it's not sequential and starting with 1?<dl class="section return"><dt>Returns</dt><dd><code>true</code> if checking block number sequence, else <code>false</code></dd></dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a063a318617679c6456802a2f5a840915">More...</a><br /></td></tr>
<tr class="separator:a063a318617679c6456802a2f5a840915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19337f49c0132536d8d775469c56bac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#aa19337f49c0132536d8d775469c56bac">getByteOrder</a> () override</td></tr>
<tr class="memdesc:aa19337f49c0132536d8d775469c56bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the byte order of the file/buffer being read.<dl class="section return"><dt>Returns</dt><dd>byte order of the file/buffer being read.</dd></dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#aa19337f49c0132536d8d775469c56bac">More...</a><br /></td></tr>
<tr class="separator:aa19337f49c0132536d8d775469c56bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a67d0b1fde4b8ebbbceda5fb301dff"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ac3a67d0b1fde4b8ebbbceda5fb301dff">getEvioVersion</a> () override</td></tr>
<tr class="memdesc:ac3a67d0b1fde4b8ebbbceda5fb301dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the evio version number.<dl class="section return"><dt>Returns</dt><dd>evio version number.</dd></dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ac3a67d0b1fde4b8ebbbceda5fb301dff">More...</a><br /></td></tr>
<tr class="separator:ac3a67d0b1fde4b8ebbbceda5fb301dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad809ffeda3b80606b4f2a76469a05f1d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ad809ffeda3b80606b4f2a76469a05f1d">getPath</a> () override</td></tr>
<tr class="memdesc:ad809ffeda3b80606b4f2a76469a05f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the path to the file.<dl class="section return"><dt>Returns</dt><dd>path to the file</dd></dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ad809ffeda3b80606b4f2a76469a05f1d">More...</a><br /></td></tr>
<tr class="separator:ad809ffeda3b80606b4f2a76469a05f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5611fcde6de0d545e86ebe9f5de5c4a2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d7/d5d/classevio_1_1_event_parser.html">EventParser</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a5611fcde6de0d545e86ebe9f5de5c4a2">getParser</a> () override</td></tr>
<tr class="memdesc:a5611fcde6de0d545e86ebe9f5de5c4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file/buffer parser.<dl class="section return"><dt>Returns</dt><dd>file/buffer parser.</dd></dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a5611fcde6de0d545e86ebe9f5de5c4a2">More...</a><br /></td></tr>
<tr class="separator:a5611fcde6de0d545e86ebe9f5de5c4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8855a45490b79bc50eb97ea4985c6efe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a8855a45490b79bc50eb97ea4985c6efe">setParser</a> (std::shared_ptr&lt; <a class="el" href="../../d7/d5d/classevio_1_1_event_parser.html">EventParser</a> &gt; &amp;evParser) override</td></tr>
<tr class="memdesc:a8855a45490b79bc50eb97ea4985c6efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the file/buffer parser.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evParser</td><td>file/buffer parser.</td></tr>
  </table>
  </dd>
</dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a8855a45490b79bc50eb97ea4985c6efe">More...</a><br /></td></tr>
<tr class="separator:a8855a45490b79bc50eb97ea4985c6efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de85bc20f69676951af001a294d0ea8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a1de85bc20f69676951af001a294d0ea8">getDictionaryXML</a> () override</td></tr>
<tr class="memdesc:a1de85bc20f69676951af001a294d0ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the XML format dictionary if there is one.<dl class="section return"><dt>Returns</dt><dd>XML format dictionary, else null.</dd></dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a1de85bc20f69676951af001a294d0ea8">More...</a><br /></td></tr>
<tr class="separator:a1de85bc20f69676951af001a294d0ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa4b9ec29f2198c25d96fb1f1889c28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a6aa4b9ec29f2198c25d96fb1f1889c28">hasDictionaryXML</a> () override</td></tr>
<tr class="memdesc:a6aa4b9ec29f2198c25d96fb1f1889c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this evio file have an associated XML dictionary?<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this evio file has an associated XML dictionary, else <code>false</code></dd></dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a6aa4b9ec29f2198c25d96fb1f1889c28">More...</a><br /></td></tr>
<tr class="separator:a6aa4b9ec29f2198c25d96fb1f1889c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95ca3bc461086c3a998d269a322f167"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d4/d12/classevio_1_1_evio_event.html">EvioEvent</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ab95ca3bc461086c3a998d269a322f167">getFirstEvent</a> () override</td></tr>
<tr class="memdesc:ab95ca3bc461086c3a998d269a322f167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the "first" event if there is one.It's also called the Beginning-Of-Run event. This event is defined once but included in each of the related split files written out. </p><dl class="section return"><dt>Returns</dt><dd>the first event is it existed, else null.</dd></dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ab95ca3bc461086c3a998d269a322f167">More...</a><br /></td></tr>
<tr class="separator:ab95ca3bc461086c3a998d269a322f167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fac9c348dce02aebde184ab8a51792"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a24fac9c348dce02aebde184ab8a51792">hasFirstEvent</a> () override</td></tr>
<tr class="memdesc:a24fac9c348dce02aebde184ab8a51792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this evio file have an associated first event? It's also called the Beginning-Of-Run event.This event is defined once but included in each of the related split files written out. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if this evio file has an associated first event, else <code>false</code></dd></dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a24fac9c348dce02aebde184ab8a51792">More...</a><br /></td></tr>
<tr class="separator:a24fac9c348dce02aebde184ab8a51792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4423942f5b5ffe914c6cd9523016d616"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a4423942f5b5ffe914c6cd9523016d616">getNumEventsRemaining</a> () override</td></tr>
<tr class="memdesc:a4423942f5b5ffe914c6cd9523016d616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of events remaining in the file.Useful only if doing a sequential read.<dl class="section return"><dt>Returns</dt><dd>number of events remaining in the file </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if failed reading from file</td></tr>
  </table>
  </dd>
</dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a4423942f5b5ffe914c6cd9523016d616">More...</a><br /></td></tr>
<tr class="separator:a4423942f5b5ffe914c6cd9523016d616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcab0d75e41dc94b7dfd6f8dc9625c17"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#abcab0d75e41dc94b7dfd6f8dc9625c17">getByteBuffer</a> () override</td></tr>
<tr class="memdesc:abcab0d75e41dc94b7dfd6f8dc9625c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the byte buffer being read.Not useful when reading files. </p><dl class="section return"><dt>Returns</dt><dd>the byte buffer being read (in certain cases).</dd></dl>
.  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#abcab0d75e41dc94b7dfd6f8dc9625c17">More...</a><br /></td></tr>
<tr class="separator:abcab0d75e41dc94b7dfd6f8dc9625c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316eddece193b0cde1a55265d37b8e10"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a316eddece193b0cde1a55265d37b8e10">fileSize</a> () override</td></tr>
<tr class="memdesc:a316eddece193b0cde1a55265d37b8e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the file being read, in bytes.<dl class="section return"><dt>Returns</dt><dd>the file size in bytes</dd></dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a316eddece193b0cde1a55265d37b8e10">More...</a><br /></td></tr>
<tr class="separator:a316eddece193b0cde1a55265d37b8e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1437a584908549758a269487373d0b4"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d5/d6e/classevio_1_1_i_block_header.html">IBlockHeader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ac1437a584908549758a269487373d0b4">getFirstBlockHeader</a> () override</td></tr>
<tr class="memdesc:ac1437a584908549758a269487373d0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns the FIRST block (record) header.<dl class="section return"><dt>Returns</dt><dd>the first block (record) header.</dd></dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ac1437a584908549758a269487373d0b4">More...</a><br /></td></tr>
<tr class="separator:ac1437a584908549758a269487373d0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f9780670a7493fe61ecd9bd478e070"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d4/d12/classevio_1_1_evio_event.html">EvioEvent</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a66f9780670a7493fe61ecd9bd478e070">getEvent</a> (size_t index) override</td></tr>
<tr class="memdesc:a66f9780670a7493fe61ecd9bd478e070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the event in the file/buffer at a given index (starting at 1).As useful as this sounds, most applications will probably call <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#abff17b5f200e64826bffce2a60f3ae66">parseNextEvent()</a> or <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#abcd2be8738fe4162409a7d2e883b672b">parseEvent(size_t)</a> instead, since it combines combines getting an event with parsing it.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>number of event desired, starting at 1, from beginning of file/buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the event in the file/buffer at the given index or null if none </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if failed file access; if failed read due to bad file/buffer format; if index out of bounds; if object closed</td></tr>
  </table>
  </dd>
</dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a66f9780670a7493fe61ecd9bd478e070">More...</a><br /></td></tr>
<tr class="separator:a66f9780670a7493fe61ecd9bd478e070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605bc27fbfa468057669a5a157478f78"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d4/d12/classevio_1_1_evio_event.html">EvioEvent</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a605bc27fbfa468057669a5a157478f78">parseEvent</a> (size_t index) override</td></tr>
<tr class="memdesc:a605bc27fbfa468057669a5a157478f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a workhorse method.It retrieves the desired event from the file/buffer, and then parses it SAX-like. It will drill down and uncover all structures (banks, segments, and tagsegments) and notify any interested listeners.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>number of event desired, starting at 1, from beginning of file/buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed event at the given index or null if none </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if failed file access; if failed read due to bad file/buffer format; if index out of bounds; if object closed</td></tr>
  </table>
  </dd>
</dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a605bc27fbfa468057669a5a157478f78">More...</a><br /></td></tr>
<tr class="separator:a605bc27fbfa468057669a5a157478f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46655f6197c4f00a3a8a7dc38f15f162"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d4/d12/classevio_1_1_evio_event.html">EvioEvent</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a46655f6197c4f00a3a8a7dc38f15f162">nextEvent</a> () override</td></tr>
<tr class="memdesc:a46655f6197c4f00a3a8a7dc38f15f162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next event in the file/buffer.As useful as this sounds, most applications will probably call <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#abff17b5f200e64826bffce2a60f3ae66">parseNextEvent()</a> instead, since it combines getting the next event with parsing the next event.Although this method can get events in versions 4+, it now delegates that to another method. No changes were made to this method from versions 1-3 in order to read the version 4 format as it is subset of versions 1-3 with variable block length.<dl class="section return"><dt>Returns</dt><dd>the next event in the file. On error it throws an <a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a>. On end of file, it returns <code>null</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if failed file access; if failed read due to bad buffer format; if object closed</td></tr>
  </table>
  </dd>
</dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a46655f6197c4f00a3a8a7dc38f15f162">More...</a><br /></td></tr>
<tr class="separator:a46655f6197c4f00a3a8a7dc38f15f162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb69bdb4a8d522a4605a41505720633a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d4/d12/classevio_1_1_evio_event.html">EvioEvent</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#afb69bdb4a8d522a4605a41505720633a">parseNextEvent</a> () override</td></tr>
<tr class="memdesc:afb69bdb4a8d522a4605a41505720633a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a workhorse method.It retrieves the next event from the file/buffer, and then parses it SAX-like. It will drill down and uncover all structures (banks, segments, and tagsegments) and notify any interested listeners.<dl class="section return"><dt>Returns</dt><dd>the event that was parsed. On error it throws an <a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a>. On end of file, it returns <code>null</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if failed file access; if read failure or bad format; if object closed</td></tr>
  </table>
  </dd>
</dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#afb69bdb4a8d522a4605a41505720633a">More...</a><br /></td></tr>
<tr class="separator:afb69bdb4a8d522a4605a41505720633a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64cac6bd49f60a3ad8ff0e621b5e391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ad64cac6bd49f60a3ad8ff0e621b5e391">parseEvent</a> (std::shared_ptr&lt; <a class="el" href="../../d4/d12/classevio_1_1_evio_event.html">EvioEvent</a> &gt; evioEvent) override</td></tr>
<tr class="memdesc:ad64cac6bd49f60a3ad8ff0e621b5e391"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will parse an event, SAX-like.It will drill down and uncover all structures (banks, segments, and tagsegments) and notify any interested listeners.As useful as this sounds, most applications will probably call <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#abff17b5f200e64826bffce2a60f3ae66">parseNextEvent()</a> instead, since it combines combines getting the next event with parsing the next event.This method is only called by synchronized methods and therefore is not synchronized.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evioEvent</td><td>the event to parse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if bad format</td></tr>
  </table>
  </dd>
</dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ad64cac6bd49f60a3ad8ff0e621b5e391">More...</a><br /></td></tr>
<tr class="separator:ad64cac6bd49f60a3ad8ff0e621b5e391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c85cf1408ce75097e67d29624235c35"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a5c85cf1408ce75097e67d29624235c35">getEventArray</a> (size_t evNumber, std::vector&lt; uint8_t &gt; &amp;vec) override</td></tr>
<tr class="memdesc:a5c85cf1408ce75097e67d29624235c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an evio bank or event in vector-of-bytes form.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evNumber</td><td>number of event of interest (starting at 1). </td></tr>
    <tr><td class="paramname">vec</td><td>vector to contain bank's/event's bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes in returned event. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if failed file access; if eventNumber out of bounds (starts at 1); if the event number does not correspond to an existing event; if object closed</td></tr>
  </table>
  </dd>
</dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a5c85cf1408ce75097e67d29624235c35">More...</a><br /></td></tr>
<tr class="separator:a5c85cf1408ce75097e67d29624235c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d24a3b4a17c63b56084cb865ab9f741"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a2d24a3b4a17c63b56084cb865ab9f741">getEventBuffer</a> (size_t evNumber, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;buf) override</td></tr>
<tr class="memdesc:a2d24a3b4a17c63b56084cb865ab9f741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an evio bank or event in <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> form.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evNumber</td><td>number of event of interest </td></tr>
    <tr><td class="paramname">buf</td><td>buffer to contain bank's/event's bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes in returned event. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if failed file access; if eventNumber out of bounds (starts at 1); if the event number does not correspond to an existing event; if object closed</td></tr>
  </table>
  </dd>
</dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a2d24a3b4a17c63b56084cb865ab9f741">More...</a><br /></td></tr>
<tr class="separator:a2d24a3b4a17c63b56084cb865ab9f741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab299451c3cb8fa93da0f4eca0666887c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ab299451c3cb8fa93da0f4eca0666887c">rewind</a> () override</td></tr>
<tr class="memdesc:ab299451c3cb8fa93da0f4eca0666887c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The equivalent of rewinding the file.What it actually does is set the position of the file/buffer back to where it was after calling the constructor - after the first header. This method, along with the two <code><a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a3a3c4a46ffffbd0d090e8ee04a5b54f2" title="This is equivalent to obtaining the current position in the file.">position()</a></code> and the <code><a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#abfcc831176f6b4b0c402838b2fa09e6f" title="This is closes the file, but for buffers it only sets the position to 0.">close()</a></code> method, allows applications to treat files in a normal random access manner.<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if object closed; if failed file access or buffer/file read</td></tr>
  </table>
  </dd>
</dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ab299451c3cb8fa93da0f4eca0666887c">More...</a><br /></td></tr>
<tr class="separator:ab299451c3cb8fa93da0f4eca0666887c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788f6442710ea217855ba4c70787b5d5"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a788f6442710ea217855ba4c70787b5d5">position</a> () override</td></tr>
<tr class="memdesc:a788f6442710ea217855ba4c70787b5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is equivalent to obtaining the current position in the file.What it actually does is return the position of the buffer. This method, along with the <code><a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a73cb48511f980029d7a55ce70c34765b" title="The equivalent of rewinding the file.">rewind()</a></code>, <code>position(int)</code> and the <code><a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#abfcc831176f6b4b0c402838b2fa09e6f" title="This is closes the file, but for buffers it only sets the position to 0.">close()</a></code> method, allows applications to treat files in a normal random access manner. Only meaningful to evio versions 1-3 and for sequential reading.<dl class="section return"><dt>Returns</dt><dd>the position of the buffer; -1 if not sequential read and version 4+ </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if object closed; if error accessing file</td></tr>
  </table>
  </dd>
</dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a788f6442710ea217855ba4c70787b5d5">More...</a><br /></td></tr>
<tr class="separator:a788f6442710ea217855ba4c70787b5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc59efe016e7c5c57350d41fd9bfbd18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#adc59efe016e7c5c57350d41fd9bfbd18">close</a> () override</td></tr>
<tr class="memdesc:adc59efe016e7c5c57350d41fd9bfbd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is closes the file, but for buffers it only sets the position to 0.This method, along with the <code><a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a73cb48511f980029d7a55ce70c34765b" title="The equivalent of rewinding the file.">rewind()</a></code> and the two <code><a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a3a3c4a46ffffbd0d090e8ee04a5b54f2" title="This is equivalent to obtaining the current position in the file.">position()</a></code> methods, allows applications to treat files in a normal random access manner.  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#adc59efe016e7c5c57350d41fd9bfbd18">More...</a><br /></td></tr>
<tr class="separator:adc59efe016e7c5c57350d41fd9bfbd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689d91e4167e2298da870cf26049d670"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d5/d6e/classevio_1_1_i_block_header.html">IBlockHeader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a689d91e4167e2298da870cf26049d670">getCurrentBlockHeader</a> () override</td></tr>
<tr class="memdesc:a689d91e4167e2298da870cf26049d670"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns the current (active) block (physical record) header.Since most users have no interest in physical records, this method should not be used.<dl class="section return"><dt>Returns</dt><dd>the current block header.</dd></dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a689d91e4167e2298da870cf26049d670">More...</a><br /></td></tr>
<tr class="separator:a689d91e4167e2298da870cf26049d670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51fae5c6c4f8a9aea1d398379f89857"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d4/d12/classevio_1_1_evio_event.html">EvioEvent</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ac51fae5c6c4f8a9aea1d398379f89857">gotoEventNumber</a> (size_t evNumber) override</td></tr>
<tr class="memdesc:ac51fae5c6c4f8a9aea1d398379f89857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Go to a specific event in the file.The events are numbered 1..N. This number is transient&ndash;it is not part of the event as stored in the evio file. In versions 4 and up this is just a wrapper on <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a848dc77538de2be992d106c590180df4">getEvent(size_t)</a>.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evNumber</td><td>the event number in a 1..N counting sense, from the start of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the specified event in file or null if there's an error or nothing at that event #. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if object closed; if failed file access</td></tr>
  </table>
  </dd>
</dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ac51fae5c6c4f8a9aea1d398379f89857">More...</a><br /></td></tr>
<tr class="separator:ac51fae5c6c4f8a9aea1d398379f89857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb236980e8a72c2253c1cc2a2c9918fb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#afb236980e8a72c2253c1cc2a2c9918fb">getEventCount</a> () override</td></tr>
<tr class="memdesc:afb236980e8a72c2253c1cc2a2c9918fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the number of events in the file/buffer.Any dictionary or first event are <b>not</b> included in the count.<dl class="section return"><dt>Returns</dt><dd>the number of events in the file/buffer. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if read failure; if failed file access; if object closed</td></tr>
  </table>
  </dd>
</dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#afb236980e8a72c2253c1cc2a2c9918fb">More...</a><br /></td></tr>
<tr class="separator:afb236980e8a72c2253c1cc2a2c9918fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3575990f705692c10344bf3f5fc753cd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a3575990f705692c10344bf3f5fc753cd">getBlockCount</a> () override</td></tr>
<tr class="memdesc:a3575990f705692c10344bf3f5fc753cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the number of blocks/records in the file/buffer including the empty block, record or trailer at the end.<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if object closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of records in the file/buffer (estimate for version 3 files).</dd></dl>
  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a3575990f705692c10344bf3f5fc753cd">More...</a><br /></td></tr>
<tr class="separator:a3575990f705692c10344bf3f5fc753cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a22e2e5f965d9524de528f242562dd62e"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a22e2e5f965d9524de528f242562dd62e">MAGIC_OFFSET</a> = 28</td></tr>
<tr class="memdesc:a22e2e5f965d9524de528f242562dd62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset to get magic number from start of file.  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a22e2e5f965d9524de528f242562dd62e">More...</a><br /></td></tr>
<tr class="separator:a22e2e5f965d9524de528f242562dd62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf98c863ffeffe19fa2e77d2db2d9698"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#adf98c863ffeffe19fa2e77d2db2d9698">VERSION_OFFSET</a> = 20</td></tr>
<tr class="memdesc:adf98c863ffeffe19fa2e77d2db2d9698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset to get version number from start of file.  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#adf98c863ffeffe19fa2e77d2db2d9698">More...</a><br /></td></tr>
<tr class="separator:adf98c863ffeffe19fa2e77d2db2d9698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375f6530f64a5293c8cf1d1ac081deab"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a375f6530f64a5293c8cf1d1ac081deab">BLOCK_SIZE_OFFSET</a> = 0</td></tr>
<tr class="memdesc:a375f6530f64a5293c8cf1d1ac081deab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset to get block size from start of block.  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a375f6530f64a5293c8cf1d1ac081deab">More...</a><br /></td></tr>
<tr class="separator:a375f6530f64a5293c8cf1d1ac081deab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3afa89ee55ec4976f6ff912af72083"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ace3afa89ee55ec4976f6ff912af72083">VERSION_MASK</a> = 0xff</td></tr>
<tr class="memdesc:ace3afa89ee55ec4976f6ff912af72083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to get version number from 6th int in block.  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ace3afa89ee55ec4976f6ff912af72083">More...</a><br /></td></tr>
<tr class="separator:ace3afa89ee55ec4976f6ff912af72083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9baf7d5622c18daa125528639ffd8f27"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a9baf7d5622c18daa125528639ffd8f27">DEFAULT_READ_BYTES</a> = 32768 * 500</td></tr>
<tr class="memdesc:a9baf7d5622c18daa125528639ffd8f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default size for a single file read in bytes when reading evio format 1-3.  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a9baf7d5622c18daa125528639ffd8f27">More...</a><br /></td></tr>
<tr class="separator:a9baf7d5622c18daa125528639ffd8f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab851d0a680a06875f14cbeee08c62c62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ab851d0a680a06875f14cbeee08c62c62">parseFirstHeader</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;headerBuf)</td></tr>
<tr class="memdesc:ab851d0a680a06875f14cbeee08c62c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 8 words of the first block (physical record) header in order to determine the evio version # and endianness of the file or buffer in question.  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ab851d0a680a06875f14cbeee08c62c62">More...</a><br /></td></tr>
<tr class="separator:ab851d0a680a06875f14cbeee08c62c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8767111bda74f2c5b994aeeee4c2cefa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#aeb9b24a83d7fc38eacf3f6b3b329f926">IEvioReader::ReadWriteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a8767111bda74f2c5b994aeeee4c2cefa">processNextBlock</a> ()</td></tr>
<tr class="memdesc:a8767111bda74f2c5b994aeeee4c2cefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the block (physical record) header.  <a href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a8767111bda74f2c5b994aeeee4c2cefa">More...</a><br /></td></tr>
<tr class="separator:a8767111bda74f2c5b994aeeee4c2cefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a class of interest to the user. </p>
<p>It is used to read any evio version format file or buffer. Create an <code><a class="el" href="../../df/dbd/classevio_1_1_evio_reader.html" title="This is a class of interest to the user.">EvioReader</a></code> object corresponding to an event file or file-formatted buffer, and from this class you can test it for consistency and, more importantly, you can call <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#afb69bdb4a8d522a4605a41505720633a">parseNextEvent</a> or <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a605bc27fbfa468057669a5a157478f78">parseEvent(size_t)</a> to get new events and to stream the embedded structures to an <a class="el" href="../../d9/d71/classevio_1_1_i_evio_listener.html" title="In SAX like behavior, implementors will listen for structures encountered when an event is parsed.">IEvioListener</a>.</p>
<p>A word to the wise, constructors for reading a file in random access mode (by setting "sequential" arg to false), will memory map the file. This is <b>not</b> a good idea if the file is not on a local disk.</p>
<p>The streaming effect of parsing an event is that the parser will read the event and hand off structures, such as banks, to any IEvioListeners. For those familiar with XML, the event is processed SAX-like. It is up to the listener to decide what to do with the structures. </p>
<p>As an alternative to stream processing, after an event is parsed, the user can use the events' tree structure for access its nodes. For those familiar with XML, the event is processed DOM-like. </p>
<dl class="section author"><dt>Author</dt><dd>heddle (original java version) </dd>
<dd>
timmer </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aeb9b24a83d7fc38eacf3f6b3b329f926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9b24a83d7fc38eacf3f6b3b329f926">&#9670;&nbsp;</a></span>ReadWriteStatus</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#aeb9b24a83d7fc38eacf3f6b3b329f926">evio::IEvioReader::ReadWriteStatus</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This <code>enum</code> denotes the status of a read/write. </p>
<p><b>Used internally.</b><br  />
 SUCCESS indicates a successful read. <br  />
 END_OF_FILE indicates that we cannot read because an END_OF_FILE has occurred. Technically this means that whatever we are trying to read is larger than the buffer's unread bytes.<br  />
 CANNOT_OPEN_FILE indicates that we cannot write because the destination file cannot be opened.<br  />
 EVIO_EXCEPTION indicates that an <a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a> was thrown during a read/write, possibly due to out of range values.<br  />
 UNKNOWN_ERROR indicates that an unrecoverable error has occurred. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aeb9b24a83d7fc38eacf3f6b3b329f926ab14e3269cc4f96bf7a442d278fc51009"></a>SUCCESS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aeb9b24a83d7fc38eacf3f6b3b329f926a6413574a07e897b7be4800fa6921e2e7"></a>END_OF_FILE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aeb9b24a83d7fc38eacf3f6b3b329f926ae0ddb8ce05a096046ff47cf917969b50"></a>CANNOT_OPEN_FILE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aeb9b24a83d7fc38eacf3f6b3b329f926ae3b4a070ccd53865afcc4bc2ad91ed47"></a>EVIO_EXCEPTION&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aeb9b24a83d7fc38eacf3f6b3b329f926a0c4ce2651b53b53a2e628c80bf3db456"></a>UNKNOWN_ERROR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaceaf45be3fe4156a280ab9f78f8697e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaceaf45be3fe4156a280ab9f78f8697e">&#9670;&nbsp;</a></span>EvioReaderV4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">evio::EvioReaderV4::EvioReaderV4 </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkBlkNumSeq</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>synced</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for reading an event file. </p>
<p>Do <b>not</b> set sequential to false for remote files.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the full path to the file that contains events. For writing event files, use an <code><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a></code> object. </td></tr>
    <tr><td class="paramname">checkBlkNumSeq</td><td>if <code>true</code> check the block number sequence and throw an exception if it is not sequential starting with 1 </td></tr>
    <tr><td class="paramname">synced</td><td>if true, this class's methods are mutex protected for thread safety. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if file arg is null; if read failure; if first block number != 1 when checkBlkNumSeq arg is true </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ab851d0a680a06875f14cbeee08c62c62">parseFirstHeader()</a>, and <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#afb69bdb4a8d522a4605a41505720633a">parseNextEvent()</a>.</p>

</div>
</div>
<a id="ada0fe4bdc542167bcaaccf7c220c0f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0fe4bdc542167bcaaccf7c220c0f44">&#9670;&nbsp;</a></span>EvioReaderV4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">evio::EvioReaderV4::EvioReaderV4 </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkBlkNumSeq</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>synced</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for reading a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td>the buffer that contains events. </td></tr>
    <tr><td class="paramname">checkBlkNumSeq</td><td>if <code>true</code> check the block number sequence and throw an exception if it is not sequential starting with 1 </td></tr>
    <tr><td class="paramname">synced</td><td>if true, this class's methods are mutex protected for thread safety. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if buffer arg is null; if first block number != 1 when checkBlkNumSeq arg is true </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ab851d0a680a06875f14cbeee08c62c62">parseFirstHeader()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a063a318617679c6456802a2f5a840915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063a318617679c6456802a2f5a840915">&#9670;&nbsp;</a></span>checkBlockNumberSequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::EvioReaderV4::checkBlockNumberSequence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this reader checking the block number sequence and throwing an exception if it's not sequential and starting with 1?<dl class="section return"><dt>Returns</dt><dd><code>true</code> if checking block number sequence, else <code>false</code></dd></dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a522697d2985c7cb42938b241e476cdb3">evio::IEvioReader</a>.</p>

</div>
</div>
<a id="adc59efe016e7c5c57350d41fd9bfbd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc59efe016e7c5c57350d41fd9bfbd18">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evio::EvioReaderV4::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is closes the file, but for buffers it only sets the position to 0.This method, along with the <code><a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a73cb48511f980029d7a55ce70c34765b" title="The equivalent of rewinding the file.">rewind()</a></code> and the two <code><a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a3a3c4a46ffffbd0d090e8ee04a5b54f2" title="This is equivalent to obtaining the current position in the file.">position()</a></code> methods, allows applications to treat files in a normal random access manner. </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#abfcc831176f6b4b0c402838b2fa09e6f">evio::IEvioReader</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ad8e9531e9f836cec9980ba88296f8ea6">setBuffer()</a>.</p>

</div>
</div>
<a id="a316eddece193b0cde1a55265d37b8e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316eddece193b0cde1a55265d37b8e10">&#9670;&nbsp;</a></span>fileSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t evio::EvioReaderV4::fileSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the file being read, in bytes.<dl class="section return"><dt>Returns</dt><dd>the file size in bytes</dd></dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#adc2e2fcc2aceea85771325bac4f3c397">evio::IEvioReader</a>.</p>

</div>
</div>
<a id="a3575990f705692c10344bf3f5fc753cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3575990f705692c10344bf3f5fc753cd">&#9670;&nbsp;</a></span>getBlockCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t evio::EvioReaderV4::getBlockCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the number of blocks/records in the file/buffer including the empty block, record or trailer at the end.<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if object closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of records in the file/buffer (estimate for version 3 files).</dd></dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#ac03a4df4105a632bb88b10d3902a14b5">evio::IEvioReader</a>.</p>

</div>
</div>
<a id="abcab0d75e41dc94b7dfd6f8dc9625c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcab0d75e41dc94b7dfd6f8dc9625c17">&#9670;&nbsp;</a></span>getByteBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; evio::EvioReaderV4::getByteBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the byte buffer being read.Not useful when reading files. </p><dl class="section return"><dt>Returns</dt><dd>the byte buffer being read (in certain cases).</dd></dl>
. </p>
<p>For files, it works only for evio format versions 2,3 and returns the internal buffer containing an evio block if using sequential access (for example files &gt; 2.1 GB). It returns the memory mapped buffer otherwise. </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#ad438c3d38ceca2c36bd6be31eb91b4f1">evio::IEvioReader</a>.</p>

</div>
</div>
<a id="aa19337f49c0132536d8d775469c56bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19337f49c0132536d8d775469c56bac">&#9670;&nbsp;</a></span>getByteOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp; evio::EvioReaderV4::getByteOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the byte order of the file/buffer being read.<dl class="section return"><dt>Returns</dt><dd>byte order of the file/buffer being read.</dd></dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a29d8c718deecc5698b2af791ac95cf0e">evio::IEvioReader</a>.</p>

</div>
</div>
<a id="a689d91e4167e2298da870cf26049d670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689d91e4167e2298da870cf26049d670">&#9670;&nbsp;</a></span>getCurrentBlockHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../d5/d6e/classevio_1_1_i_block_header.html">IBlockHeader</a> &gt; evio::EvioReaderV4::getCurrentBlockHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This returns the current (active) block (physical record) header.Since most users have no interest in physical records, this method should not be used.<dl class="section return"><dt>Returns</dt><dd>the current block header.</dd></dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a2045b543588af4ed7a48f2613d0d40d6">evio::IEvioReader</a>.</p>

</div>
</div>
<a id="a1de85bc20f69676951af001a294d0ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de85bc20f69676951af001a294d0ea8">&#9670;&nbsp;</a></span>getDictionaryXML()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string evio::EvioReaderV4::getDictionaryXML </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the XML format dictionary if there is one.<dl class="section return"><dt>Returns</dt><dd>XML format dictionary, else null.</dd></dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#ac23b043c8fc151f4d0dfc1a61ed481cc">evio::IEvioReader</a>.</p>

</div>
</div>
<a id="a66f9780670a7493fe61ecd9bd478e070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f9780670a7493fe61ecd9bd478e070">&#9670;&nbsp;</a></span>getEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../d4/d12/classevio_1_1_evio_event.html">EvioEvent</a> &gt; evio::EvioReaderV4::getEvent </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the event in the file/buffer at a given index (starting at 1).As useful as this sounds, most applications will probably call <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#abff17b5f200e64826bffce2a60f3ae66">parseNextEvent()</a> or <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#abcd2be8738fe4162409a7d2e883b672b">parseEvent(size_t)</a> instead, since it combines combines getting an event with parsing it.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>number of event desired, starting at 1, from beginning of file/buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the event in the file/buffer at the given index or null if none </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if failed file access; if failed read due to bad file/buffer format; if index out of bounds; if object closed</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a848dc77538de2be992d106c590180df4">evio::IEvioReader</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ab95ca3bc461086c3a998d269a322f167">getFirstEvent()</a>, <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a46655f6197c4f00a3a8a7dc38f15f162">nextEvent()</a>, and <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a605bc27fbfa468057669a5a157478f78">parseEvent()</a>.</p>

</div>
</div>
<a id="a5c85cf1408ce75097e67d29624235c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c85cf1408ce75097e67d29624235c35">&#9670;&nbsp;</a></span>getEventArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::EvioReaderV4::getEventArray </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>evNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an evio bank or event in vector-of-bytes form.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evNumber</td><td>number of event of interest (starting at 1). </td></tr>
    <tr><td class="paramname">vec</td><td>vector to contain bank's/event's bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes in returned event. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if failed file access; if eventNumber out of bounds (starts at 1); if the event number does not correspond to an existing event; if object closed</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a8781be206ac8c3058beea4607168b329">evio::IEvioReader</a>.</p>

</div>
</div>
<a id="a2d24a3b4a17c63b56084cb865ab9f741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d24a3b4a17c63b56084cb865ab9f741">&#9670;&nbsp;</a></span>getEventBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::EvioReaderV4::getEventBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>evNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an evio bank or event in <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> form.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evNumber</td><td>number of event of interest </td></tr>
    <tr><td class="paramname">buf</td><td>buffer to contain bank's/event's bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes in returned event. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if failed file access; if eventNumber out of bounds (starts at 1); if the event number does not correspond to an existing event; if object closed</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a8aab3078f0825fdc44adb996637286d5">evio::IEvioReader</a>.</p>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#aa0e335238a57eaa0bffee8f968e5995f">evio::ByteBuffer::array()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#ac07ae24bab386451176df095a376d330">evio::ByteBuffer::expand()</a>, and <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#afb08d1dbc5fbf780afd27617a67eb750">evio::ByteBuffer::limit()</a>.</p>

</div>
</div>
<a id="afb236980e8a72c2253c1cc2a2c9918fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb236980e8a72c2253c1cc2a2c9918fb">&#9670;&nbsp;</a></span>getEventCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t evio::EvioReaderV4::getEventCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the number of events in the file/buffer.Any dictionary or first event are <b>not</b> included in the count.<dl class="section return"><dt>Returns</dt><dd>the number of events in the file/buffer. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if read failure; if failed file access; if object closed</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a083befb0e32e9349014602d820d10284">evio::IEvioReader</a>.</p>

<p class="reference">References <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a6aa4b9ec29f2198c25d96fb1f1889c28">hasDictionaryXML()</a>, <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a46655f6197c4f00a3a8a7dc38f15f162">nextEvent()</a>, and <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ab299451c3cb8fa93da0f4eca0666887c">rewind()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a4423942f5b5ffe914c6cd9523016d616">getNumEventsRemaining()</a>.</p>

</div>
</div>
<a id="ac3a67d0b1fde4b8ebbbceda5fb301dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a67d0b1fde4b8ebbbceda5fb301dff">&#9670;&nbsp;</a></span>getEvioVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::EvioReaderV4::getEvioVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the evio version number.<dl class="section return"><dt>Returns</dt><dd>evio version number.</dd></dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#ade702470274a154209f94c8eb8de046e">evio::IEvioReader</a>.</p>

</div>
</div>
<a id="ac1437a584908549758a269487373d0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1437a584908549758a269487373d0b4">&#9670;&nbsp;</a></span>getFirstBlockHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../d5/d6e/classevio_1_1_i_block_header.html">IBlockHeader</a> &gt; evio::EvioReaderV4::getFirstBlockHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This returns the FIRST block (record) header.<dl class="section return"><dt>Returns</dt><dd>the first block (record) header.</dd></dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a0d13f3328420b54c37766141d3c8b688">evio::IEvioReader</a>.</p>

</div>
</div>
<a id="ab95ca3bc461086c3a998d269a322f167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95ca3bc461086c3a998d269a322f167">&#9670;&nbsp;</a></span>getFirstEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../d4/d12/classevio_1_1_evio_event.html">EvioEvent</a> &gt; evio::EvioReaderV4::getFirstEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the "first" event if there is one.It's also called the Beginning-Of-Run event. This event is defined once but included in each of the related split files written out. </p><dl class="section return"><dt>Returns</dt><dd>the first event is it existed, else null.</dd></dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#aa5b24915b5fa9c647784866088116120">evio::IEvioReader</a>.</p>

<p class="reference">References <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a66f9780670a7493fe61ecd9bd478e070">getEvent()</a>, and <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a24fac9c348dce02aebde184ab8a51792">hasFirstEvent()</a>.</p>

</div>
</div>
<a id="a4423942f5b5ffe914c6cd9523016d616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4423942f5b5ffe914c6cd9523016d616">&#9670;&nbsp;</a></span>getNumEventsRemaining()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t evio::EvioReaderV4::getNumEventsRemaining </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of events remaining in the file.Useful only if doing a sequential read.<dl class="section return"><dt>Returns</dt><dd>number of events remaining in the file </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if failed reading from file</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a4eeea1ddbfbe0d76e4669c440cf1e5b0">evio::IEvioReader</a>.</p>

<p class="reference">References <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#afb236980e8a72c2253c1cc2a2c9918fb">getEventCount()</a>.</p>

</div>
</div>
<a id="a5611fcde6de0d545e86ebe9f5de5c4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5611fcde6de0d545e86ebe9f5de5c4a2">&#9670;&nbsp;</a></span>getParser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../d7/d5d/classevio_1_1_event_parser.html">EventParser</a> &gt; &amp; evio::EvioReaderV4::getParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the file/buffer parser.<dl class="section return"><dt>Returns</dt><dd>file/buffer parser.</dd></dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#ad26dab3458bf03003a0cbbe84fefa567">evio::IEvioReader</a>.</p>

</div>
</div>
<a id="ad809ffeda3b80606b4f2a76469a05f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad809ffeda3b80606b4f2a76469a05f1d">&#9670;&nbsp;</a></span>getPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string evio::EvioReaderV4::getPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the path to the file.<dl class="section return"><dt>Returns</dt><dd>path to the file</dd></dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a5dd302d0d8651ebe45ed81d66f1eea96">evio::IEvioReader</a>.</p>

</div>
</div>
<a id="ac51fae5c6c4f8a9aea1d398379f89857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51fae5c6c4f8a9aea1d398379f89857">&#9670;&nbsp;</a></span>gotoEventNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../d4/d12/classevio_1_1_evio_event.html">EvioEvent</a> &gt; evio::EvioReaderV4::gotoEventNumber </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>evNumber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Go to a specific event in the file.The events are numbered 1..N. This number is transient&ndash;it is not part of the event as stored in the evio file. In versions 4 and up this is just a wrapper on <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a848dc77538de2be992d106c590180df4">getEvent(size_t)</a>.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evNumber</td><td>the event number in a 1..N counting sense, from the start of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the specified event in file or null if there's an error or nothing at that event #. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if object closed; if failed file access</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a0ff6709076fcdd97d13f813f1e6dfd35">evio::IEvioReader</a>.</p>

</div>
</div>
<a id="a6aa4b9ec29f2198c25d96fb1f1889c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa4b9ec29f2198c25d96fb1f1889c28">&#9670;&nbsp;</a></span>hasDictionaryXML()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::EvioReaderV4::hasDictionaryXML </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this evio file have an associated XML dictionary?<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this evio file has an associated XML dictionary, else <code>false</code></dd></dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a3b8d52dbf2b63734bb6b9844cc7f09a3">evio::IEvioReader</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#afb236980e8a72c2253c1cc2a2c9918fb">getEventCount()</a>, and <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ab299451c3cb8fa93da0f4eca0666887c">rewind()</a>.</p>

</div>
</div>
<a id="a24fac9c348dce02aebde184ab8a51792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fac9c348dce02aebde184ab8a51792">&#9670;&nbsp;</a></span>hasFirstEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::EvioReaderV4::hasFirstEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this evio file have an associated first event? It's also called the Beginning-Of-Run event.This event is defined once but included in each of the related split files written out. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if this evio file has an associated first event, else <code>false</code></dd></dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a8aa2bdd85a0b9dc864dd2c7a1ed084b8">evio::IEvioReader</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ab95ca3bc461086c3a998d269a322f167">getFirstEvent()</a>.</p>

</div>
</div>
<a id="a697baee61837fc5a935083d1b45a2e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a697baee61837fc5a935083d1b45a2e1b">&#9670;&nbsp;</a></span>isClosed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::EvioReaderV4::isClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#abfcc831176f6b4b0c402838b2fa09e6f">close()</a> been called (without reopening by calling <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a1018ab2d476c0638970ef40a7fb5e45f">setBuffer(std::shared_ptr&lt;ByteBuffer&gt; &amp;)</a>)?<dl class="section return"><dt>Returns</dt><dd><div class="fragment"><div class="line"><span class="keyword">true</span> </div>
</div><!-- fragment --> if this object closed, else<div class="fragment"><div class="line"><span class="keyword">false</span> </div>
</div><!-- fragment --> .</dd></dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#ab5bad722797b96b9b756d739b9aa803f">evio::IEvioReader</a>.</p>

</div>
</div>
<a id="a46655f6197c4f00a3a8a7dc38f15f162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46655f6197c4f00a3a8a7dc38f15f162">&#9670;&nbsp;</a></span>nextEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../d4/d12/classevio_1_1_evio_event.html">EvioEvent</a> &gt; evio::EvioReaderV4::nextEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the next event in the file/buffer.As useful as this sounds, most applications will probably call <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#abff17b5f200e64826bffce2a60f3ae66">parseNextEvent()</a> instead, since it combines getting the next event with parsing the next event.Although this method can get events in versions 4+, it now delegates that to another method. No changes were made to this method from versions 1-3 in order to read the version 4 format as it is subset of versions 1-3 with variable block length.<dl class="section return"><dt>Returns</dt><dd>the next event in the file. On error it throws an <a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a>. On end of file, it returns <code>null</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if failed file access; if failed read due to bad buffer format; if object closed</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a67dd00a6ade28faedc3876240f35edeb">evio::IEvioReader</a>.</p>

<p class="reference">References <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a66f9780670a7493fe61ecd9bd478e070">getEvent()</a>, <a class="el" href="../../d4/d12/classevio_1_1_evio_event.html#a3baa3d9bbaabf8f826ca02fb656e776d">evio::EvioEvent::getInstance()</a>, and <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a8767111bda74f2c5b994aeeee4c2cefa">processNextBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#afb236980e8a72c2253c1cc2a2c9918fb">getEventCount()</a>, <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#afb69bdb4a8d522a4605a41505720633a">parseNextEvent()</a>, and <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ab299451c3cb8fa93da0f4eca0666887c">rewind()</a>.</p>

</div>
</div>
<a id="a605bc27fbfa468057669a5a157478f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605bc27fbfa468057669a5a157478f78">&#9670;&nbsp;</a></span>parseEvent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../d4/d12/classevio_1_1_evio_event.html">EvioEvent</a> &gt; evio::EvioReaderV4::parseEvent </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a workhorse method.It retrieves the desired event from the file/buffer, and then parses it SAX-like. It will drill down and uncover all structures (banks, segments, and tagsegments) and notify any interested listeners.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>number of event desired, starting at 1, from beginning of file/buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed event at the given index or null if none </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if failed file access; if failed read due to bad file/buffer format; if index out of bounds; if object closed</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#abcd2be8738fe4162409a7d2e883b672b">evio::IEvioReader</a>.</p>

<p class="reference">References <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a66f9780670a7493fe61ecd9bd478e070">getEvent()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#afb69bdb4a8d522a4605a41505720633a">parseNextEvent()</a>.</p>

</div>
</div>
<a id="ad64cac6bd49f60a3ad8ff0e621b5e391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64cac6bd49f60a3ad8ff0e621b5e391">&#9670;&nbsp;</a></span>parseEvent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evio::EvioReaderV4::parseEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../d4/d12/classevio_1_1_evio_event.html">EvioEvent</a> &gt;&#160;</td>
          <td class="paramname"><em>evioEvent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This will parse an event, SAX-like.It will drill down and uncover all structures (banks, segments, and tagsegments) and notify any interested listeners.As useful as this sounds, most applications will probably call <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#abff17b5f200e64826bffce2a60f3ae66">parseNextEvent()</a> instead, since it combines combines getting the next event with parsing the next event.This method is only called by synchronized methods and therefore is not synchronized.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evioEvent</td><td>the event to parse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if bad format</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#ad5ad0599b4726846b3e34db9b036db99">evio::IEvioReader</a>.</p>

</div>
</div>
<a id="ab851d0a680a06875f14cbeee08c62c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab851d0a680a06875f14cbeee08c62c62">&#9670;&nbsp;</a></span>parseFirstHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evio::EvioReaderV4::parseFirstHeader </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>headerBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads 8 words of the first block (physical record) header in order to determine the evio version # and endianness of the file or buffer in question. </p>
<p>These things do <b>not</b> need to be examined in subsequent block headers. Called only by synchronized methods or constructors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">headerBuf</td><td>buffer containing data to parse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if buffer too small, contains invalid data, or bad block # sequence </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#a5240c7673d80d6e03e890b3472ac00d4">evio::ByteOrder::getOppositeEndian()</a>, <a class="el" href="../../da/de6/classevio_1_1_block_header_v4.html#a76120f781b57819705f163ada7103517">evio::BlockHeaderV4::HEADER_SIZE</a>, <a class="el" href="../../d5/d6e/classevio_1_1_i_block_header.html#ac5f22d640a8987649db4fd4c8c699cb7">evio::IBlockHeader::MAGIC_NUMBER</a>, <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a22e2e5f965d9524de528f242562dd62e">MAGIC_OFFSET</a>, <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ace3afa89ee55ec4976f6ff912af72083">VERSION_MASK</a>, and <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#adf98c863ffeffe19fa2e77d2db2d9698">VERSION_OFFSET</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#aaceaf45be3fe4156a280ab9f78f8697e">EvioReaderV4()</a>, and <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ad8e9531e9f836cec9980ba88296f8ea6">setBuffer()</a>.</p>

</div>
</div>
<a id="afb69bdb4a8d522a4605a41505720633a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb69bdb4a8d522a4605a41505720633a">&#9670;&nbsp;</a></span>parseNextEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../d4/d12/classevio_1_1_evio_event.html">EvioEvent</a> &gt; evio::EvioReaderV4::parseNextEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a workhorse method.It retrieves the next event from the file/buffer, and then parses it SAX-like. It will drill down and uncover all structures (banks, segments, and tagsegments) and notify any interested listeners.<dl class="section return"><dt>Returns</dt><dd>the event that was parsed. On error it throws an <a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a>. On end of file, it returns <code>null</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if failed file access; if read failure or bad format; if object closed</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#abff17b5f200e64826bffce2a60f3ae66">evio::IEvioReader</a>.</p>

<p class="reference">References <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a46655f6197c4f00a3a8a7dc38f15f162">nextEvent()</a>, and <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a605bc27fbfa468057669a5a157478f78">parseEvent()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#aaceaf45be3fe4156a280ab9f78f8697e">EvioReaderV4()</a>.</p>

</div>
</div>
<a id="a788f6442710ea217855ba4c70787b5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788f6442710ea217855ba4c70787b5d5">&#9670;&nbsp;</a></span>position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t evio::EvioReaderV4::position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is equivalent to obtaining the current position in the file.What it actually does is return the position of the buffer. This method, along with the <code><a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a73cb48511f980029d7a55ce70c34765b" title="The equivalent of rewinding the file.">rewind()</a></code>, <code>position(int)</code> and the <code><a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#abfcc831176f6b4b0c402838b2fa09e6f" title="This is closes the file, but for buffers it only sets the position to 0.">close()</a></code> method, allows applications to treat files in a normal random access manner. Only meaningful to evio versions 1-3 and for sequential reading.<dl class="section return"><dt>Returns</dt><dd>the position of the buffer; -1 if not sequential read and version 4+ </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if object closed; if error accessing file</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a3a3c4a46ffffbd0d090e8ee04a5b54f2">evio::IEvioReader</a>.</p>

</div>
</div>
<a id="a8767111bda74f2c5b994aeeee4c2cefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8767111bda74f2c5b994aeeee4c2cefa">&#9670;&nbsp;</a></span>processNextBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#aeb9b24a83d7fc38eacf3f6b3b329f926">IEvioReader::ReadWriteStatus</a> evio::EvioReaderV4::processNextBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the block (physical record) header. </p>
<p>Assumes mapped buffer or file is positioned at start of the next block header. If a sequential file: version 4, Read the entire next block into internal buffer. version 1-3, If unused data still exists in internal buffer, don't read anymore in right now as there is at least 1 block there (integral # of blocks read in). If no data in internal buffer read DEFAULT_READ_BYTES or the rest of the file, whichever is smaller, into the internal buffer.</p>
<p>By the time this is called, the version # and byte order have already been determined. Not necessary to do that for each block header that's read. Called from synchronized method.</p>
<p>A Bank header is 8, 32-bit ints. The first int is the size of the block in ints (not counting the length itself, i.e., the number of ints to follow).</p>
<p>Most users should have no need for this method, since most applications do not care about the block (physical record) header.</p>
<dl class="section return"><dt>Returns</dt><dd>status of read attempt </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if file access problems, evio format problems </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a9baf7d5622c18daa125528639ffd8f27">DEFAULT_READ_BYTES</a>, <a class="el" href="../../da/de6/classevio_1_1_block_header_v4.html#a76120f781b57819705f163ada7103517">evio::BlockHeaderV4::HEADER_SIZE</a>, and <a class="el" href="../../d1/d02/_byte_order_8h.html#a700fb30611761c46a674a45cc28ff561">SWAP_32</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a46655f6197c4f00a3a8a7dc38f15f162">nextEvent()</a>.</p>

</div>
</div>
<a id="ab299451c3cb8fa93da0f4eca0666887c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab299451c3cb8fa93da0f4eca0666887c">&#9670;&nbsp;</a></span>rewind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evio::EvioReaderV4::rewind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The equivalent of rewinding the file.What it actually does is set the position of the file/buffer back to where it was after calling the constructor - after the first header. This method, along with the two <code><a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a3a3c4a46ffffbd0d090e8ee04a5b54f2" title="This is equivalent to obtaining the current position in the file.">position()</a></code> and the <code><a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#abfcc831176f6b4b0c402838b2fa09e6f" title="This is closes the file, but for buffers it only sets the position to 0.">close()</a></code> method, allows applications to treat files in a normal random access manner.<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if object closed; if failed file access or buffer/file read</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a73cb48511f980029d7a55ce70c34765b">evio::IEvioReader</a>.</p>

<p class="reference">References <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a6aa4b9ec29f2198c25d96fb1f1889c28">hasDictionaryXML()</a>, and <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a46655f6197c4f00a3a8a7dc38f15f162">nextEvent()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#afb236980e8a72c2253c1cc2a2c9918fb">getEventCount()</a>.</p>

</div>
</div>
<a id="ad8e9531e9f836cec9980ba88296f8ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e9531e9f836cec9980ba88296f8ea6">&#9670;&nbsp;</a></span>setBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evio::EvioReaderV4::setBuffer </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method can be used to avoid creating additional <a class="el" href="../../df/dbd/classevio_1_1_evio_reader.html" title="This is a class of interest to the user.">EvioReader</a> objects by reusing this one with another buffer.The method <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#abfcc831176f6b4b0c402838b2fa09e6f">close()</a> is called before anything else.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> to be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">underflow_error</td><td>if not enough data in buffer. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if buf is null; buf not in proper format; if first record/block number != 1 when checkRecNumSeq arg is true.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a1018ab2d476c0638970ef40a7fb5e45f">evio::IEvioReader</a>.</p>

<p class="reference">References <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#adc59efe016e7c5c57350d41fd9bfbd18">close()</a>, and <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ab851d0a680a06875f14cbeee08c62c62">parseFirstHeader()</a>.</p>

</div>
</div>
<a id="a8855a45490b79bc50eb97ea4985c6efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8855a45490b79bc50eb97ea4985c6efe">&#9670;&nbsp;</a></span>setParser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evio::EvioReaderV4::setParser </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../d7/d5d/classevio_1_1_event_parser.html">EventParser</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>evParser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the file/buffer parser.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evParser</td><td>file/buffer parser.</td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Implements <a class="el" href="../../de/d97/classevio_1_1_i_evio_reader.html#a906861412ddde5f377d529e2ce691a71">evio::IEvioReader</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a375f6530f64a5293c8cf1d1ac081deab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a375f6530f64a5293c8cf1d1ac081deab">&#9670;&nbsp;</a></span>BLOCK_SIZE_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t evio::EvioReaderV4::BLOCK_SIZE_OFFSET = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Offset to get block size from start of block. </p>

</div>
</div>
<a id="a9baf7d5622c18daa125528639ffd8f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9baf7d5622c18daa125528639ffd8f27">&#9670;&nbsp;</a></span>DEFAULT_READ_BYTES</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t evio::EvioReaderV4::DEFAULT_READ_BYTES = 32768 * 500</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default size for a single file read in bytes when reading evio format 1-3. </p>
<p>Equivalent to 500, 32,768 byte blocks. This constant <b>MUST BE</b> an integer multiple of 32768. </p>

<p class="reference">Referenced by <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#a8767111bda74f2c5b994aeeee4c2cefa">processNextBlock()</a>.</p>

</div>
</div>
<a id="a22e2e5f965d9524de528f242562dd62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e2e5f965d9524de528f242562dd62e">&#9670;&nbsp;</a></span>MAGIC_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t evio::EvioReaderV4::MAGIC_OFFSET = 28</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Offset to get magic number from start of file. </p>

<p class="reference">Referenced by <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ab851d0a680a06875f14cbeee08c62c62">parseFirstHeader()</a>.</p>

</div>
</div>
<a id="ace3afa89ee55ec4976f6ff912af72083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3afa89ee55ec4976f6ff912af72083">&#9670;&nbsp;</a></span>VERSION_MASK</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t evio::EvioReaderV4::VERSION_MASK = 0xff</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mask to get version number from 6th int in block. </p>

<p class="reference">Referenced by <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ab851d0a680a06875f14cbeee08c62c62">parseFirstHeader()</a>.</p>

</div>
</div>
<a id="adf98c863ffeffe19fa2e77d2db2d9698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf98c863ffeffe19fa2e77d2db2d9698">&#9670;&nbsp;</a></span>VERSION_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t evio::EvioReaderV4::VERSION_OFFSET = 20</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Offset to get version number from start of file. </p>

<p class="reference">Referenced by <a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html#ab851d0a680a06875f14cbeee08c62c62">parseFirstHeader()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="../../d3/d9e/_evio_reader_v4_8h.html">EvioReaderV4.h</a></li>
<li><a class="el" href="../../de/da5/_evio_reader_v4_8cpp.html">EvioReaderV4.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d9/deb/namespaceevio.html">evio</a></li><li class="navelem"><a class="el" href="../../dd/db3/classevio_1_1_evio_reader_v4.html">EvioReaderV4</a></li>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
