<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>evio: evio::RecordInput Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">evio
   &#160;<span id="projectnumber">6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('de/da2/classevio_1_1_record_input.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="../../d3/db9/classevio_1_1_record_input-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">evio::RecordInput Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class which reads data to create an Evio or HIPO Record.  
 <a href="../../de/da2/classevio_1_1_record_input.html#details">More...</a></p>

<p><code>#include &lt;RecordInput.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a594a0b6430cfd782d741e5835dda7d0a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#a594a0b6430cfd782d741e5835dda7d0a">RecordInput</a> ()</td></tr>
<tr class="memdesc:a594a0b6430cfd782d741e5835dda7d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="../../de/da2/classevio_1_1_record_input.html#a594a0b6430cfd782d741e5835dda7d0a">More...</a><br /></td></tr>
<tr class="separator:a594a0b6430cfd782d741e5835dda7d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f3443a651a5777f4ca5703a65ec0a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#a50f3443a651a5777f4ca5703a65ec0a4">RecordInput</a> (const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;order)</td></tr>
<tr class="memdesc:a50f3443a651a5777f4ca5703a65ec0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="../../de/da2/classevio_1_1_record_input.html#a50f3443a651a5777f4ca5703a65ec0a4">More...</a><br /></td></tr>
<tr class="separator:a50f3443a651a5777f4ca5703a65ec0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36390ccb249caf2b414fabfd6dd2aaf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#ad36390ccb249caf2b414fabfd6dd2aaf">RecordInput</a> (const <a class="el" href="../../de/da2/classevio_1_1_record_input.html">RecordInput</a> &amp;recordIn)</td></tr>
<tr class="memdesc:ad36390ccb249caf2b414fabfd6dd2aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="../../de/da2/classevio_1_1_record_input.html#ad36390ccb249caf2b414fabfd6dd2aaf">More...</a><br /></td></tr>
<tr class="separator:ad36390ccb249caf2b414fabfd6dd2aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99fdb7643197e0a5936ae98fe90f9cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#ac99fdb7643197e0a5936ae98fe90f9cd">RecordInput</a> (<a class="el" href="../../de/da2/classevio_1_1_record_input.html">RecordInput</a> &amp;&amp;srcRec) noexcept</td></tr>
<tr class="memdesc:ac99fdb7643197e0a5936ae98fe90f9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="../../de/da2/classevio_1_1_record_input.html#ac99fdb7643197e0a5936ae98fe90f9cd">More...</a><br /></td></tr>
<tr class="separator:ac99fdb7643197e0a5936ae98fe90f9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d86a58f649571c03497c7eb2ba125a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#a34d86a58f649571c03497c7eb2ba125a">~RecordInput</a> ()=default</td></tr>
<tr class="separator:a34d86a58f649571c03497c7eb2ba125a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40d7cca1eb46111544ca0a3537d9fdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da2/classevio_1_1_record_input.html">RecordInput</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#aa40d7cca1eb46111544ca0a3537d9fdc">operator=</a> (<a class="el" href="../../de/da2/classevio_1_1_record_input.html">RecordInput</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:aa40d7cca1eb46111544ca0a3537d9fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="../../de/da2/classevio_1_1_record_input.html#aa40d7cca1eb46111544ca0a3537d9fdc">More...</a><br /></td></tr>
<tr class="separator:aa40d7cca1eb46111544ca0a3537d9fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d88256111bd532501b99bb95583fe93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da2/classevio_1_1_record_input.html">RecordInput</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#a6d88256111bd532501b99bb95583fe93">operator=</a> (const <a class="el" href="../../de/da2/classevio_1_1_record_input.html">RecordInput</a> &amp;other)</td></tr>
<tr class="memdesc:a6d88256111bd532501b99bb95583fe93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="../../de/da2/classevio_1_1_record_input.html#a6d88256111bd532501b99bb95583fe93">More...</a><br /></td></tr>
<tr class="separator:a6d88256111bd532501b99bb95583fe93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe9771eb8a45b7a6e3b63f0458c0255"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d8/d64/classevio_1_1_record_header.html">RecordHeader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#aabe9771eb8a45b7a6e3b63f0458c0255">getHeader</a> ()</td></tr>
<tr class="memdesc:aabe9771eb8a45b7a6e3b63f0458c0255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the header of this record.  <a href="../../de/da2/classevio_1_1_record_input.html#aabe9771eb8a45b7a6e3b63f0458c0255">More...</a><br /></td></tr>
<tr class="separator:aabe9771eb8a45b7a6e3b63f0458c0255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b1a052e0520138565229072470b036"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#ac8b1a052e0520138565229072470b036">getByteOrder</a> ()</td></tr>
<tr class="memdesc:ac8b1a052e0520138565229072470b036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the byte order of the internal buffers.  <a href="../../de/da2/classevio_1_1_record_input.html#ac8b1a052e0520138565229072470b036">More...</a><br /></td></tr>
<tr class="separator:ac8b1a052e0520138565229072470b036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3374ca3748213d7b25252b2f5e9d193"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#ad3374ca3748213d7b25252b2f5e9d193">getUncompressedDataBuffer</a> ()</td></tr>
<tr class="memdesc:ad3374ca3748213d7b25252b2f5e9d193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer with all uncompressed data in it.  <a href="../../de/da2/classevio_1_1_record_input.html#ad3374ca3748213d7b25252b2f5e9d193">More...</a><br /></td></tr>
<tr class="separator:ad3374ca3748213d7b25252b2f5e9d193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f50d5521b94d5c4a520e39a7ef9025f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#a0f50d5521b94d5c4a520e39a7ef9025f">hasIndex</a> () const</td></tr>
<tr class="memdesc:a0f50d5521b94d5c4a520e39a7ef9025f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this record contain an event index?  <a href="../../de/da2/classevio_1_1_record_input.html#a0f50d5521b94d5c4a520e39a7ef9025f">More...</a><br /></td></tr>
<tr class="separator:a0f50d5521b94d5c4a520e39a7ef9025f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34df12d892e4c91c541d4be07147741"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#af34df12d892e4c91c541d4be07147741">hasUserHeader</a> () const</td></tr>
<tr class="memdesc:af34df12d892e4c91c541d4be07147741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this record contain a user header?  <a href="../../de/da2/classevio_1_1_record_input.html#af34df12d892e4c91c541d4be07147741">More...</a><br /></td></tr>
<tr class="separator:af34df12d892e4c91c541d4be07147741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc47d4d9e244aa4aa89d9a1006484ef"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#a3fc47d4d9e244aa4aa89d9a1006484ef">getEvent</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buffer, uint32_t index, size_t bufOffset=0)</td></tr>
<tr class="memdesc:a3fc47d4d9e244aa4aa89d9a1006484ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the event at the given index and write it into the given byte buffer.  <a href="../../de/da2/classevio_1_1_record_input.html#a3fc47d4d9e244aa4aa89d9a1006484ef">More...</a><br /></td></tr>
<tr class="separator:a3fc47d4d9e244aa4aa89d9a1006484ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a32c2c8ad1ba30a4204c8a56fb84bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#a48a32c2c8ad1ba30a4204c8a56fb84bb">getEvent</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;buffer, uint32_t index, size_t bufOffset=0)</td></tr>
<tr class="memdesc:a48a32c2c8ad1ba30a4204c8a56fb84bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the event at the given index and write it into the given byte buffer.  <a href="../../de/da2/classevio_1_1_record_input.html#a48a32c2c8ad1ba30a4204c8a56fb84bb">More...</a><br /></td></tr>
<tr class="separator:a48a32c2c8ad1ba30a4204c8a56fb84bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6d188181b47c1e8933555f2d76a435"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#a8d6d188181b47c1e8933555f2d76a435">getUserHeader</a> ()</td></tr>
<tr class="memdesc:a8d6d188181b47c1e8933555f2d76a435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the user header contained in this record and return it in an allocated array.  <a href="../../de/da2/classevio_1_1_record_input.html#a8d6d188181b47c1e8933555f2d76a435">More...</a><br /></td></tr>
<tr class="separator:a8d6d188181b47c1e8933555f2d76a435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af590580abb73974099c107444b355d97"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#af590580abb73974099c107444b355d97">getUserHeader</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buffer, size_t bufOffset=0)</td></tr>
<tr class="memdesc:af590580abb73974099c107444b355d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get any existing user header and write it into the given byte buffer.  <a href="../../de/da2/classevio_1_1_record_input.html#af590580abb73974099c107444b355d97">More...</a><br /></td></tr>
<tr class="separator:af590580abb73974099c107444b355d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f421e53b8e608d79d8b901034b19dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#ad5f421e53b8e608d79d8b901034b19dc">getUserHeader</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;buffer, size_t bufOffset=0)</td></tr>
<tr class="memdesc:ad5f421e53b8e608d79d8b901034b19dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get any existing user header and write it into the given byte buffer.  <a href="../../de/da2/classevio_1_1_record_input.html#ad5f421e53b8e608d79d8b901034b19dc">More...</a><br /></td></tr>
<tr class="separator:ad5f421e53b8e608d79d8b901034b19dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4c76794e12fa3433bbc084a0b70196"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#a2a4c76794e12fa3433bbc084a0b70196">getEvent</a> (uint32_t index, uint32_t *len)</td></tr>
<tr class="memdesc:a2a4c76794e12fa3433bbc084a0b70196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the event at the given index and return it in an allocated array.  <a href="../../de/da2/classevio_1_1_record_input.html#a2a4c76794e12fa3433bbc084a0b70196">More...</a><br /></td></tr>
<tr class="separator:a2a4c76794e12fa3433bbc084a0b70196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00b2a5e045dcb0dda304b658d97ed26"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#aa00b2a5e045dcb0dda304b658d97ed26">getEventLength</a> (uint32_t index) const</td></tr>
<tr class="memdesc:aa00b2a5e045dcb0dda304b658d97ed26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the event with given index.  <a href="../../de/da2/classevio_1_1_record_input.html#aa00b2a5e045dcb0dda304b658d97ed26">More...</a><br /></td></tr>
<tr class="separator:aa00b2a5e045dcb0dda304b658d97ed26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7840a207a13cb1bbe312f35fcc0eca2c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#a7840a207a13cb1bbe312f35fcc0eca2c">getEntries</a> () const</td></tr>
<tr class="memdesc:a7840a207a13cb1bbe312f35fcc0eca2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of the events packed in the record.  <a href="../../de/da2/classevio_1_1_record_input.html#a7840a207a13cb1bbe312f35fcc0eca2c">More...</a><br /></td></tr>
<tr class="separator:a7840a207a13cb1bbe312f35fcc0eca2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae291a1b2eb21afb9d6366bfeaa220b80"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../de/da2/classevio_1_1_record_input.html">RecordInput</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#ae291a1b2eb21afb9d6366bfeaa220b80">getUserHeaderAsRecord</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;buffer, size_t bufOffset)</td></tr>
<tr class="memdesc:ae291a1b2eb21afb9d6366bfeaa220b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get any existing user header and write it into the given byte buffer.  <a href="../../de/da2/classevio_1_1_record_input.html#ae291a1b2eb21afb9d6366bfeaa220b80">More...</a><br /></td></tr>
<tr class="separator:ae291a1b2eb21afb9d6366bfeaa220b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfee12a45ae1f40be0048c1a9044a07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#a8bfee12a45ae1f40be0048c1a9044a07">readRecord</a> (std::ifstream &amp;file, size_t position)</td></tr>
<tr class="memdesc:a8bfee12a45ae1f40be0048c1a9044a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads record from the file at given position.  <a href="../../de/da2/classevio_1_1_record_input.html#a8bfee12a45ae1f40be0048c1a9044a07">More...</a><br /></td></tr>
<tr class="separator:a8bfee12a45ae1f40be0048c1a9044a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e735902f78f781e3bb49b2e71c37fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#a42e735902f78f781e3bb49b2e71c37fc">readRecord</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;buffer, size_t offset)</td></tr>
<tr class="memdesc:a42e735902f78f781e3bb49b2e71c37fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a record from the buffer at the given offset.  <a href="../../de/da2/classevio_1_1_record_input.html#a42e735902f78f781e3bb49b2e71c37fc">More...</a><br /></td></tr>
<tr class="separator:a42e735902f78f781e3bb49b2e71c37fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1a9f105120b8118fedd4ab43d502f1fa"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#a1a9f105120b8118fedd4ab43d502f1fa">uncompressRecord</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;srcBuf, size_t srcOff, std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;dstBuf, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html">RecordHeader</a> &amp;hdr)</td></tr>
<tr class="memdesc:a1a9f105120b8118fedd4ab43d502f1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompress the data of a record from the source buffer at the given offset into the destination buffer.  <a href="../../de/da2/classevio_1_1_record_input.html#a1a9f105120b8118fedd4ab43d502f1fa">More...</a><br /></td></tr>
<tr class="separator:a1a9f105120b8118fedd4ab43d502f1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b22f107be73ebb28d7ffc907ba81fc"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da2/classevio_1_1_record_input.html#a13b22f107be73ebb28d7ffc907ba81fc">uncompressRecord</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;srcBuf, size_t srcOff, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;dstBuf, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html">RecordHeader</a> &amp;header)</td></tr>
<tr class="memdesc:a13b22f107be73ebb28d7ffc907ba81fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncompress the data of a record from the source buffer at the given offset into the destination buffer.  <a href="../../de/da2/classevio_1_1_record_input.html#a13b22f107be73ebb28d7ffc907ba81fc">More...</a><br /></td></tr>
<tr class="separator:a13b22f107be73ebb28d7ffc907ba81fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class which reads data to create an Evio or HIPO Record. </p>
<p>This class is NOT thread safe!</p>
<pre>
RECORD STRUCTURE:</pre><pre>              Uncompressed                                      Compressed</pre><pre>   +----------------------------------+            +----------------------------------+
   |       General Record Header      |            |       General Record Header      |
   +----------------------------------+            +----------------------------------+</pre><pre>   +----------------------------------+ ---------&gt; +----------------------------------+
   |           Index Array            |            |        Compressed Data           |
   +----------------------------------+            |             Record               |
                                                   |                                  |
   +----------------------------------+            |                                  |
   |           User Header            |            |                  ----------------|
   |           (Optional)             |            |                  |    Pad 3      |
   |                  ----------------|            +----------------------------------+
   |                  |    Pad 1      |           ^
   +----------------------------------+          /
                                                /
   +----------------------------------+       /
   |           Data Record            |     /
   |                                  |    /
   |                  ----------------|   /
   |                  |    Pad 2      | /
   +----------------------------------+</pre><pre>GENERAL RECORD HEADER STRUCTURE ( see RecordHeader.java )</pre><pre>   +----------------------------------+
 1 |         Record Length            | // 32bit words, inclusive
   +----------------------------------+
 2 +         Record Number            |
   +----------------------------------+
 3 +         Header Length            | // 14 (words)
   +----------------------------------+
 4 +       Event (Index) Count        |
   +----------------------------------+
 5 +      Index Array Length          | // bytes
   +-----------------------+---------+
 6 +       Bit Info        | Version  | // version (8 bits)
   +-----------------------+----------+
 7 +      User Header Length          | // bytes
   +----------------------------------+
 8 +          Magic Number            | // 0xc0da0100
   +----------------------------------+
 9 +     Uncompressed Data Length     | // bytes
   +------+---------------------------+
10 +  CT  |  Data Length Compressed   | // CT = compression type (4 bits)
   +----------------------------------+
11 +        General Register 1        | // UID 1st (64 bits)
   +--                              --+
12 +                                  |
   +----------------------------------+
13 +        General Register 2        | // UID 2nd (64 bits)
   +--                              --+
14 +                                  |
   +----------------------------------+
</pre><dl class="section version"><dt>Version</dt><dd>6.0 </dd></dl>
<dl class="section since"><dt>Since</dt><dd>6.0 10/13/17 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>gavalian </dd>
<dd>
timmer (C++ version) </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a594a0b6430cfd782d741e5835dda7d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594a0b6430cfd782d741e5835dda7d0a">&#9670;&nbsp;</a></span>RecordInput() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">evio::RecordInput::RecordInput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a3d5f0120189717ffc8d2d480d89cb91a">evio::ByteBuffer::order()</a>.</p>

</div>
</div>
<a id="a50f3443a651a5777f4ca5703a65ec0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f3443a651a5777f4ca5703a65ec0a4">&#9670;&nbsp;</a></span>RecordInput() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">evio::RecordInput::RecordInput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>byte order of internal byte arrays. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad36390ccb249caf2b414fabfd6dd2aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36390ccb249caf2b414fabfd6dd2aaf">&#9670;&nbsp;</a></span>RecordInput() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">evio::RecordInput::RecordInput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/da2/classevio_1_1_record_input.html">RecordInput</a> &amp;&#160;</td>
          <td class="paramname"><em>recordIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a id="ac99fdb7643197e0a5936ae98fe90f9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99fdb7643197e0a5936ae98fe90f9cd">&#9670;&nbsp;</a></span>RecordInput() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">evio::RecordInput::RecordInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da2/classevio_1_1_record_input.html">RecordInput</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>srcRec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcRec</td><td><a class="el" href="../../de/da2/classevio_1_1_record_input.html" title="Class which reads data to create an Evio or HIPO Record.">RecordInput</a> to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34d86a58f649571c03497c7eb2ba125a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d86a58f649571c03497c7eb2ba125a">&#9670;&nbsp;</a></span>~RecordInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">evio::RecordInput::~RecordInput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac8b1a052e0520138565229072470b036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b1a052e0520138565229072470b036">&#9670;&nbsp;</a></span>getByteOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp; evio::RecordInput::getByteOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the byte order of the internal buffers. </p>
<dl class="section return"><dt>Returns</dt><dd>byte order of the internal buffers. </dd></dl>

</div>
</div>
<a id="a7840a207a13cb1bbe312f35fcc0eca2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7840a207a13cb1bbe312f35fcc0eca2c">&#9670;&nbsp;</a></span>getEntries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::RecordInput::getEntries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of the events packed in the record. </p>
<dl class="section return"><dt>Returns</dt><dd>number of the events packed in the record </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a124946e794a7b252fc41b6edd7f3f982">evio::Reader::getEvent()</a>, <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a5cac5c4702dec37c7ba7807421583da8">evio::Reader::getEventLength()</a>, <a class="el" href="../../de/da2/classevio_1_1_record_input.html#aa00b2a5e045dcb0dda304b658d97ed26">getEventLength()</a>, and <a class="el" href="../../d3/d56/classevio_1_1_reader.html#ac96bfa4922dce74d379ca204abb2001b">evio::Reader::getRecordEventCount()</a>.</p>

</div>
</div>
<a id="a48a32c2c8ad1ba30a4204c8a56fb84bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a32c2c8ad1ba30a4204c8a56fb84bb">&#9670;&nbsp;</a></span>getEvent() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp; evio::RecordInput::getEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the event at the given index and write it into the given byte buffer. </p>
<p>The given byte buffer has to be large enough to receive all the event's data, but the buffer.limit() is ignored &amp; reset. Buffer's byte order is set to that of the internal buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>buffer to be filled with event. </td></tr>
    <tr><td class="paramname">index</td><td>index of event starting at 0. </td></tr>
    <tr><td class="paramname">bufOffset</td><td>offset into buffer to place event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer buffer arg. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if index too large, or buffer has insufficient space to contain event (buffer.capacity() &lt; event size). </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#aa0e335238a57eaa0bffee8f968e5995f">evio::ByteBuffer::array()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#abf7abf99aa7544601997f40eba298648">evio::ByteBuffer::arrayOffset()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a6496a99b06b5ed67b8c93b148fd87323">evio::ByteBuffer::capacity()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#afb08d1dbc5fbf780afd27617a67eb750">evio::ByteBuffer::limit()</a>, and <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a3d5f0120189717ffc8d2d480d89cb91a">evio::ByteBuffer::order()</a>.</p>

</div>
</div>
<a id="a3fc47d4d9e244aa4aa89d9a1006484ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc47d4d9e244aa4aa89d9a1006484ef">&#9670;&nbsp;</a></span>getEvent() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; evio::RecordInput::getEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the event at the given index and write it into the given byte buffer. </p>
<p>The given byte buffer has to be large enough to receive all the event's data, but the buffer-&gt;limit() is ignored &amp; reset. Buffer's byte order is set to that of the internal buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>buffer to be filled with event. </td></tr>
    <tr><td class="paramname">index</td><td>index of event starting at 0. </td></tr>
    <tr><td class="paramname">bufOffset</td><td>offset into buffer to place event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer buffer arg. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if index too large, or buffer has insufficient space to contain event (buffer-&gt;capacity() &lt; event size). </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a9be6c85f5fc872e5e47e13d5c34555a3">evio::Reader::extractDictionaryFromBuffer()</a>, <a class="el" href="../../d3/d56/classevio_1_1_reader.html#afaa4a188742e9090fe9be391ce5f3731">evio::Reader::extractDictionaryFromFile()</a>, and <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a124946e794a7b252fc41b6edd7f3f982">evio::Reader::getEvent()</a>.</p>

</div>
</div>
<a id="a2a4c76794e12fa3433bbc084a0b70196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a4c76794e12fa3433bbc084a0b70196">&#9670;&nbsp;</a></span>getEvent() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; uint8_t &gt; evio::RecordInput::getEvent </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the event at the given index and return it in an allocated array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of event starting at 0. If index too large, it's set to last index. </td></tr>
    <tr><td class="paramname">len</td><td>pointer to int which gets filled with the data length in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte array containing event. </dd></dl>

</div>
</div>
<a id="aa00b2a5e045dcb0dda304b658d97ed26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00b2a5e045dcb0dda304b658d97ed26">&#9670;&nbsp;</a></span>getEventLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::RecordInput::getEventLength </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of the event with given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of the event </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of the data in bytes or zero if index does not coresspond to a valid event. </dd></dl>

<p class="reference">References <a class="el" href="../../de/da2/classevio_1_1_record_input.html#a7840a207a13cb1bbe312f35fcc0eca2c">getEntries()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a5cac5c4702dec37c7ba7807421583da8">evio::Reader::getEventLength()</a>.</p>

</div>
</div>
<a id="aabe9771eb8a45b7a6e3b63f0458c0255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe9771eb8a45b7a6e3b63f0458c0255">&#9670;&nbsp;</a></span>getHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../d8/d64/classevio_1_1_record_header.html">RecordHeader</a> &gt; evio::RecordInput::getHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the header of this record. </p>
<dl class="section return"><dt>Returns</dt><dd>header of this record. </dd></dl>

</div>
</div>
<a id="ad3374ca3748213d7b25252b2f5e9d193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3374ca3748213d7b25252b2f5e9d193">&#9670;&nbsp;</a></span>getUncompressedDataBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; evio::RecordInput::getUncompressedDataBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer with all uncompressed data in it. </p>
<p>It's position and limit are set to read only event data. That means no header, index, or user-header. </p><dl class="section return"><dt>Returns</dt><dd>the buffer with uncompressed event data in it. </dd></dl>

</div>
</div>
<a id="a8d6d188181b47c1e8933555f2d76a435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6d188181b47c1e8933555f2d76a435">&#9670;&nbsp;</a></span>getUserHeader() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; uint8_t &gt; evio::RecordInput::getUserHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the user header contained in this record and return it in an allocated array. </p>
<dl class="section return"><dt>Returns</dt><dd>the user header contained in this record, or null if none. </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../de/da2/classevio_1_1_record_input.html#af590580abb73974099c107444b355d97">getUserHeader()</a>, and <a class="el" href="../../de/da2/classevio_1_1_record_input.html#ae291a1b2eb21afb9d6366bfeaa220b80">getUserHeaderAsRecord()</a>.</p>

</div>
</div>
<a id="ad5f421e53b8e608d79d8b901034b19dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f421e53b8e608d79d8b901034b19dc">&#9670;&nbsp;</a></span>getUserHeader() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp; evio::RecordInput::getUserHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get any existing user header and write it into the given byte buffer. </p>
<p>The given byte buffer must be large enough to contain user header. Buffer's byte order is set to that of the internal buffers. Buffer's position is set to bufOffset and limit is set to bufOffset + userHeader size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>buffer to be filled with user header. </td></tr>
    <tr><td class="paramname">bufOffset</td><td>offset into buffer to place user header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer passed in (position = limit = bufOffset if no user header exists). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if buffer has insufficient space to contain user header (buffer.capacity() - bufOffset &lt; user header size). </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#aa0e335238a57eaa0bffee8f968e5995f">evio::ByteBuffer::array()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#abf7abf99aa7544601997f40eba298648">evio::ByteBuffer::arrayOffset()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a6496a99b06b5ed67b8c93b148fd87323">evio::ByteBuffer::capacity()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#afb08d1dbc5fbf780afd27617a67eb750">evio::ByteBuffer::limit()</a>, and <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a3d5f0120189717ffc8d2d480d89cb91a">evio::ByteBuffer::order()</a>.</p>

</div>
</div>
<a id="af590580abb73974099c107444b355d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af590580abb73974099c107444b355d97">&#9670;&nbsp;</a></span>getUserHeader() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; evio::RecordInput::getUserHeader </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get any existing user header and write it into the given byte buffer. </p>
<p>The given byte buffer must be large enough to contain user header. Buffer's byte order is set to that of the internal buffers. Buffer's position is set to bufOffset and limit is set to bufOffset + userHeader size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>buffer to be filled with user header. </td></tr>
    <tr><td class="paramname">bufOffset</td><td>offset into buffer to place user header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer passed in (position = limit = bufOffset if no user header exists). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if buffer has insufficient space to contain user header (buffer.capacity() - bufOffset &lt; user header size). </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../de/da2/classevio_1_1_record_input.html#a8d6d188181b47c1e8933555f2d76a435">getUserHeader()</a>.</p>

</div>
</div>
<a id="ae291a1b2eb21afb9d6366bfeaa220b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae291a1b2eb21afb9d6366bfeaa220b80">&#9670;&nbsp;</a></span>getUserHeaderAsRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../de/da2/classevio_1_1_record_input.html">RecordInput</a> &gt; evio::RecordInput::getUserHeaderAsRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get any existing user header and write it into the given byte buffer. </p>
<p>The byte buffer must be large enough to contain it. Warning, buffer.limit() is ignored &amp; reset. Parse the user header into the given recordInput object which will be set to the byte order of this object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>buffer to be filled with user header </td></tr>
    <tr><td class="paramname">bufOffset</td><td>offset into buffer to place user header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>record parsed from user header or nullptr if no user header exists. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if buffer has insufficient space to contain user header (buffer.capacity() - bufOffset &lt; user header size), or if buffer not in hipo format. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../de/da2/classevio_1_1_record_input.html#a8d6d188181b47c1e8933555f2d76a435">getUserHeader()</a>, and <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a32b043081cd3a62187f2577ce2966e7d">evio::ByteBuffer::remaining()</a>.</p>

</div>
</div>
<a id="a0f50d5521b94d5c4a520e39a7ef9025f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f50d5521b94d5c4a520e39a7ef9025f">&#9670;&nbsp;</a></span>hasIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::RecordInput::hasIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this record contain an event index? </p>
<dl class="section return"><dt>Returns</dt><dd>true if record contains an event index, else false. </dd></dl>

</div>
</div>
<a id="af34df12d892e4c91c541d4be07147741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34df12d892e4c91c541d4be07147741">&#9670;&nbsp;</a></span>hasUserHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::RecordInput::hasUserHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this record contain a user header? </p>
<dl class="section return"><dt>Returns</dt><dd>true if record contains a user header, else false. </dd></dl>

</div>
</div>
<a id="a6d88256111bd532501b99bb95583fe93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d88256111bd532501b99bb95583fe93">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da2/classevio_1_1_record_input.html">RecordInput</a> &amp; evio::RecordInput::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/da2/classevio_1_1_record_input.html">RecordInput</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>right side object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>left side object. </dd></dl>

</div>
</div>
<a id="aa40d7cca1eb46111544ca0a3537d9fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40d7cca1eb46111544ca0a3537d9fdc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da2/classevio_1_1_record_input.html">RecordInput</a> &amp; evio::RecordInput::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da2/classevio_1_1_record_input.html">RecordInput</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>right side object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>left side object. </dd></dl>

</div>
</div>
<a id="a42e735902f78f781e3bb49b2e71c37fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e735902f78f781e3bb49b2e71c37fc">&#9670;&nbsp;</a></span>readRecord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::RecordInput::readRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a record from the buffer at the given offset. </p>
<p>Call this method or <a class="el" href="../../de/da2/classevio_1_1_record_input.html#a8bfee12a45ae1f40be0048c1a9044a07">readRecord(std::ifstream &amp;, size_t)</a> before calling any other. Any compressed data is decompressed. Memory is allocated as needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>buffer containing record data. </td></tr>
    <tr><td class="paramname">offset</td><td>offset into buffer to beginning of record data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if buffer contains too little data, is not in proper format, or version earlier than 6 or error in uncompressing gzipped data. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#aa0e335238a57eaa0bffee8f968e5995f">evio::ByteBuffer::array()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#abf7abf99aa7544601997f40eba298648">evio::ByteBuffer::arrayOffset()</a>, <a class="el" href="../../da/d08/classevio_1_1_compressor.html#abab453336d92bc8e693825ac143ff101">evio::Compressor::getInstance()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#afb08d1dbc5fbf780afd27617a67eb750">evio::ByteBuffer::limit()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a3d5f0120189717ffc8d2d480d89cb91a">evio::ByteBuffer::order()</a>, and <a class="el" href="../../da/d08/classevio_1_1_compressor.html#a7c536c78b588c8d70b51e28d0eab1dd8">evio::Compressor::uncompressLZ4()</a>.</p>

</div>
</div>
<a id="a8bfee12a45ae1f40be0048c1a9044a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfee12a45ae1f40be0048c1a9044a07">&#9670;&nbsp;</a></span>readRecord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::RecordInput::readRecord </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads record from the file at given position. </p>
<p>Call this method or <a class="el" href="../../de/da2/classevio_1_1_record_input.html#a42e735902f78f781e3bb49b2e71c37fc">readRecord(ByteBuffer &amp;, size_t)</a> before calling any other. Any compressed data is decompressed. Memory is allocated as needed. First the header is read, then the length of the record is read from header, then following bytes are read and decompressed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>opened file descriptor </td></tr>
    <tr><td class="paramname">position</td><td>position in the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if file contains too little data, if the input data was corrupted (including if the input data is an incomplete stream), is not in proper format, or version earlier than 6, or error in uncompressing gzipped data. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#aa0e335238a57eaa0bffee8f968e5995f">evio::ByteBuffer::array()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a6496a99b06b5ed67b8c93b148fd87323">evio::ByteBuffer::capacity()</a>, <a class="el" href="../../da/d08/classevio_1_1_compressor.html#abab453336d92bc8e693825ac143ff101">evio::Compressor::getInstance()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a0e09d731589bcfe2705d0c606192f6eb">evio::RecordHeader::HEADER_SIZE_BYTES</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a3d5f0120189717ffc8d2d480d89cb91a">evio::ByteBuffer::order()</a>, and <a class="el" href="../../da/d08/classevio_1_1_compressor.html#a7c536c78b588c8d70b51e28d0eab1dd8">evio::Compressor::uncompressLZ4()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a9be6c85f5fc872e5e47e13d5c34555a3">evio::Reader::extractDictionaryFromBuffer()</a>, <a class="el" href="../../d3/d56/classevio_1_1_reader.html#afaa4a188742e9090fe9be391ce5f3731">evio::Reader::extractDictionaryFromFile()</a>, and <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a8396556b577deaa8cc017fb69324da92">evio::Reader::readRecord()</a>.</p>

</div>
</div>
<a id="a13b22f107be73ebb28d7ffc907ba81fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b22f107be73ebb28d7ffc907ba81fc">&#9670;&nbsp;</a></span>uncompressRecord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::RecordInput::uncompressRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>srcBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcOff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>dstBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d64/classevio_1_1_record_header.html">RecordHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>hdr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uncompress the data of a record from the source buffer at the given offset into the destination buffer. </p>
<p>Be aware that the position &amp; limit of srcBuf may be changed. The limit of dstBuf may be changed. The position of dstBuf will be set to just after the user-header and just before the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcBuf</td><td>buffer containing record data. </td></tr>
    <tr><td class="paramname">srcOff</td><td>offset into srcBuf to beginning of record data. </td></tr>
    <tr><td class="paramname">dstBuf</td><td>buffer into which the record is uncompressed. </td></tr>
    <tr><td class="paramname">hdr</td><td><a class="el" href="../../d8/d64/classevio_1_1_record_header.html">RecordHeader</a> to be used to read the record header in srcBuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the original record size in srcBuf (bytes). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if srcBuf contains too little data, is not in proper format, or version earlier than 6. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#aa0e335238a57eaa0bffee8f968e5995f">evio::ByteBuffer::array()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#abf7abf99aa7544601997f40eba298648">evio::ByteBuffer::arrayOffset()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#ac420593fe475899308138f3bd98e5f38">evio::RecordHeader::BIT_INFO_OFFSET</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a6496a99b06b5ed67b8c93b148fd87323">evio::ByteBuffer::capacity()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a588247cf4b37ae9e2f35912cd2b7aae5">evio::RecordHeader::COMPRESSION_TYPE_OFFSET</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#ada84924ed1f01899fc4500b07c7f488b">evio::RecordHeader::getBitInfoWord()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#af1acf0f962eed8b770022681f6e10a5b">evio::RecordHeader::getCompressedDataLength()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#aba16ed1ed865333327bf64ad53d09e76">evio::RecordHeader::getCompressionType()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#aa434393ea672e70e77bd7fa188eff393">evio::RecordHeader::getDataLengthWords()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a0221831e904860de343cfa2fcbe05f2c">evio::RecordHeader::getHeaderLength()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#af943f7595eb02bbbb769a27ccc8f5aa4">evio::RecordHeader::getIndexLength()</a>, <a class="el" href="../../da/d08/classevio_1_1_compressor.html#abab453336d92bc8e693825ac143ff101">evio::Compressor::getInstance()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#ac33a0f8082aa36f0e8fd2562d82e647a">evio::RecordHeader::getLength()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#ace2be836d16a4e4b58df6a6059d378b2">evio::RecordHeader::getUncompressedRecordLength()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a84ab13deb24469bc81dba390eeb72577">evio::RecordHeader::getUserHeaderLengthWords()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#afb08d1dbc5fbf780afd27617a67eb750">evio::ByteBuffer::limit()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a88f84e6b1757db70542eac13294fc80e">evio::ByteBuffer::position()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#ab864753c79b9a896ae8ff2e09ebfc44f">evio::ByteBuffer::put()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a8bc5745c6525ec0e5bfaee09db9b5c60">evio::ByteBuffer::putInt()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#ac212a9e36880e2bdcb107cbe5101b50a">evio::RecordHeader::readHeader()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a58e2767d98597e040d5640e4c288b90c">evio::RecordHeader::RECORD_LENGTH_OFFSET</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a7270727098611e695f009bc6e125aaa7">evio::RecordHeader::setCompressedDataLength()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#ae5812b82ce0e7ca51921ad30c9de7fe1">evio::RecordHeader::setCompressionType()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a2eb84874448358dc0fc468b537eed18a">evio::RecordHeader::setLength()</a>, <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747a056585718cbf5c7808c0e37b1f88dbb9">evio::Compressor::UNCOMPRESSED</a>, and <a class="el" href="../../da/d08/classevio_1_1_compressor.html#a7c536c78b588c8d70b51e28d0eab1dd8">evio::Compressor::uncompressLZ4()</a>.</p>

</div>
</div>
<a id="a1a9f105120b8118fedd4ab43d502f1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9f105120b8118fedd4ab43d502f1fa">&#9670;&nbsp;</a></span>uncompressRecord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::RecordInput::uncompressRecord </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>srcBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcOff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dstBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d64/classevio_1_1_record_header.html">RecordHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>hdr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uncompress the data of a record from the source buffer at the given offset into the destination buffer. </p>
<p>Be aware that the position &amp; limit of srcBuf may be changed. The limit of dstBuf may be changed. The position of dstBuf will be set to just after the user-header and just before the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcBuf</td><td>buffer containing record data. </td></tr>
    <tr><td class="paramname">srcOff</td><td>offset into srcBuf to beginning of record data. </td></tr>
    <tr><td class="paramname">dstBuf</td><td>buffer into which the record is uncompressed. </td></tr>
    <tr><td class="paramname">hdr</td><td><a class="el" href="../../d8/d64/classevio_1_1_record_header.html">RecordHeader</a> to be used to read the record header in srcBuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the original record size in srcBuf (bytes). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if srcBuf contains too little data, is not in proper format, or version earlier than 6. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a2df955f07faf6a4cd92cc8184eaa5d04">evio::Reader::scanBuffer()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="../../df/d02/_record_input_8h.html">RecordInput.h</a></li>
<li><a class="el" href="../../d6/d35/_record_input_8cpp.html">RecordInput.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d9/deb/namespaceevio.html">evio</a></li><li class="navelem"><a class="el" href="../../de/da2/classevio_1_1_record_input.html">RecordInput</a></li>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
