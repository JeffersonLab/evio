<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>evio: evio::Reader Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">evio
   &#160;<span id="projectnumber">6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d3/d56/classevio_1_1_reader.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../db/d08/classevio_1_1_reader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">evio::Reader Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../d3/d56/classevio_1_1_reader.html" title="Reader class that reads files stored in the HIPO format.">Reader</a> class that reads files stored in the HIPO format.  
 <a href="../../d3/d56/classevio_1_1_reader.html#details">More...</a></p>

<p><code>#include &lt;Reader.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a26384beac93f62f7747109055817c7be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a26384beac93f62f7747109055817c7be">Reader</a> ()</td></tr>
<tr class="memdesc:a26384beac93f62f7747109055817c7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="../../d3/d56/classevio_1_1_reader.html#a26384beac93f62f7747109055817c7be">More...</a><br /></td></tr>
<tr class="separator:a26384beac93f62f7747109055817c7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ad5aaa65657201f8e3165b6cf07a8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#ac4ad5aaa65657201f8e3165b6cf07a8b">Reader</a> (std::string const &amp;filename)</td></tr>
<tr class="memdesc:ac4ad5aaa65657201f8e3165b6cf07a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with filename.  <a href="../../d3/d56/classevio_1_1_reader.html#ac4ad5aaa65657201f8e3165b6cf07a8b">More...</a><br /></td></tr>
<tr class="separator:ac4ad5aaa65657201f8e3165b6cf07a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df29efd8d9ef6c8e41ab8c12c642da8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a0df29efd8d9ef6c8e41ab8c12c642da8">Reader</a> (std::string const &amp;filename, bool forceScan)</td></tr>
<tr class="memdesc:a0df29efd8d9ef6c8e41ab8c12c642da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with filename.  <a href="../../d3/d56/classevio_1_1_reader.html#a0df29efd8d9ef6c8e41ab8c12c642da8">More...</a><br /></td></tr>
<tr class="separator:a0df29efd8d9ef6c8e41ab8c12c642da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a03589aaecd0cb9c819dec50ccbc132"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a4a03589aaecd0cb9c819dec50ccbc132">Reader</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buffer, bool checkRecordNumSeq=false)</td></tr>
<tr class="memdesc:a4a03589aaecd0cb9c819dec50ccbc132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for reading buffer with evio data.  <a href="../../d3/d56/classevio_1_1_reader.html#a4a03589aaecd0cb9c819dec50ccbc132">More...</a><br /></td></tr>
<tr class="separator:a4a03589aaecd0cb9c819dec50ccbc132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a75ad257fe61c79c1ebb2a079aa9ab0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a3a75ad257fe61c79c1ebb2a079aa9ab0">~Reader</a> ()=default</td></tr>
<tr class="separator:a3a75ad257fe61c79c1ebb2a079aa9ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783002c7c34ba467b9880ec4bd66158d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a783002c7c34ba467b9880ec4bd66158d">open</a> (std::string const &amp;filename, bool scan=true)</td></tr>
<tr class="memdesc:a783002c7c34ba467b9880ec4bd66158d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an input stream in binary mode.  <a href="../../d3/d56/classevio_1_1_reader.html#a783002c7c34ba467b9880ec4bd66158d">More...</a><br /></td></tr>
<tr class="separator:a783002c7c34ba467b9880ec4bd66158d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6253fb80cafdffe93063710dc68f89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#afb6253fb80cafdffe93063710dc68f89">close</a> ()</td></tr>
<tr class="memdesc:afb6253fb80cafdffe93063710dc68f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">This closes the file.  <a href="../../d3/d56/classevio_1_1_reader.html#afb6253fb80cafdffe93063710dc68f89">More...</a><br /></td></tr>
<tr class="separator:afb6253fb80cafdffe93063710dc68f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4cc2b0b225780ff29a42509a6963bd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#af4cc2b0b225780ff29a42509a6963bd0">isClosed</a> () const</td></tr>
<tr class="memdesc:af4cc2b0b225780ff29a42509a6963bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has <a class="el" href="../../d3/d56/classevio_1_1_reader.html#afb6253fb80cafdffe93063710dc68f89">close()</a> been called (without reopening by calling <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a1bacb79593e55b32cd9749d14fea8b59">setBuffer(std::shared_ptr&lt;ByteBuffer&gt; &amp;)</a>)?  <a href="../../d3/d56/classevio_1_1_reader.html#af4cc2b0b225780ff29a42509a6963bd0">More...</a><br /></td></tr>
<tr class="separator:af4cc2b0b225780ff29a42509a6963bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c79ae478e1f977a14cd766778054419"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a3c79ae478e1f977a14cd766778054419">isFile</a> () const</td></tr>
<tr class="memdesc:a3c79ae478e1f977a14cd766778054419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a file being read?  <a href="../../d3/d56/classevio_1_1_reader.html#a3c79ae478e1f977a14cd766778054419">More...</a><br /></td></tr>
<tr class="separator:a3c79ae478e1f977a14cd766778054419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f2552cf046588eddb5c521eb8058ef"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a43f2552cf046588eddb5c521eb8058ef">getFileName</a> () const</td></tr>
<tr class="memdesc:a43f2552cf046588eddb5c521eb8058ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the file being read.  <a href="../../d3/d56/classevio_1_1_reader.html#a43f2552cf046588eddb5c521eb8058ef">More...</a><br /></td></tr>
<tr class="separator:a43f2552cf046588eddb5c521eb8058ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0adfb972556ea299cb59a9a514307e2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#ac0adfb972556ea299cb59a9a514307e2">getFileSize</a> () const</td></tr>
<tr class="memdesc:ac0adfb972556ea299cb59a9a514307e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the file being read, in bytes.  <a href="../../d3/d56/classevio_1_1_reader.html#ac0adfb972556ea299cb59a9a514307e2">More...</a><br /></td></tr>
<tr class="separator:ac0adfb972556ea299cb59a9a514307e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bacb79593e55b32cd9749d14fea8b59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a1bacb79593e55b32cd9749d14fea8b59">setBuffer</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buf)</td></tr>
<tr class="memdesc:a1bacb79593e55b32cd9749d14fea8b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method can be used to avoid creating additional <a class="el" href="../../d3/d56/classevio_1_1_reader.html" title="Reader class that reads files stored in the HIPO format.">Reader</a> objects by reusing this one with another buffer.  <a href="../../d3/d56/classevio_1_1_reader.html#a1bacb79593e55b32cd9749d14fea8b59">More...</a><br /></td></tr>
<tr class="separator:a1bacb79593e55b32cd9749d14fea8b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9578b8e07c84e052426e3726f81b48d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#af9578b8e07c84e052426e3726f81b48d">getBuffer</a> ()</td></tr>
<tr class="memdesc:af9578b8e07c84e052426e3726f81b48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer being read, if any.  <a href="../../d3/d56/classevio_1_1_reader.html#af9578b8e07c84e052426e3726f81b48d">More...</a><br /></td></tr>
<tr class="separator:af9578b8e07c84e052426e3726f81b48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a502d28bf5b95c174c748893402cc7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a19a502d28bf5b95c174c748893402cc7">getBufferOffset</a> () const</td></tr>
<tr class="memdesc:a19a502d28bf5b95c174c748893402cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the beginning position of the buffer being read.  <a href="../../d3/d56/classevio_1_1_reader.html#a19a502d28bf5b95c174c748893402cc7">More...</a><br /></td></tr>
<tr class="separator:a19a502d28bf5b95c174c748893402cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8845c561180e09fee8da6b0edc17fd0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/da6/classevio_1_1_file_header.html">FileHeader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a8845c561180e09fee8da6b0edc17fd0a">getFileHeader</a> ()</td></tr>
<tr class="memdesc:a8845c561180e09fee8da6b0edc17fd0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file header from reading a file.  <a href="../../d3/d56/classevio_1_1_reader.html#a8845c561180e09fee8da6b0edc17fd0a">More...</a><br /></td></tr>
<tr class="separator:a8845c561180e09fee8da6b0edc17fd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff65c3cf0199dafdb3a3624c5989790b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d8/d64/classevio_1_1_record_header.html">RecordHeader</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#aff65c3cf0199dafdb3a3624c5989790b">getFirstRecordHeader</a> ()</td></tr>
<tr class="memdesc:aff65c3cf0199dafdb3a3624c5989790b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first record header from reading a file/buffer.  <a href="../../d3/d56/classevio_1_1_reader.html#aff65c3cf0199dafdb3a3624c5989790b">More...</a><br /></td></tr>
<tr class="separator:aff65c3cf0199dafdb3a3624c5989790b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b31893d43ec1ac9711446da39641f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a50b31893d43ec1ac9711446da39641f4">getByteOrder</a> ()</td></tr>
<tr class="memdesc:a50b31893d43ec1ac9711446da39641f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the byte order of the file/buffer being read.  <a href="../../d3/d56/classevio_1_1_reader.html#a50b31893d43ec1ac9711446da39641f4">More...</a><br /></td></tr>
<tr class="separator:a50b31893d43ec1ac9711446da39641f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599c40fe3023c1f7eba42d697dc9e7ae"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a599c40fe3023c1f7eba42d697dc9e7ae">getVersion</a> () const</td></tr>
<tr class="memdesc:a599c40fe3023c1f7eba42d697dc9e7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Evio format version number of the file/buffer being read.  <a href="../../d3/d56/classevio_1_1_reader.html#a599c40fe3023c1f7eba42d697dc9e7ae">More...</a><br /></td></tr>
<tr class="separator:a599c40fe3023c1f7eba42d697dc9e7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61126c219647016814078a04da66c998"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a61126c219647016814078a04da66c998">isCompressed</a> () const</td></tr>
<tr class="memdesc:a61126c219647016814078a04da66c998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the data in the file/buffer compressed?  <a href="../../d3/d56/classevio_1_1_reader.html#a61126c219647016814078a04da66c998">More...</a><br /></td></tr>
<tr class="separator:a61126c219647016814078a04da66c998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1601c387a3516a2c63e46bb413307366"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a1601c387a3516a2c63e46bb413307366">isEvioFormat</a> () const</td></tr>
<tr class="memdesc:a1601c387a3516a2c63e46bb413307366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this file/buffer contain non-evio format events?  <a href="../../d3/d56/classevio_1_1_reader.html#a1601c387a3516a2c63e46bb413307366">More...</a><br /></td></tr>
<tr class="separator:a1601c387a3516a2c63e46bb413307366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae935304efa5fa7fbb733f840ebd8638f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#ae935304efa5fa7fbb733f840ebd8638f">getDictionary</a> ()</td></tr>
<tr class="memdesc:ae935304efa5fa7fbb733f840ebd8638f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the XML format dictionary if there is one.  <a href="../../d3/d56/classevio_1_1_reader.html#ae935304efa5fa7fbb733f840ebd8638f">More...</a><br /></td></tr>
<tr class="separator:ae935304efa5fa7fbb733f840ebd8638f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670e815e202c81fdce1948181346a533"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a670e815e202c81fdce1948181346a533">hasDictionary</a> () const</td></tr>
<tr class="memdesc:a670e815e202c81fdce1948181346a533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this evio file/buffer have an associated XML dictionary?  <a href="../../d3/d56/classevio_1_1_reader.html#a670e815e202c81fdce1948181346a533">More...</a><br /></td></tr>
<tr class="separator:a670e815e202c81fdce1948181346a533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e3f6d09dfcb8dfa3f0b826840d661b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; uint8_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#ad8e3f6d09dfcb8dfa3f0b826840d661b">getFirstEvent</a> (uint32_t *size)</td></tr>
<tr class="memdesc:ad8e3f6d09dfcb8dfa3f0b826840d661b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a byte array representing the first event.  <a href="../../d3/d56/classevio_1_1_reader.html#ad8e3f6d09dfcb8dfa3f0b826840d661b">More...</a><br /></td></tr>
<tr class="separator:ad8e3f6d09dfcb8dfa3f0b826840d661b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7e085359156352c43eafd1a9dca017"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#ada7e085359156352c43eafd1a9dca017">getFirstEventSize</a> ()</td></tr>
<tr class="memdesc:ada7e085359156352c43eafd1a9dca017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size, in bytes, of byte array representing the first event.  <a href="../../d3/d56/classevio_1_1_reader.html#ada7e085359156352c43eafd1a9dca017">More...</a><br /></td></tr>
<tr class="separator:ada7e085359156352c43eafd1a9dca017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b7f7c0191d12cca51496984a87451d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a86b7f7c0191d12cca51496984a87451d">hasFirstEvent</a> () const</td></tr>
<tr class="memdesc:a86b7f7c0191d12cca51496984a87451d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this evio file/buffer have an associated first event?  <a href="../../d3/d56/classevio_1_1_reader.html#a86b7f7c0191d12cca51496984a87451d">More...</a><br /></td></tr>
<tr class="separator:a86b7f7c0191d12cca51496984a87451d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f81445d73ac7fd45acb9fb42ac4c19e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a8f81445d73ac7fd45acb9fb42ac4c19e">getEventCount</a> () const</td></tr>
<tr class="memdesc:a8f81445d73ac7fd45acb9fb42ac4c19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of events in file/buffer.  <a href="../../d3/d56/classevio_1_1_reader.html#a8f81445d73ac7fd45acb9fb42ac4c19e">More...</a><br /></td></tr>
<tr class="separator:a8f81445d73ac7fd45acb9fb42ac4c19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a95a2f9f75aae81032d4c2cb1878272"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a2a95a2f9f75aae81032d4c2cb1878272">getRecordCount</a> () const</td></tr>
<tr class="memdesc:a2a95a2f9f75aae81032d4c2cb1878272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of records read from the file/buffer.  <a href="../../d3/d56/classevio_1_1_reader.html#a2a95a2f9f75aae81032d4c2cb1878272">More...</a><br /></td></tr>
<tr class="separator:a2a95a2f9f75aae81032d4c2cb1878272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3190f8f8f70e1b308129126862163bc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; RecordPosition &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#ab3190f8f8f70e1b308129126862163bc">getRecordPositions</a> ()</td></tr>
<tr class="memdesc:ab3190f8f8f70e1b308129126862163bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the list of record positions in the file.  <a href="../../d3/d56/classevio_1_1_reader.html#ab3190f8f8f70e1b308129126862163bc">More...</a><br /></td></tr>
<tr class="separator:ab3190f8f8f70e1b308129126862163bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af507fdb30b317aee5ab110c82d938a60"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#af507fdb30b317aee5ab110c82d938a60">getEventNodes</a> ()</td></tr>
<tr class="memdesc:af507fdb30b317aee5ab110c82d938a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the list of <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html" title="This class is used to store relevant info about an evio container (bank, segment, or tag segment),...">EvioNode</a> objects contained in the buffer being read.  <a href="../../d3/d56/classevio_1_1_reader.html#af507fdb30b317aee5ab110c82d938a60">More...</a><br /></td></tr>
<tr class="separator:af507fdb30b317aee5ab110c82d938a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3505be0c73b68da9f624e6a99583d2f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a3505be0c73b68da9f624e6a99583d2f6">getCheckRecordNumberSequence</a> () const</td></tr>
<tr class="memdesc:a3505be0c73b68da9f624e6a99583d2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether or not record numbers are enforced to be sequential.  <a href="../../d3/d56/classevio_1_1_reader.html#a3505be0c73b68da9f624e6a99583d2f6">More...</a><br /></td></tr>
<tr class="separator:a3505be0c73b68da9f624e6a99583d2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0e3949e458d596c1ef80a14715edf4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a9c0e3949e458d596c1ef80a14715edf4">getNumEventsRemaining</a> () const</td></tr>
<tr class="memdesc:a9c0e3949e458d596c1ef80a14715edf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of events remaining in the file/buffer.  <a href="../../d3/d56/classevio_1_1_reader.html#a9c0e3949e458d596c1ef80a14715edf4">More...</a><br /></td></tr>
<tr class="separator:a9c0e3949e458d596c1ef80a14715edf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad43feecd285a8d86284332a15c7dad"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a6ad43feecd285a8d86284332a15c7dad">getNextEvent</a> (uint32_t *len)</td></tr>
<tr class="memdesc:a6ad43feecd285a8d86284332a15c7dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a byte array representing the next event from the file/buffer while sequentially reading.  <a href="../../d3/d56/classevio_1_1_reader.html#a6ad43feecd285a8d86284332a15c7dad">More...</a><br /></td></tr>
<tr class="separator:a6ad43feecd285a8d86284332a15c7dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75374b81e59321dc8ac75f22a552b890"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a75374b81e59321dc8ac75f22a552b890">getPrevEvent</a> (uint32_t *len)</td></tr>
<tr class="memdesc:a75374b81e59321dc8ac75f22a552b890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a byte array representing the previous event from the sequential queue.  <a href="../../d3/d56/classevio_1_1_reader.html#a75374b81e59321dc8ac75f22a552b890">More...</a><br /></td></tr>
<tr class="separator:a75374b81e59321dc8ac75f22a552b890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf674124c4ad45cf97a4fb96bdcf44d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a0bf674124c4ad45cf97a4fb96bdcf44d">getNextEventNode</a> ()</td></tr>
<tr class="memdesc:a0bf674124c4ad45cf97a4fb96bdcf44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html" title="This class is used to store relevant info about an evio container (bank, segment, or tag segment),...">EvioNode</a> representing the next event from the buffer while sequentially reading.  <a href="../../d3/d56/classevio_1_1_reader.html#a0bf674124c4ad45cf97a4fb96bdcf44d">More...</a><br /></td></tr>
<tr class="separator:a0bf674124c4ad45cf97a4fb96bdcf44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e48758d1652e9104bcea1c6b95c2d5"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a31e48758d1652e9104bcea1c6b95c2d5">readUserHeader</a> ()</td></tr>
<tr class="memdesc:a31e48758d1652e9104bcea1c6b95c2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads user header of the file header/first record header of buffer.  <a href="../../d3/d56/classevio_1_1_reader.html#a31e48758d1652e9104bcea1c6b95c2d5">More...</a><br /></td></tr>
<tr class="separator:a31e48758d1652e9104bcea1c6b95c2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124946e794a7b252fc41b6edd7f3f982"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a124946e794a7b252fc41b6edd7f3f982">getEvent</a> (uint32_t index, uint32_t *len)</td></tr>
<tr class="memdesc:a124946e794a7b252fc41b6edd7f3f982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a byte array representing the specified event from the file/buffer.  <a href="../../d3/d56/classevio_1_1_reader.html#a124946e794a7b252fc41b6edd7f3f982">More...</a><br /></td></tr>
<tr class="separator:a124946e794a7b252fc41b6edd7f3f982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f1d79b0af42a813ced54c2309f9015"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#ae2f1d79b0af42a813ced54c2309f9015">getEvent</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;buf, uint32_t index)</td></tr>
<tr class="memdesc:ae2f1d79b0af42a813ced54c2309f9015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a byte array representing the specified event from the file/buffer and place it in the given buf.  <a href="../../d3/d56/classevio_1_1_reader.html#ae2f1d79b0af42a813ced54c2309f9015">More...</a><br /></td></tr>
<tr class="separator:ae2f1d79b0af42a813ced54c2309f9015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae085af5e0fc6fcfb6a845c00619a83cd"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#ae085af5e0fc6fcfb6a845c00619a83cd">getEvent</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buf, uint32_t index)</td></tr>
<tr class="memdesc:ae085af5e0fc6fcfb6a845c00619a83cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a byte array representing the specified event from the file/buffer and place it in the given buf.  <a href="../../d3/d56/classevio_1_1_reader.html#ae085af5e0fc6fcfb6a845c00619a83cd">More...</a><br /></td></tr>
<tr class="separator:ae085af5e0fc6fcfb6a845c00619a83cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cac5c4702dec37c7ba7807421583da8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a5cac5c4702dec37c7ba7807421583da8">getEventLength</a> (uint32_t index)</td></tr>
<tr class="memdesc:a5cac5c4702dec37c7ba7807421583da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the event with given index.  <a href="../../d3/d56/classevio_1_1_reader.html#a5cac5c4702dec37c7ba7807421583da8">More...</a><br /></td></tr>
<tr class="separator:a5cac5c4702dec37c7ba7807421583da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9cb8a3d521076ba625233e60924fa6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a3a9cb8a3d521076ba625233e60924fa6">getEventNode</a> (uint32_t index)</td></tr>
<tr class="memdesc:a3a9cb8a3d521076ba625233e60924fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html" title="This class is used to store relevant info about an evio container (bank, segment, or tag segment),...">EvioNode</a> representing the specified event from the buffer.  <a href="../../d3/d56/classevio_1_1_reader.html#a3a9cb8a3d521076ba625233e60924fa6">More...</a><br /></td></tr>
<tr class="separator:a3a9cb8a3d521076ba625233e60924fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5dc5c459a924ac7a9f5b7568416553"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a5c5dc5c459a924ac7a9f5b7568416553">hasNext</a> () const</td></tr>
<tr class="memdesc:a5c5dc5c459a924ac7a9f5b7568416553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the file has an event to read next.  <a href="../../d3/d56/classevio_1_1_reader.html#a5c5dc5c459a924ac7a9f5b7568416553">More...</a><br /></td></tr>
<tr class="separator:a5c5dc5c459a924ac7a9f5b7568416553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a9286f898d8377ca8147f65e1c9ba6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a80a9286f898d8377ca8147f65e1c9ba6">hasPrev</a> () const</td></tr>
<tr class="memdesc:a80a9286f898d8377ca8147f65e1c9ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the stream has previous event to be accessed through, <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a75374b81e59321dc8ac75f22a552b890" title="Get a byte array representing the previous event from the sequential queue.">getPrevEvent()</a>  <a href="../../d3/d56/classevio_1_1_reader.html#a80a9286f898d8377ca8147f65e1c9ba6">More...</a><br /></td></tr>
<tr class="separator:a80a9286f898d8377ca8147f65e1c9ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96bfa4922dce74d379ca204abb2001b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#ac96bfa4922dce74d379ca204abb2001b">getRecordEventCount</a> () const</td></tr>
<tr class="memdesc:ac96bfa4922dce74d379ca204abb2001b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of events in current record.  <a href="../../d3/d56/classevio_1_1_reader.html#ac96bfa4922dce74d379ca204abb2001b">More...</a><br /></td></tr>
<tr class="separator:ac96bfa4922dce74d379ca204abb2001b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33564511c3eca188b121c6da3ecf34ee"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a33564511c3eca188b121c6da3ecf34ee">getCurrentRecord</a> () const</td></tr>
<tr class="memdesc:a33564511c3eca188b121c6da3ecf34ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the current record.  <a href="../../d3/d56/classevio_1_1_reader.html#a33564511c3eca188b121c6da3ecf34ee">More...</a><br /></td></tr>
<tr class="separator:a33564511c3eca188b121c6da3ecf34ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686feebf1b15f63bdc008c8892904d3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da2/classevio_1_1_record_input.html">RecordInput</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a686feebf1b15f63bdc008c8892904d3f">getCurrentRecordStream</a> ()</td></tr>
<tr class="memdesc:a686feebf1b15f63bdc008c8892904d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current record stream.  <a href="../../d3/d56/classevio_1_1_reader.html#a686feebf1b15f63bdc008c8892904d3f">More...</a><br /></td></tr>
<tr class="separator:a686feebf1b15f63bdc008c8892904d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8396556b577deaa8cc017fb69324da92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a8396556b577deaa8cc017fb69324da92">readRecord</a> (uint32_t index)</td></tr>
<tr class="memdesc:a8396556b577deaa8cc017fb69324da92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads record from the file/buffer at the given record index.  <a href="../../d3/d56/classevio_1_1_reader.html#a8396556b577deaa8cc017fb69324da92">More...</a><br /></td></tr>
<tr class="separator:a8396556b577deaa8cc017fb69324da92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae81ead1409e411a9445d18a32c633156"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#ae81ead1409e411a9445d18a32c633156">extractDictionaryAndFirstEvent</a> ()</td></tr>
<tr class="memdesc:ae81ead1409e411a9445d18a32c633156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract dictionary and first event from file/buffer if possible, else do nothing.  <a href="../../d3/d56/classevio_1_1_reader.html#ae81ead1409e411a9445d18a32c633156">More...</a><br /></td></tr>
<tr class="separator:ae81ead1409e411a9445d18a32c633156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be6c85f5fc872e5e47e13d5c34555a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a9be6c85f5fc872e5e47e13d5c34555a3">extractDictionaryFromBuffer</a> ()</td></tr>
<tr class="memdesc:a9be6c85f5fc872e5e47e13d5c34555a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract dictionary and first event from buffer if possible, else do nothing.  <a href="../../d3/d56/classevio_1_1_reader.html#a9be6c85f5fc872e5e47e13d5c34555a3">More...</a><br /></td></tr>
<tr class="separator:a9be6c85f5fc872e5e47e13d5c34555a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa4a188742e9090fe9be391ce5f3731"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#afaa4a188742e9090fe9be391ce5f3731">extractDictionaryFromFile</a> ()</td></tr>
<tr class="memdesc:afaa4a188742e9090fe9be391ce5f3731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract dictionary and first event from file if possible, else do nothing.  <a href="../../d3/d56/classevio_1_1_reader.html#afaa4a188742e9090fe9be391ce5f3731">More...</a><br /></td></tr>
<tr class="separator:afaa4a188742e9090fe9be391ce5f3731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df955f07faf6a4cd92cc8184eaa5d04"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a2df955f07faf6a4cd92cc8184eaa5d04">scanBuffer</a> ()</td></tr>
<tr class="memdesc:a2df955f07faf6a4cd92cc8184eaa5d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method scans a buffer to find all records and store their position, length, and event count.  <a href="../../d3/d56/classevio_1_1_reader.html#a2df955f07faf6a4cd92cc8184eaa5d04">More...</a><br /></td></tr>
<tr class="separator:a2df955f07faf6a4cd92cc8184eaa5d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703075aab48cc798dbccc8cb14d74725"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a703075aab48cc798dbccc8cb14d74725">scanUncompressedBuffer</a> ()</td></tr>
<tr class="memdesc:a703075aab48cc798dbccc8cb14d74725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan buffer containing uncompressed data to find all records and store their position, length, and event count.  <a href="../../d3/d56/classevio_1_1_reader.html#a703075aab48cc798dbccc8cb14d74725">More...</a><br /></td></tr>
<tr class="separator:a703075aab48cc798dbccc8cb14d74725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9102d8facfed74bd17872cb452be8e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#aa9102d8facfed74bd17872cb452be8e8">forceScanFile</a> ()</td></tr>
<tr class="memdesc:aa9102d8facfed74bd17872cb452be8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan file to find all records and store their position, length, and event count.  <a href="../../d3/d56/classevio_1_1_reader.html#aa9102d8facfed74bd17872cb452be8e8">More...</a><br /></td></tr>
<tr class="separator:aa9102d8facfed74bd17872cb452be8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3c02dd9c1c87a57f4b73076071bced"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a7a3c02dd9c1c87a57f4b73076071bced">scanFile</a> (bool force)</td></tr>
<tr class="memdesc:a7a3c02dd9c1c87a57f4b73076071bced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the file to index all the record positions.  <a href="../../d3/d56/classevio_1_1_reader.html#a7a3c02dd9c1c87a57f4b73076071bced">More...</a><br /></td></tr>
<tr class="separator:a7a3c02dd9c1c87a57f4b73076071bced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ecfb216487866c7a3ddd6e5c8b153b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a74ecfb216487866c7a3ddd6e5c8b153b">addStructure</a> (uint32_t eventNumber, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;addBuffer)</td></tr>
<tr class="memdesc:a74ecfb216487866c7a3ddd6e5c8b153b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method adds an evio container (bank, segment, or tag segment) as the last structure contained in an event.  <a href="../../d3/d56/classevio_1_1_reader.html#a74ecfb216487866c7a3ddd6e5c8b153b">More...</a><br /></td></tr>
<tr class="separator:a74ecfb216487866c7a3ddd6e5c8b153b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dccea3833e50fdeebbae49ab787fde"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a20dccea3833e50fdeebbae49ab787fde">removeStructure</a> (std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; &amp;removeNode)</td></tr>
<tr class="memdesc:a20dccea3833e50fdeebbae49ab787fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method removes the data, represented by the given node, from the buffer.  <a href="../../d3/d56/classevio_1_1_reader.html#a20dccea3833e50fdeebbae49ab787fde">More...</a><br /></td></tr>
<tr class="separator:a20dccea3833e50fdeebbae49ab787fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41649b4f4ede403e3bf180e21e1f213"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#af41649b4f4ede403e3bf180e21e1f213">show</a> () const</td></tr>
<tr class="memdesc:af41649b4f4ede403e3bf180e21e1f213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out all record position information.  <a href="../../d3/d56/classevio_1_1_reader.html#af41649b4f4ede403e3bf180e21e1f213">More...</a><br /></td></tr>
<tr class="separator:af41649b4f4ede403e3bf180e21e1f213"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a4f2b8719299dfbe6baa2e5e5c23f558d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a4f2b8719299dfbe6baa2e5e5c23f558d">findRecordInfo</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buf, uint32_t offset, uint32_t *info, uint32_t infoLen)</td></tr>
<tr class="memdesc:a4f2b8719299dfbe6baa2e5e5c23f558d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from a record header in order to determine things like the bitInfo word, various lengths, etc.  <a href="../../d3/d56/classevio_1_1_reader.html#a4f2b8719299dfbe6baa2e5e5c23f558d">More...</a><br /></td></tr>
<tr class="separator:a4f2b8719299dfbe6baa2e5e5c23f558d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9934d70bae0210536661c0a478dee03"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#ab9934d70bae0210536661c0a478dee03">findRecordInfo</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;buf, uint32_t offset, uint32_t *info, uint32_t infoLen)</td></tr>
<tr class="memdesc:ab9934d70bae0210536661c0a478dee03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from a record header in order to determine things like the bitInfo word, various lengths, etc.  <a href="../../d3/d56/classevio_1_1_reader.html#ab9934d70bae0210536661c0a478dee03">More...</a><br /></td></tr>
<tr class="separator:ab9934d70bae0210536661c0a478dee03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a32f95a8849a0400219cb3f9d977dd9b9"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d56/classevio_1_1_reader.html#a32f95a8849a0400219cb3f9d977dd9b9">EvioCompactReaderV6</a></td></tr>
<tr class="separator:a32f95a8849a0400219cb3f9d977dd9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="../../d3/d56/classevio_1_1_reader.html" title="Reader class that reads files stored in the HIPO format.">Reader</a> class that reads files stored in the HIPO format. </p>
<pre>
File has this structure:</pre><pre>   +----------------------------------+
   |      General File Header         |
   +----------------------------------+
   +----------------------------------+
   |         Index (optional)         |
   +----------------------------------+
   +----------------------------------+
   |     User Header (optional)       |
   +----------------------------------+
   +----------------------------------+
   |                                  |
   |            Record 1              |
   |                                  |
   |                                  |
   |                                  |
   +----------------------------------+
                  ...
   +----------------------------------+
   |                                  |
   |            Record N              |
   |                                  |
   |                                  |
   |                                  |
   +----------------------------------+
   +----------------------------------+
   |       Trailer (optional)         |
   +----------------------------------+
   +----------------------------------+
   |    Trailer's Index (optional)    |
   +----------------------------------+</pre><pre>Buffer or streamed data has this structure:</pre><pre>   +----------------------------------+
   |                                  |
   |            Record 1              |
   |                                  |
   |                                  |
   |                                  |
   +----------------------------------+
                  ...
   +----------------------------------+
   |                                  |
   |            Record N              |
   |                                  |
   |                                  |
   |                                  |
   +----------------------------------+
   +----------------------------------+
   |       Trailer (optional)         |
   +----------------------------------+</pre><pre>The important thing with a buffer or streaming is for the last header or
trailer to set the "last record" bit.</pre><pre></pre><p>Something to keep in mind is one can intersperse sequential calls (getNextEvent, getPrevEvent, or getNextEventNode) with random access calls (getEvent or getEventNode), and the sequence remains unchanged after the random access.</p>
<dl class="section version"><dt>Version</dt><dd>6.0 </dd></dl>
<dl class="section since"><dt>Since</dt><dd>6.0 08/10/2017 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>gavalian (original Java) </dd>
<dd>
timmer </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/da6/classevio_1_1_file_header.html">FileHeader</a> </dd>
<dd>
<a class="el" href="../../de/da2/classevio_1_1_record_input.html" title="Class which reads data to create an Evio or HIPO Record.">RecordInput</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a26384beac93f62f7747109055817c7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26384beac93f62f7747109055817c7be">&#9670;&nbsp;</a></span>Reader() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">evio::Reader::Reader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Does nothing. The <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a783002c7c34ba467b9880ec4bd66158d">open(std::string const &amp;, bool)</a> method has to be called to open the input stream. Also <a class="el" href="../../d3/d56/classevio_1_1_reader.html#aa9102d8facfed74bd17872cb452be8e8">forceScanFile()</a> needs to be called to find records. </p>

</div>
</div>
<a id="ac4ad5aaa65657201f8e3165b6cf07a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ad5aaa65657201f8e3165b6cf07a8b">&#9670;&nbsp;</a></span>Reader() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">evio::Reader::Reader </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with filename. </p>
<p>Creates instance and opens the input stream with given name. Uses existing indexes in file before scanning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>input file name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if error reading file </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if file is not in the proper format or earlier than version 6 </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a783002c7c34ba467b9880ec4bd66158d">open()</a>.</p>

</div>
</div>
<a id="a0df29efd8d9ef6c8e41ab8c12c642da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df29efd8d9ef6c8e41ab8c12c642da8">&#9670;&nbsp;</a></span>Reader() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">evio::Reader::Reader </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceScan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor with filename. </p>
<p>Creates instance and opens the input stream with given name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>input file name. </td></tr>
    <tr><td class="paramname">forceScan</td><td>if true, force a scan of file, else use existing indexes first. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if error reading file </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if file is not in the proper format or earlier than version 6 </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a783002c7c34ba467b9880ec4bd66158d">open()</a>, and <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a7a3c02dd9c1c87a57f4b73076071bced">scanFile()</a>.</p>

</div>
</div>
<a id="a4a03589aaecd0cb9c819dec50ccbc132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a03589aaecd0cb9c819dec50ccbc132">&#9670;&nbsp;</a></span>Reader() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">evio::Reader::Reader </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkRecordNumSeq</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for reading buffer with evio data. </p>
<p>Buffer must be ready to read with position and limit set properly. If the given buffer contains compressed data, it is uncompressed into another buffer. The buffer containing the newly uncompressed data then becomes the internal buffer of this object. It can be obtained by calling <a class="el" href="../../d3/d56/classevio_1_1_reader.html#af9578b8e07c84e052426e3726f81b48d">getBuffer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>buffer with evio data. </td></tr>
    <tr><td class="paramname">checkRecordNumSeq</td><td>if true, check to see if all record numbers are in order, if not throw exception. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if buffer too small, not in the proper format, or earlier than version 6; if checkRecordNumSeq is true and records are out of sequence. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a2df955f07faf6a4cd92cc8184eaa5d04">scanBuffer()</a>.</p>

</div>
</div>
<a id="a3a75ad257fe61c79c1ebb2a079aa9ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a75ad257fe61c79c1ebb2a079aa9ab0">&#9670;&nbsp;</a></span>~Reader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">evio::Reader::~Reader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a74ecfb216487866c7a3ddd6e5c8b153b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ecfb216487866c7a3ddd6e5c8b153b">&#9670;&nbsp;</a></span>addStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp; evio::Reader::addStructure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eventNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>addBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method adds an evio container (bank, segment, or tag segment) as the last structure contained in an event. </p>
<p>It is the responsibility of the caller to make sure that the buffer argument contains valid evio data (only data representing the structure to be added - not in file format with record header and the like) which is compatible with the type of data stored in the given event.</p>
<p>To produce such evio data use <a class="el" href="../../d9/ddd/classevio_1_1_base_structure.html#a216a3d4858d6280df0f42d397b2759dc">EvioBank#write(ByteBuffer &amp;)</a>, <a class="el" href="../../d9/ddd/classevio_1_1_base_structure.html#a216a3d4858d6280df0f42d397b2759dc">EvioSegment#write(ByteBuffer &amp;)</a> or <a class="el" href="../../d9/ddd/classevio_1_1_base_structure.html#a216a3d4858d6280df0f42d397b2759dc">EvioTagSegment#write(ByteBuffer &amp;)</a> depending on whether a bank, seg, or tagseg is being added.</p>
<p>The given buffer argument must be ready to read with its position and limit defining the limits of the data to copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventNumber</td><td>number of event to which addBuffer is to be added </td></tr>
    <tr><td class="paramname">addBuffer</td><td>buffer containing evio data to add (<b>not</b> evio file format, i.e. no record headers) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> object which is created and filled with all the data including what was just added. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if eventNumber out of bounds; if addBuffer arg is empty or has non-evio format; if addBuffer is opposite endian to current event buffer; if added data is not the proper length (i.e. multiple of 4 bytes); if the event number does not correspond to an existing event; if there is an internal programming error; if object closed </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a3d5f0120189717ffc8d2d480d89cb91a">evio::ByteBuffer::order()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a32b043081cd3a62187f2577ce2966e7d">evio::ByteBuffer::remaining()</a>, <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a2df955f07faf6a4cd92cc8184eaa5d04">scanBuffer()</a>, and <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#aa8e92627a8294434d3e4762fd42e4dff">evio::RecordHeader::UNCOMPRESSED_LENGTH_OFFSET</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#a1f3c9c9126189dedf2380861a9bd21b9">evio::EvioCompactReaderV6::addStructure()</a>.</p>

</div>
</div>
<a id="afb6253fb80cafdffe93063710dc68f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6253fb80cafdffe93063710dc68f89">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Reader::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This closes the file. </p>
<p><br  />
 </p>

<p class="reference">Referenced by <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a1bacb79593e55b32cd9749d14fea8b59">setBuffer()</a>.</p>

</div>
</div>
<a id="ae81ead1409e411a9445d18a32c633156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81ead1409e411a9445d18a32c633156">&#9670;&nbsp;</a></span>extractDictionaryAndFirstEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Reader::extractDictionaryAndFirstEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract dictionary and first event from file/buffer if possible, else do nothing. </p>

<p class="reference">References <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a9be6c85f5fc872e5e47e13d5c34555a3">extractDictionaryFromBuffer()</a>, and <a class="el" href="../../d3/d56/classevio_1_1_reader.html#afaa4a188742e9090fe9be391ce5f3731">extractDictionaryFromFile()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/d56/classevio_1_1_reader.html#ae935304efa5fa7fbb733f840ebd8638f">getDictionary()</a>, <a class="el" href="../../d3/d56/classevio_1_1_reader.html#ad8e3f6d09dfcb8dfa3f0b826840d661b">getFirstEvent()</a>, and <a class="el" href="../../d3/d56/classevio_1_1_reader.html#ada7e085359156352c43eafd1a9dca017">getFirstEventSize()</a>.</p>

</div>
</div>
<a id="a9be6c85f5fc872e5e47e13d5c34555a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be6c85f5fc872e5e47e13d5c34555a3">&#9670;&nbsp;</a></span>extractDictionaryFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Reader::extractDictionaryFromBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract dictionary and first event from buffer if possible, else do nothing. </p>

<p class="reference">References <a class="el" href="../../de/da2/classevio_1_1_record_input.html#a3fc47d4d9e244aa4aa89d9a1006484ef">evio::RecordInput::getEvent()</a>, and <a class="el" href="../../de/da2/classevio_1_1_record_input.html#a8bfee12a45ae1f40be0048c1a9044a07">evio::RecordInput::readRecord()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/d56/classevio_1_1_reader.html#ae81ead1409e411a9445d18a32c633156">extractDictionaryAndFirstEvent()</a>.</p>

</div>
</div>
<a id="afaa4a188742e9090fe9be391ce5f3731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa4a188742e9090fe9be391ce5f3731">&#9670;&nbsp;</a></span>extractDictionaryFromFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Reader::extractDictionaryFromFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract dictionary and first event from file if possible, else do nothing. </p>

<p class="reference">References <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a3dcda5bb2237da5621027d3cc3f079ef">evio::FileHeader::getByteOrder()</a>, <a class="el" href="../../de/da2/classevio_1_1_record_input.html#a3fc47d4d9e244aa4aa89d9a1006484ef">evio::RecordInput::getEvent()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#ab307d9483f8651a997a1848caf0ee3a3">evio::FileHeader::getHeaderLength()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a5c09903e37568563ecd71b92fae94188">evio::FileHeader::getIndexLength()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a2d17cf7044ec110cbfb8ef440f4cd42a">evio::FileHeader::getUserHeaderLength()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a9267f205919e107f08d268e4ffc92e1e">evio::FileHeader::hasDictionary()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a55417ae68a5f938e25bac2673c88e36c">evio::FileHeader::hasFirstEvent()</a>, and <a class="el" href="../../de/da2/classevio_1_1_record_input.html#a8bfee12a45ae1f40be0048c1a9044a07">evio::RecordInput::readRecord()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/d56/classevio_1_1_reader.html#ae81ead1409e411a9445d18a32c633156">extractDictionaryAndFirstEvent()</a>.</p>

</div>
</div>
<a id="ab9934d70bae0210536661c0a478dee03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9934d70bae0210536661c0a478dee03">&#9670;&nbsp;</a></span>findRecordInfo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Reader::findRecordInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>infoLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data from a record header in order to determine things like the bitInfo word, various lengths, etc. </p>
<p>Does <b>not</b> change the position or limit of buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer containing evio header. </td></tr>
    <tr><td class="paramname">offset</td><td>byte offset into buffer. </td></tr>
    <tr><td class="paramname">info</td><td>array in which to store header info. Elements are: <ol start="0">
<li>
bit info word </li>
<li>
record length in bytes (inclusive) </li>
<li>
compression type </li>
<li>
header length in bytes </li>
<li>
index array length in bytes </li>
<li>
user header length in bytes (no padding included)  </li>
<li>
uncompressed data length in bytes (no padding, w/o record header) </li>
</ol>
</td></tr>
    <tr><td class="paramname">infoLen</td><td>len in 32-bit words of array at info. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">underflow_error</td><td>if not enough data in buffer. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>null info arg or info.length &lt; 7. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#ac420593fe475899308138f3bd98e5f38">evio::RecordHeader::BIT_INFO_OFFSET</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a6496a99b06b5ed67b8c93b148fd87323">evio::ByteBuffer::capacity()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a588247cf4b37ae9e2f35912cd2b7aae5">evio::RecordHeader::COMPRESSION_TYPE_OFFSET</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#ae5d68743951ae65bd72a1477a728993c">evio::RecordHeader::EVENT_COUNT_OFFSET</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a01783f61f04c093b71f58cd1adbde2fa">evio::ByteBuffer::getInt()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#aed99e247427969d1e27670edea24f0e2">evio::RecordHeader::HEADER_LENGTH_OFFSET</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a1b0ce8aa63d88b861fca36a5561c7122">evio::RecordHeader::INDEX_ARRAY_OFFSET</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#afb08d1dbc5fbf780afd27617a67eb750">evio::ByteBuffer::limit()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a58e2767d98597e040d5640e4c288b90c">evio::RecordHeader::RECORD_LENGTH_OFFSET</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#aa8e92627a8294434d3e4762fd42e4dff">evio::RecordHeader::UNCOMPRESSED_LENGTH_OFFSET</a>, and <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a37f1b0d0b94e58f9015204f675bbd3f8">evio::RecordHeader::USER_LENGTH_OFFSET</a>.</p>

</div>
</div>
<a id="a4f2b8719299dfbe6baa2e5e5c23f558d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2b8719299dfbe6baa2e5e5c23f558d">&#9670;&nbsp;</a></span>findRecordInfo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Reader::findRecordInfo </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>infoLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data from a record header in order to determine things like the bitInfo word, various lengths, etc. </p>
<p>Does <b>not</b> change the position or limit of buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer containing evio header. </td></tr>
    <tr><td class="paramname">offset</td><td>byte offset into buffer. </td></tr>
    <tr><td class="paramname">info</td><td>array in which to store header info. Elements are: <ol start="0">
<li>
bit info word </li>
<li>
record length in bytes (inclusive) </li>
<li>
compression type </li>
<li>
header length in bytes </li>
<li>
index array length in bytes </li>
<li>
user header length in bytes (no padding included)  </li>
<li>
uncompressed data length in bytes (no padding, w/o record header) </li>
</ol>
</td></tr>
    <tr><td class="paramname">infoLen</td><td>len in 32-bit words of array at info. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">underflow_error</td><td>if not enough data in buffer. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>null info arg or info.length &lt; 7. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9102d8facfed74bd17872cb452be8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9102d8facfed74bd17872cb452be8e8">&#9670;&nbsp;</a></span>forceScanFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Reader::forceScanFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan file to find all records and store their position, length, and event count. </p>
<p>Safe to call this method successively. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if error reading file </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if file is not in the proper format or earlier than version 6; if checkRecordNumberSequence is true and records are out of sequence. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a57e4929eec1b82fccce0a34a163fa11e">evio::FileEventIndex::addEventSize()</a>, <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a8ef8d2866a105a8b4973aa208f5162b8">evio::FileEventIndex::clear()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a3dcda5bb2237da5621027d3cc3f079ef">evio::FileHeader::getByteOrder()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a850be1f267c82ff109e5db4ac59522a3">evio::RecordHeader::getEntries()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#ab307d9483f8651a997a1848caf0ee3a3">evio::FileHeader::getHeaderLength()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a5c09903e37568563ecd71b92fae94188">evio::FileHeader::getIndexLength()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#ac33a0f8082aa36f0e8fd2562d82e647a">evio::RecordHeader::getLength()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a622ecbac309d428a1e9a916827e1b112">evio::RecordHeader::getRecordNumber()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a2d17cf7044ec110cbfb8ef440f4cd42a">evio::FileHeader::getUserHeaderLength()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#ac3b2d21a621f65578bf76c61e9fd0816">evio::FileHeader::getUserHeaderLengthPadding()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#ac7d8b3b526c36a94f32c584129084d26">evio::FileHeader::getVersion()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a0e09d731589bcfe2705d0c606192f6eb">evio::RecordHeader::HEADER_SIZE_BYTES</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a14eee9e0d70573180ed3556216969a07">evio::FileHeader::readHeader()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#ac212a9e36880e2bdcb107cbe5101b50a">evio::RecordHeader::readHeader()</a>, and <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747a056585718cbf5c7808c0e37b1f88dbb9">evio::Compressor::UNCOMPRESSED</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a7a3c02dd9c1c87a57f4b73076071bced">scanFile()</a>.</p>

</div>
</div>
<a id="af9578b8e07c84e052426e3726f81b48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9578b8e07c84e052426e3726f81b48d">&#9670;&nbsp;</a></span>getBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; evio::Reader::getBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer being read, if any. </p>
<p>This may not be the buffer given in the constructor or in <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a1bacb79593e55b32cd9749d14fea8b59">setBuffer</a> if the original data was compressed. All data in the returned buffer is uncompressed. </p><dl class="section return"><dt>Returns</dt><dd>buffer being read, if any. </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#a3d7fe439c3b1c77da15c6cf5c62045da">evio::EvioCompactReaderV6::close()</a>, <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#ab420fa4d7dd2165e5b8747665cbc8a45">evio::EvioCompactReaderV6::getByteBuffer()</a>, and <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#a5d853972ed19b80b62c6a30ab45ccc40">evio::EvioCompactReaderV6::toFile()</a>.</p>

</div>
</div>
<a id="a19a502d28bf5b95c174c748893402cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a502d28bf5b95c174c748893402cc7">&#9670;&nbsp;</a></span>getBufferOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t evio::Reader::getBufferOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the beginning position of the buffer being read. </p>
<dl class="section return"><dt>Returns</dt><dd>the beginning position of the buffer being read. </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#a3d7fe439c3b1c77da15c6cf5c62045da">evio::EvioCompactReaderV6::close()</a>.</p>

</div>
</div>
<a id="a50b31893d43ec1ac9711446da39641f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b31893d43ec1ac9711446da39641f4">&#9670;&nbsp;</a></span>getByteOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp; evio::Reader::getByteOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the byte order of the file/buffer being read. </p>
<dl class="section return"><dt>Returns</dt><dd>byte order of the file/buffer being read. </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#ae465a857603f5eeb4afb1d10e1b12477">evio::EvioCompactReaderV6::getByteOrder()</a>, and <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#a77e4fd561288419aed99b62ed7120b5f">evio::EvioCompactReaderV6::getFileByteOrder()</a>.</p>

</div>
</div>
<a id="a3505be0c73b68da9f624e6a99583d2f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3505be0c73b68da9f624e6a99583d2f6">&#9670;&nbsp;</a></span>getCheckRecordNumberSequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::Reader::getCheckRecordNumberSequence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get whether or not record numbers are enforced to be sequential. </p>
<dl class="section return"><dt>Returns</dt><dd><div class="fragment"><div class="line"><span class="keyword">true</span> </div>
</div><!-- fragment --> if record numbers are enforced to be sequential. </dd></dl>

</div>
</div>
<a id="a33564511c3eca188b121c6da3ecf34ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33564511c3eca188b121c6da3ecf34ee">&#9670;&nbsp;</a></span>getCurrentRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::Reader::getCurrentRecord </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the current record. </p>
<dl class="section return"><dt>Returns</dt><dd>index of the current record. </dd></dl>

</div>
</div>
<a id="a686feebf1b15f63bdc008c8892904d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686feebf1b15f63bdc008c8892904d3f">&#9670;&nbsp;</a></span>getCurrentRecordStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da2/classevio_1_1_record_input.html">RecordInput</a> &amp; evio::Reader::getCurrentRecordStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current record stream. </p>
<dl class="section return"><dt>Returns</dt><dd>current record stream. </dd></dl>

</div>
</div>
<a id="ae935304efa5fa7fbb733f840ebd8638f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae935304efa5fa7fbb733f840ebd8638f">&#9670;&nbsp;</a></span>getDictionary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string evio::Reader::getDictionary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the XML format dictionary if there is one. </p>
<dl class="section return"><dt>Returns</dt><dd>XML format dictionary, else null. </dd></dl>

<p class="reference">References <a class="el" href="../../d3/d56/classevio_1_1_reader.html#ae81ead1409e411a9445d18a32c633156">extractDictionaryAndFirstEvent()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#a69c2500d72dbf660d62e3e4962ebd6fe">evio::EvioCompactReaderV6::getDictionary()</a>, and <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#aa120d697ac0367adea97fb21268c2098">evio::EvioCompactReaderV6::getDictionaryXML()</a>.</p>

</div>
</div>
<a id="ae2f1d79b0af42a813ced54c2309f9015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f1d79b0af42a813ced54c2309f9015">&#9670;&nbsp;</a></span>getEvent() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp; evio::Reader::getEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a byte array representing the specified event from the file/buffer and place it in the given buf. </p>
<p>If no buf is given (arg is null), create a buffer internally and return it. If index is out of bounds, null is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer in which to place event data. </td></tr>
    <tr><td class="paramname">index</td><td>index of specified event within the entire file/buffer, contiguous starting at 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buf. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if file/buffer not in hipo format, if buf has insufficient space to contain event (buf.capacity() &lt; event size), or index too large. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../de/da2/classevio_1_1_record_input.html#a7840a207a13cb1bbe312f35fcc0eca2c">evio::RecordInput::getEntries()</a>, <a class="el" href="../../de/da2/classevio_1_1_record_input.html#a3fc47d4d9e244aa4aa89d9a1006484ef">evio::RecordInput::getEvent()</a>, <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a61558272861e209f8a3603777a6b10ec">evio::FileEventIndex::getMaxEvents()</a>, <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a45985f2f0ac14cba859effb75ad72fe9">evio::FileEventIndex::getRecordEventNumber()</a>, <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a3ca3ecb9bc534dbd09fc3cd199291cfd">evio::FileEventIndex::getRecordNumber()</a>, <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a8396556b577deaa8cc017fb69324da92">readRecord()</a>, and <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#aee78f211f79c1ed181019e65e1e55485">evio::FileEventIndex::setEvent()</a>.</p>

</div>
</div>
<a id="ae085af5e0fc6fcfb6a845c00619a83cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae085af5e0fc6fcfb6a845c00619a83cd">&#9670;&nbsp;</a></span>getEvent() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; evio::Reader::getEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a byte array representing the specified event from the file/buffer and place it in the given buf. </p>
<p>If no buf is given (arg is null), create a buffer internally and return it. If index is out of bounds, null is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer in which to place event data. </td></tr>
    <tr><td class="paramname">index</td><td>index of specified event within the entire file/buffer, contiguous starting at 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buf or null if buf is null. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if file/buffer not in hipo format, if buf has insufficient space to contain event (buf.capacity() &lt; event size), or index too large. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a124946e794a7b252fc41b6edd7f3f982">getEvent()</a>.</p>

</div>
</div>
<a id="a124946e794a7b252fc41b6edd7f3f982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124946e794a7b252fc41b6edd7f3f982">&#9670;&nbsp;</a></span>getEvent() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; uint8_t &gt; evio::Reader::getEvent </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a byte array representing the specified event from the file/buffer. </p>
<p>If index is out of bounds, null is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of specified event within the entire file/buffer, contiguous starting at 0. </td></tr>
    <tr><td class="paramname">len</td><td>pointer to int that gets filled with the returned event's len in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte array representing the specified event or null if index is out of bounds. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if file/buffer not in hipo format </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../de/da2/classevio_1_1_record_input.html#a7840a207a13cb1bbe312f35fcc0eca2c">evio::RecordInput::getEntries()</a>, <a class="el" href="../../de/da2/classevio_1_1_record_input.html#a3fc47d4d9e244aa4aa89d9a1006484ef">evio::RecordInput::getEvent()</a>, <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a61558272861e209f8a3603777a6b10ec">evio::FileEventIndex::getMaxEvents()</a>, <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a45985f2f0ac14cba859effb75ad72fe9">evio::FileEventIndex::getRecordEventNumber()</a>, <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a3ca3ecb9bc534dbd09fc3cd199291cfd">evio::FileEventIndex::getRecordNumber()</a>, <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a8396556b577deaa8cc017fb69324da92">readRecord()</a>, and <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#aee78f211f79c1ed181019e65e1e55485">evio::FileEventIndex::setEvent()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/d56/classevio_1_1_reader.html#ae085af5e0fc6fcfb6a845c00619a83cd">getEvent()</a>, <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a6ad43feecd285a8d86284332a15c7dad">getNextEvent()</a>, and <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a75374b81e59321dc8ac75f22a552b890">getPrevEvent()</a>.</p>

</div>
</div>
<a id="a8f81445d73ac7fd45acb9fb42ac4c19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f81445d73ac7fd45acb9fb42ac4c19e">&#9670;&nbsp;</a></span>getEventCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::Reader::getEventCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of events in file/buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>number of events in file/buffer. </dd></dl>

<p class="reference">References <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a61558272861e209f8a3603777a6b10ec">evio::FileEventIndex::getMaxEvents()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#afc46bc1edb5e81976671fd276e8996d1">evio::EvioCompactReaderV6::getEventCount()</a>, and <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#ada40ca9faba8685e5a5b7f1295991a09">evio::EvioCompactReaderV6::searchEvent()</a>.</p>

</div>
</div>
<a id="a5cac5c4702dec37c7ba7807421583da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cac5c4702dec37c7ba7807421583da8">&#9670;&nbsp;</a></span>getEventLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::Reader::getEventLength </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of the event with given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of the event </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of the data in bytes or zero if index does not correspond to a valid event. </dd></dl>

<p class="reference">References <a class="el" href="../../de/da2/classevio_1_1_record_input.html#a7840a207a13cb1bbe312f35fcc0eca2c">evio::RecordInput::getEntries()</a>, <a class="el" href="../../de/da2/classevio_1_1_record_input.html#aa00b2a5e045dcb0dda304b658d97ed26">evio::RecordInput::getEventLength()</a>, <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a61558272861e209f8a3603777a6b10ec">evio::FileEventIndex::getMaxEvents()</a>, <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a45985f2f0ac14cba859effb75ad72fe9">evio::FileEventIndex::getRecordEventNumber()</a>, <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a3ca3ecb9bc534dbd09fc3cd199291cfd">evio::FileEventIndex::getRecordNumber()</a>, <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a8396556b577deaa8cc017fb69324da92">readRecord()</a>, and <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#aee78f211f79c1ed181019e65e1e55485">evio::FileEventIndex::setEvent()</a>.</p>

</div>
</div>
<a id="a3a9cb8a3d521076ba625233e60924fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9cb8a3d521076ba625233e60924fa6">&#9670;&nbsp;</a></span>getEventNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; evio::Reader::getEventNode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html" title="This class is used to store relevant info about an evio container (bank, segment, or tag segment),...">EvioNode</a> representing the specified event from the buffer. </p>
<p>If index is out of bounds, nullptr is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of specified event within the entire buffer, starting at 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../de/dd0/classevio_1_1_evio_node.html" title="This class is used to store relevant info about an evio container (bank, segment, or tag segment),...">EvioNode</a> representing the specified event or null if index is out of bounds, reading a file or data is compressed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>index too large or reading from file. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a61558272861e209f8a3603777a6b10ec">evio::FileEventIndex::getMaxEvents()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#a696dbddadc545a386faf9e2b1a97c323">evio::EvioCompactReaderV6::getEvent()</a>, <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#ab71ba09770614343d962c9c55cad24a5">evio::EvioCompactReaderV6::getEventBuffer()</a>, and <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#ae8f3f4ced78563fea3e3be533f7c0486">evio::EvioCompactReaderV6::removeEvent()</a>.</p>

</div>
</div>
<a id="af507fdb30b317aee5ab110c82d938a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af507fdb30b317aee5ab110c82d938a60">&#9670;&nbsp;</a></span>getEventNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; &gt; &amp; evio::Reader::getEventNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to the list of <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html" title="This class is used to store relevant info about an evio container (bank, segment, or tag segment),...">EvioNode</a> objects contained in the buffer being read. </p>
<p>To be used internally to evio. </p><dl class="section return"><dt>Returns</dt><dd>list of <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html" title="This class is used to store relevant info about an evio container (bank, segment, or tag segment),...">EvioNode</a> objects contained in the buffer being read. </dd></dl>

</div>
</div>
<a id="a8845c561180e09fee8da6b0edc17fd0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8845c561180e09fee8da6b0edc17fd0a">&#9670;&nbsp;</a></span>getFileHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/da6/classevio_1_1_file_header.html">FileHeader</a> &amp; evio::Reader::getFileHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the file header from reading a file. </p>
<dl class="section return"><dt>Returns</dt><dd>file header from reading a file. </dd></dl>

</div>
</div>
<a id="a43f2552cf046588eddb5c521eb8058ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f2552cf046588eddb5c521eb8058ef">&#9670;&nbsp;</a></span>getFileName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string evio::Reader::getFileName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the file being read. </p>
<dl class="section return"><dt>Returns</dt><dd>name of the file being read or null if none. </dd></dl>

</div>
</div>
<a id="ac0adfb972556ea299cb59a9a514307e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0adfb972556ea299cb59a9a514307e2">&#9670;&nbsp;</a></span>getFileSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t evio::Reader::getFileSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the file being read, in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>size of the file being read, in bytes, or 0 if none. </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#ac357dcb878677ccb7167ddbf012c88a3">evio::EvioCompactReaderV6::fileSize()</a>.</p>

</div>
</div>
<a id="ad8e3f6d09dfcb8dfa3f0b826840d661b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e3f6d09dfcb8dfa3f0b826840d661b">&#9670;&nbsp;</a></span>getFirstEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; uint8_t &gt; &amp; evio::Reader::getFirstEvent </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a byte array representing the first event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>pointer filled with the size, in bytes, of the first event (0 if none). If null, this is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte array representing the first event. Null if none. </dd></dl>

<p class="reference">References <a class="el" href="../../d3/d56/classevio_1_1_reader.html#ae81ead1409e411a9445d18a32c633156">extractDictionaryAndFirstEvent()</a>.</p>

</div>
</div>
<a id="ada7e085359156352c43eafd1a9dca017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7e085359156352c43eafd1a9dca017">&#9670;&nbsp;</a></span>getFirstEventSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::Reader::getFirstEventSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get size, in bytes, of byte array representing the first event. </p>
<dl class="section return"><dt>Returns</dt><dd>size, in bytes, of byte array representing the first event. 0 if none. </dd></dl>

<p class="reference">References <a class="el" href="../../d3/d56/classevio_1_1_reader.html#ae81ead1409e411a9445d18a32c633156">extractDictionaryAndFirstEvent()</a>.</p>

</div>
</div>
<a id="aff65c3cf0199dafdb3a3624c5989790b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff65c3cf0199dafdb3a3624c5989790b">&#9670;&nbsp;</a></span>getFirstRecordHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../d8/d64/classevio_1_1_record_header.html">RecordHeader</a> &gt; &amp; evio::Reader::getFirstRecordHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first record header from reading a file/buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>first record header from reading a file/buffer. </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#a9f3a5b5c982c7525efafc24c97efffca">evio::EvioCompactReaderV6::getFirstBlockHeader()</a>.</p>

</div>
</div>
<a id="a6ad43feecd285a8d86284332a15c7dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad43feecd285a8d86284332a15c7dad">&#9670;&nbsp;</a></span>getNextEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; uint8_t &gt; evio::Reader::getNextEvent </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a byte array representing the next event from the file/buffer while sequentially reading. </p>
<p>If the previous call was to <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a75374b81e59321dc8ac75f22a552b890">getPrevEvent</a>, this will get the event past what that returned. Once the last event is returned, this will return null. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>pointer to int that gets filled with the returned event's len in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte array representing the next event or null if there is none. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if file/buffer not in hipo format </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a124946e794a7b252fc41b6edd7f3f982">getEvent()</a>.</p>

</div>
</div>
<a id="a0bf674124c4ad45cf97a4fb96bdcf44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf674124c4ad45cf97a4fb96bdcf44d">&#9670;&nbsp;</a></span>getNextEventNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; evio::Reader::getNextEventNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html" title="This class is used to store relevant info about an evio container (bank, segment, or tag segment),...">EvioNode</a> representing the next event from the buffer while sequentially reading. </p>
<p>Calling this and calling <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a6ad43feecd285a8d86284332a15c7dad">getNextEvent()</a> have the same effect in terms of advancing the same internal counter. If the previous call was to <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a75374b81e59321dc8ac75f22a552b890">getPrevEvent</a>, this will get the event past what that returned. Once the last event is returned, this will return null.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../de/dd0/classevio_1_1_evio_node.html" title="This class is used to store relevant info about an evio container (bank, segment, or tag segment),...">EvioNode</a> representing the next event or null if no more events, reading a file or data is compressed. </dd></dl>

<p class="reference">References <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a61558272861e209f8a3603777a6b10ec">evio::FileEventIndex::getMaxEvents()</a>.</p>

</div>
</div>
<a id="a9c0e3949e458d596c1ef80a14715edf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0e3949e458d596c1ef80a14715edf4">&#9670;&nbsp;</a></span>getNumEventsRemaining()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::Reader::getNumEventsRemaining </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of events remaining in the file/buffer. </p>
<p>Useful only if doing a sequential read.</p>
<dl class="section return"><dt>Returns</dt><dd>number of events remaining in the file/buffer </dd></dl>

<p class="reference">References <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a61558272861e209f8a3603777a6b10ec">evio::FileEventIndex::getMaxEvents()</a>.</p>

</div>
</div>
<a id="a75374b81e59321dc8ac75f22a552b890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75374b81e59321dc8ac75f22a552b890">&#9670;&nbsp;</a></span>getPrevEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; uint8_t &gt; evio::Reader::getPrevEvent </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a byte array representing the previous event from the sequential queue. </p>
<p>If the previous call was to <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a6ad43feecd285a8d86284332a15c7dad">getNextEvent</a>, this will get the event previous to what that returned. If this is called before getNextEvent, it will always return null. Once the first event is returned, this will return null. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>pointer to int that gets filled with the returned event's len in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte array representing the previous event or null if there is none. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if the file/buffer is not in HIPO format </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a124946e794a7b252fc41b6edd7f3f982">getEvent()</a>.</p>

</div>
</div>
<a id="a2a95a2f9f75aae81032d4c2cb1878272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a95a2f9f75aae81032d4c2cb1878272">&#9670;&nbsp;</a></span>getRecordCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::Reader::getRecordCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of records read from the file/buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>number of records read from the file/buffer. </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#a00b3f3e0d56465d5f24046505d1d7899">evio::EvioCompactReaderV6::getBlockCount()</a>.</p>

</div>
</div>
<a id="ac96bfa4922dce74d379ca204abb2001b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96bfa4922dce74d379ca204abb2001b">&#9670;&nbsp;</a></span>getRecordEventCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::Reader::getRecordEventCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of events in current record. </p>
<dl class="section return"><dt>Returns</dt><dd>number of events in current record. </dd></dl>

<p class="reference">References <a class="el" href="../../de/da2/classevio_1_1_record_input.html#a7840a207a13cb1bbe312f35fcc0eca2c">evio::RecordInput::getEntries()</a>.</p>

</div>
</div>
<a id="ab3190f8f8f70e1b308129126862163bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3190f8f8f70e1b308129126862163bc">&#9670;&nbsp;</a></span>getRecordPositions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Reader::RecordPosition &gt; &amp; evio::Reader::getRecordPositions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the list of record positions in the file. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a599c40fe3023c1f7eba42d697dc9e7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599c40fe3023c1f7eba42d697dc9e7ae">&#9670;&nbsp;</a></span>getVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::Reader::getVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Evio format version number of the file/buffer being read. </p>
<dl class="section return"><dt>Returns</dt><dd>Evio format version number of the file/buffer being read. </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#a7649fc2ff23dc473169c420970ffa3c3">evio::EvioCompactReaderV6::getEvioVersion()</a>.</p>

</div>
</div>
<a id="a670e815e202c81fdce1948181346a533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670e815e202c81fdce1948181346a533">&#9670;&nbsp;</a></span>hasDictionary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::Reader::hasDictionary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this evio file/buffer have an associated XML dictionary? </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this evio file/buffer has an associated XML dictionary, else <code>false</code>. </dd></dl>

<p class="reference">References <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a9267f205919e107f08d268e4ffc92e1e">evio::FileHeader::hasDictionary()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#af18113b678a7720413235246cb80cc66">evio::EvioCompactReaderV6::hasDictionary()</a>.</p>

</div>
</div>
<a id="a86b7f7c0191d12cca51496984a87451d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b7f7c0191d12cca51496984a87451d">&#9670;&nbsp;</a></span>hasFirstEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::Reader::hasFirstEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this evio file/buffer have an associated first event? </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this evio file/buffer has an associated first event, else <code>false</code>. </dd></dl>

<p class="reference">References <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a55417ae68a5f938e25bac2673c88e36c">evio::FileHeader::hasFirstEvent()</a>.</p>

</div>
</div>
<a id="a5c5dc5c459a924ac7a9f5b7568416553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5dc5c459a924ac7a9f5b7568416553">&#9670;&nbsp;</a></span>hasNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::Reader::hasNext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the file has an event to read next. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the next event is available, false otherwise </dd></dl>

<p class="reference">References <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a17b9ddcffc2fac25bbe7acd08b8fba14">evio::FileEventIndex::canAdvance()</a>.</p>

</div>
</div>
<a id="a80a9286f898d8377ca8147f65e1c9ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a9286f898d8377ca8147f65e1c9ba6">&#9670;&nbsp;</a></span>hasPrev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::Reader::hasPrev </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the stream has previous event to be accessed through, <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a75374b81e59321dc8ac75f22a552b890" title="Get a byte array representing the previous event from the sequential queue.">getPrevEvent()</a> </p>
<dl class="section return"><dt>Returns</dt><dd>true if previous event is accessible, false otherwise </dd></dl>

<p class="reference">References <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a1493f1dc0dc3a0786597f7c10bf73826">evio::FileEventIndex::canRetreat()</a>.</p>

</div>
</div>
<a id="af4cc2b0b225780ff29a42509a6963bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4cc2b0b225780ff29a42509a6963bd0">&#9670;&nbsp;</a></span>isClosed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::Reader::isClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Has <a class="el" href="../../d3/d56/classevio_1_1_reader.html#afb6253fb80cafdffe93063710dc68f89">close()</a> been called (without reopening by calling <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a1bacb79593e55b32cd9749d14fea8b59">setBuffer(std::shared_ptr&lt;ByteBuffer&gt; &amp;)</a>)? </p>
<dl class="section return"><dt>Returns</dt><dd><div class="fragment"><div class="line"><span class="keyword">true</span> </div>
</div><!-- fragment --> if this object closed, else<div class="fragment"><div class="line"><span class="keyword">false</span> </div>
</div><!-- fragment --> . </dd></dl>

</div>
</div>
<a id="a61126c219647016814078a04da66c998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61126c219647016814078a04da66c998">&#9670;&nbsp;</a></span>isCompressed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::Reader::isCompressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the data in the file/buffer compressed? </p>
<dl class="section return"><dt>Returns</dt><dd>true if data is compressed. </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#a2d7817a9492ced7b19f19246a6240fd2">evio::EvioCompactReaderV6::isCompressed()</a>.</p>

</div>
</div>
<a id="a1601c387a3516a2c63e46bb413307366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1601c387a3516a2c63e46bb413307366">&#9670;&nbsp;</a></span>isEvioFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::Reader::isEvioFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this file/buffer contain non-evio format events? </p>
<dl class="section return"><dt>Returns</dt><dd>true if all events are in evio format, else false. </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#ac3251410f333f38134578eb449a84b07">evio::EvioCompactReaderV6::EvioCompactReaderV6()</a>, and <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#a27e5b1de45af6d22ca73c173335b6ebc">evio::EvioCompactReaderV6::setBuffer()</a>.</p>

</div>
</div>
<a id="a3c79ae478e1f977a14cd766778054419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c79ae478e1f977a14cd766778054419">&#9670;&nbsp;</a></span>isFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::Reader::isFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is a file being read? </p>
<dl class="section return"><dt>Returns</dt><dd><div class="fragment"><div class="line"><span class="keyword">true</span> </div>
</div><!-- fragment --> if a file is being read,<div class="fragment"><div class="line"><span class="keyword">false</span> </div>
</div><!-- fragment --> if it's a buffer. </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#adf515c1131fef9c6f1164dea6fe984f5">evio::EvioCompactReaderV6::isFile()</a>.</p>

</div>
</div>
<a id="a783002c7c34ba467b9880ec4bd66158d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783002c7c34ba467b9880ec4bd66158d">&#9670;&nbsp;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Reader::open </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scan</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens an input stream in binary mode. </p>
<p>Scans for records in the file and stores record information in internal array. Each record can be read from the file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>input file name </td></tr>
    <tr><td class="paramname">scan</td><td>if true, call scanFile(false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if error handling file </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a7a3c02dd9c1c87a57f4b73076071bced">scanFile()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#a2113fbe908c3e873169afea53265a750">evio::EvioCompactReaderV6::EvioCompactReaderV6()</a>, and <a class="el" href="../../d3/d56/classevio_1_1_reader.html#ac4ad5aaa65657201f8e3165b6cf07a8b">Reader()</a>.</p>

</div>
</div>
<a id="a8396556b577deaa8cc017fb69324da92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8396556b577deaa8cc017fb69324da92">&#9670;&nbsp;</a></span>readRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::Reader::readRecord </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads record from the file/buffer at the given record index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>record index (starting at 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid index and successful reading record, else false. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if file/buffer not in hipo format </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../de/da2/classevio_1_1_record_input.html#a8bfee12a45ae1f40be0048c1a9044a07">evio::RecordInput::readRecord()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a124946e794a7b252fc41b6edd7f3f982">getEvent()</a>, and <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a5cac5c4702dec37c7ba7807421583da8">getEventLength()</a>.</p>

</div>
</div>
<a id="a31e48758d1652e9104bcea1c6b95c2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e48758d1652e9104bcea1c6b95c2d5">&#9670;&nbsp;</a></span>readUserHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; evio::Reader::readUserHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads user header of the file header/first record header of buffer. </p>
<p>The returned <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> also contains endianness of the file/buffer. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> containing the user header of the file/buffer. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if error reading file </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a3dcda5bb2237da5621027d3cc3f079ef">evio::FileHeader::getByteOrder()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#ab307d9483f8651a997a1848caf0ee3a3">evio::FileHeader::getHeaderLength()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a5c09903e37568563ecd71b92fae94188">evio::FileHeader::getIndexLength()</a>, and <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a2d17cf7044ec110cbfb8ef440f4cd42a">evio::FileHeader::getUserHeaderLength()</a>.</p>

</div>
</div>
<a id="a20dccea3833e50fdeebbae49ab787fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20dccea3833e50fdeebbae49ab787fde">&#9670;&nbsp;</a></span>removeStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp; evio::Reader::removeStructure </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>removeNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method removes the data, represented by the given node, from the buffer. </p>
<p>It also marks all nodes taken from that buffer as obsolete. They must not be used anymore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">removeNode</td><td>evio structure to remove from buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> updated to reflect the node removal </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if object closed; if node was not found in any event; if internal programming error; if buffer has compressed data; </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#afb08d1dbc5fbf780afd27617a67eb750">evio::ByteBuffer::limit()</a>, <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a2df955f07faf6a4cd92cc8184eaa5d04">scanBuffer()</a>, <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747a056585718cbf5c7808c0e37b1f88dbb9">evio::Compressor::UNCOMPRESSED</a>, and <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#aa8e92627a8294434d3e4762fd42e4dff">evio::RecordHeader::UNCOMPRESSED_LENGTH_OFFSET</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#aed6b963403e2b393a3b1a2979e004525">evio::EvioCompactReaderV6::removeStructure()</a>.</p>

</div>
</div>
<a id="a2df955f07faf6a4cd92cc8184eaa5d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df955f07faf6a4cd92cc8184eaa5d04">&#9670;&nbsp;</a></span>scanBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; evio::Reader::scanBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method scans a buffer to find all records and store their position, length, and event count. </p>
<p>It also finds all events and creates &amp; stores their associated <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html" title="This class is used to store relevant info about an evio container (bank, segment, or tag segment),...">EvioNode</a> objects. The difficulty with doing this is that the buffer may contain compressed data. It must then be uncompressed into a different buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>buffer containing uncompressed data. This buffer is different than the internal buffer. Ready to read. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if buffer not in the proper format or earlier than version 6; if checkRecordNumberSequence is true and records are out of sequence. </td></tr>
    <tr><td class="paramname">underflow_error</td><td>if not enough data in buffer. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a57e4929eec1b82fccce0a34a163fa11e">evio::FileEventIndex::addEventSize()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#aa0e335238a57eaa0bffee8f968e5995f">evio::ByteBuffer::array()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#abf7abf99aa7544601997f40eba298648">evio::ByteBuffer::arrayOffset()</a>, <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a8ef8d2866a105a8b4973aa208f5162b8">evio::FileEventIndex::clear()</a>, <a class="el" href="../../df/dd8/classevio_1_1_header_type.html#a2b01085c1ea7b23010e4cb4447f2d04a">evio::HeaderType::EVIO_RECORD</a>, <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html#a4729f50cfe20a7e7672fdd1bbe4a366c">evio::EvioNode::extractEventNode()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#ac0fff5d178b4f360080891fb9079d469">evio::RecordHeader::getByteOrder()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a850be1f267c82ff109e5db4ac59522a3">evio::RecordHeader::getEntries()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a0221831e904860de343cfa2fcbe05f2c">evio::RecordHeader::getHeaderLength()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#ac33a0f8082aa36f0e8fd2562d82e647a">evio::RecordHeader::getLength()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a622ecbac309d428a1e9a916827e1b112">evio::RecordHeader::getRecordNumber()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#ace2be836d16a4e4b58df6a6059d378b2">evio::RecordHeader::getUncompressedRecordLength()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#ac6ce4d8a602fe70693a80435ed6f1361">evio::RecordHeader::getVersion()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a0e09d731589bcfe2705d0c606192f6eb">evio::RecordHeader::HEADER_SIZE_BYTES</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#af29b64992fcd30c456db80719c56a60f">evio::RecordHeader::isCompressed()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#adb2fa395660e3d9656ef5ae91e12b4be">evio::RecordHeader::isLastRecord()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a3d5f0120189717ffc8d2d480d89cb91a">evio::ByteBuffer::order()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a88f84e6b1757db70542eac13294fc80e">evio::ByteBuffer::position()</a>, <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a703075aab48cc798dbccc8cb14d74725">scanUncompressedBuffer()</a>, and <a class="el" href="../../de/da2/classevio_1_1_record_input.html#a1a9f105120b8118fedd4ab43d502f1fa">evio::RecordInput::uncompressRecord()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a4a03589aaecd0cb9c819dec50ccbc132">Reader()</a>, <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a74ecfb216487866c7a3ddd6e5c8b153b">addStructure()</a>, <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a20dccea3833e50fdeebbae49ab787fde">removeStructure()</a>, and <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a1bacb79593e55b32cd9749d14fea8b59">setBuffer()</a>.</p>

</div>
</div>
<a id="a7a3c02dd9c1c87a57f4b73076071bced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3c02dd9c1c87a57f4b73076071bced">&#9670;&nbsp;</a></span>scanFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Reader::scanFile </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scans the file to index all the record positions. </p>
<p>It takes advantage of any existing indexes in file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>if true, force a file scan even if header or trailer have index info. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if error reading file </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if file is not in the proper format or earlier than version 6 </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a57e4929eec1b82fccce0a34a163fa11e">evio::FileEventIndex::addEventSize()</a>, <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a8ef8d2866a105a8b4973aa208f5162b8">evio::FileEventIndex::clear()</a>, <a class="el" href="../../d3/d56/classevio_1_1_reader.html#aa9102d8facfed74bd17872cb452be8e8">forceScanFile()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a3dcda5bb2237da5621027d3cc3f079ef">evio::FileHeader::getByteOrder()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#ab307d9483f8651a997a1848caf0ee3a3">evio::FileHeader::getHeaderLength()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a5c09903e37568563ecd71b92fae94188">evio::FileHeader::getIndexLength()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#af943f7595eb02bbbb769a27ccc8f5aa4">evio::RecordHeader::getIndexLength()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a01c1f92000c5a0f3b2f11b0c0e5e3a74">evio::FileHeader::getLength()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#ae74a6ac13dcc45024e5db04491d96841">evio::FileHeader::getTrailerPosition()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#ac7d8b3b526c36a94f32c584129084d26">evio::FileHeader::getVersion()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a34cb81cab9f49ec663cd083c4133747f">evio::FileHeader::hasIndex()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a893b59302d5f0b77733da2deb85e15b8">evio::FileHeader::hasTrailerWithIndex()</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a60a8eab054b6f02e84d8975e3aa436b9">evio::FileHeader::HEADER_SIZE_BYTES</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a0e09d731589bcfe2705d0c606192f6eb">evio::RecordHeader::HEADER_SIZE_BYTES</a>, <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a14eee9e0d70573180ed3556216969a07">evio::FileHeader::readHeader()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#ac212a9e36880e2bdcb107cbe5101b50a">evio::RecordHeader::readHeader()</a>, <a class="el" href="../../d3/d87/classevio_1_1_util.html#a61734ea9adbf63b8497fe36864c46a00">evio::Util::toIntArray()</a>, and <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747a056585718cbf5c7808c0e37b1f88dbb9">evio::Compressor::UNCOMPRESSED</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a0df29efd8d9ef6c8e41ab8c12c642da8">Reader()</a>, and <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a783002c7c34ba467b9880ec4bd66158d">open()</a>.</p>

</div>
</div>
<a id="a703075aab48cc798dbccc8cb14d74725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703075aab48cc798dbccc8cb14d74725">&#9670;&nbsp;</a></span>scanUncompressedBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Reader::scanUncompressedBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan buffer containing uncompressed data to find all records and store their position, length, and event count. </p>
<p>Also finds all events and creates &amp; stores their associated <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html" title="This class is used to store relevant info about an evio container (bank, segment, or tag segment),...">EvioNode</a> objects. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if buffer too small, not in the proper format, or earlier than version 6; if checkRecordNumberSequence is true and records are out of sequence. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a57e4929eec1b82fccce0a34a163fa11e">evio::FileEventIndex::addEventSize()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#aa0e335238a57eaa0bffee8f968e5995f">evio::ByteBuffer::array()</a>, <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a8ef8d2866a105a8b4973aa208f5162b8">evio::FileEventIndex::clear()</a>, <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html#a4729f50cfe20a7e7672fdd1bbe4a366c">evio::EvioNode::extractEventNode()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#ac0fff5d178b4f360080891fb9079d469">evio::RecordHeader::getByteOrder()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#aba16ed1ed865333327bf64ad53d09e76">evio::RecordHeader::getCompressionType()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a850be1f267c82ff109e5db4ac59522a3">evio::RecordHeader::getEntries()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a0221831e904860de343cfa2fcbe05f2c">evio::RecordHeader::getHeaderLength()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#af943f7595eb02bbbb769a27ccc8f5aa4">evio::RecordHeader::getIndexLength()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#ac33a0f8082aa36f0e8fd2562d82e647a">evio::RecordHeader::getLength()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a622ecbac309d428a1e9a916827e1b112">evio::RecordHeader::getRecordNumber()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a84ab13deb24469bc81dba390eeb72577">evio::RecordHeader::getUserHeaderLengthWords()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#ac6ce4d8a602fe70693a80435ed6f1361">evio::RecordHeader::getVersion()</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a0e09d731589bcfe2705d0c606192f6eb">evio::RecordHeader::HEADER_SIZE_BYTES</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#ac212a9e36880e2bdcb107cbe5101b50a">evio::RecordHeader::readHeader()</a>, and <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747a056585718cbf5c7808c0e37b1f88dbb9">evio::Compressor::UNCOMPRESSED</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a2df955f07faf6a4cd92cc8184eaa5d04">scanBuffer()</a>.</p>

</div>
</div>
<a id="a1bacb79593e55b32cd9749d14fea8b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bacb79593e55b32cd9749d14fea8b59">&#9670;&nbsp;</a></span>setBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Reader::setBuffer </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method can be used to avoid creating additional <a class="el" href="../../d3/d56/classevio_1_1_reader.html" title="Reader class that reads files stored in the HIPO format.">Reader</a> objects by reusing this one with another buffer. </p>
<p>If the given buffer contains compressed data, it is uncompressed into another buffer. The buffer containing the newly uncompressed data then becomes the internal buffer of this object. It can be obtained by calling <a class="el" href="../../d3/d56/classevio_1_1_reader.html#af9578b8e07c84e052426e3726f81b48d">getBuffer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> to be read </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">underflow_error</td><td>if not enough data in buffer. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if buf arg is null, not in the proper format, or earlier than version 6 </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../df/dbf/classevio_1_1_file_event_index.html#a8ef8d2866a105a8b4973aa208f5162b8">evio::FileEventIndex::clear()</a>, <a class="el" href="../../d3/d56/classevio_1_1_reader.html#afb6253fb80cafdffe93063710dc68f89">close()</a>, and <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a2df955f07faf6a4cd92cc8184eaa5d04">scanBuffer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#ac3251410f333f38134578eb449a84b07">evio::EvioCompactReaderV6::EvioCompactReaderV6()</a>, and <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html#a27e5b1de45af6d22ca73c173335b6ebc">evio::EvioCompactReaderV6::setBuffer()</a>.</p>

</div>
</div>
<a id="af41649b4f4ede403e3bf180e21e1f213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41649b4f4ede403e3bf180e21e1f213">&#9670;&nbsp;</a></span>show()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evio::Reader::show </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print out all record position information. </p>
<p><br  />
 </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a32f95a8849a0400219cb3f9d977dd9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f95a8849a0400219cb3f9d977dd9b9">&#9670;&nbsp;</a></span>EvioCompactReaderV6</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="../../dd/d94/classevio_1_1_evio_compact_reader_v6.html">EvioCompactReaderV6</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="../../dd/d3d/_reader_8h.html">Reader.h</a></li>
<li><a class="el" href="../../d8/d15/_reader_8cpp.html">Reader.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d9/deb/namespaceevio.html">evio</a></li><li class="navelem"><a class="el" href="../../d3/d56/classevio_1_1_reader.html">Reader</a></li>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
