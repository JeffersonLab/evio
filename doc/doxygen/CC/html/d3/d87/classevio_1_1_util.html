<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>evio: evio::Util Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">evio
   &#160;<span id="projectnumber">6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d3/d87/classevio_1_1_util.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="../../de/d60/classevio_1_1_util-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">evio::Util Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class containing static methods of general purpose.  
 <a href="../../d3/d87/classevio_1_1_util.html#details">More...</a></p>

<p><code>#include &lt;Util.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0d84a3a050a9c03869fa3c7dd7287737"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a0d84a3a050a9c03869fa3c7dd7287737">getWords</a> (uint32_t length)</td></tr>
<tr class="memdesc:a0d84a3a050a9c03869fa3c7dd7287737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns length padded to 4-byte boundary for given length in bytes.  <a href="../../d3/d87/classevio_1_1_util.html#a0d84a3a050a9c03869fa3c7dd7287737">More...</a><br /></td></tr>
<tr class="separator:a0d84a3a050a9c03869fa3c7dd7287737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af174f6cb1faa20acb06238db0ce353ed"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#af174f6cb1faa20acb06238db0ce353ed">getPadding</a> (uint32_t length)</td></tr>
<tr class="memdesc:af174f6cb1faa20acb06238db0ce353ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of bytes needed to pad to 4-byte boundary for the given length.  <a href="../../d3/d87/classevio_1_1_util.html#af174f6cb1faa20acb06238db0ce353ed">More...</a><br /></td></tr>
<tr class="separator:af174f6cb1faa20acb06238db0ce353ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc29d65753be764d27f4851efdb3846"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a4cc29d65753be764d27f4851efdb3846">iStrEquals</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:a4cc29d65753be764d27f4851efdb3846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case insensitive compare for 2 strings.  <a href="../../d3/d87/classevio_1_1_util.html#a4cc29d65753be764d27f4851efdb3846">More...</a><br /></td></tr>
<tr class="separator:a4cc29d65753be764d27f4851efdb3846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0841939d9ccc701e4b69c58c148355"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="../../d5/d23/classevio_1_1_data_type.html">DataType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a2e0841939d9ccc701e4b69c58c148355">getDataType</a> (const std::string &amp;type)</td></tr>
<tr class="memdesc:a2e0841939d9ccc701e4b69c58c148355"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns an XML element name given an evio data type.  <a href="../../d3/d87/classevio_1_1_util.html#a2e0841939d9ccc701e4b69c58c148355">More...</a><br /></td></tr>
<tr class="separator:a2e0841939d9ccc701e4b69c58c148355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61734ea9adbf63b8497fe36864c46a00"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a61734ea9adbf63b8497fe36864c46a00">toIntArray</a> (char const *data, uint32_t dataLen, const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;byteOrder, uint32_t *dest)</td></tr>
<tr class="memdesc:a61734ea9adbf63b8497fe36864c46a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn byte array into an int array.  <a href="../../d3/d87/classevio_1_1_util.html#a61734ea9adbf63b8497fe36864c46a00">More...</a><br /></td></tr>
<tr class="separator:a61734ea9adbf63b8497fe36864c46a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107bf333efeb2bb3d65104ce9d2edbf9"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a107bf333efeb2bb3d65104ce9d2edbf9">toInt</a> (char b1, char b2, char b3, char b4, const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;byteOrder)</td></tr>
<tr class="memdesc:a107bf333efeb2bb3d65104ce9d2edbf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn 4 bytes into an unsigned 32 bit int.  <a href="../../d3/d87/classevio_1_1_util.html#a107bf333efeb2bb3d65104ce9d2edbf9">More...</a><br /></td></tr>
<tr class="separator:a107bf333efeb2bb3d65104ce9d2edbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e37f2e2bb42b2f052ebfec4f0ff25c8"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a5e37f2e2bb42b2f052ebfec4f0ff25c8">toInt</a> (uint8_t const *data, <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> const &amp;byteOrder)</td></tr>
<tr class="memdesc:a5e37f2e2bb42b2f052ebfec4f0ff25c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn 4 bytes into an unsigned 32 bit int.  <a href="../../d3/d87/classevio_1_1_util.html#a5e37f2e2bb42b2f052ebfec4f0ff25c8">More...</a><br /></td></tr>
<tr class="separator:a5e37f2e2bb42b2f052ebfec4f0ff25c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48601a712a5622c5b8cab2415e0d9ffe"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a48601a712a5622c5b8cab2415e0d9ffe">toLong</a> (uint8_t const *data, <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> const &amp;byteOrder)</td></tr>
<tr class="memdesc:a48601a712a5622c5b8cab2415e0d9ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn 4 bytes into an unsigned 32 bit int.  <a href="../../d3/d87/classevio_1_1_util.html#a48601a712a5622c5b8cab2415e0d9ffe">More...</a><br /></td></tr>
<tr class="separator:a48601a712a5622c5b8cab2415e0d9ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69d28ab3f58cc5457f5b39439937b10"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#ab69d28ab3f58cc5457f5b39439937b10">toBytes</a> (uint32_t data, const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;byteOrder, uint8_t *dest)</td></tr>
<tr class="memdesc:ab69d28ab3f58cc5457f5b39439937b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write int into byte array.  <a href="../../d3/d87/classevio_1_1_util.html#ab69d28ab3f58cc5457f5b39439937b10">More...</a><br /></td></tr>
<tr class="separator:ab69d28ab3f58cc5457f5b39439937b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fc7ea971b35381db2d15f0769bbf43"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#af7fc7ea971b35381db2d15f0769bbf43">toBytes</a> (uint64_t data, const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;byteOrder, uint8_t *dest)</td></tr>
<tr class="memdesc:af7fc7ea971b35381db2d15f0769bbf43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn long into byte array.  <a href="../../d3/d87/classevio_1_1_util.html#af7fc7ea971b35381db2d15f0769bbf43">More...</a><br /></td></tr>
<tr class="separator:af7fc7ea971b35381db2d15f0769bbf43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdb1845ea7d246a088e156ff810c924"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a4bdb1845ea7d246a088e156ff810c924">toBytes</a> (uint32_t data, const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;byteOrder, std::vector&lt; uint8_t &gt; &amp;dest, size_t off)</td></tr>
<tr class="memdesc:a4bdb1845ea7d246a088e156ff810c924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write int into byte vector.  <a href="../../d3/d87/classevio_1_1_util.html#a4bdb1845ea7d246a088e156ff810c924">More...</a><br /></td></tr>
<tr class="separator:a4bdb1845ea7d246a088e156ff810c924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad930d1a274b50b4a1fe53dd7d81b95ee"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#ad930d1a274b50b4a1fe53dd7d81b95ee">toBytes</a> (uint16_t data, const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;byteOrder, uint8_t *dest)</td></tr>
<tr class="memdesc:ad930d1a274b50b4a1fe53dd7d81b95ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write short into byte array.  <a href="../../d3/d87/classevio_1_1_util.html#ad930d1a274b50b4a1fe53dd7d81b95ee">More...</a><br /></td></tr>
<tr class="separator:ad930d1a274b50b4a1fe53dd7d81b95ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61875b5df6961b5c8398d0156389d35"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#aa61875b5df6961b5c8398d0156389d35">toBytes</a> (uint16_t data, const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;byteOrder, std::vector&lt; uint8_t &gt; &amp;dest, size_t off)</td></tr>
<tr class="memdesc:aa61875b5df6961b5c8398d0156389d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write short into byte vector.  <a href="../../d3/d87/classevio_1_1_util.html#aa61875b5df6961b5c8398d0156389d35">More...</a><br /></td></tr>
<tr class="separator:aa61875b5df6961b5c8398d0156389d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431fdeccf76259fb59d1faee497745de"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a431fdeccf76259fb59d1faee497745de">NO_NAME_STRING</a> ()</td></tr>
<tr class="memdesc:a431fdeccf76259fb59d1faee497745de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string used to indicate that no name can be determined.  <a href="../../d3/d87/classevio_1_1_util.html#a431fdeccf76259fb59d1faee497745de">More...</a><br /></td></tr>
<tr class="separator:a431fdeccf76259fb59d1faee497745de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480d33b2eeef523ab4d2109d88d5f323"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a480d33b2eeef523ab4d2109d88d5f323">findEvioVersion</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;bb, size_t initialPos)</td></tr>
<tr class="memdesc:a480d33b2eeef523ab4d2109d88d5f323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a couple things in a block/record header in order to determine the evio version and endianness of a buffer/file.  <a href="../../d3/d87/classevio_1_1_util.html#a480d33b2eeef523ab4d2109d88d5f323">More...</a><br /></td></tr>
<tr class="separator:a480d33b2eeef523ab4d2109d88d5f323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6051f0bb6642d74ea674e5361b6994f8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a6051f0bb6642d74ea674e5361b6994f8">printBytes</a> (const std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; buf, uint32_t position, uint32_t bytes, const std::string &amp;label)</td></tr>
<tr class="memdesc:a6051f0bb6642d74ea674e5361b6994f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method takes a byte buffer and prints out the desired number of bytes from the given position, in hex.  <a href="../../d3/d87/classevio_1_1_util.html#a6051f0bb6642d74ea674e5361b6994f8">More...</a><br /></td></tr>
<tr class="separator:a6051f0bb6642d74ea674e5361b6994f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66847f39ab5cf153f005866eb5332fce"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a66847f39ab5cf153f005866eb5332fce">printBytes</a> (const <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;buf, uint32_t position, uint32_t bytes, const std::string &amp;label)</td></tr>
<tr class="memdesc:a66847f39ab5cf153f005866eb5332fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method takes a byte buffer and prints out the desired number of bytes from the given position, in hex.  <a href="../../d3/d87/classevio_1_1_util.html#a66847f39ab5cf153f005866eb5332fce">More...</a><br /></td></tr>
<tr class="separator:a66847f39ab5cf153f005866eb5332fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab164e1302d6850315d45c0be6f1a8df0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#ab164e1302d6850315d45c0be6f1a8df0">printBytes</a> (uint8_t const *data, uint32_t bytes, const std::string &amp;label)</td></tr>
<tr class="memdesc:ab164e1302d6850315d45c0be6f1a8df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method takes a pointer and prints out the desired number of bytes from the given position, in hex.  <a href="../../d3/d87/classevio_1_1_util.html#ab164e1302d6850315d45c0be6f1a8df0">More...</a><br /></td></tr>
<tr class="separator:ab164e1302d6850315d45c0be6f1a8df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69bace572e57dd144399015a87bcaef"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#af69bace572e57dd144399015a87bcaef">printBytes</a> (const std::string &amp;fileName, uint64_t offset, uint32_t bytes, const std::string &amp;label)</td></tr>
<tr class="memdesc:af69bace572e57dd144399015a87bcaef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method takes a file and prints out the desired number of bytes from the given offset, in hex.  <a href="../../d3/d87/classevio_1_1_util.html#af69bace572e57dd144399015a87bcaef">More...</a><br /></td></tr>
<tr class="separator:af69bace572e57dd144399015a87bcaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24c479c35a111fa7b43c9a05a409336"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#ad24c479c35a111fa7b43c9a05a409336">writeBytes</a> (const std::string &amp;fileName, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;buf)</td></tr>
<tr class="memdesc:ad24c479c35a111fa7b43c9a05a409336"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method takes a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> and writes its data to a file.  <a href="../../d3/d87/classevio_1_1_util.html#ad24c479c35a111fa7b43c9a05a409336">More...</a><br /></td></tr>
<tr class="separator:ad24c479c35a111fa7b43c9a05a409336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0fcfe01a261f79b571a12dba7faee4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a8a0fcfe01a261f79b571a12dba7faee4">readBytes</a> (const std::string &amp;fileName, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;buf)</td></tr>
<tr class="memdesc:a8a0fcfe01a261f79b571a12dba7faee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method reads part of a file into a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a>.  <a href="../../d3/d87/classevio_1_1_util.html#a8a0fcfe01a261f79b571a12dba7faee4">More...</a><br /></td></tr>
<tr class="separator:a8a0fcfe01a261f79b571a12dba7faee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf01b40cf83fcdd27115f66b67e848c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#aecf01b40cf83fcdd27115f66b67e848c">powerOfTwo</a> (int x, bool roundUp)</td></tr>
<tr class="memdesc:aecf01b40cf83fcdd27115f66b67e848c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the power of 2 closest to the given argument.  <a href="../../d3/d87/classevio_1_1_util.html#aecf01b40cf83fcdd27115f66b67e848c">More...</a><br /></td></tr>
<tr class="separator:aecf01b40cf83fcdd27115f66b67e848c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ceb7a53b91600618abe70e56290a17f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a8ceb7a53b91600618abe70e56290a17f">stringToASCII</a> (const std::string &amp;input, std::vector&lt; uint8_t &gt; &amp;array)</td></tr>
<tr class="memdesc:a8ceb7a53b91600618abe70e56290a17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an input string as ASCII in which each character is one byte.  <a href="../../d3/d87/classevio_1_1_util.html#a8ceb7a53b91600618abe70e56290a17f">More...</a><br /></td></tr>
<tr class="separator:a8ceb7a53b91600618abe70e56290a17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66a3b2b14b36d08d9b9fac4555e15fe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#ac66a3b2b14b36d08d9b9fac4555e15fe">stringToASCII</a> (const std::string &amp;input, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;buf)</td></tr>
<tr class="memdesc:ac66a3b2b14b36d08d9b9fac4555e15fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an input string as ASCII in which each character is one byte.  <a href="../../d3/d87/classevio_1_1_util.html#ac66a3b2b14b36d08d9b9fac4555e15fe">More...</a><br /></td></tr>
<tr class="separator:ac66a3b2b14b36d08d9b9fac4555e15fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fb04e9424d2289798ce4fa72a0427a"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#ad5fb04e9424d2289798ce4fa72a0427a">stringsToRawSize</a> (std::vector&lt; std::string &gt; const &amp;strings)</td></tr>
<tr class="memdesc:ad5fb04e9424d2289798ce4fa72a0427a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the number of bytes in a raw evio format of the given string array, not including header.  <a href="../../d3/d87/classevio_1_1_util.html#ad5fb04e9424d2289798ce4fa72a0427a">More...</a><br /></td></tr>
<tr class="separator:ad5fb04e9424d2289798ce4fa72a0427a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a1f64bd5ff18c187625eb2d7c684a0"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a29a1f64bd5ff18c187625eb2d7c684a0">stringToRawSize</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a29a1f64bd5ff18c187625eb2d7c684a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the number of bytes in a raw evio format of the given string array (with a single string), not including header.  <a href="../../d3/d87/classevio_1_1_util.html#a29a1f64bd5ff18c187625eb2d7c684a0">More...</a><br /></td></tr>
<tr class="separator:a29a1f64bd5ff18c187625eb2d7c684a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa190851d3b2fe20f4c0d02bae9713f10"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#aa190851d3b2fe20f4c0d02bae9713f10">stringsToRawBytes</a> (std::vector&lt; std::string &gt; &amp;strings, std::vector&lt; uint8_t &gt; &amp;bytes)</td></tr>
<tr class="memdesc:aa190851d3b2fe20f4c0d02bae9713f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method transforms an array/vector of strings into raw evio format data, not including header.  <a href="../../d3/d87/classevio_1_1_util.html#aa190851d3b2fe20f4c0d02bae9713f10">More...</a><br /></td></tr>
<tr class="separator:aa190851d3b2fe20f4c0d02bae9713f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5917af0b5e13bce0d20a07d2a014c55c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a5917af0b5e13bce0d20a07d2a014c55c">unpackRawBytesToStrings</a> (std::vector&lt; uint8_t &gt; &amp;bytes, size_t offset, std::vector&lt; std::string &gt; &amp;strData)</td></tr>
<tr class="memdesc:a5917af0b5e13bce0d20a07d2a014c55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method extracts an array of strings from byte array of raw evio string data.  <a href="../../d3/d87/classevio_1_1_util.html#a5917af0b5e13bce0d20a07d2a014c55c">More...</a><br /></td></tr>
<tr class="separator:a5917af0b5e13bce0d20a07d2a014c55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685d924c620feaf4093cadfa4ab2e5a2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a685d924c620feaf4093cadfa4ab2e5a2">unpackRawBytesToStrings</a> (std::vector&lt; uint8_t &gt; &amp;bytes, size_t offset, size_t maxLength, std::vector&lt; std::string &gt; &amp;strData)</td></tr>
<tr class="memdesc:a685d924c620feaf4093cadfa4ab2e5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method extracts an array of strings from byte array of raw evio string data.  <a href="../../d3/d87/classevio_1_1_util.html#a685d924c620feaf4093cadfa4ab2e5a2">More...</a><br /></td></tr>
<tr class="separator:a685d924c620feaf4093cadfa4ab2e5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dabe5e1409c9f9791b74442901715da"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a0dabe5e1409c9f9791b74442901715da">unpackRawBytesToStrings</a> (uint8_t *bytes, size_t length, std::vector&lt; std::string &gt; &amp;strData)</td></tr>
<tr class="memdesc:a0dabe5e1409c9f9791b74442901715da"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method extracts an array of strings from byte array of raw evio string data.  <a href="../../d3/d87/classevio_1_1_util.html#a0dabe5e1409c9f9791b74442901715da">More...</a><br /></td></tr>
<tr class="separator:a0dabe5e1409c9f9791b74442901715da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f369d12866c60689c6f381a2b87f64"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a46f369d12866c60689c6f381a2b87f64">unpackRawBytesToStrings</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;buffer, size_t pos, size_t length, std::vector&lt; std::string &gt; &amp;strData)</td></tr>
<tr class="memdesc:a46f369d12866c60689c6f381a2b87f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method extracts an array of strings from buffer containing raw evio string data.  <a href="../../d3/d87/classevio_1_1_util.html#a46f369d12866c60689c6f381a2b87f64">More...</a><br /></td></tr>
<tr class="separator:a46f369d12866c60689c6f381a2b87f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3533bfa3ba79b476ba13485657fb89e6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a3533bfa3ba79b476ba13485657fb89e6">stringBuilderToStrings</a> (std::string const &amp;strData, bool onlyGoodChars, std::vector&lt; std::string &gt; &amp;strings)</td></tr>
<tr class="memdesc:a3533bfa3ba79b476ba13485657fb89e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method extracts an array of strings from a string containing evio string data.  <a href="../../d3/d87/classevio_1_1_util.html#a3533bfa3ba79b476ba13485657fb89e6">More...</a><br /></td></tr>
<tr class="separator:a3533bfa3ba79b476ba13485657fb89e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efb23b17ee1beafd27b3633e032bd07"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a9efb23b17ee1beafd27b3633e032bd07">expandEnvironmentalVariables</a> (std::string &amp;text)</td></tr>
<tr class="memdesc:a9efb23b17ee1beafd27b3633e032bd07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute environmental variables in a given string when they come in the form, .  <a href="../../d3/d87/classevio_1_1_util.html#a9efb23b17ee1beafd27b3633e032bd07">More...</a><br /></td></tr>
<tr class="separator:a9efb23b17ee1beafd27b3633e032bd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7533e223ab3a55e4a23552fe61c2c2ac"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a7533e223ab3a55e4a23552fe61c2c2ac">countAndFixIntSpecifiers</a> (std::string &amp;text)</td></tr>
<tr class="memdesc:a7533e223ab3a55e4a23552fe61c2c2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of integer specifiers (e.g.  <a href="../../d3/d87/classevio_1_1_util.html#a7533e223ab3a55e4a23552fe61c2c2ac">More...</a><br /></td></tr>
<tr class="separator:a7533e223ab3a55e4a23552fe61c2c2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542fb63b5849885087ac24795604b4b6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a542fb63b5849885087ac24795604b4b6">generateBaseFileName</a> (const std::string &amp;baseName, const std::string &amp;runType, std::string &amp;modifiedBaseName)</td></tr>
<tr class="memdesc:a542fb63b5849885087ac24795604b4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method generates part of a file name given a base file name as an argument.  <a href="../../d3/d87/classevio_1_1_util.html#a542fb63b5849885087ac24795604b4b6">More...</a><br /></td></tr>
<tr class="separator:a542fb63b5849885087ac24795604b4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76482198f230e3afadbb65d1e6feedd9"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a76482198f230e3afadbb65d1e6feedd9">generateFileName</a> (std::string fileName, uint32_t specifierCount, uint32_t runNumber, uint64_t split, uint32_t splitNumber, uint32_t streamId, uint32_t streamCount)</td></tr>
<tr class="memdesc:a76482198f230e3afadbb65d1e6feedd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method does NOT work on its own.  <a href="../../d3/d87/classevio_1_1_util.html#a76482198f230e3afadbb65d1e6feedd9">More...</a><br /></td></tr>
<tr class="separator:a76482198f230e3afadbb65d1e6feedd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7e3cdb039ddd0f026a735b458ac64f4a"><td class="memItemLeft" align="right" valign="top">static constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d87/classevio_1_1_util.html#a7e3cdb039ddd0f026a735b458ac64f4a">padValue</a> [4] = {0,3,2,1}</td></tr>
<tr class="memdesc:a7e3cdb039ddd0f026a735b458ac64f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array to help find number of bytes to pad data.  <a href="../../d3/d87/classevio_1_1_util.html#a7e3cdb039ddd0f026a735b458ac64f4a">More...</a><br /></td></tr>
<tr class="separator:a7e3cdb039ddd0f026a735b458ac64f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class containing static methods of general purpose. </p>
<dl class="section version"><dt>Version</dt><dd>6.0 </dd></dl>
<dl class="section since"><dt>Since</dt><dd>6.0 11/2/19 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>timmer </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a7533e223ab3a55e4a23552fe61c2c2ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7533e223ab3a55e4a23552fe61c2c2ac">&#9670;&nbsp;</a></span>countAndFixIntSpecifiers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t evio::Util::countAndFixIntSpecifiers </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of integer specifiers (e.g. </p>
<p>%34d, %07x) in the given string, making sure any number preceding "x" or "d" starts with a 0. This is done so there will be no empty spaces in the resulting string (i.e. file name) when final substitutions are made for these specifiers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>string to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of integer specifiers. </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../d3/d87/classevio_1_1_util.html#a542fb63b5849885087ac24795604b4b6">generateBaseFileName()</a>.</p>

</div>
</div>
<a id="a9efb23b17ee1beafd27b3633e032bd07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efb23b17ee1beafd27b3633e032bd07">&#9670;&nbsp;</a></span>expandEnvironmentalVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::expandEnvironmentalVariables </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitute environmental variables in a given string when they come in the form, . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>string to analyze. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="../../d3/d87/classevio_1_1_util.html#a542fb63b5849885087ac24795604b4b6">generateBaseFileName()</a>.</p>

</div>
</div>
<a id="a480d33b2eeef523ab4d2109d88d5f323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480d33b2eeef523ab4d2109d88d5f323">&#9670;&nbsp;</a></span>findEvioVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t evio::Util::findEvioVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>initialPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a couple things in a block/record header in order to determine the evio version and endianness of a buffer/file. </p>
<p>The endianness can be read from the given <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> by calling, bb.order(). This does <b>not</b> change any parameters of the given buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> to read from. </td></tr>
    <tr><td class="paramname">initialPos</td><td>position in bb to start reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>evio version. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">underflow_error</td><td>if not enough data in buffer. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>bad magic number in header. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d5/d6e/classevio_1_1_i_block_header.html#a4e8ce12915b48acab0739a56cc1d641d">evio::IBlockHeader::BIT_INFO_OFFSET</a>, <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#aa11600b2ff36c44d7f2f8e345cfc937d">evio::ByteOrder::ENDIAN_BIG</a>, <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#ae70d8b2df728e3776bb6bb843260bb71">evio::ByteOrder::ENDIAN_LITTLE</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a01783f61f04c093b71f58cd1adbde2fa">evio::ByteBuffer::getInt()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a586571da6b6789902ecb5a67c319b34a">evio::ByteBuffer::getUInt()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#afb08d1dbc5fbf780afd27617a67eb750">evio::ByteBuffer::limit()</a>, <a class="el" href="../../d5/d6e/classevio_1_1_i_block_header.html#ac5f22d640a8987649db4fd4c8c699cb7">evio::IBlockHeader::MAGIC_NUMBER</a>, <a class="el" href="../../d5/d6e/classevio_1_1_i_block_header.html#a55aa26334a5f90f245dd5f3bd688ff07">evio::IBlockHeader::MAGIC_OFFSET</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a3d5f0120189717ffc8d2d480d89cb91a">evio::ByteBuffer::order()</a>, and <a class="el" href="../../d5/d6e/classevio_1_1_i_block_header.html#af24d4ac1e9d1e2a23529b3e4e367ac95">evio::IBlockHeader::VERSION_MASK</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d6/d5f/classevio_1_1_evio_compact_reader.html#a1c0f4061dd974ee2053b795afc57c177">evio::EvioCompactReader::EvioCompactReader()</a>, and <a class="el" href="../../df/dbd/classevio_1_1_evio_reader.html#a0214facdecc8bc06896ba03d026d58e6">evio::EvioReader::EvioReader()</a>.</p>

</div>
</div>
<a id="a542fb63b5849885087ac24795604b4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542fb63b5849885087ac24795604b4b6">&#9670;&nbsp;</a></span>generateBaseFileName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int evio::Util::generateBaseFileName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>runType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>modifiedBaseName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method generates part of a file name given a base file name as an argument. </p>
<p>The base file name may contain up to 3, C-style integer format specifiers (such as <b>%03d</b>, or <b>x</b>). If more than 3 are found, an exception will be thrown. If no "0" precedes any integer between the "%" and the "d" or "x" of the format specifier, it will be added automatically in order to avoid spaces in the returned string. In the <a class="el" href="../../d3/d87/classevio_1_1_util.html#a76482198f230e3afadbb65d1e6feedd9">generateFileName(std::string, uint32_t, uint32_t, uint64_t, uint32_t, uint32_t, uint32_t)</a> method, the first occurrence will be substituted with the given runNumber value. If the file is being split, the second will be substituted with the split number. If there are multiple streams, the third will be substituted with the stream id.</p>
<p>The base file name may contain characters of the form <b></b> which will be substituted with the value of the associated environmental variable or a blank string if none is found.</p>
<p>Finally, the base file name may contain occurrences of the string "%s" which will be substituted with the value of the runType arg or nothing if the runType is null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseName</td><td>file name to start with </td></tr>
    <tr><td class="paramname">runType</td><td>run type/configuration name </td></tr>
    <tr><td class="paramname">modifiedBaseName</td><td>final generated base file name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of C-style int format specifiers found in baseName arg. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if baseName arg is improperly formatted or blank </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d3/d87/classevio_1_1_util.html#a7533e223ab3a55e4a23552fe61c2c2ac">countAndFixIntSpecifiers()</a>, and <a class="el" href="../../d3/d87/classevio_1_1_util.html#a9efb23b17ee1beafd27b3633e032bd07">expandEnvironmentalVariables()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a5271d9b38e1e974be98f3ff98d5ed602">evio::EventWriter::EventWriter()</a>.</p>

</div>
</div>
<a id="a76482198f230e3afadbb65d1e6feedd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76482198f230e3afadbb65d1e6feedd9">&#9670;&nbsp;</a></span>generateFileName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string evio::Util::generateFileName </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>specifierCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>runNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>splitNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>streamCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method does NOT work on its own. </p>
<p>It generates a complete file name from the previously determined baseFileName obtained from calling <a class="el" href="../../d3/d87/classevio_1_1_util.html#a542fb63b5849885087ac24795604b4b6">generateBaseFileName</a>. If evio data is to be split up into multiple files (split &gt; 0), numbers are used to distinguish between the split files with splitNumber. If baseFileName contains C-style int format specifiers (specifierCount &gt; 0), then the first occurrence will be substituted with the given runNumber value. If the file is being split, the second will be substituted with the splitNumber. If there are multiple streams, the third will be substituted with the stream id.</p>
<p>If no specifier for the splitNumber exists, it is tacked onto the end of the file name. If no specifier for the stream id exists, it is tacked onto the end of the file name, after the splitNumber. No run numbers are ever tacked on without a specifier.</p>
<p>For splitting: if there is only 1 stream, no stream ids are used and any third specifier is removed. For non-splitting: if there is only 1 stream, no stream ids are used and any second and third specifiers are removed. For multiple streams, the second specifier is removed and the 3rd substituted with the stream id. For all cases: if there are more than 3 specifiers, <b>NO SUBSTITUTIONS ARE DONE.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>file name to use as a basis for the generated file name </td></tr>
    <tr><td class="paramname">specifierCount</td><td>number of C-style int format specifiers in baseFileName arg </td></tr>
    <tr><td class="paramname">runNumber</td><td>CODA run number </td></tr>
    <tr><td class="paramname">split</td><td>number of bytes at which to split off evio file </td></tr>
    <tr><td class="paramname">splitNumber</td><td>number of the split file </td></tr>
    <tr><td class="paramname">streamId</td><td>number of the stream id </td></tr>
    <tr><td class="paramname">streamCount</td><td>total number of streams</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>generated file name</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if the baseFileName arg contains printing format specifiers which are not compatible with integers and interfere with formatting. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a5271d9b38e1e974be98f3ff98d5ed602">evio::EventWriter::EventWriter()</a>.</p>

</div>
</div>
<a id="a2e0841939d9ccc701e4b69c58c148355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0841939d9ccc701e4b69c58c148355">&#9670;&nbsp;</a></span>getDataType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="../../d5/d23/classevio_1_1_data_type.html">DataType</a>&amp; evio::Util::getDataType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns an XML element name given an evio data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>evio data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XML element name used in evio event xml output </dd></dl>

<p class="reference">References <a class="el" href="../../d5/d23/classevio_1_1_data_type.html#ab38996675c5240d92a1593fac3600cdc">evio::DataType::ALSOBANK</a>, <a class="el" href="../../d5/d23/classevio_1_1_data_type.html#a84e08dfdd193f7c1b336dc06b222fa73">evio::DataType::ALSOSEGMENT</a>, <a class="el" href="../../d5/d23/classevio_1_1_data_type.html#a9a9803199ba7b5236f9fb5ccaacc9c6d">evio::DataType::CHAR8</a>, <a class="el" href="../../d5/d23/classevio_1_1_data_type.html#a44ebcac2851a8e66b41605ab55bc6708">evio::DataType::CHARSTAR8</a>, <a class="el" href="../../d5/d23/classevio_1_1_data_type.html#a9790e6d2d964cd17518b510cade71013">evio::DataType::COMPOSITE</a>, <a class="el" href="../../d5/d23/classevio_1_1_data_type.html#a018e0280b01ac441c63dc529f391c812">evio::DataType::DOUBLE64</a>, <a class="el" href="../../d5/d23/classevio_1_1_data_type.html#a15212317494206aed89652808e36ffcb">evio::DataType::FLOAT32</a>, <a class="el" href="../../d5/d23/classevio_1_1_data_type.html#ae23b05542b144e3b7d72628280532195">evio::DataType::INT32</a>, <a class="el" href="../../d3/d87/classevio_1_1_util.html#a4cc29d65753be764d27f4851efdb3846">iStrEquals()</a>, <a class="el" href="../../d5/d23/classevio_1_1_data_type.html#a0ad3467f252ad341a3f630f0210bc9e1">evio::DataType::LONG64</a>, <a class="el" href="../../d5/d23/classevio_1_1_data_type.html#a64b4f4f0ccc080ba2d28040f49cfef3c">evio::DataType::NOT_A_VALID_TYPE</a>, <a class="el" href="../../d5/d23/classevio_1_1_data_type.html#a227fb12c5f747c91239e4d305fa83447">evio::DataType::SHORT16</a>, <a class="el" href="../../d5/d23/classevio_1_1_data_type.html#a96276904feb345922470078df8b5e5c7">evio::DataType::TAGSEGMENT</a>, <a class="el" href="../../d5/d23/classevio_1_1_data_type.html#a1d561abba7301ebf74fefad8b29fa8ae">evio::DataType::UCHAR8</a>, <a class="el" href="../../d5/d23/classevio_1_1_data_type.html#ab594570d76a48584ae27c5e2276b3c04">evio::DataType::UINT32</a>, <a class="el" href="../../d5/d23/classevio_1_1_data_type.html#a0f556bae625e41a9adc3bae9949112d3">evio::DataType::ULONG64</a>, <a class="el" href="../../d5/d23/classevio_1_1_data_type.html#a2b3013fda814a931239319319790c761">evio::DataType::UNKNOWN32</a>, and <a class="el" href="../../d5/d23/classevio_1_1_data_type.html#aa4dc041c0f0796a4b7dd12d11a9c325a">evio::DataType::USHORT16</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d0/d00/classevio_1_1_evio_x_m_l_dictionary.html#a522c4afb7b3601a7bf5c2469dff2397d">evio::EvioXMLDictionary::parseXML()</a>.</p>

</div>
</div>
<a id="af174f6cb1faa20acb06238db0ce353ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af174f6cb1faa20acb06238db0ce353ed">&#9670;&nbsp;</a></span>getPadding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t evio::Util::getPadding </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of bytes needed to pad to 4-byte boundary for the given length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>length in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes needed to pad to 4-byte boundary. </dd></dl>

<p class="reference">References <a class="el" href="../../d3/d87/classevio_1_1_util.html#a7e3cdb039ddd0f026a735b458ac64f4a">padValue</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/d87/classevio_1_1_util.html#a0d84a3a050a9c03869fa3c7dd7287737">getWords()</a>, and <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a5d19dfdbc256c2bf9025795442cb59ff">evio::FileHeader::setUserHeaderLength()</a>.</p>

</div>
</div>
<a id="a0d84a3a050a9c03869fa3c7dd7287737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d84a3a050a9c03869fa3c7dd7287737">&#9670;&nbsp;</a></span>getWords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t evio::Util::getWords </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns length padded to 4-byte boundary for given length in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>length in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length in bytes padded to 4-byte boundary. </dd></dl>

<p class="reference">References <a class="el" href="../../d3/d87/classevio_1_1_util.html#af174f6cb1faa20acb06238db0ce353ed">getPadding()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/da6/classevio_1_1_file_header.html#a5d19dfdbc256c2bf9025795442cb59ff">evio::FileHeader::setUserHeaderLength()</a>.</p>

</div>
</div>
<a id="a4cc29d65753be764d27f4851efdb3846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc29d65753be764d27f4851efdb3846">&#9670;&nbsp;</a></span>iStrEquals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool evio::Util::iStrEquals </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Case insensitive compare for 2 strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first string. </td></tr>
    <tr><td class="paramname">b</td><td>second string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if equal, else false. </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../d3/d87/classevio_1_1_util.html#a2e0841939d9ccc701e4b69c58c148355">getDataType()</a>, and <a class="el" href="../../d0/d00/classevio_1_1_evio_x_m_l_dictionary.html#a522c4afb7b3601a7bf5c2469dff2397d">evio::EvioXMLDictionary::parseXML()</a>.</p>

</div>
</div>
<a id="a431fdeccf76259fb59d1faee497745de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431fdeccf76259fb59d1faee497745de">&#9670;&nbsp;</a></span>NO_NAME_STRING()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; evio::Util::NO_NAME_STRING </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a string used to indicate that no name can be determined. </p>
<dl class="section return"><dt>Returns</dt><dd>string used to indicate that no name can be determined. </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../d0/d00/classevio_1_1_evio_x_m_l_dictionary.html#a4bce21db121f872b2144333677a9e2c4">evio::EvioXMLDictionary::NO_NAME_STRING()</a>.</p>

</div>
</div>
<a id="aecf01b40cf83fcdd27115f66b67e848c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf01b40cf83fcdd27115f66b67e848c">&#9670;&nbsp;</a></span>powerOfTwo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int evio::Util::powerOfTwo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>roundUp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the power of 2 closest to the given argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>value to get the power of 2 closest to. </td></tr>
    <tr><td class="paramname">roundUp</td><td>if true, round up, else down </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if x is negative or the closest power of 2 to value </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a5271d9b38e1e974be98f3ff98d5ed602">evio::EventWriter::EventWriter()</a>.</p>

</div>
</div>
<a id="a66847f39ab5cf153f005866eb5332fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66847f39ab5cf153f005866eb5332fce">&#9670;&nbsp;</a></span>printBytes() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::printBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method takes a byte buffer and prints out the desired number of bytes from the given position, in hex. </p>
<p>Prints all bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer to print out </td></tr>
    <tr><td class="paramname">position</td><td>position of data (bytes) in buffer to start printing </td></tr>
    <tr><td class="paramname">bytes</td><td>number of bytes to print in hex </td></tr>
    <tr><td class="paramname">label</td><td>a label to print as header </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a6496a99b06b5ed67b8c93b148fd87323">evio::ByteBuffer::capacity()</a>.</p>

</div>
</div>
<a id="a6051f0bb6642d74ea674e5361b6994f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6051f0bb6642d74ea674e5361b6994f8">&#9670;&nbsp;</a></span>printBytes() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::printBytes </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method takes a byte buffer and prints out the desired number of bytes from the given position, in hex. </p>
<p>Prints all bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer to print out </td></tr>
    <tr><td class="paramname">position</td><td>position of data (bytes) in buffer to start printing </td></tr>
    <tr><td class="paramname">bytes</td><td>number of bytes to print in hex </td></tr>
    <tr><td class="paramname">label</td><td>a label to print as header </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="../../d3/d87/classevio_1_1_util.html#af69bace572e57dd144399015a87bcaef">printBytes()</a>.</p>

</div>
</div>
<a id="af69bace572e57dd144399015a87bcaef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69bace572e57dd144399015a87bcaef">&#9670;&nbsp;</a></span>printBytes() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::printBytes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method takes a file and prints out the desired number of bytes from the given offset, in hex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>file to print out </td></tr>
    <tr><td class="paramname">offset</td><td>offset into file to start printing </td></tr>
    <tr><td class="paramname">bytes</td><td>number of bytes to print in hex </td></tr>
    <tr><td class="paramname">label</td><td>a label to print as header </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#aa0e335238a57eaa0bffee8f968e5995f">evio::ByteBuffer::array()</a>, and <a class="el" href="../../d3/d87/classevio_1_1_util.html#a6051f0bb6642d74ea674e5361b6994f8">printBytes()</a>.</p>

</div>
</div>
<a id="ab164e1302d6850315d45c0be6f1a8df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab164e1302d6850315d45c0be6f1a8df0">&#9670;&nbsp;</a></span>printBytes() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::printBytes </td>
          <td>(</td>
          <td class="paramtype">uint8_t const *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method takes a pointer and prints out the desired number of bytes from the given position, in hex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>data to print out </td></tr>
    <tr><td class="paramname">bytes</td><td>number of bytes to print in hex </td></tr>
    <tr><td class="paramname">label</td><td>a label to print as header </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a0fcfe01a261f79b571a12dba7faee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0fcfe01a261f79b571a12dba7faee4">&#9670;&nbsp;</a></span>readBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::readBytes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method reads part of a file into a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a>. </p>
<p>The buffer's position will be at the end of the data that is read. The caller will have to flip the buffer to read it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>file to read from. </td></tr>
    <tr><td class="paramname">buf</td><td>buffer to write into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>bad file name or unable to do I/O. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#aa0e335238a57eaa0bffee8f968e5995f">evio::ByteBuffer::array()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#abf7abf99aa7544601997f40eba298648">evio::ByteBuffer::arrayOffset()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#afb08d1dbc5fbf780afd27617a67eb750">evio::ByteBuffer::limit()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a88f84e6b1757db70542eac13294fc80e">evio::ByteBuffer::position()</a>, and <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a32b043081cd3a62187f2577ce2966e7d">evio::ByteBuffer::remaining()</a>.</p>

</div>
</div>
<a id="a3533bfa3ba79b476ba13485657fb89e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3533bfa3ba79b476ba13485657fb89e6">&#9670;&nbsp;</a></span>stringBuilderToStrings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::stringBuilderToStrings </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>strData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyGoodChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method extracts an array of strings from a string containing evio string data. </p>
<p>If non-printable chars are found (besides those used to terminate strings), then 1 string with all characters will be returned. However, if the "onlyGoodChars" flag is true, 1 string is returned in truncated form without the bad characters at the end.</p>
<p>The name of this method is taken from the java and has little to do with C++. That's done for ease of code maintenance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strData</td><td>containing string data </td></tr>
    <tr><td class="paramname">onlyGoodChars</td><td>if true and non-printable chars found, only 1 string with printable ASCII chars will be returned. </td></tr>
    <tr><td class="paramname">strings</td><td>vector in which to place extracted strings. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="../../d3/d87/classevio_1_1_util.html#a685d924c620feaf4093cadfa4ab2e5a2">unpackRawBytesToStrings()</a>.</p>

</div>
</div>
<a id="aa190851d3b2fe20f4c0d02bae9713f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa190851d3b2fe20f4c0d02bae9713f10">&#9670;&nbsp;</a></span>stringsToRawBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::stringsToRawBytes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method transforms an array/vector of strings into raw evio format data, not including header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>vector of strings to transform. </td></tr>
    <tr><td class="paramname">bytes</td><td>vector of bytes to contain evio formatted strings. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d3/d87/classevio_1_1_util.html#ad5fb04e9424d2289798ce4fa72a0427a">stringsToRawSize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/dce/classevio_1_1_compact_event_builder.html#a9835683a45cb69bbaec9f8f41c691ce0">evio::CompactEventBuilder::addStringData()</a>.</p>

</div>
</div>
<a id="ad5fb04e9424d2289798ce4fa72a0427a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fb04e9424d2289798ce4fa72a0427a">&#9670;&nbsp;</a></span>stringsToRawSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t evio::Util::stringsToRawSize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; const &amp;&#160;</td>
          <td class="paramname"><em>strings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns the number of bytes in a raw evio format of the given string array, not including header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>vector of strings to size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes in a raw evio format of the given strings </dd>
<dd>
0 if vector empty. </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../d0/d19/classevio_1_1_composite_data_1_1_data.html#a3fc56698abe1c67bbd9c244c427090dd">evio::CompositeData::Data::addString()</a>, <a class="el" href="../../d9/ddd/classevio_1_1_base_structure.html#adc7c9d3969d7e561016ba76dded03058">evio::BaseStructure::stringsToRawBytes()</a>, and <a class="el" href="../../d3/d87/classevio_1_1_util.html#aa190851d3b2fe20f4c0d02bae9713f10">stringsToRawBytes()</a>.</p>

</div>
</div>
<a id="ac66a3b2b14b36d08d9b9fac4555e15fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66a3b2b14b36d08d9b9fac4555e15fe">&#9670;&nbsp;</a></span>stringToASCII() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::stringToASCII </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an input string as ASCII in which each character is one byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>input string. </td></tr>
    <tr><td class="paramname">buf</td><td><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> in which to place ASCII. Clears existing data and may expand internal storage. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a11a85b28fd30c969f567c8c7f5848275">evio::ByteBuffer::clear()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#ac07ae24bab386451176df095a376d330">evio::ByteBuffer::expand()</a>, and <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#ab864753c79b9a896ae8ff2e09ebfc44f">evio::ByteBuffer::put()</a>.</p>

</div>
</div>
<a id="a8ceb7a53b91600618abe70e56290a17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ceb7a53b91600618abe70e56290a17f">&#9670;&nbsp;</a></span>stringToASCII() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::stringToASCII </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an input string as ASCII in which each character is one byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>input string. </td></tr>
    <tr><td class="paramname">array</td><td>vector in which to place ASCII. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29a1f64bd5ff18c187625eb2d7c684a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a1f64bd5ff18c187625eb2d7c684a0">&#9670;&nbsp;</a></span>stringToRawSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t evio::Util::stringToRawSize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns the number of bytes in a raw evio format of the given string array (with a single string), not including header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>single string to size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes in a raw evio format of the given strings or 0 if vector empty. </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../df/d43/classevio_1_1_tag_segment_header.html#a2a8a8430edafaf5858b86ea6f6e9815d">evio::TagSegmentHeader::TagSegmentHeader()</a>.</p>

</div>
</div>
<a id="aa61875b5df6961b5c8398d0156389d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61875b5df6961b5c8398d0156389d35">&#9670;&nbsp;</a></span>toBytes() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::toBytes </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>byteOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write short into byte vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>short to convert. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>byte order of vector. </td></tr>
    <tr><td class="paramname">dest</td><td>vector in which to write short. </td></tr>
    <tr><td class="paramname">off</td><td>offset into vector where short is to be written. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#aa11600b2ff36c44d7f2f8e345cfc937d">evio::ByteOrder::ENDIAN_BIG</a>.</p>

</div>
</div>
<a id="ad930d1a274b50b4a1fe53dd7d81b95ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad930d1a274b50b4a1fe53dd7d81b95ee">&#9670;&nbsp;</a></span>toBytes() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::toBytes </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>byteOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write short into byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>short to convert. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>byte order of array. </td></tr>
    <tr><td class="paramname">dest</td><td>array in which to write short. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if dest is null or too small. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#aa11600b2ff36c44d7f2f8e345cfc937d">evio::ByteOrder::ENDIAN_BIG</a>.</p>

</div>
</div>
<a id="a4bdb1845ea7d246a088e156ff810c924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bdb1845ea7d246a088e156ff810c924">&#9670;&nbsp;</a></span>toBytes() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::toBytes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>byteOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write int into byte vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>int to convert. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>byte order of vector. </td></tr>
    <tr><td class="paramname">dest</td><td>vector in which to write int. </td></tr>
    <tr><td class="paramname">off</td><td>offset into vector where int is to be written. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#aa11600b2ff36c44d7f2f8e345cfc937d">evio::ByteOrder::ENDIAN_BIG</a>.</p>

</div>
</div>
<a id="ab69d28ab3f58cc5457f5b39439937b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69d28ab3f58cc5457f5b39439937b10">&#9670;&nbsp;</a></span>toBytes() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::toBytes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>byteOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write int into byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>int to convert. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>byte order of written bytes. </td></tr>
    <tr><td class="paramname">dest</td><td>array in which to write int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if dest is null or too small. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#aa11600b2ff36c44d7f2f8e345cfc937d">evio::ByteOrder::ENDIAN_BIG</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/d90/classevio_1_1_bank_header.html#af17d69932a1d6ebd14bcdfe7b9022db5">evio::BankHeader::write()</a>, <a class="el" href="../../d1/d89/classevio_1_1_segment_header.html#a8431fe65ab32bc72f25ae5584f07eb95">evio::SegmentHeader::write()</a>, and <a class="el" href="../../df/d43/classevio_1_1_tag_segment_header.html#aa792a400774c62abced5d451affb49e0">evio::TagSegmentHeader::write()</a>.</p>

</div>
</div>
<a id="af7fc7ea971b35381db2d15f0769bbf43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fc7ea971b35381db2d15f0769bbf43">&#9670;&nbsp;</a></span>toBytes() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::toBytes </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>byteOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turn long into byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>long to convert. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>byte order of written bytes. </td></tr>
    <tr><td class="paramname">dest</td><td>array in which to write long. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if dest is null or too small </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#aa11600b2ff36c44d7f2f8e345cfc937d">evio::ByteOrder::ENDIAN_BIG</a>.</p>

</div>
</div>
<a id="a107bf333efeb2bb3d65104ce9d2edbf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107bf333efeb2bb3d65104ce9d2edbf9">&#9670;&nbsp;</a></span>toInt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t evio::Util::toInt </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>b3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>b4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>byteOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turn 4 bytes into an unsigned 32 bit int. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b1</td><td>1st byte </td></tr>
    <tr><td class="paramname">b2</td><td>2nd byte </td></tr>
    <tr><td class="paramname">b3</td><td>3rd byte </td></tr>
    <tr><td class="paramname">b4</td><td>4th byte </td></tr>
    <tr><td class="paramname">byteOrder</td><td>if big endian, 1st byte is most significant &amp; 4th is least </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int converted from byte array </dd></dl>

<p class="reference">References <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#aa11600b2ff36c44d7f2f8e345cfc937d">evio::ByteOrder::ENDIAN_BIG</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../df/dbd/classevio_1_1_evio_reader.html#adc4c3dce642cc01d8f46cecffcc93296">evio::EvioReader::getEvent()</a>, and <a class="el" href="../../d3/d87/classevio_1_1_util.html#a61734ea9adbf63b8497fe36864c46a00">toIntArray()</a>.</p>

</div>
</div>
<a id="a5e37f2e2bb42b2f052ebfec4f0ff25c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e37f2e2bb42b2f052ebfec4f0ff25c8">&#9670;&nbsp;</a></span>toInt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t evio::Util::toInt </td>
          <td>(</td>
          <td class="paramtype">uint8_t const *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> const &amp;&#160;</td>
          <td class="paramname"><em>byteOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turn 4 bytes into an unsigned 32 bit int. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to bytes to convert. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>byte order of bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int converted from byte array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if data is null. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#aa11600b2ff36c44d7f2f8e345cfc937d">evio::ByteOrder::ENDIAN_BIG</a>.</p>

</div>
</div>
<a id="a61734ea9adbf63b8497fe36864c46a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61734ea9adbf63b8497fe36864c46a00">&#9670;&nbsp;</a></span>toIntArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::toIntArray </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>byteOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turn byte array into an int array. </p>
<p>Number of int array elements = number of bytes / 4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>char array to convert. </td></tr>
    <tr><td class="paramname">dataLen</td><td>number of bytes to convert. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>byte order of supplied bytes. </td></tr>
    <tr><td class="paramname">dest</td><td>array in which to write converted bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if data or dest is null </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d3/d87/classevio_1_1_util.html#a107bf333efeb2bb3d65104ce9d2edbf9">toInt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/d62/classevio_1_1_event_header_parser.html#a27b67f99e484aeece2a45d052607d99b">evio::EventHeaderParser::createBankHeader()</a>, <a class="el" href="../../dd/d62/classevio_1_1_event_header_parser.html#adb2fa91855279219b9ae49184314310b">evio::EventHeaderParser::createSegmentHeader()</a>, <a class="el" href="../../dd/d62/classevio_1_1_event_header_parser.html#a7326819543761ef2a1962ef16d73359e">evio::EventHeaderParser::createTagSegmentHeader()</a>, and <a class="el" href="../../d3/d56/classevio_1_1_reader.html#a7a3c02dd9c1c87a57f4b73076071bced">evio::Reader::scanFile()</a>.</p>

</div>
</div>
<a id="a48601a712a5622c5b8cab2415e0d9ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48601a712a5622c5b8cab2415e0d9ffe">&#9670;&nbsp;</a></span>toLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t evio::Util::toLong </td>
          <td>(</td>
          <td class="paramtype">uint8_t const *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> const &amp;&#160;</td>
          <td class="paramname"><em>byteOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turn 4 bytes into an unsigned 32 bit int. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to bytes to convert </td></tr>
    <tr><td class="paramname">byteOrder</td><td>byte order of bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int converted from byte array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if data is null. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#aa11600b2ff36c44d7f2f8e345cfc937d">evio::ByteOrder::ENDIAN_BIG</a>.</p>

</div>
</div>
<a id="a46f369d12866c60689c6f381a2b87f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f369d12866c60689c6f381a2b87f64">&#9670;&nbsp;</a></span>unpackRawBytesToStrings() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::unpackRawBytesToStrings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>strData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method extracts an array of strings from buffer containing raw evio string data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>buffer containing evio string data </td></tr>
    <tr><td class="paramname">pos</td><td>position of string data in buffer </td></tr>
    <tr><td class="paramname">length</td><td>length of string data in buffer in bytes </td></tr>
    <tr><td class="paramname">strData</td><td>vector in which to place extracted strings. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#aa0e335238a57eaa0bffee8f968e5995f">evio::ByteBuffer::array()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#abf7abf99aa7544601997f40eba298648">evio::ByteBuffer::arrayOffset()</a>, and <a class="el" href="../../d3/d87/classevio_1_1_util.html#a3533bfa3ba79b476ba13485657fb89e6">stringBuilderToStrings()</a>.</p>

</div>
</div>
<a id="a685d924c620feaf4093cadfa4ab2e5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a685d924c620feaf4093cadfa4ab2e5a2">&#9670;&nbsp;</a></span>unpackRawBytesToStrings() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::unpackRawBytesToStrings </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>strData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method extracts an array of strings from byte array of raw evio string data. </p>
<p>Don't go beyond the specified max character limit and stop at the first non-character value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>raw evio string data </td></tr>
    <tr><td class="paramname">offset</td><td>offset into raw data vector </td></tr>
    <tr><td class="paramname">maxLength</td><td>max length in bytes of valid data in bytes vector </td></tr>
    <tr><td class="paramname">strData</td><td>vector in which to place extracted strings. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d3/d87/classevio_1_1_util.html#a3533bfa3ba79b476ba13485657fb89e6">stringBuilderToStrings()</a>.</p>

</div>
</div>
<a id="a5917af0b5e13bce0d20a07d2a014c55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5917af0b5e13bce0d20a07d2a014c55c">&#9670;&nbsp;</a></span>unpackRawBytesToStrings() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::unpackRawBytesToStrings </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>strData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method extracts an array of strings from byte array of raw evio string data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>raw evio string data. </td></tr>
    <tr><td class="paramname">offset</td><td>offset into raw data array. </td></tr>
    <tr><td class="paramname">strData</td><td>vector in which to place extracted strings. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dabe5e1409c9f9791b74442901715da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dabe5e1409c9f9791b74442901715da">&#9670;&nbsp;</a></span>unpackRawBytesToStrings() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::unpackRawBytesToStrings </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>strData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method extracts an array of strings from byte array of raw evio string data. </p>
<p>Don't go beyond the specified max character limit and stop at the first non-character value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>raw evio string data </td></tr>
    <tr><td class="paramname">length</td><td>length in bytes of valid data in bytes vector </td></tr>
    <tr><td class="paramname">strData</td><td>vector in which to place extracted strings. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d3/d87/classevio_1_1_util.html#a3533bfa3ba79b476ba13485657fb89e6">stringBuilderToStrings()</a>.</p>

</div>
</div>
<a id="ad24c479c35a111fa7b43c9a05a409336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24c479c35a111fa7b43c9a05a409336">&#9670;&nbsp;</a></span>writeBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::Util::writeBytes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method takes a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> and writes its data to a file. </p>
<p>This will overwrite any existing file of the same name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>file to write to. </td></tr>
    <tr><td class="paramname">buf</td><td>buffer to write into the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>bad file name or unable to write. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#aa0e335238a57eaa0bffee8f968e5995f">evio::ByteBuffer::array()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#abf7abf99aa7544601997f40eba298648">evio::ByteBuffer::arrayOffset()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a88f84e6b1757db70542eac13294fc80e">evio::ByteBuffer::position()</a>, and <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a32b043081cd3a62187f2577ce2966e7d">evio::ByteBuffer::remaining()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7e3cdb039ddd0f026a735b458ac64f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3cdb039ddd0f026a735b458ac64f4a">&#9670;&nbsp;</a></span>padValue</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t evio::Util::padValue[4] = {0,3,2,1}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array to help find number of bytes to pad data. </p>

<p class="reference">Referenced by <a class="el" href="../../d3/d87/classevio_1_1_util.html#af174f6cb1faa20acb06238db0ce353ed">getPadding()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="../../dd/d90/_util_8h.html">Util.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d9/deb/namespaceevio.html">evio</a></li><li class="navelem"><a class="el" href="../../d3/d87/classevio_1_1_util.html">Util</a></li>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
