<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>evio: evio::EventWriter Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">evio
   &#160;<span id="projectnumber">6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d9/dcd/classevio_1_1_event_writer.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="../../df/d29/classevio_1_1_event_writer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">evio::EventWriter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a> object is used for writing events to a file or to a byte buffer.  
 <a href="../../d9/dcd/classevio_1_1_event_writer.html#details">More...</a></p>

<p><code>#include &lt;EventWriter.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a17225fd6d6a7fdfa9d20a75966f5c11a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a17225fd6d6a7fdfa9d20a75966f5c11a">EventWriter</a> (std::string &amp;filename, const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;byteOrder=<a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#aa96046df3a55b85a31f2c33e4d903cf1">ByteOrder::nativeOrder</a>(), bool append=false)</td></tr>
<tr class="memdesc:a17225fd6d6a7fdfa9d20a75966f5c11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <code><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a></code> for writing to a file in the specified byte order.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a17225fd6d6a7fdfa9d20a75966f5c11a">More...</a><br /></td></tr>
<tr class="separator:a17225fd6d6a7fdfa9d20a75966f5c11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92be16234de2fd45d4c19a710fdac9be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a92be16234de2fd45d4c19a710fdac9be">EventWriter</a> (std::string &amp;filename, std::string &amp;dictionary, const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;byteOrder=<a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#aa96046df3a55b85a31f2c33e4d903cf1">ByteOrder::nativeOrder</a>(), bool append=false)</td></tr>
<tr class="memdesc:a92be16234de2fd45d4c19a710fdac9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <code><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a></code> for writing to a file in NATIVE byte order.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a92be16234de2fd45d4c19a710fdac9be">More...</a><br /></td></tr>
<tr class="separator:a92be16234de2fd45d4c19a710fdac9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5271d9b38e1e974be98f3ff98d5ed602"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a5271d9b38e1e974be98f3ff98d5ed602">EventWriter</a> (std::string baseName, const std::string &amp;directory, const std::string &amp;runType, uint32_t runNumber, uint64_t split, uint32_t maxRecordSize, uint32_t maxEventCount, const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;byteOrder, const std::string &amp;xmlDictionary, bool overWriteOK, bool append, std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt; firstEvent, uint32_t streamId, uint32_t splitNumber, uint32_t splitIncrement, uint32_t streamCount, <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747">Compressor::CompressionType</a> compressionType, uint32_t compressionThreads, uint32_t ringSize, uint32_t bufferSize)</td></tr>
<tr class="memdesc:a5271d9b38e1e974be98f3ff98d5ed602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <code><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a></code> for writing events to a file.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a5271d9b38e1e974be98f3ff98d5ed602">More...</a><br /></td></tr>
<tr class="separator:a5271d9b38e1e974be98f3ff98d5ed602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b4acef57cfd15dcc5844c385824c90"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a93b4acef57cfd15dcc5844c385824c90">EventWriter</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buf)</td></tr>
<tr class="memdesc:a93b4acef57cfd15dcc5844c385824c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <code><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a></code> for writing events to a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a>.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a93b4acef57cfd15dcc5844c385824c90">More...</a><br /></td></tr>
<tr class="separator:a93b4acef57cfd15dcc5844c385824c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66db745e2ef5e1fcca14eae4683dc160"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a66db745e2ef5e1fcca14eae4683dc160">EventWriter</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buf, std::string &amp;xmlDictionary)</td></tr>
<tr class="memdesc:a66db745e2ef5e1fcca14eae4683dc160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <code><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a></code> for writing events to a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a>.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a66db745e2ef5e1fcca14eae4683dc160">More...</a><br /></td></tr>
<tr class="separator:a66db745e2ef5e1fcca14eae4683dc160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4c374c6cf244dfd6f777917b7c7ea3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a0a4c374c6cf244dfd6f777917b7c7ea3">EventWriter</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buf, uint32_t maxRecordSize, uint32_t maxEventCount, const std::string &amp;xmlDictionary, uint32_t recordNumber, std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt; const &amp;firstEvent, <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747">Compressor::CompressionType</a> compressionType)</td></tr>
<tr class="memdesc:a0a4c374c6cf244dfd6f777917b7c7ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <code><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a></code> for writing events to a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a>.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a0a4c374c6cf244dfd6f777917b7c7ea3">More...</a><br /></td></tr>
<tr class="separator:a0a4c374c6cf244dfd6f777917b7c7ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74140e35e3c934cf63e095d4d2ac73f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a74140e35e3c934cf63e095d4d2ac73f5">isDiskFull</a> ()</td></tr>
<tr class="memdesc:a74140e35e3c934cf63e095d4d2ac73f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If writing file, is the partition it resides on full? Not full, in this context, means there's enough space to write a full split file + a full record + an extra 10MB as a safety factor.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a74140e35e3c934cf63e095d4d2ac73f5">More...</a><br /></td></tr>
<tr class="separator:a74140e35e3c934cf63e095d4d2ac73f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3e5edb367a7ca355e0f0e936db44b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a8d3e5edb367a7ca355e0f0e936db44b6">setBuffer</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buf, std::bitset&lt; 24 &gt; *bitInfo, uint32_t recNumber)</td></tr>
<tr class="memdesc:a8d3e5edb367a7ca355e0f0e936db44b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the buffer being written into (initially set in constructor).  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a8d3e5edb367a7ca355e0f0e936db44b6">More...</a><br /></td></tr>
<tr class="separator:a8d3e5edb367a7ca355e0f0e936db44b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c84d3cc0d530dcafeb325d3fd78a79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a59c84d3cc0d530dcafeb325d3fd78a79">setBuffer</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buf)</td></tr>
<tr class="memdesc:a59c84d3cc0d530dcafeb325d3fd78a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the buffer being written into (initially set in constructor).  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a59c84d3cc0d530dcafeb325d3fd78a79">More...</a><br /></td></tr>
<tr class="separator:a59c84d3cc0d530dcafeb325d3fd78a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f560ab96c146e6a3c288d202cadb1e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#ab9f560ab96c146e6a3c288d202cadb1e">getByteBuffer</a> ()</td></tr>
<tr class="memdesc:ab9f560ab96c146e6a3c288d202cadb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If writing to a file, return null.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#ab9f560ab96c146e6a3c288d202cadb1e">More...</a><br /></td></tr>
<tr class="separator:ab9f560ab96c146e6a3c288d202cadb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b8192088442c20102b758a10c7d45e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#aa4b8192088442c20102b758a10c7d45e">setSourceId</a> (int sId)</td></tr>
<tr class="memdesc:aa4b8192088442c20102b758a10c7d45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the source Id in the first block header.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#aa4b8192088442c20102b758a10c7d45e">More...</a><br /></td></tr>
<tr class="separator:aa4b8192088442c20102b758a10c7d45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5177b190e06a2b28fd62136f4b4eb0a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a5177b190e06a2b28fd62136f4b4eb0a2">setEventType</a> (int type)</td></tr>
<tr class="memdesc:a5177b190e06a2b28fd62136f4b4eb0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bit info of a record header for a specified CODA event type.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a5177b190e06a2b28fd62136f4b4eb0a2">More...</a><br /></td></tr>
<tr class="separator:a5177b190e06a2b28fd62136f4b4eb0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9314950dbd90b4d776549376c56160ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a9314950dbd90b4d776549376c56160ea">writingToFile</a> () const</td></tr>
<tr class="memdesc:a9314950dbd90b4d776549376c56160ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this object writing to file?  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a9314950dbd90b4d776549376c56160ea">More...</a><br /></td></tr>
<tr class="separator:a9314950dbd90b4d776549376c56160ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82458e15e94f88450f061de51d1d3e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#aa82458e15e94f88450f061de51d1d3e8">isClosed</a> () const</td></tr>
<tr class="memdesc:aa82458e15e94f88450f061de51d1d3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed">close()</a> been called (without reopening by calling <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a8d3e5edb367a7ca355e0f0e936db44b6">setBuffer()</a>) ?  <a href="../../d9/dcd/classevio_1_1_event_writer.html#aa82458e15e94f88450f061de51d1d3e8">More...</a><br /></td></tr>
<tr class="separator:aa82458e15e94f88450f061de51d1d3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869c87c1e922b6e7cf509e7bd4e92c68"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a869c87c1e922b6e7cf509e7bd4e92c68">getCurrentFilename</a> () const</td></tr>
<tr class="memdesc:a869c87c1e922b6e7cf509e7bd4e92c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the current file being written to.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a869c87c1e922b6e7cf509e7bd4e92c68">More...</a><br /></td></tr>
<tr class="separator:a869c87c1e922b6e7cf509e7bd4e92c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2456f9ee73604178342bb55792df85c5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a2456f9ee73604178342bb55792df85c5">getBytesWrittenToBuffer</a> () const</td></tr>
<tr class="memdesc:a2456f9ee73604178342bb55792df85c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If writing to a buffer, get the number of bytes written to it including the trailer.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a2456f9ee73604178342bb55792df85c5">More...</a><br /></td></tr>
<tr class="separator:a2456f9ee73604178342bb55792df85c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea264cc1787db07728ed795858c04c7a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#aea264cc1787db07728ed795858c04c7a">getCurrentFilePath</a> () const</td></tr>
<tr class="memdesc:aea264cc1787db07728ed795858c04c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the full name or path of the current file being written to.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#aea264cc1787db07728ed795858c04c7a">More...</a><br /></td></tr>
<tr class="separator:aea264cc1787db07728ed795858c04c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21d6b4fa57b43b338dab195a6c2be1c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#ae21d6b4fa57b43b338dab195a6c2be1c">getSplitNumber</a> () const</td></tr>
<tr class="memdesc:ae21d6b4fa57b43b338dab195a6c2be1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current split number which is the split number of file to be written next.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#ae21d6b4fa57b43b338dab195a6c2be1c">More...</a><br /></td></tr>
<tr class="separator:ae21d6b4fa57b43b338dab195a6c2be1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4093dbd44f2773872fce88855c9357"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#afb4093dbd44f2773872fce88855c9357">getSplitCount</a> () const</td></tr>
<tr class="memdesc:afb4093dbd44f2773872fce88855c9357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of split files produced by this writer.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#afb4093dbd44f2773872fce88855c9357">More...</a><br /></td></tr>
<tr class="separator:afb4093dbd44f2773872fce88855c9357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498ee5a0039c4265741917390b0a380e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a498ee5a0039c4265741917390b0a380e">getRecordNumber</a> () const</td></tr>
<tr class="memdesc:a498ee5a0039c4265741917390b0a380e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current record number.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a498ee5a0039c4265741917390b0a380e">More...</a><br /></td></tr>
<tr class="separator:a498ee5a0039c4265741917390b0a380e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318697a18126aaf937a97f9bae3939f7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a318697a18126aaf937a97f9bae3939f7">getEventsWritten</a> () const</td></tr>
<tr class="memdesc:a318697a18126aaf937a97f9bae3939f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of events written to a file/buffer.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a318697a18126aaf937a97f9bae3939f7">More...</a><br /></td></tr>
<tr class="separator:a318697a18126aaf937a97f9bae3939f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fed50d9fd092e3ae3a9ad2c18b8180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#aa6fed50d9fd092e3ae3a9ad2c18b8180">getByteOrder</a> () const</td></tr>
<tr class="memdesc:aa6fed50d9fd092e3ae3a9ad2c18b8180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the byte order of the buffer/file being written into.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#aa6fed50d9fd092e3ae3a9ad2c18b8180">More...</a><br /></td></tr>
<tr class="separator:aa6fed50d9fd092e3ae3a9ad2c18b8180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0beda1c8332e1f2785303fd21b15918"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#af0beda1c8332e1f2785303fd21b15918">setStartingRecordNumber</a> (uint32_t startingRecordNumber)</td></tr>
<tr class="memdesc:af0beda1c8332e1f2785303fd21b15918"><td class="mdescLeft">&#160;</td><td class="mdescRight">&zwj;**  <a href="../../d9/dcd/classevio_1_1_event_writer.html#af0beda1c8332e1f2785303fd21b15918">More...</a><br /></td></tr>
<tr class="separator:af0beda1c8332e1f2785303fd21b15918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a40dc76bca3e2eff745130bc27fea1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a17a40dc76bca3e2eff745130bc27fea1">setFirstEvent</a> (std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; &amp;node)</td></tr>
<tr class="memdesc:a17a40dc76bca3e2eff745130bc27fea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an event which will be written to the file as well as to all split files.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a17a40dc76bca3e2eff745130bc27fea1">More...</a><br /></td></tr>
<tr class="separator:a17a40dc76bca3e2eff745130bc27fea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820160c1cd81b96cb9ea01d1d9f0771d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a820160c1cd81b96cb9ea01d1d9f0771d">setFirstEvent</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buf)</td></tr>
<tr class="memdesc:a820160c1cd81b96cb9ea01d1d9f0771d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an event which will be written to the file as well as to all split files.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a820160c1cd81b96cb9ea01d1d9f0771d">More...</a><br /></td></tr>
<tr class="separator:a820160c1cd81b96cb9ea01d1d9f0771d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e10cb04c9523dba4030e1e9be6f22ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a6e10cb04c9523dba4030e1e9be6f22ef">setFirstEvent</a> (std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt; bank)</td></tr>
<tr class="memdesc:a6e10cb04c9523dba4030e1e9be6f22ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an event which will be written to the file as well as to all split files.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a6e10cb04c9523dba4030e1e9be6f22ef">More...</a><br /></td></tr>
<tr class="separator:a6e10cb04c9523dba4030e1e9be6f22ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cb01e88b8e2f2e4346eb3b93b58071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a38cb01e88b8e2f2e4346eb3b93b58071">flush</a> ()</td></tr>
<tr class="memdesc:a38cb01e88b8e2f2e4346eb3b93b58071"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method flushes any remaining internally buffered data to file.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a38cb01e88b8e2f2e4346eb3b93b58071">More...</a><br /></td></tr>
<tr class="separator:a38cb01e88b8e2f2e4346eb3b93b58071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2687708de5933b1b9aecb2930706ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed">close</a> ()</td></tr>
<tr class="memdesc:a1f2687708de5933b1b9aecb2930706ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method flushes any remaining data to file and disables this object.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed">More...</a><br /></td></tr>
<tr class="separator:a1f2687708de5933b1b9aecb2930706ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a3edcbf2d5e3005ecb0cec061dfbaf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a91a3edcbf2d5e3005ecb0cec061dfbaf">hasRoom</a> (uint32_t bytes)</td></tr>
<tr class="memdesc:a91a3edcbf2d5e3005ecb0cec061dfbaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is there room to write this many bytes to an output buffer as a single event? Will always return true when writing to a file.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a91a3edcbf2d5e3005ecb0cec061dfbaf">More...</a><br /></td></tr>
<tr class="separator:a91a3edcbf2d5e3005ecb0cec061dfbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bf54cb6551a7e6d151741bcc798d3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a34bf54cb6551a7e6d151741bcc798d3a">writeEvent</a> (std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; &amp;node, bool force)</td></tr>
<tr class="memdesc:a34bf54cb6551a7e6d151741bcc798d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an event (bank) into a record in evio/hipo version 6 format.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a34bf54cb6551a7e6d151741bcc798d3a">More...</a><br /></td></tr>
<tr class="separator:a34bf54cb6551a7e6d151741bcc798d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945805c4c7a8697b5f98089a2c6a4f06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a945805c4c7a8697b5f98089a2c6a4f06">writeEvent</a> (std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; &amp;node, bool force, bool duplicate)</td></tr>
<tr class="memdesc:a945805c4c7a8697b5f98089a2c6a4f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an event (bank) into a record in evio/hipo version 6 format.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a945805c4c7a8697b5f98089a2c6a4f06">More...</a><br /></td></tr>
<tr class="separator:a945805c4c7a8697b5f98089a2c6a4f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c347265d6480cd5e6c85d873d6399f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a6c347265d6480cd5e6c85d873d6399f4">writeEventToFile</a> (std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; &amp;node, bool force, bool duplicate)</td></tr>
<tr class="memdesc:a6c347265d6480cd5e6c85d873d6399f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an event (bank) into a record and eventually to a file in evio/hipo version 6 format.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a6c347265d6480cd5e6c85d873d6399f4">More...</a><br /></td></tr>
<tr class="separator:a6c347265d6480cd5e6c85d873d6399f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2483d8fe62cca4b1684b624ed85cc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a7e2483d8fe62cca4b1684b624ed85cc7">writeEvent</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;bankBuffer)</td></tr>
<tr class="memdesc:a7e2483d8fe62cca4b1684b624ed85cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an event (bank) into a record in evio/hipo version 6 format.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a7e2483d8fe62cca4b1684b624ed85cc7">More...</a><br /></td></tr>
<tr class="separator:a7e2483d8fe62cca4b1684b624ed85cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd737141e74b419863aab6900fa2eea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1dd737141e74b419863aab6900fa2eea">writeEvent</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;bankBuffer, bool force)</td></tr>
<tr class="memdesc:a1dd737141e74b419863aab6900fa2eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an event (bank) into a record in evio/hipo version 6 format.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a1dd737141e74b419863aab6900fa2eea">More...</a><br /></td></tr>
<tr class="separator:a1dd737141e74b419863aab6900fa2eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4354616f2b2ad92ce267249f48c64d51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a4354616f2b2ad92ce267249f48c64d51">writeEvent</a> (std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt; bank)</td></tr>
<tr class="memdesc:a4354616f2b2ad92ce267249f48c64d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an event (bank) into a record in evio/hipo version 6 format.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a4354616f2b2ad92ce267249f48c64d51">More...</a><br /></td></tr>
<tr class="separator:a4354616f2b2ad92ce267249f48c64d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9360732276d183390766275326cf1900"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a9360732276d183390766275326cf1900">writeEvent</a> (std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt; bank, bool force)</td></tr>
<tr class="memdesc:a9360732276d183390766275326cf1900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an event (bank) into a record in evio/hipo version 6 format.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#a9360732276d183390766275326cf1900">More...</a><br /></td></tr>
<tr class="separator:a9360732276d183390766275326cf1900"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae7a045426957215f5336f040a9d77f01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#ae7a045426957215f5336f040a9d77f01">examineFileHeader</a> ()</td></tr>
<tr class="memdesc:ae7a045426957215f5336f040a9d77f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads part of the file header in order to determine the evio version # and endianness of the file in question.  <a href="../../d9/dcd/classevio_1_1_event_writer.html#ae7a045426957215f5336f040a9d77f01">More...</a><br /></td></tr>
<tr class="separator:ae7a045426957215f5336f040a9d77f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a> object is used for writing events to a file or to a byte buffer. </p>
<p>This class does NOT write versions 1-4 data, only version 6! This class is not thread-safe.</p>
<pre></pre><pre>           FILE Uncompressed</pre><pre>   +----------------------------------+
   +                                  +
   +      General File Header         +
   +                                  +
   +----------------------------------+
   +----------------------------------+
   +                                  +
   +     Index Array (optional)       +
   +                                  +
   +----------------------------------+
   +----------------------------------+
   +      User Header (optional)      +
   +        --------------------------+
   +       |        Padding           +
   +----------------------------------+
   +----------------------------------+
   +                                  +
   +          Data Record 1           +
   +                                  +
   +----------------------------------+<ul>
<li><ul>
<li></li>
<li>+----------------------------------+
   +                                  +
   +          Data Record N           +
   +                                  +
   +----------------------------------+</li>
</ul>
</li>
</ul>
</pre><pre>=============================================
=============================================</pre><pre>             FILE Compressed</pre><pre>   +----------------------------------+
   +                                  +
   +      General File Header         +
   +                                  +
   +----------------------------------+
   +----------------------------------+
   +                                  +
   +     Index Array (optional)       +
   +                                  +
   +----------------------------------+
   +----------------------------------+
   +      User Header (optional)      +
   +        --------------------------+
   +       |         Padding          +
   +----------------------------------+
   +----------------------------------+
   +           Compressed             +
   +          Data Record 1           +
   +                                  +
   +----------------------------------+<ul>
<li><ul>
<li></li>
<li>+----------------------------------+
   +           Compressed             +
   +          Data Record N           +
   +                                  +
   +----------------------------------+</li>
</ul>
<p class="startli">The User Header contains a data record which
   holds the dictionary and first event, if any.
   The general file header, index array, and
   user header are never compressed.</p>
<p class="startli">Writing a buffer is done without the general file header
   and the index array and user header which follow.</p>
</li>
</ul>
</pre><pre></pre><dl class="section date"><dt>Date</dt><dd>01/21/2020 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>timmer </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a17225fd6d6a7fdfa9d20a75966f5c11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17225fd6d6a7fdfa9d20a75966f5c11a">&#9670;&nbsp;</a></span>EventWriter() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">evio::EventWriter::EventWriter </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>byteOrder</em> = <code><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#aa96046df3a55b85a31f2c33e4d903cf1">ByteOrder::nativeOrder</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>append</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <code><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a></code> for writing to a file in the specified byte order. </p>
<p>If the file already exists, its contents will be overwritten unless it is being appended to. If it doesn't exist, it will be created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>name of the file to write to.<br  />
 </td></tr>
    <tr><td class="paramname">byteOrder</td><td>the byte order in which to write the file. </td></tr>
    <tr><td class="paramname">append</td><td>if <code>true</code> and the file already exists, all events to be written will be appended to the end of the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>file cannot be created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92be16234de2fd45d4c19a710fdac9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92be16234de2fd45d4c19a710fdac9be">&#9670;&nbsp;</a></span>EventWriter() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">evio::EventWriter::EventWriter </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>dictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>byteOrder</em> = <code><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#aa96046df3a55b85a31f2c33e4d903cf1">ByteOrder::nativeOrder</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>append</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an <code><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a></code> for writing to a file in NATIVE byte order. </p>
<p>If the file already exists, its contents will be overwritten unless it is being appended to. If it doesn't exist, it will be created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the file object to write to.<br  />
 </td></tr>
    <tr><td class="paramname">dictionary</td><td>dictionary in xml format or null if none. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>the byte order in which to write the file. </td></tr>
    <tr><td class="paramname">append</td><td>if <code>true</code> and the file already exists, all events to be written will be appended to the end of the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>file cannot be created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5271d9b38e1e974be98f3ff98d5ed602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5271d9b38e1e974be98f3ff98d5ed602">&#9670;&nbsp;</a></span>EventWriter() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">evio::EventWriter::EventWriter </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>runType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>runNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxRecordSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxEventCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>byteOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xmlDictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overWriteOK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>append</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt;&#160;</td>
          <td class="paramname"><em>firstEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>splitNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>splitIncrement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>streamCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747">Compressor::CompressionType</a>&#160;</td>
          <td class="paramname"><em>compressionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>compressionThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ringSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <code><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a></code> for writing events to a file. </p>
<p>If the file already exists, its contents will be overwritten unless the "overWriteOK" argument is <code>false</code> in which case an exception will be thrown. Unless ..., the option to append these events to an existing file is <code>true</code>, in which case everything is fine. If the file doesn't exist, it will be created. Byte order defaults to big endian if arg is null. File can be split while writing.</p>
<p>The base file name may contain up to 2, C-style integer format specifiers using "d" and "x" (such as <b>%03d</b>, or <b>x</b>). If more than 2 are found, an exception will be thrown. If no "0" precedes any integer between the "%" and the "d" or "x" of the format specifier, it will be added automatically in order to avoid spaces in the file name. The first specifier will be substituted with the given runNumber value. If the file is being split, the second will be substituted with the split number which starts at 0. If 2 specifiers exist and the file is not being split, no substitutions are made. If no specifier for the splitNumber exists, it is tacked onto the end of the file name after a dot (.). If streamCount &gt; 1, the split number is calculated starting with streamId and incremented by streamCount each time. In this manner, all split files will have unique, sequential names even though there are multiple parallel ERs. </p>
<p>The base file name may contain characters of the form <b></b> which will be substituted with the value of the associated environmental variable or a blank string if none is found.</p>
<p>The base file name may also contain occurrences of the string "%s" which will be substituted with the value of the runType arg or nothing if the runType is null.</p>
<p>If multiple streams of data, each writing a file, end up with the same file name, they can be difcompressionferentiated by a stream id, starting split # and split increment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseName</td><td>base file name used to generate complete file name (may not be null) </td></tr>
    <tr><td class="paramname">directory</td><td>directory in which file is to be placed </td></tr>
    <tr><td class="paramname">runType</td><td>name of run type configuration to be used in naming files </td></tr>
    <tr><td class="paramname">runNumber</td><td>number of the CODA run, used in naming files </td></tr>
    <tr><td class="paramname">split</td><td>if &lt; 1, do not split file, write to only one file of unlimited size. Else this is max size in bytes to make a file before closing it and starting writing another. </td></tr>
    <tr><td class="paramname">maxRecordSize</td><td>max number of uncompressed data bytes each record can hold. Value of &lt; 8MB results in default of 8MB. The size of the record will not be larger than this size unless a single event itself is larger. </td></tr>
    <tr><td class="paramname">maxEventCount</td><td>max number of events each record can hold. Value &lt;= O means use default (1M). </td></tr>
    <tr><td class="paramname">byteOrder</td><td>the byte order in which to write the file. This is ignored if appending to existing file. Defaults to Big Endian if null. </td></tr>
    <tr><td class="paramname">xmlDictionary</td><td>dictionary in xml format or null if none. </td></tr>
    <tr><td class="paramname">overWriteOK</td><td>if <code>false</code> and the file already exists, an exception is thrown rather than overwriting it. </td></tr>
    <tr><td class="paramname">append</td><td>if <code>true</code> append written data to given file. </td></tr>
    <tr><td class="paramname">firstEvent</td><td>the first event written into each file (after any dictionary) including all split files; may be null. Useful for adding common, static info into each split file. </td></tr>
    <tr><td class="paramname">streamId</td><td>streamId number (100 &gt; id &gt; -1) for file name </td></tr>
    <tr><td class="paramname">splitNumber</td><td>number at which to start the split numbers </td></tr>
    <tr><td class="paramname">splitIncrement</td><td>amount to increment split number each time another file is created. </td></tr>
    <tr><td class="paramname">streamCount</td><td>total number of streams in DAQ. </td></tr>
    <tr><td class="paramname">compressionType</td><td>type of data compression to do (0=none, 1=lz4 fast, 2=lz4 best, 3=gzip). </td></tr>
    <tr><td class="paramname">compressionThreads</td><td>number of threads doing compression simultaneously. </td></tr>
    <tr><td class="paramname">ringSize</td><td>number of records in supply ring. If set to &lt; compressionThreads, it is forced to equal that value and is also forced to be a multiple of 2, rounded up. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>number of bytes to make each internal buffer which will be storing events before writing them to a file. 9MB = default if bufferSize = 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if maxRecordSize or maxEventCount exceed limits; if streamCount &gt; 1 and streamId &lt; 0; if defined dictionary or first event while appending; if splitting file while appending; if file name arg is null; if file could not be opened, positioned, or written to; if file exists but user requested no over-writing or appending; if streamId &lt; 0, splitNumber &lt; 0, or splitIncrement &lt; 1. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../df/dd8/classevio_1_1_header_type.html#a2b01085c1ea7b23010e4cb4447f2d04a">evio::HeaderType::EVIO_RECORD</a>, <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#ae7a045426957215f5336f040a9d77f01">examineFileHeader()</a>, <a class="el" href="../../d3/d87/classevio_1_1_util.html#a542fb63b5849885087ac24795604b4b6">evio::Util::generateBaseFileName()</a>, <a class="el" href="../../d3/d87/classevio_1_1_util.html#a76482198f230e3afadbb65d1e6feedd9">evio::Util::generateFileName()</a>, <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747a4fd632e8126f17acee8a305f25885bb1">evio::Compressor::GZIP</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a0e09d731589bcfe2705d0c606192f6eb">evio::RecordHeader::HEADER_SIZE_BYTES</a>, <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747ae7be56dd20228ef22b2c4f79d0a491ae">evio::Compressor::LZ4</a>, <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747a4e6c89e2c89beb57840a5b0bdb2c539d">evio::Compressor::LZ4_BEST</a>, <a class="el" href="../../d3/d87/classevio_1_1_util.html#aecf01b40cf83fcdd27115f66b67e848c">evio::Util::powerOfTwo()</a>, and <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747a056585718cbf5c7808c0e37b1f88dbb9">evio::Compressor::UNCOMPRESSED</a>.</p>

</div>
</div>
<a id="a93b4acef57cfd15dcc5844c385824c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b4acef57cfd15dcc5844c385824c90">&#9670;&nbsp;</a></span>EventWriter() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">evio::EventWriter::EventWriter </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <code><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a></code> for writing events to a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a>. </p>
<p>Uses the default number and size of records in buffer. Will overwrite any existing data in buffer!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer to write to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if buf arg is null </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66db745e2ef5e1fcca14eae4683dc160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66db745e2ef5e1fcca14eae4683dc160">&#9670;&nbsp;</a></span>EventWriter() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">evio::EventWriter::EventWriter </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>xmlDictionary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <code><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a></code> for writing events to a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a>. </p>
<p>Uses the default number and size of records in buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer to write to. </td></tr>
    <tr><td class="paramname">xmlDictionary</td><td>dictionary in xml format or null if none. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if buf arg is null </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a4c374c6cf244dfd6f777917b7c7ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4c374c6cf244dfd6f777917b7c7ea3">&#9670;&nbsp;</a></span>EventWriter() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">evio::EventWriter::EventWriter </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxRecordSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxEventCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xmlDictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>recordNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>firstEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747">Compressor::CompressionType</a>&#160;</td>
          <td class="paramname"><em>compressionType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <code><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a></code> for writing events to a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a>. </p>
<p>The buffer's position is set to 0 before writing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer to write to starting at position = 0. </td></tr>
    <tr><td class="paramname">maxRecordSize</td><td>max number of data bytes each record can hold. Value of &lt; 8MB results in default of 8MB. The size of the record will not be larger than this size unless a single event itself is larger. </td></tr>
    <tr><td class="paramname">maxEventCount</td><td>max number of events each record can hold. Value &lt;= O means use default (1M). </td></tr>
    <tr><td class="paramname">xmlDictionary</td><td>dictionary in xml format or null if none. </td></tr>
    <tr><td class="paramname">recordNumber</td><td>number at which to start record number counting. </td></tr>
    <tr><td class="paramname">firstEvent</td><td>the first event written into the buffer (after any dictionary). May be null. Not useful when writing to a buffer as this event may be written using normal means. </td></tr>
    <tr><td class="paramname">compressionType</td><td>type of data compression to do (0=none, 1=lz4 fast, 2=lz4 best, 3=gzip)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if maxRecordSize or maxEventCount exceed limits; </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../df/dd8/classevio_1_1_header_type.html#a2b01085c1ea7b23010e4cb4447f2d04a">evio::HeaderType::EVIO_RECORD</a>, <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747a4fd632e8126f17acee8a305f25885bb1">evio::Compressor::GZIP</a>, <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a0e09d731589bcfe2705d0c606192f6eb">evio::RecordHeader::HEADER_SIZE_BYTES</a>, <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747ae7be56dd20228ef22b2c4f79d0a491ae">evio::Compressor::LZ4</a>, <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747a4e6c89e2c89beb57840a5b0bdb2c539d">evio::Compressor::LZ4_BEST</a>, and <a class="el" href="../../da/d08/classevio_1_1_compressor.html#aed2330d08ee8c96b2690fec7f9a68747a056585718cbf5c7808c0e37b1f88dbb9">evio::Compressor::UNCOMPRESSED</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1f2687708de5933b1b9aecb2930706ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2687708de5933b1b9aecb2930706ed">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EventWriter::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method flushes any remaining data to file and disables this object. </p>
<p>May not call this when simultaneously calling writeEvent, flush, setFirstEvent, or getByteBuffer. </p>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#aa0e335238a57eaa0bffee8f968e5995f">evio::ByteBuffer::array()</a>, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a3d5f0120189717ffc8d2d480d89cb91a">evio::ByteBuffer::order()</a>, and <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a8bc5745c6525ec0e5bfaee09db9b5c60">evio::ByteBuffer::putInt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/d06/classevio_1_1_event_builder.html#ad11bd244d4bc1fef7cc84e0de74af323">evio::EventBuilder::main()</a>.</p>

</div>
</div>
<a id="ae7a045426957215f5336f040a9d77f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a045426957215f5336f040a9d77f01">&#9670;&nbsp;</a></span>examineFileHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EventWriter::examineFileHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads part of the file header in order to determine the evio version # and endianness of the file in question. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>not in append mode, contains too little data, is not in proper format, version earlier than 6, premature EOF or file reading error, and all other exceptions. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html#a88f84e6b1757db70542eac13294fc80e">evio::ByteBuffer::position()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a5271d9b38e1e974be98f3ff98d5ed602">EventWriter()</a>.</p>

</div>
</div>
<a id="a38cb01e88b8e2f2e4346eb3b93b58071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38cb01e88b8e2f2e4346eb3b93b58071">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EventWriter::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method flushes any remaining internally buffered data to file. </p>
<p>Calling <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed">close()</a> automatically does this so it isn't necessary to call before closing. This method should only be used when writing events at such a low rate that it takes an inordinate amount of time for internally buffered data to be written to the file.</p>
<p>Calling this may easily kill performance. May not call this when simultaneously calling writeEvent, close, setFirstEvent, or getByteBuffer. </p>

</div>
</div>
<a id="ab9f560ab96c146e6a3c288d202cadb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f560ab96c146e6a3c288d202cadb1e">&#9670;&nbsp;</a></span>getByteBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; evio::EventWriter::getByteBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If writing to a file, return null. </p>
<p>If writing to a buffer, get a duplicate of the user-given buffer being written into. The buffer's position will be 0 and its limit will be the size of the valid data. Basically, it's ready to be read from. The returned buffer shares data with the original buffer but has separate limit, position, and mark. Useful if trying to send buffer over the network. Do not call this while simultaneously calling close, flush, setFirstEvent, or writeEvent.</p>
<dl class="section return"><dt>Returns</dt><dd>buffer being written into, made ready for reading; null if writing to file </dd></dl>

</div>
</div>
<a id="aa6fed50d9fd092e3ae3a9ad2c18b8180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6fed50d9fd092e3ae3a9ad2c18b8180">&#9670;&nbsp;</a></span>getByteOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> EventWriter::getByteOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the byte order of the buffer/file being written into. </p>
<dl class="section return"><dt>Returns</dt><dd>byte order of the buffer/file being written into. </dd></dl>

</div>
</div>
<a id="a2456f9ee73604178342bb55792df85c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2456f9ee73604178342bb55792df85c5">&#9670;&nbsp;</a></span>getBytesWrittenToBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t evio::EventWriter::getBytesWrittenToBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If writing to a buffer, get the number of bytes written to it including the trailer. </p>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to buffer </dd></dl>

</div>
</div>
<a id="a869c87c1e922b6e7cf509e7bd4e92c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869c87c1e922b6e7cf509e7bd4e92c68">&#9670;&nbsp;</a></span>getCurrentFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string evio::EventWriter::getCurrentFilename </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the current file being written to. </p>
<p>Returns empty string if no file. </p><dl class="section return"><dt>Returns</dt><dd>the name of the current file being written to. </dd></dl>

</div>
</div>
<a id="aea264cc1787db07728ed795858c04c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea264cc1787db07728ed795858c04c7a">&#9670;&nbsp;</a></span>getCurrentFilePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string evio::EventWriter::getCurrentFilePath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the full name or path of the current file being written to. </p>
<p>Returns empty string if no file. </p><dl class="section return"><dt>Returns</dt><dd>the full name or path of the current file being written to. </dd></dl>

</div>
</div>
<a id="a318697a18126aaf937a97f9bae3939f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318697a18126aaf937a97f9bae3939f7">&#9670;&nbsp;</a></span>getEventsWritten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t EventWriter::getEventsWritten </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of events written to a file/buffer. </p>
<p>Remember that a particular event may not yet be flushed to the file/buffer. If the file being written to is split, the returned value refers to all split files taken together.</p>
<dl class="section return"><dt>Returns</dt><dd>number of events written to a file/buffer. </dd></dl>

</div>
</div>
<a id="a498ee5a0039c4265741917390b0a380e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498ee5a0039c4265741917390b0a380e">&#9670;&nbsp;</a></span>getRecordNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t EventWriter::getRecordNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current record number. </p>
<p>Warning, this value may be changing. </p><dl class="section return"><dt>Returns</dt><dd>the current record number. </dd></dl>

</div>
</div>
<a id="afb4093dbd44f2773872fce88855c9357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4093dbd44f2773872fce88855c9357">&#9670;&nbsp;</a></span>getSplitCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t EventWriter::getSplitCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of split files produced by this writer. </p>
<dl class="section return"><dt>Returns</dt><dd>number of split files produced by this writer. </dd></dl>

</div>
</div>
<a id="ae21d6b4fa57b43b338dab195a6c2be1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21d6b4fa57b43b338dab195a6c2be1c">&#9670;&nbsp;</a></span>getSplitNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t EventWriter::getSplitNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current split number which is the split number of file to be written next. </p>
<p>Warning, this value may be changing. </p><dl class="section return"><dt>Returns</dt><dd>the current split number which is the split number of file to be written next. </dd></dl>

</div>
</div>
<a id="a91a3edcbf2d5e3005ecb0cec061dfbaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a3edcbf2d5e3005ecb0cec061dfbaf">&#9670;&nbsp;</a></span>hasRoom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EventWriter::hasRoom </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is there room to write this many bytes to an output buffer as a single event? Will always return true when writing to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>number of bytes to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><div class="fragment"><div class="line"><span class="keyword">true</span> </div>
</div><!-- fragment --> if there still room in the output buffer, else<div class="fragment"><div class="line"><span class="keyword">false</span> </div>
</div><!-- fragment --> . </dd></dl>

</div>
</div>
<a id="aa82458e15e94f88450f061de51d1d3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82458e15e94f88450f061de51d1d3e8">&#9670;&nbsp;</a></span>isClosed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::EventWriter::isClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Has <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed">close()</a> been called (without reopening by calling <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a8d3e5edb367a7ca355e0f0e936db44b6">setBuffer()</a>) ? </p>
<dl class="section return"><dt>Returns</dt><dd><div class="fragment"><div class="line"><span class="keyword">true</span> </div>
</div><!-- fragment --> if this object closed, else<div class="fragment"><div class="line"><span class="keyword">false</span> </div>
</div><!-- fragment --> . </dd></dl>

</div>
</div>
<a id="a74140e35e3c934cf63e095d4d2ac73f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74140e35e3c934cf63e095d4d2ac73f5">&#9670;&nbsp;</a></span>isDiskFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::EventWriter::isDiskFull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If writing file, is the partition it resides on full? Not full, in this context, means there's enough space to write a full split file + a full record + an extra 10MB as a safety factor. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the partition the file resides on is full, else false. </dd></dl>

</div>
</div>
<a id="a59c84d3cc0d530dcafeb325d3fd78a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c84d3cc0d530dcafeb325d3fd78a79">&#9670;&nbsp;</a></span>setBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::EventWriter::setBuffer </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the buffer being written into (initially set in constructor). </p>
<p>This method allows the user to avoid having to create a new <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a> each time a bank needs to be written to a different buffer. This does nothing if writing to a file.</p>
<p>Do <b>not</b> use this method unless you know what you are doing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer to write to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if this object was not closed prior to resetting the buffer, buffer arg is null, or writing to file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d3e5edb367a7ca355e0f0e936db44b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3e5edb367a7ca355e0f0e936db44b6">&#9670;&nbsp;</a></span>setBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::EventWriter::setBuffer </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::bitset&lt; 24 &gt; *&#160;</td>
          <td class="paramname"><em>bitInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>recNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the buffer being written into (initially set in constructor). </p>
<p>This method allows the user to avoid having to create a new <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a> each time a bank needs to be written to a different buffer. This does nothing if writing to a file.</p>
<p>Do <b>not</b> use this method unless you know what you are doing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer to write to. </td></tr>
    <tr><td class="paramname">bitInfo</td><td>set of bits to include in first record header. </td></tr>
    <tr><td class="paramname">recNumber</td><td>number at which to start record number counting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if this object was not closed prior to resetting the buffer, buffer arg is null, or writing to file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5177b190e06a2b28fd62136f4b4eb0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5177b190e06a2b28fd62136f4b4eb0a2">&#9670;&nbsp;</a></span>setEventType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::EventWriter::setEventType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the bit info of a record header for a specified CODA event type. </p>
<p>Must be called AFTER <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#a3f77e14621f9abcb226b48a1939cb8c5">RecordHeader#setBitInfo(bool, bool, bool)</a> or <a class="el" href="../../d8/d64/classevio_1_1_record_header.html#acbd14b3e5c1cd26c7b5d8a734aca59b5">RecordHeader#setBitInfoWord(uint32_t)</a> in order to have change preserved. This should only be used internally by CODA in emu software.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>event type (0=ROC raw, 1=Physics, 2=Partial Physics, 3=Disentangled, 4=User, 5=Control, 15=Other, else = nothing set). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a820160c1cd81b96cb9ea01d1d9f0771d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820160c1cd81b96cb9ea01d1d9f0771d">&#9670;&nbsp;</a></span>setFirstEvent() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EventWriter::setFirstEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an event which will be written to the file as well as to all split files. </p>
<p>It's called the "first event" as it will be the first event written to each split file if this method is called early enough or the first event was defined in the constructor. In evio version 6, any dictionary and the first event are written to a common record which is stored in the user-header part of the file header if writing to a file. When writing to a buffer it's stored in the first record's user-header. The common record data is never compressed.</p>
<p><b>FILE:</b> Since this method can only be called after the constructor, the common record may have already been written with its dictionary and possibly another firstEvent. If that is the case, the event given here will be written immediately somewhere in the body of the file. Any subsequent splits will have this event as the first event in the file header. On the other hand, if the common record has not yet been written to the file, this event becomes the first event in the file header.</p>
<p><b>BUFFER:</b> By its nature this method is not all that useful for writing to a buffer since the buffer is never split. Writing this event is done by storing the common record in the main record's user-header. When writing to a buffer, the common record is not written until main buffer is full and flushCurrentRecordToBuffer() is called. That is not done until <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed" title="This method flushes any remaining data to file and disables this object.">close()</a> or <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a38cb01e88b8e2f2e4346eb3b93b58071" title="This method flushes any remaining internally buffered data to file.">flush()</a> is called. In other words, there is still time to change the common record up until close is called.</p>
<p>Do not call this while simultaneously calling close, flush, writeEvent, or getByteBuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer containing event to be placed first in each file written including all splits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if error writing to file if first event is opposite byte order of internal buffer; if bad data format; if <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed" title="This method flushes any remaining data to file and disables this object.">close()</a> already called; if file could not be opened for writing; if file exists but user requested no over-writing; if no room when writing to user-given buffer; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e10cb04c9523dba4030e1e9be6f22ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e10cb04c9523dba4030e1e9be6f22ef">&#9670;&nbsp;</a></span>setFirstEvent() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EventWriter::setFirstEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt;&#160;</td>
          <td class="paramname"><em>bank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an event which will be written to the file as well as to all split files. </p>
<p>It's called the "first event" as it will be the first event written to each split file if this method is called early enough or the first event was defined in the constructor. In evio version 6, any dictionary and the first event are written to a common record which is stored in the user-header part of the file header if writing to a file. When writing to a buffer it's stored in the first record's user-header. The common record data is never compressed.</p>
<p><b>FILE:</b> Since this method can only be called after the constructor, the common record may have already been written with its dictionary and possibly another firstEvent. If that is the case, the event given here will be written immediately somewhere in the body of the file. Any subsequent splits will have this event as the first event in the file header. On the other hand, if the common record has not yet been written to the file, this event becomes the first event in the file header.</p>
<p><b>BUFFER:</b> By its nature this method is not all that useful for writing to a buffer since the buffer is never split. Writing this event is done by storing the common record in the main record's user-header. When writing to a buffer, the common record is not written until main buffer is full and flushCurrentRecordToBuffer() is called. That is not done until <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed" title="This method flushes any remaining data to file and disables this object.">close()</a> or <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a38cb01e88b8e2f2e4346eb3b93b58071" title="This method flushes any remaining internally buffered data to file.">flush()</a> is called. In other words, there is still time to change the common record up until close is called.</p>
<p>Do not call this while simultaneously calling close, flush, writeEvent, or getByteBuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>event to be placed first in each file written including all splits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if error writing to file if first event is opposite byte order of internal buffer; if bad data format; if <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed" title="This method flushes any remaining data to file and disables this object.">close()</a> already called; if file could not be opened for writing; if file exists but user requested no over-writing; if no room when writing to user-given buffer; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17a40dc76bca3e2eff745130bc27fea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a40dc76bca3e2eff745130bc27fea1">&#9670;&nbsp;</a></span>setFirstEvent() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EventWriter::setFirstEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an event which will be written to the file as well as to all split files. </p>
<p>It's called the "first event" as it will be the first event written to each split file if this method is called early enough or the first event was defined in the constructor. In evio version 6, any dictionary and the first event are written to a common record which is stored in the user-header part of the file header if writing to a file. When writing to a buffer it's stored in the first record's user-header. The common record data is never compressed.</p>
<p><b>FILE:</b> Since this method can only be called after the constructor, the common record may have already been written with its dictionary and possibly another firstEvent. If that is the case, the event given here will be written immediately somewhere in the body of the file. Any subsequent splits will have this event as the first event in the file header. On the other hand, if the common record has not yet been written to the file, this event becomes the first event in the file header.</p>
<p><b>BUFFER:</b> By its nature this method is not all that useful for writing to a buffer since the buffer is never split. Writing this event is done by storing the common record in the main record's user-header. When writing to a buffer, the common record is not written until main buffer is full and flushCurrentRecordToBuffer() is called. That is not done until <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed" title="This method flushes any remaining data to file and disables this object.">close()</a> or <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a38cb01e88b8e2f2e4346eb3b93b58071" title="This method flushes any remaining internally buffered data to file.">flush()</a> is called. In other words, there is still time to change the common record up until close is called.</p>
<p>Do not call this while simultaneously calling close, flush, writeEvent, or getByteBuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>node representing event to be placed first in each file written including all splits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if error writing to file if first event is opposite byte order of internal buffer; if bad data format; if <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed" title="This method flushes any remaining data to file and disables this object.">close()</a> already called; if file could not be opened for writing; if file exists but user requested no over-writing; if no room when writing to user-given buffer; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4b8192088442c20102b758a10c7d45e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b8192088442c20102b758a10c7d45e">&#9670;&nbsp;</a></span>setSourceId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::EventWriter::setSourceId </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of the source Id in the first block header. </p>
<p>Only necessary to do this when using <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a> in EMU's RocSimulation module. Only the ROC sends sourceId in header. In evio 6, the source id is stored in user register 1. In earlier versions it's stored in reserved1. This should only be used internally by CODA in emu software.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sId</td><td>value of the source Id. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0beda1c8332e1f2785303fd21b15918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0beda1c8332e1f2785303fd21b15918">&#9670;&nbsp;</a></span>setStartingRecordNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EventWriter::setStartingRecordNumber </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startingRecordNumber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&zwj;** </p>
<p>Set the number with which to start record numbers. This method does nothing if events have already been written. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingRecordNumber</td><td>the number with which to start record numbers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e2483d8fe62cca4b1684b624ed85cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2483d8fe62cca4b1684b624ed85cc7">&#9670;&nbsp;</a></span>writeEvent() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EventWriter::writeEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bankBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an event (bank) into a record in evio/hipo version 6 format. </p>
<p>Once the record is full and if writing to a file (for multiple compression threads), the record will be sent to a thread which may compress the data, then it will be sent to a thread to write the record to file. If there is only 1 compression thread, it's all done in the thread which call this method.</p>
<p>If writing to a buffer, once the record is full this method returns false - indicating that the last event was NOT written to the record. To finish the writing process, call <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed">close()</a>. This will compress the data if desired and then write it to the buffer.</p>
<p>The buffer must contain only the event's data (event header and event data) and must <b>not</b> be in complete evio file format. Do not call this while simultaneously calling close, flush, setFirstEvent, or getByteBuffer.</p>
<p>This method is not used to write the dictionary or the first event which are both placed in the common record which, in turn, is the user header part of the file header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bankBuffer</td><td>the bank (as a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> object) to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if writing to buffer: true if event was added to record, false if buffer full, or record event count limit exceeded.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if error writing file if event is opposite byte order of internal buffer; if <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed" title="This method flushes any remaining data to file and disables this object.">close()</a> already called; if bad eventBuffer format; if file could not be opened for writing; if file exists but user requested no over-writing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1dd737141e74b419863aab6900fa2eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd737141e74b419863aab6900fa2eea">&#9670;&nbsp;</a></span>writeEvent() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EventWriter::writeEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bankBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an event (bank) into a record in evio/hipo version 6 format. </p>
<p>Once the record is full and if writing to a file (for multiple compression threads), the record will be sent to a thread which may compress the data, then it will be sent to a thread to write the record to file. If there is only 1 compression thread, it's all done in the thread which call this method.</p>
<p>If writing to a buffer, once the record is full this method returns false - indicating that the last event was NOT written to the record. To finish the writing process, call <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed">close()</a>. This will compress the data if desired and then write it to the buffer.</p>
<p>The buffer must contain only the event's data (event header and event data) and must <b>not</b> be in complete evio file format. Do not call this while simultaneously calling close, flush, setFirstEvent, or getByteBuffer.</p>
<p>Be warned that injudicious use of a true 2nd arg, the force flag, will <b>kill</b> performance when writing to a file.</p>
<p>This method is not used to write the dictionary or the first event which are both placed in the common record which, in turn, is the user header part of the file header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bankBuffer</td><td>the bank (as a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> object) to write. </td></tr>
    <tr><td class="paramname">force</td><td>if writing to disk, force it to write event to the disk. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if writing to buffer: true if event was added to record, false if buffer full, or record event count limit exceeded.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if error writing file if event is opposite byte order of internal buffer; if <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed" title="This method flushes any remaining data to file and disables this object.">close()</a> already called; if bad eventBuffer format; if file could not be opened for writing; if file exists but user requested no over-writing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4354616f2b2ad92ce267249f48c64d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4354616f2b2ad92ce267249f48c64d51">&#9670;&nbsp;</a></span>writeEvent() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EventWriter::writeEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt;&#160;</td>
          <td class="paramname"><em>bank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an event (bank) into a record in evio/hipo version 6 format. </p>
<p>Once the record is full and if writing to a file (for multiple compression threads), the record will be sent to a thread which may compress the data, then it will be sent to a thread to write the record to file. If there is only 1 compression thread, it's all done in the thread which call this method.</p>
<p>If writing to a buffer, once the record is full this method returns false - indicating that the last event was NOT written to the record. To finish the writing process, call <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed">close()</a>. This will compress the data if desired and then write it to the buffer.</p>
<p>Do not call this while simultaneously calling close, flush, setFirstEvent, or getByteBuffer.</p>
<p>This method is not used to write the dictionary or the first event which are both placed in the common record which, in turn, is the user header part of the file header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>the bank to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if writing to buffer: true if event was added to record, false if buffer full, or record event count limit exceeded.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if error writing file if <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed" title="This method flushes any remaining data to file and disables this object.">close()</a> already called; if file could not be opened for writing; if file exists but user requested no over-writing;. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9360732276d183390766275326cf1900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9360732276d183390766275326cf1900">&#9670;&nbsp;</a></span>writeEvent() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EventWriter::writeEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt;&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an event (bank) into a record in evio/hipo version 6 format. </p>
<p>Once the record is full and if writing to a file (for multiple compression threads), the record will be sent to a thread which may compress the data, then it will be sent to a thread to write the record to file. If there is only 1 compression thread, it's all done in the thread which call this method.</p>
<p>If writing to a buffer, once the record is full this method returns false - indicating that the last event was NOT written to the record. To finish the writing process, call <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed">close()</a>. This will compress the data if desired and then write it to the buffer.</p>
<p>Do not call this while simultaneously calling close, flush, setFirstEvent, or getByteBuffer.</p>
<p>This method is not used to write the dictionary or the first event which are both placed in the common record which, in turn, is the user header part of the file header.</p>
<p>Be warned that injudicious use of the 2nd arg, the force flag, will <b>kill</b> performance when writing to a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>the bank to write. </td></tr>
    <tr><td class="paramname">force</td><td>if writing to disk, force it to write event to the disk. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if writing to buffer: true if event was added to record, false if buffer full, or record event count limit exceeded.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if error writing file if <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed" title="This method flushes any remaining data to file and disables this object.">close()</a> already called; if file could not be opened for writing; if file exists but user requested no over-writing;. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34bf54cb6551a7e6d151741bcc798d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34bf54cb6551a7e6d151741bcc798d3a">&#9670;&nbsp;</a></span>writeEvent() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EventWriter::writeEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an event (bank) into a record in evio/hipo version 6 format. </p>
<p>Once the record is full and if writing to a file (for multiple compression threads), the record will be sent to a thread which may compress the data, then it will be sent to a thread to write the record to file. If there is only 1 compression thread, it's all done in the thread which call this method.</p>
<p>If writing to a buffer, once the record is full this method returns false - indicating that the last event was NOT written to the record. To finish the writing process, call <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed">close()</a>. This will compress the data if desired and then write it to the buffer.</p>
<p>The buffer must contain only the event's data (event header and event data) and must <b>not</b> be in complete evio file format. Do not call this while simultaneously calling close, flush, setFirstEvent, or getByteBuffer.</p>
<p>Be warned that injudicious use of a true 2nd arg, the force flag, will <b>kill</b> performance when writing to a file.</p>
<p>This method is not used to write the dictionary or the first event which are both placed in the common record which, in turn, is the user header part of the file header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>object representing the event to write in buffer form </td></tr>
    <tr><td class="paramname">force</td><td>if writing to disk, force it to write event to the disk. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if writing to buffer: true if event was added to record, false if buffer full, or record event count limit exceeded.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if error writing file if event is opposite byte order of internal buffer; if <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed" title="This method flushes any remaining data to file and disables this object.">close()</a> already called; if bad eventBuffer format; if file could not be opened for writing; if file exists but user requested no over-writing; if null node arg; </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="../../db/d06/classevio_1_1_event_builder.html#ad11bd244d4bc1fef7cc84e0de74af323">evio::EventBuilder::main()</a>.</p>

</div>
</div>
<a id="a945805c4c7a8697b5f98089a2c6a4f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945805c4c7a8697b5f98089a2c6a4f06">&#9670;&nbsp;</a></span>writeEvent() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EventWriter::writeEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>duplicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an event (bank) into a record in evio/hipo version 6 format. </p>
<p>Once the record is full and if writing to a file (for multiple compression threads), the record will be sent to a thread which may compress the data, then it will be sent to a thread to write the record to file. If there is only 1 compression thread, it's all done in the thread which call this method.</p>
<p>If writing to a buffer, once the record is full this method returns false - indicating that the last event was NOT written to the record. To finish the writing process, call <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed">close()</a>. This will compress the data if desired and then write it to the buffer.</p>
<p>The buffer must contain only the event's data (event header and event data) and must <b>not</b> be in complete evio file format. Do not call this while simultaneously calling close, flush, setFirstEvent, or getByteBuffer.</p>
<p>Be warned that injudicious use of a true 2nd arg, the force flag, will <b>kill</b> performance when writing to a file. A true 3rd arg can be used when the backing buffer of the node is accessed by multiple threads simultaneously. This allows that buffer's limit and position to be changed without interfering with the other threads.</p>
<p>This method is not used to write the dictionary or the first event which are both placed in the common record which, in turn, is the user header part of the file header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>object representing the event to write in buffer form </td></tr>
    <tr><td class="paramname">force</td><td>if writing to disk, force it to write event to the disk. </td></tr>
    <tr><td class="paramname">duplicate</td><td>if true, duplicate node's buffer so its position and limit can be changed without issue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if writing to buffer: true if event was added to record, false if buffer full, or record event count limit exceeded.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if error writing file if event is opposite byte order of internal buffer; if <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed" title="This method flushes any remaining data to file and disables this object.">close()</a> already called; if bad eventBuffer format; if file could not be opened for writing; if file exists but user requested no over-writing; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c347265d6480cd5e6c85d873d6399f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c347265d6480cd5e6c85d873d6399f4">&#9670;&nbsp;</a></span>writeEventToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EventWriter::writeEventToFile </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>duplicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an event (bank) into a record and eventually to a file in evio/hipo version 6 format. </p>
<p>Once the record is full and if writing with multiple compression threads, the record will be sent to a thread which may compress the data, then it will be sent to a thread to write the record to file. If there is only 1 compression thread, it's all done in the thread which call this method.</p>
<p><b> If splitting files, this method returns false if disk partition is too full to write the complete, next split file. If force arg is true, write anyway. DO NOT mix calling this method with calling <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a34bf54cb6551a7e6d151741bcc798d3a">writeEvent()</a> (all variants). Results are unpredictable as it messes up the logic used to quit writing to full disk. </b></p>
<p>The buffer must contain only the event's data (event header and event data) and must <b>not</b> be in complete evio file format. Do not call this while simultaneously calling close, flush, setFirstEvent, or getByteBuffer.</p>
<p>Be warned that injudicious use of a true 2nd arg, the force flag, will <b>kill</b> performance when writing to a file. A true 3rd arg can be used when the backing buffer of the node is accessed by multiple threads simultaneously. This allows that buffer's limit and position to be changed without interfering with the other threads.</p>
<p>This method is not used to write the dictionary or the first event which are both placed in the common record which, in turn, is the user header part of the file header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>object representing the event to write in buffer form </td></tr>
    <tr><td class="paramname">force</td><td>if writing to disk, force it to write event to the disk. </td></tr>
    <tr><td class="paramname">duplicate</td><td>if true, duplicate node's buffer so its position and limit can be changed without issue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if event was added to record. If splitting files, false if disk partition too full to write the complete, next split file. False if interrupted. If force arg is true, write anyway.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if error writing file if event is opposite byte order of internal buffer; if <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html#a1f2687708de5933b1b9aecb2930706ed" title="This method flushes any remaining data to file and disables this object.">close()</a> already called; if bad eventBuffer format; if file could not be opened for writing; if file exists but user requested no over-writing; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9314950dbd90b4d776549376c56160ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9314950dbd90b4d776549376c56160ea">&#9670;&nbsp;</a></span>writingToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::EventWriter::writingToFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this object writing to file? </p>
<dl class="section return"><dt>Returns</dt><dd><div class="fragment"><div class="line"><span class="keyword">true</span> </div>
</div><!-- fragment --> if writing to file, else<div class="fragment"><div class="line"><span class="keyword">false</span> </div>
</div><!-- fragment --> . </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="../../d6/d12/_event_writer_8h.html">EventWriter.h</a></li>
<li><a class="el" href="../../db/dc8/_event_writer_8cpp.html">EventWriter.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d9/deb/namespaceevio.html">evio</a></li><li class="navelem"><a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html">EventWriter</a></li>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
