<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>evio: evio::CompositeData Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">evio
   &#160;<span id="projectnumber">6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d5/d4b/classevio_1_1_composite_data.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="../../d3/def/classevio_1_1_composite_data-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">evio::CompositeData Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>COMPOSITE DATA:  
 <a href="../../d5/d4b/classevio_1_1_composite_data.html#details">More...</a></p>

<p><code>#include &lt;CompositeData.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d19/classevio_1_1_composite_data_1_1_data.html">Data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to provide all data when constructing a <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> object.  <a href="../../d0/d19/classevio_1_1_composite_data_1_1_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d1c/classevio_1_1_composite_data_1_1_data_item.html">DataItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines an individual data item.  <a href="../../d2/d1c/classevio_1_1_composite_data_1_1_data_item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd7/unionevio_1_1_composite_data_1_1_single_member.html">SingleMember</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds a single, primitive type data item.  <a href="../../d3/dd7/unionevio_1_1_composite_data_1_1_single_member.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab2677724ff9e19b546303c46decde01c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#ab2677724ff9e19b546303c46decde01c">getPadding</a> () const</td></tr>
<tr class="memdesc:ab2677724ff9e19b546303c46decde01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data padding (0, 1, 2, or 3 bytes).  <a href="../../d5/d4b/classevio_1_1_composite_data.html#ab2677724ff9e19b546303c46decde01c">More...</a><br /></td></tr>
<tr class="separator:ab2677724ff9e19b546303c46decde01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad2a6deede81c1b8d233c4bf04a808a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#aaad2a6deede81c1b8d233c4bf04a808a">getFormat</a> () const</td></tr>
<tr class="memdesc:aaad2a6deede81c1b8d233c4bf04a808a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the format string.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#aaad2a6deede81c1b8d233c4bf04a808a">More...</a><br /></td></tr>
<tr class="separator:aaad2a6deede81c1b8d233c4bf04a808a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7b28094dd581a54f250532a35e3270"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a2f7b28094dd581a54f250532a35e3270">getByteOrder</a> () const</td></tr>
<tr class="memdesc:a2f7b28094dd581a54f250532a35e3270"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the raw data byte order.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a2f7b28094dd581a54f250532a35e3270">More...</a><br /></td></tr>
<tr class="separator:a2f7b28094dd581a54f250532a35e3270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21c4e2a371ea21a74395c12c94fe786"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#af21c4e2a371ea21a74395c12c94fe786">getRawBytes</a> ()</td></tr>
<tr class="memdesc:af21c4e2a371ea21a74395c12c94fe786"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets a vector of the raw byte representation of this object's data.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#af21c4e2a371ea21a74395c12c94fe786">More...</a><br /></td></tr>
<tr class="separator:af21c4e2a371ea21a74395c12c94fe786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc5af5e5da00d80d774a9fe479d8aa3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../d2/d1c/classevio_1_1_composite_data_1_1_data_item.html">DataItem</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a3fc5af5e5da00d80d774a9fe479d8aa3">getItems</a> ()</td></tr>
<tr class="memdesc:a3fc5af5e5da00d80d774a9fe479d8aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets a vector of all the data items inside the composite.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a3fc5af5e5da00d80d774a9fe479d8aa3">More...</a><br /></td></tr>
<tr class="separator:a3fc5af5e5da00d80d774a9fe479d8aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99dfb9bb23c3510e505873be50405c74"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../d5/d23/classevio_1_1_data_type.html">DataType</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a99dfb9bb23c3510e505873be50405c74">getTypes</a> ()</td></tr>
<tr class="memdesc:a99dfb9bb23c3510e505873be50405c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets a vector of all the types of the data items inside the composite.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a99dfb9bb23c3510e505873be50405c74">More...</a><br /></td></tr>
<tr class="separator:a99dfb9bb23c3510e505873be50405c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2731962b346699babeadbf33e1ed76"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int32_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a9a2731962b346699babeadbf33e1ed76">getNValues</a> ()</td></tr>
<tr class="memdesc:a9a2731962b346699babeadbf33e1ed76"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets a vector of all the N values of the data items inside the composite.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a9a2731962b346699babeadbf33e1ed76">More...</a><br /></td></tr>
<tr class="separator:a9a2731962b346699babeadbf33e1ed76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041913022da9f5b5706df102754d11d8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int16_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a041913022da9f5b5706df102754d11d8">getnValues</a> ()</td></tr>
<tr class="memdesc:a041913022da9f5b5706df102754d11d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets a vector of all the n values of the data items inside the composite.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a041913022da9f5b5706df102754d11d8">More...</a><br /></td></tr>
<tr class="separator:a041913022da9f5b5706df102754d11d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2fbbddf755a416bebcc937e1b2e049"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int8_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a8b2fbbddf755a416bebcc937e1b2e049">getmValues</a> ()</td></tr>
<tr class="memdesc:a8b2fbbddf755a416bebcc937e1b2e049"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets a vector of all the m values of the data items inside the composite.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a8b2fbbddf755a416bebcc937e1b2e049">More...</a><br /></td></tr>
<tr class="separator:a8b2fbbddf755a416bebcc937e1b2e049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6413ad67219bfe853fc4cfeedbc9062"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#aa6413ad67219bfe853fc4cfeedbc9062">index</a> () const</td></tr>
<tr class="memdesc:aa6413ad67219bfe853fc4cfeedbc9062"><td class="mdescLeft">&#160;</td><td class="mdescRight">This methods returns the index of the data item to be returned on the next call to one of the get&lt;Type&gt;() methods (e.g.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#aa6413ad67219bfe853fc4cfeedbc9062">More...</a><br /></td></tr>
<tr class="separator:aa6413ad67219bfe853fc4cfeedbc9062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd89a9276e8622c455d53fb08fc0f3e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#acd89a9276e8622c455d53fb08fc0f3e2">index</a> (uint32_t index)</td></tr>
<tr class="memdesc:acd89a9276e8622c455d53fb08fc0f3e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This methods sets the index of the data item to be returned on the next call to one of the get&lt;Type&gt;() methods (e.g.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#acd89a9276e8622c455d53fb08fc0f3e2">More...</a><br /></td></tr>
<tr class="separator:acd89a9276e8622c455d53fb08fc0f3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831e022b94e5cfa718eae2873b074a7f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a831e022b94e5cfa718eae2873b074a7f">getNValue</a> ()</td></tr>
<tr class="memdesc:a831e022b94e5cfa718eae2873b074a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the next N value data item if it's the correct type.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a831e022b94e5cfa718eae2873b074a7f">More...</a><br /></td></tr>
<tr class="separator:a831e022b94e5cfa718eae2873b074a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa206e158c862ec8b9fce92144d2248db"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#aa206e158c862ec8b9fce92144d2248db">getnValue</a> ()</td></tr>
<tr class="memdesc:aa206e158c862ec8b9fce92144d2248db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the next n value data item if it's the correct type.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#aa206e158c862ec8b9fce92144d2248db">More...</a><br /></td></tr>
<tr class="separator:aa206e158c862ec8b9fce92144d2248db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07a747245b539cebf92a696c1b16aed"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#ac07a747245b539cebf92a696c1b16aed">getmValue</a> ()</td></tr>
<tr class="memdesc:ac07a747245b539cebf92a696c1b16aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the next m value data item if it's the correct type.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#ac07a747245b539cebf92a696c1b16aed">More...</a><br /></td></tr>
<tr class="separator:ac07a747245b539cebf92a696c1b16aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dafd1a151cd30536bf0b1365b5eca36"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a8dafd1a151cd30536bf0b1365b5eca36">getHollerit</a> ()</td></tr>
<tr class="memdesc:a8dafd1a151cd30536bf0b1365b5eca36"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the next HOLLERIT data item if it's the correct type.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a8dafd1a151cd30536bf0b1365b5eca36">More...</a><br /></td></tr>
<tr class="separator:a8dafd1a151cd30536bf0b1365b5eca36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3edbeee22feff7fb0f3e69c6e10c45"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#aae3edbeee22feff7fb0f3e69c6e10c45">getChar</a> ()</td></tr>
<tr class="memdesc:aae3edbeee22feff7fb0f3e69c6e10c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the next data item as a byte/char if it's the correct type.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#aae3edbeee22feff7fb0f3e69c6e10c45">More...</a><br /></td></tr>
<tr class="separator:aae3edbeee22feff7fb0f3e69c6e10c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f0186a35212a05ee95cb1cd8b4e134"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#af7f0186a35212a05ee95cb1cd8b4e134">getUChar</a> ()</td></tr>
<tr class="memdesc:af7f0186a35212a05ee95cb1cd8b4e134"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the next data item as an unsigned byte/char if it's the correct type.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#af7f0186a35212a05ee95cb1cd8b4e134">More...</a><br /></td></tr>
<tr class="separator:af7f0186a35212a05ee95cb1cd8b4e134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da190d6db4c05c79f910f29c3a5762c"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a6da190d6db4c05c79f910f29c3a5762c">getShort</a> ()</td></tr>
<tr class="memdesc:a6da190d6db4c05c79f910f29c3a5762c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the next data item as a short if it's the correct type.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a6da190d6db4c05c79f910f29c3a5762c">More...</a><br /></td></tr>
<tr class="separator:a6da190d6db4c05c79f910f29c3a5762c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd9d2a6da5aab24000d320a83dee469"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#acdd9d2a6da5aab24000d320a83dee469">getUShort</a> ()</td></tr>
<tr class="memdesc:acdd9d2a6da5aab24000d320a83dee469"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the next data item as an unsigned short if it's the correct type.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#acdd9d2a6da5aab24000d320a83dee469">More...</a><br /></td></tr>
<tr class="separator:acdd9d2a6da5aab24000d320a83dee469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ad26a95c2d76895804566191685980"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a81ad26a95c2d76895804566191685980">getInt</a> ()</td></tr>
<tr class="memdesc:a81ad26a95c2d76895804566191685980"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the next data item as an int if it's the correct type.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a81ad26a95c2d76895804566191685980">More...</a><br /></td></tr>
<tr class="separator:a81ad26a95c2d76895804566191685980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedcf9d23b3e771ea685ead0625716a4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#aaedcf9d23b3e771ea685ead0625716a4">getUInt</a> ()</td></tr>
<tr class="memdesc:aaedcf9d23b3e771ea685ead0625716a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the next data item as an unsigned int if it's the correct type.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#aaedcf9d23b3e771ea685ead0625716a4">More...</a><br /></td></tr>
<tr class="separator:aaedcf9d23b3e771ea685ead0625716a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fafb79e736650145b63d479d4b5bb0"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a67fafb79e736650145b63d479d4b5bb0">getLong</a> ()</td></tr>
<tr class="memdesc:a67fafb79e736650145b63d479d4b5bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the next data item as a long if it's the correct type.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a67fafb79e736650145b63d479d4b5bb0">More...</a><br /></td></tr>
<tr class="separator:a67fafb79e736650145b63d479d4b5bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3d25cbcf25e1acf12c00ad475ea342"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a1f3d25cbcf25e1acf12c00ad475ea342">getULong</a> ()</td></tr>
<tr class="memdesc:a1f3d25cbcf25e1acf12c00ad475ea342"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the next data item as an unsigned long if it's the correct type.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a1f3d25cbcf25e1acf12c00ad475ea342">More...</a><br /></td></tr>
<tr class="separator:a1f3d25cbcf25e1acf12c00ad475ea342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3831e073d43eb3391c62bd504d0bc98"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#af3831e073d43eb3391c62bd504d0bc98">getFloat</a> ()</td></tr>
<tr class="memdesc:af3831e073d43eb3391c62bd504d0bc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the next data item as a float if it's the correct type.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#af3831e073d43eb3391c62bd504d0bc98">More...</a><br /></td></tr>
<tr class="separator:af3831e073d43eb3391c62bd504d0bc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc16363efef2f43da7be7f85ce535ba1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#acc16363efef2f43da7be7f85ce535ba1">getDouble</a> ()</td></tr>
<tr class="memdesc:acc16363efef2f43da7be7f85ce535ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the next data item as a double if it's the correct type.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#acc16363efef2f43da7be7f85ce535ba1">More...</a><br /></td></tr>
<tr class="separator:acc16363efef2f43da7be7f85ce535ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c19fefe67d96e4a0d283770c07d4024"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a5c19fefe67d96e4a0d283770c07d4024">getStrings</a> ()</td></tr>
<tr class="memdesc:a5c19fefe67d96e4a0d283770c07d4024"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the next data item as a vector of strings if it's the correct type.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a5c19fefe67d96e4a0d283770c07d4024">More...</a><br /></td></tr>
<tr class="separator:a5c19fefe67d96e4a0d283770c07d4024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c413a1200c9c998b4d6464f89e85ec9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a0c413a1200c9c998b4d6464f89e85ec9">swap</a> ()</td></tr>
<tr class="memdesc:a0c413a1200c9c998b4d6464f89e85ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method swaps the data of this composite type between big &amp; little endian.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a0c413a1200c9c998b4d6464f89e85ec9">More...</a><br /></td></tr>
<tr class="separator:a0c413a1200c9c998b4d6464f89e85ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4acdf0c61154d716ddafccf90d99fc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#ac4acdf0c61154d716ddafccf90d99fc7">process</a> ()</td></tr>
<tr class="memdesc:ac4acdf0c61154d716ddafccf90d99fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method extracts and stores all the data items and their types in various lists.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#ac4acdf0c61154d716ddafccf90d99fc7">More...</a><br /></td></tr>
<tr class="separator:ac4acdf0c61154d716ddafccf90d99fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22cbe87e198afe3318679a5866803aa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#ac22cbe87e198afe3318679a5866803aa">toString</a> (const std::string &amp;indent, bool hex)</td></tr>
<tr class="memdesc:ac22cbe87e198afe3318679a5866803aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a string representation of the composite data.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#ac22cbe87e198afe3318679a5866803aa">More...</a><br /></td></tr>
<tr class="separator:ac22cbe87e198afe3318679a5866803aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867123b42afb4031262debfa4f5f3075"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a867123b42afb4031262debfa4f5f3075">toString</a> () const</td></tr>
<tr class="memdesc:a867123b42afb4031262debfa4f5f3075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a string representation of the composite data.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a867123b42afb4031262debfa4f5f3075">More...</a><br /></td></tr>
<tr class="separator:a867123b42afb4031262debfa4f5f3075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaceb035845b0a7b47120d9797c8aebae"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#aaceb035845b0a7b47120d9797c8aebae">toString</a> (bool hex) const</td></tr>
<tr class="memdesc:aaceb035845b0a7b47120d9797c8aebae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a string representation of this <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> object suitable for displaying in org.jlab.coda.jevio.graphics.EventTreeFrame gui.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#aaceb035845b0a7b47120d9797c8aebae">More...</a><br /></td></tr>
<tr class="separator:aaceb035845b0a7b47120d9797c8aebae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9d5734937d2a68199b9e8094239a69b7"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html">CompositeData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a9d5734937d2a68199b9e8094239a69b7">getInstance</a> (std::string &amp;format, const <a class="el" href="../../d0/d19/classevio_1_1_composite_data_1_1_data.html">Data</a> &amp;data)</td></tr>
<tr class="memdesc:a9d5734937d2a68199b9e8094239a69b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to return a shared pointer to a constructed object of this class.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a9d5734937d2a68199b9e8094239a69b7">More...</a><br /></td></tr>
<tr class="separator:a9d5734937d2a68199b9e8094239a69b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc647a4fbfdf51e7865051623bfd53d"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html">CompositeData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a1dc647a4fbfdf51e7865051623bfd53d">getInstance</a> (std::string &amp;format, const <a class="el" href="../../d0/d19/classevio_1_1_composite_data_1_1_data.html">Data</a> &amp;data, uint16_t formatTag, uint16_t dataTag, uint8_t dataNum, <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> const &amp;order=<a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#ae4055f708921d4e6540ab4662d27147c">ByteOrder::ENDIAN_LOCAL</a>)</td></tr>
<tr class="memdesc:a1dc647a4fbfdf51e7865051623bfd53d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to return a shared pointer to a constructed object of this class.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a1dc647a4fbfdf51e7865051623bfd53d">More...</a><br /></td></tr>
<tr class="separator:a1dc647a4fbfdf51e7865051623bfd53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c477eae80930f1b6f1b5a97443b9cd"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html">CompositeData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#ae8c477eae80930f1b6f1b5a97443b9cd">getInstance</a> (uint8_t *bytes, <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> const &amp;order=<a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#ae4055f708921d4e6540ab4662d27147c">ByteOrder::ENDIAN_LOCAL</a>)</td></tr>
<tr class="memdesc:ae8c477eae80930f1b6f1b5a97443b9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to return a shared pointer to a constructed object of this class.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#ae8c477eae80930f1b6f1b5a97443b9cd">More...</a><br /></td></tr>
<tr class="separator:ae8c477eae80930f1b6f1b5a97443b9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8112b46fbe778b67876724ae55459b33"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html">CompositeData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a8112b46fbe778b67876724ae55459b33">getInstance</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;bytes)</td></tr>
<tr class="memdesc:a8112b46fbe778b67876724ae55459b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to return a shared pointer to a constructed object of this class.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a8112b46fbe778b67876724ae55459b33">More...</a><br /></td></tr>
<tr class="separator:a8112b46fbe778b67876724ae55459b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9134283cf594778b9e4e925d199e0cc7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a9134283cf594778b9e4e925d199e0cc7">parse</a> (uint8_t *bytes, size_t bytesSize, <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> const &amp;order, std::vector&lt; std::shared_ptr&lt; <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html">CompositeData</a> &gt;&gt; &amp;list)</td></tr>
<tr class="memdesc:a9134283cf594778b9e4e925d199e0cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method parses an array of raw bytes into an vector of <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> objects.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a9134283cf594778b9e4e925d199e0cc7">More...</a><br /></td></tr>
<tr class="separator:a9134283cf594778b9e4e925d199e0cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c44828a1acbffe083cc5122f8c4c8f1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a1c44828a1acbffe083cc5122f8c4c8f1">generateRawBytes</a> (std::vector&lt; std::shared_ptr&lt; <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html">CompositeData</a> &gt;&gt; &amp;data, std::vector&lt; uint8_t &gt; &amp;rawBytes, <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;order)</td></tr>
<tr class="memdesc:a1c44828a1acbffe083cc5122f8c4c8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method generates raw bytes of evio format from a vector of <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> objects.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a1c44828a1acbffe083cc5122f8c4c8f1">More...</a><br /></td></tr>
<tr class="separator:a1c44828a1acbffe083cc5122f8c4c8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fa03576610d49d7a3f33f6945727cd"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a88fa03576610d49d7a3f33f6945727cd">stringsToFormat</a> (std::vector&lt; std::string &gt; strings)</td></tr>
<tr class="memdesc:a88fa03576610d49d7a3f33f6945727cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method helps the <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> object creator by finding the proper format string parameter for putting this array of Strings into its data.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a88fa03576610d49d7a3f33f6945727cd">More...</a><br /></td></tr>
<tr class="separator:a88fa03576610d49d7a3f33f6945727cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf415d7d278a0f0bff5945712cb3d258"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#abf415d7d278a0f0bff5945712cb3d258">compositeFormatToInt</a> (const std::string &amp;formatStr, std::vector&lt; uint16_t &gt; &amp;ifmt)</td></tr>
<tr class="separator:abf415d7d278a0f0bff5945712cb3d258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf40a2dfe3ba46ef019b16c2abcf9aba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#adf40a2dfe3ba46ef019b16c2abcf9aba">swapAll</a> (uint8_t *src, uint8_t *dest, size_t length, bool srcIsLocal)</td></tr>
<tr class="memdesc:adf40a2dfe3ba46ef019b16c2abcf9aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts (swaps) a buffer of EVIO composite type between big &amp; little endian.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#adf40a2dfe3ba46ef019b16c2abcf9aba">More...</a><br /></td></tr>
<tr class="separator:adf40a2dfe3ba46ef019b16c2abcf9aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f5f3b55b2d9202e02b19fd645e5262"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#af2f5f3b55b2d9202e02b19fd645e5262">swapAll</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;buf, uint32_t srcPos, uint32_t len)</td></tr>
<tr class="memdesc:af2f5f3b55b2d9202e02b19fd645e5262"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method swaps the data in a buffer, containing EVIO composite type, between big &amp; little endian.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#af2f5f3b55b2d9202e02b19fd645e5262">More...</a><br /></td></tr>
<tr class="separator:af2f5f3b55b2d9202e02b19fd645e5262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a813a3387240a4bf3f6ad70edbd3c6a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a6a813a3387240a4bf3f6ad70edbd3c6a">swapAll</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buf, uint32_t srcPos, uint32_t len)</td></tr>
<tr class="memdesc:a6a813a3387240a4bf3f6ad70edbd3c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method swaps the data in a buffer, containing EVIO composite type, between big &amp; little endian.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a6a813a3387240a4bf3f6ad70edbd3c6a">More...</a><br /></td></tr>
<tr class="separator:a6a813a3387240a4bf3f6ad70edbd3c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5785b1537215340b8b4f2551e463f56c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a5785b1537215340b8b4f2551e463f56c">swapAll</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;srcBuf, std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;destBuf, uint32_t srcPos, uint32_t destPos, uint32_t len)</td></tr>
<tr class="memdesc:a5785b1537215340b8b4f2551e463f56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts (swaps) a buffer, containing EVIO composite type, between big &amp; little endian.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a5785b1537215340b8b4f2551e463f56c">More...</a><br /></td></tr>
<tr class="separator:a5785b1537215340b8b4f2551e463f56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103088fd6ee8b4b9a1edc7f1a204f6c2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a103088fd6ee8b4b9a1edc7f1a204f6c2">swapAll</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;srcBuffer, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;destBuffer, uint32_t srcPos, uint32_t destPos, uint32_t len)</td></tr>
<tr class="memdesc:a103088fd6ee8b4b9a1edc7f1a204f6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts (swaps) a buffer, containing EVIO composite type, between big &amp; little endian.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a103088fd6ee8b4b9a1edc7f1a204f6c2">More...</a><br /></td></tr>
<tr class="separator:a103088fd6ee8b4b9a1edc7f1a204f6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465184e11d0b2902cf44b634e7c8e7f7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a465184e11d0b2902cf44b634e7c8e7f7">swapData</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;srcBuf, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;destBuf, size_t nBytes, const std::vector&lt; uint16_t &gt; &amp;ifmt)</td></tr>
<tr class="memdesc:a465184e11d0b2902cf44b634e7c8e7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts (swaps) EVIO composite type data between Big endian and Little endian.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a465184e11d0b2902cf44b634e7c8e7f7">More...</a><br /></td></tr>
<tr class="separator:a465184e11d0b2902cf44b634e7c8e7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa73ee1c055d2ae17fd0b927c12db9c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#adaa73ee1c055d2ae17fd0b927c12db9c">swapData</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;srcBuf, std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;destBuf, size_t srcPos, size_t destPos, size_t nBytes, const std::vector&lt; uint16_t &gt; &amp;ifmt)</td></tr>
<tr class="memdesc:adaa73ee1c055d2ae17fd0b927c12db9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts (swaps) EVIO composite type data between Big endian and Little endian.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#adaa73ee1c055d2ae17fd0b927c12db9c">More...</a><br /></td></tr>
<tr class="separator:adaa73ee1c055d2ae17fd0b927c12db9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f9c073bb8eb07f6c5bcb021effffa2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a41f9c073bb8eb07f6c5bcb021effffa2">swapData</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;srcBuf, <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;destBuf, size_t srcPos, size_t destPos, size_t nBytes, const std::vector&lt; uint16_t &gt; &amp;ifmt)</td></tr>
<tr class="memdesc:a41f9c073bb8eb07f6c5bcb021effffa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts (swaps) EVIO composite type data between Big endian and Little endian.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a41f9c073bb8eb07f6c5bcb021effffa2">More...</a><br /></td></tr>
<tr class="separator:a41f9c073bb8eb07f6c5bcb021effffa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8471f9f68caf00e713970ef755de2dd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#ab8471f9f68caf00e713970ef755de2dd">swapData</a> (int32_t *src, int32_t *dest, size_t nwrd, const std::vector&lt; uint16_t &gt; &amp;ifmt, uint32_t padding, bool srcIsLocal)</td></tr>
<tr class="memdesc:ab8471f9f68caf00e713970ef755de2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts (swaps) EVIO composite type data between Big endian and Little endian.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#ab8471f9f68caf00e713970ef755de2dd">More...</a><br /></td></tr>
<tr class="separator:ab8471f9f68caf00e713970ef755de2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7ab62439d624c9951124f3e8cbfbaf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a1a7ab62439d624c9951124f3e8cbfbaf">swapData</a> (int32_t *iarr, int nwrd, const std::vector&lt; uint16_t &gt; &amp;ifmt, uint32_t padding)</td></tr>
<tr class="memdesc:a1a7ab62439d624c9951124f3e8cbfbaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts (swaps) an array of EVIO composite type data between IEEE (big endian) and DECS (little endian) in place.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#a1a7ab62439d624c9951124f3e8cbfbaf">More...</a><br /></td></tr>
<tr class="separator:a1a7ab62439d624c9951124f3e8cbfbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe504814bd6e02b610280ac2544fa0ee"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#afe504814bd6e02b610280ac2544fa0ee">dataToRawBytes</a> (<a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;rawBuf, <a class="el" href="../../d0/d19/classevio_1_1_composite_data_1_1_data.html">Data</a> const &amp;data, std::vector&lt; uint16_t &gt; &amp;ifmt)</td></tr>
<tr class="memdesc:afe504814bd6e02b610280ac2544fa0ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method takes a <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> object and a transformed format string and uses that to write data into a buffer/array in raw form.  <a href="../../d5/d4b/classevio_1_1_composite_data.html#afe504814bd6e02b610280ac2544fa0ee">More...</a><br /></td></tr>
<tr class="separator:afe504814bd6e02b610280ac2544fa0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>COMPOSITE DATA: </p>
<p>This is a new type of data (value = 0xf) which originated with Hall B. It is a composite type and allows for possible expansion in the future if there is a demand. Basically it allows the user to specify a custom format by means of a string - stored in a tagsegment. The data in that format follows in a bank. The routine to swap this data must be provided by the definer of the composite type - in this case Hall B. The swapping function is plugged into this evio library's swapping routine.</p>
<p>Here's what the data looks like. </p><pre></pre><pre>MSB(31)                          LSB(0)
&lt;---  32 bits ------------------------&gt;
_______________________________________
|  tag    | type |    length          | --&gt; tagsegment header
|_________|______|____________________|
|        <a class="el" href="../../d0/d19/classevio_1_1_composite_data_1_1_data.html" title="This class is used to provide all data when constructing a CompositeData object.">Data</a> Format String           |
|                                     |
|_____________________________________|
|              length                 | \
|_____________________________________|  \  bank header
|       tag      |  type   |   num    |  /
|________________|_________|__________| /
|               <a class="el" href="../../d0/d19/classevio_1_1_composite_data_1_1_data.html" title="This class is used to provide all data when constructing a CompositeData object.">Data</a>                  |
|                                     |
|_____________________________________|
</pre><p>The beginning tagsegment is a normal evio tagsegment containing a string (type = 0x3). Currently its type and tag are not used - at least not for data formatting. The bank is a normal evio bank header with data following. The format string is used to read/write this data so that takes care of any padding that may exist. As with the tagsegment, the tags and type are ignored.</p>
<p>This is the class defining the composite data type. It is a mixture of header and raw data. This class is <b>NOT</b> thread safe.</p>
<dl class="section author"><dt>Author</dt><dd>timmer </dd></dl>
<dl class="section date"><dt>Date</dt><dd>4/17/2020 </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="abf415d7d278a0f0bff5945712cb3d258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf415d7d278a0f0bff5945712cb3d258">&#9670;&nbsp;</a></span>compositeFormatToInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int evio::CompositeData::compositeFormatToInt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>formatStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint16_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ifmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre>
 This method was originally called called "eviofmt".
 It transforms a composite, format-containing
 ASCII string to a vector of shorts codes. It is to be used
 in conjunction with <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a465184e11d0b2902cf44b634e7c8e7f7">swapData</a> to swap the endianness of
 composite data.</pre><pre>  format code bits &lt;- format in ascii form
   [15:14] [13:8] [7:0]
     Nnm      #     0           #'('
       0      0     0            ')'
     Nnm      #     1           #'i'   unsigned int
     Nnm      #     2           #'F'   floating point
     Nnm      #     3           #'a'   8-bit char (C++)
     Nnm      #     4           #'S'   short
     Nnm      #     5           #'s'   unsigned short
     Nnm      #     6           #'C'   char
     Nnm      #     7           #'c'   unsigned char
     Nnm      #     8           #'D'   double (64-bit float)
     Nnm      #     9           #'L'   long long (64-bit int)
     Nnm      #    10           #'l'   unsigned long long (64-bit int)
     Nnm      #    11           #'I'   int
     Nnm      #    12           #'A'   hollerit (4-byte char with int endining)</pre><pre>  NOTES:
   1. The number of repeats '#' must be the number between 2 and 63, number 1 assumed by default
   2. If the number of repeats is symbol 'N' instead of the number, it will be taken from data assuming 'int32' format;
      if the number of repeats is symbol 'n' instead of the number, it will be taken from data assuming 'int16' format;
      if the number of repeats is symbol 'm' instead of the number, it will be taken from data assuming 'int8' format;
      Two bits Nnm [15:14], if not zero, requires to take the number of repeats from data in appropriate format:
           [01] means that number is integer (N),
           [10] - short (n),
           [11] - char (m)
   3. If format ends but end of data did not reach, format in last parenthesis
      will be repeated until all data processed; if there are no parenthesis
      in format, data processing will be started from the beginnig of the format
      (FORTRAN agreement)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">formatStr</td><td>composite data format string </td></tr>
    <tr><td class="paramname">ifmt</td><td>unsigned short vector to hold transformed format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of shorts in ifmt[] (positive) </dd>
<dd>
-1 to -8 for improper format string</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Sergey Boiarinov </dd></dl>

</div>
</div>
<a id="afe504814bd6e02b610280ac2544fa0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe504814bd6e02b610280ac2544fa0ee">&#9670;&nbsp;</a></span>dataToRawBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::CompositeData::dataToRawBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>rawBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d19/classevio_1_1_composite_data_1_1_data.html">Data</a> const &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint16_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ifmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method takes a <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> object and a transformed format string and uses that to write data into a buffer/array in raw form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rawBuf</td><td>data buffer in which to put the raw bytes </td></tr>
    <tr><td class="paramname">data</td><td>data to convert to raw bytes </td></tr>
    <tr><td class="paramname">ifmt</td><td>format list as produced by <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#abf415d7d278a0f0bff5945712cb3d258">compositeFormatToInt(const std::string &amp;, std::vector&lt;uint16_t&gt; &amp;)</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if ifmt size &lt;= 0; if srcBuf or destBuf is too small; not enough dataItems for the given format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c44828a1acbffe083cc5122f8c4c8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c44828a1acbffe083cc5122f8c4c8f1">&#9670;&nbsp;</a></span>generateRawBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::CompositeData::generateRawBytes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html">CompositeData</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>rawBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method generates raw bytes of evio format from a vector of <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> objects. </p>
<p>The returned vector consists of gluing together all the individual objects' rawByte arrays. All <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> element must be of the same byte order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>vector of <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> objects to turn into bytes (input). </td></tr>
    <tr><td class="paramname">rawBytes</td><td>vector of raw, evio format bytes (output). </td></tr>
    <tr><td class="paramname">order</td><td>byte order of output. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="../../de/dce/classevio_1_1_compact_event_builder.html#aa9b4794a8a205b1e96fe7226cef3c864">evio::CompactEventBuilder::addCompositeData()</a>, and <a class="el" href="../../d9/ddd/classevio_1_1_base_structure.html#a84c0b49e9886b62dae99c8b32bec410a">evio::BaseStructure::updateCompositeData()</a>.</p>

</div>
</div>
<a id="a2f7b28094dd581a54f250532a35e3270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7b28094dd581a54f250532a35e3270">&#9670;&nbsp;</a></span>getByteOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> evio::CompositeData::getByteOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the raw data byte order. </p>
<dl class="section return"><dt>Returns</dt><dd>raw data byte order. </dd></dl>

</div>
</div>
<a id="aae3edbeee22feff7fb0f3e69c6e10c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3edbeee22feff7fb0f3e69c6e10c45">&#9670;&nbsp;</a></span>getChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t evio::CompositeData::getChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the next data item as a byte/char if it's the correct type. </p>
<dl class="section return"><dt>Returns</dt><dd>data item value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::underflow_error</td><td>if at end of data. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if data is not int8_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc16363efef2f43da7be7f85ce535ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc16363efef2f43da7be7f85ce535ba1">&#9670;&nbsp;</a></span>getDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double evio::CompositeData::getDouble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the next data item as a double if it's the correct type. </p>
<dl class="section return"><dt>Returns</dt><dd>data item value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::underflow_error</td><td>if at end of data. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if data is not double. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3831e073d43eb3391c62bd504d0bc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3831e073d43eb3391c62bd504d0bc98">&#9670;&nbsp;</a></span>getFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float evio::CompositeData::getFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the next data item as a float if it's the correct type. </p>
<dl class="section return"><dt>Returns</dt><dd>data item value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">underflow_error</td><td>if at end of data. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if data is not float. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaad2a6deede81c1b8d233c4bf04a808a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad2a6deede81c1b8d233c4bf04a808a">&#9670;&nbsp;</a></span>getFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string evio::CompositeData::getFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the format string. </p>
<dl class="section return"><dt>Returns</dt><dd>format string. </dd></dl>

</div>
</div>
<a id="a8dafd1a151cd30536bf0b1365b5eca36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dafd1a151cd30536bf0b1365b5eca36">&#9670;&nbsp;</a></span>getHollerit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t evio::CompositeData::getHollerit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the next HOLLERIT data item if it's the correct type. </p>
<dl class="section return"><dt>Returns</dt><dd>data item value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::underflow_error</td><td>if at end of data. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if data is not HOLLERIT. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8112b46fbe778b67876724ae55459b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8112b46fbe778b67876724ae55459b33">&#9670;&nbsp;</a></span>getInstance() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html">CompositeData</a>&gt; evio::CompositeData::getInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to return a shared pointer to a constructed object of this class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> of raw data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared pointer of <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> object. </dd></dl>

</div>
</div>
<a id="a9d5734937d2a68199b9e8094239a69b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5734937d2a68199b9e8094239a69b7">&#9670;&nbsp;</a></span>getInstance() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html">CompositeData</a>&gt; evio::CompositeData::getInstance </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d19/classevio_1_1_composite_data_1_1_data.html">Data</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to return a shared pointer to a constructed object of this class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>data format string. </td></tr>
    <tr><td class="paramname">data</td><td>object containing composite data description. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared pointer of <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> object. </dd></dl>

</div>
</div>
<a id="a1dc647a4fbfdf51e7865051623bfd53d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc647a4fbfdf51e7865051623bfd53d">&#9670;&nbsp;</a></span>getInstance() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html">CompositeData</a>&gt; evio::CompositeData::getInstance </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d19/classevio_1_1_composite_data_1_1_data.html">Data</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>formatTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dataTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dataNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> const &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#ae4055f708921d4e6540ab4662d27147c">ByteOrder::ENDIAN_LOCAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to return a shared pointer to a constructed object of this class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>data format string. </td></tr>
    <tr><td class="paramname">data</td><td>object containing composite data description. </td></tr>
    <tr><td class="paramname">formatTag</td><td>tag of evio segment containing format. </td></tr>
    <tr><td class="paramname">dataTag</td><td>tag of evio bank containing data. </td></tr>
    <tr><td class="paramname">dataNum</td><td>num of evio bank containing data. </td></tr>
    <tr><td class="paramname">order</td><td>desired byteOrder of generated raw data. Defaults to local endian. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared pointer of <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> object. </dd></dl>

</div>
</div>
<a id="ae8c477eae80930f1b6f1b5a97443b9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c477eae80930f1b6f1b5a97443b9cd">&#9670;&nbsp;</a></span>getInstance() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html">CompositeData</a>&gt; evio::CompositeData::getInstance </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> const &amp;&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#ae4055f708921d4e6540ab4662d27147c">ByteOrder::ENDIAN_LOCAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to return a shared pointer to a constructed object of this class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>pointer to raw data. </td></tr>
    <tr><td class="paramname">order</td><td>byte order of raw data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared pointer of <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> object. </dd></dl>

</div>
</div>
<a id="a81ad26a95c2d76895804566191685980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ad26a95c2d76895804566191685980">&#9670;&nbsp;</a></span>getInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t evio::CompositeData::getInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the next data item as an int if it's the correct type. </p>
<dl class="section return"><dt>Returns</dt><dd>data item value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::underflow_error</td><td>if at end of data. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if data is not int32_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fc5af5e5da00d80d774a9fe479d8aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc5af5e5da00d80d774a9fe479d8aa3">&#9670;&nbsp;</a></span>getItems()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="../../d2/d1c/classevio_1_1_composite_data_1_1_data_item.html">DataItem</a>&gt;&amp; evio::CompositeData::getItems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets a vector of all the data items inside the composite. </p>
<p><b>Do not change the vector contents.</b> </p><dl class="section return"><dt>Returns</dt><dd>reference to vector of all the data items inside the composite. </dd></dl>

</div>
</div>
<a id="a67fafb79e736650145b63d479d4b5bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67fafb79e736650145b63d479d4b5bb0">&#9670;&nbsp;</a></span>getLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t evio::CompositeData::getLong </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the next data item as a long if it's the correct type. </p>
<dl class="section return"><dt>Returns</dt><dd>data item value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::underflow_error</td><td>if at end of data. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if data is not int64_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac07a747245b539cebf92a696c1b16aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07a747245b539cebf92a696c1b16aed">&#9670;&nbsp;</a></span>getmValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t evio::CompositeData::getmValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the next m value data item if it's the correct type. </p>
<dl class="section return"><dt>Returns</dt><dd>data item value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::underflow_error</td><td>if at end of data. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if data is not mValue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b2fbbddf755a416bebcc937e1b2e049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2fbbddf755a416bebcc937e1b2e049">&#9670;&nbsp;</a></span>getmValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int8_t&gt;&amp; evio::CompositeData::getmValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets a vector of all the m values of the data items inside the composite. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to vector of all the m values of the data items inside the composite. </dd></dl>

</div>
</div>
<a id="a831e022b94e5cfa718eae2873b074a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831e022b94e5cfa718eae2873b074a7f">&#9670;&nbsp;</a></span>getNValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t evio::CompositeData::getNValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the next N value data item if it's the correct type. </p>
<dl class="section return"><dt>Returns</dt><dd>data item value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::underflow_error</td><td>if at end of data. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if data is not NValue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa206e158c862ec8b9fce92144d2248db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa206e158c862ec8b9fce92144d2248db">&#9670;&nbsp;</a></span>getnValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t evio::CompositeData::getnValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the next n value data item if it's the correct type. </p>
<dl class="section return"><dt>Returns</dt><dd>data item value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::underflow_error</td><td>if at end of data. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if data is not nValue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a2731962b346699babeadbf33e1ed76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2731962b346699babeadbf33e1ed76">&#9670;&nbsp;</a></span>getNValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int32_t&gt;&amp; evio::CompositeData::getNValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets a vector of all the N values of the data items inside the composite. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to vector of all the N values of the data items inside the composite. </dd></dl>

</div>
</div>
<a id="a041913022da9f5b5706df102754d11d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041913022da9f5b5706df102754d11d8">&#9670;&nbsp;</a></span>getnValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int16_t&gt;&amp; evio::CompositeData::getnValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets a vector of all the n values of the data items inside the composite. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to vector of all the n values of the data items inside the composite. </dd></dl>

</div>
</div>
<a id="ab2677724ff9e19b546303c46decde01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2677724ff9e19b546303c46decde01c">&#9670;&nbsp;</a></span>getPadding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::CompositeData::getPadding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the data padding (0, 1, 2, or 3 bytes). </p>
<dl class="section return"><dt>Returns</dt><dd>data padding. </dd></dl>

</div>
</div>
<a id="af21c4e2a371ea21a74395c12c94fe786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21c4e2a371ea21a74395c12c94fe786">&#9670;&nbsp;</a></span>getRawBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint8_t&gt;&amp; evio::CompositeData::getRawBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets a vector of the raw byte representation of this object's data. </p>
<p><b>Do not change the vector contents.</b> </p><dl class="section return"><dt>Returns</dt><dd>reference to vector of raw bytes representing of this object's data. </dd></dl>

</div>
</div>
<a id="a6da190d6db4c05c79f910f29c3a5762c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da190d6db4c05c79f910f29c3a5762c">&#9670;&nbsp;</a></span>getShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t evio::CompositeData::getShort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the next data item as a short if it's the correct type. </p>
<dl class="section return"><dt>Returns</dt><dd>data item value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::underflow_error</td><td>if at end of data. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if data is not int16_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c19fefe67d96e4a0d283770c07d4024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c19fefe67d96e4a0d283770c07d4024">&#9670;&nbsp;</a></span>getStrings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt;&amp; evio::CompositeData::getStrings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the next data item as a vector of strings if it's the correct type. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to vector of strings in data item. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::underflow_error</td><td>if at end of data. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if data is not vector of strings. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99dfb9bb23c3510e505873be50405c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99dfb9bb23c3510e505873be50405c74">&#9670;&nbsp;</a></span>getTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="../../d5/d23/classevio_1_1_data_type.html">DataType</a>&gt;&amp; evio::CompositeData::getTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets a vector of all the types of the data items inside the composite. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to vector of all the types of the data items inside the composite. </dd></dl>

</div>
</div>
<a id="af7f0186a35212a05ee95cb1cd8b4e134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f0186a35212a05ee95cb1cd8b4e134">&#9670;&nbsp;</a></span>getUChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t evio::CompositeData::getUChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the next data item as an unsigned byte/char if it's the correct type. </p>
<dl class="section return"><dt>Returns</dt><dd>data item value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::underflow_error</td><td>if at end of data. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if data is not uint8_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaedcf9d23b3e771ea685ead0625716a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaedcf9d23b3e771ea685ead0625716a4">&#9670;&nbsp;</a></span>getUInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::CompositeData::getUInt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the next data item as an unsigned int if it's the correct type. </p>
<dl class="section return"><dt>Returns</dt><dd>data item value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::underflow_error</td><td>if at end of data. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if data is not uint32_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f3d25cbcf25e1acf12c00ad475ea342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3d25cbcf25e1acf12c00ad475ea342">&#9670;&nbsp;</a></span>getULong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t evio::CompositeData::getULong </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the next data item as an unsigned long if it's the correct type. </p>
<dl class="section return"><dt>Returns</dt><dd>data item value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::underflow_error</td><td>if at end of data. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if data is not uint64_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdd9d2a6da5aab24000d320a83dee469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd9d2a6da5aab24000d320a83dee469">&#9670;&nbsp;</a></span>getUShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t evio::CompositeData::getUShort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the next data item as an unsigned short if it's the correct type. </p>
<dl class="section return"><dt>Returns</dt><dd>data item value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::underflow_error</td><td>if at end of data. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if data is not uint16_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6413ad67219bfe853fc4cfeedbc9062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6413ad67219bfe853fc4cfeedbc9062">&#9670;&nbsp;</a></span>index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::CompositeData::index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This methods returns the index of the data item to be returned on the next call to one of the get&lt;Type&gt;() methods (e.g. </p>
<p><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a81ad26a95c2d76895804566191685980">getInt()</a>. </p><dl class="section return"><dt>Returns</dt><dd>returns the index of the data item to be returned </dd></dl>

</div>
</div>
<a id="acd89a9276e8622c455d53fb08fc0f3e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd89a9276e8622c455d53fb08fc0f3e2">&#9670;&nbsp;</a></span>index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::CompositeData::index </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This methods sets the index of the data item to be returned on the next call to one of the get&lt;Type&gt;() methods (e.g. </p>
<p><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#a81ad26a95c2d76895804566191685980">getInt()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the next data item to be returned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9134283cf594778b9e4e925d199e0cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9134283cf594778b9e4e925d199e0cc7">&#9670;&nbsp;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::CompositeData::parse </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytesSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> const &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html">CompositeData</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method parses an array of raw bytes into an vector of <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> objects. </p>
<p>Vector is initially cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>array of raw bytes to parse. </td></tr>
    <tr><td class="paramname">bytesSize</td><td>size in bytes of bytes. </td></tr>
    <tr><td class="paramname">order</td><td>byte order of raw bytes. </td></tr>
    <tr><td class="paramname">list</td><td>vector that will hold all parsed <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if null args or bad format of raw data. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="../../d9/ddd/classevio_1_1_base_structure.html#ac5e88c4f6a89a59851bf08a613d6ac42">evio::BaseStructure::getCompositeData()</a>.</p>

</div>
</div>
<a id="ac4acdf0c61154d716ddafccf90d99fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4acdf0c61154d716ddafccf90d99fc7">&#9670;&nbsp;</a></span>process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::CompositeData::process </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method extracts and stores all the data items and their types in various lists. </p>

</div>
</div>
<a id="a88fa03576610d49d7a3f33f6945727cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88fa03576610d49d7a3f33f6945727cd">&#9670;&nbsp;</a></span>stringsToFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string evio::CompositeData::stringsToFormat </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>strings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method helps the <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> object creator by finding the proper format string parameter for putting this array of Strings into its data. </p>
<p>The format is in the form "Ma" where M is an actual integer. Warning, in this case, M may not be greater than 15. If you want a longer string or array of strings, use the format "Na" with a literal N. The N value can be added through <a class="el" href="../../d0/d19/classevio_1_1_composite_data_1_1_data.html#a859c1963dd27ee0ea8dd11bdd125f0b3">CompositeData::Data#addN(uint32_t)</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>array of strings to eventually put into a <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string representing its format to be used in the <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> object's format string; empty string if arg has 0 length. </dd></dl>

</div>
</div>
<a id="a0c413a1200c9c998b4d6464f89e85ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c413a1200c9c998b4d6464f89e85ec9">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::CompositeData::swap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method swaps the data of this composite type between big &amp; little endian. </p>
<p>It swaps the entire type including the beginning tagsegment header, the following format string it contains, the data's bank header, and finally the data itself.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if internal error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2f5f3b55b2d9202e02b19fd645e5262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f5f3b55b2d9202e02b19fd645e5262">&#9670;&nbsp;</a></span>swapAll() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::CompositeData::swapAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method swaps the data in a buffer, containing EVIO composite type, between big &amp; little endian. </p>
<p>It swaps the entire type including the beginning tagsegment header, the following format string it contains, the data's bank header, and finally the data itself. The src buffer may contain an array of composite type items and all will be swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>source and destination data buffer. </td></tr>
    <tr><td class="paramname">srcPos</td><td>position in srcBuffer to beginning swapping </td></tr>
    <tr><td class="paramname">len</td><td>length of data in buf to swap in 32 bit words</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if srcPos or len too large; if len too small. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if srcBuffer not in evio format; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a103088fd6ee8b4b9a1edc7f1a204f6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103088fd6ee8b4b9a1edc7f1a204f6c2">&#9670;&nbsp;</a></span>swapAll() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::CompositeData::swapAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>srcBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>destBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>destPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method converts (swaps) a buffer, containing EVIO composite type, between big &amp; little endian. </p>
<p>It swaps the entire type including the beginning tagsegment header, the following format string it contains, the data's bank header, and finally the data itself. The src buffer may contain an array of composite type items and all will be swapped.</p>
<p><b>This only swaps data if buffer arguments have opposite byte order!</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcBuffer</td><td>source data buffer </td></tr>
    <tr><td class="paramname">destBuffer</td><td>destination data buffer </td></tr>
    <tr><td class="paramname">srcPos</td><td>position in srcBuffer to beginning swapping </td></tr>
    <tr><td class="paramname">destPos</td><td>position in destBuffer to beginning writing swapped data </td></tr>
    <tr><td class="paramname">len</td><td>length of data in srcBuffer to swap in 32 bit words</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if srcBuffer not in evio format; if destBuffer too small; if bad values for srcPos/destPos/len args; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a813a3387240a4bf3f6ad70edbd3c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a813a3387240a4bf3f6ad70edbd3c6a">&#9670;&nbsp;</a></span>swapAll() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::CompositeData::swapAll </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method swaps the data in a buffer, containing EVIO composite type, between big &amp; little endian. </p>
<p>It swaps the entire type including the beginning tagsegment header, the following format string it contains, the data's bank header, and finally the data itself. The src buffer may contain an array of composite type items and all will be swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>source and destination data buffer. </td></tr>
    <tr><td class="paramname">srcPos</td><td>position in srcBuffer to beginning swapping </td></tr>
    <tr><td class="paramname">len</td><td>length of data in buf to swap in 32 bit words</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if srcPos or len too large; if len too small. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if srcBuffer not in evio format; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5785b1537215340b8b4f2551e463f56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5785b1537215340b8b4f2551e463f56c">&#9670;&nbsp;</a></span>swapAll() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::CompositeData::swapAll </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>srcBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>destBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>destPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method converts (swaps) a buffer, containing EVIO composite type, between big &amp; little endian. </p>
<p>It swaps the entire type including the beginning tagsegment header, the following format string it contains, the data's bank header, and finally the data itself. The src buffer may contain an array of composite type items and all will be swapped.</p>
<p><b>This only swaps data if buffer arguments have opposite byte order!</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcBuf</td><td>source data buffer </td></tr>
    <tr><td class="paramname">destBuf</td><td>destination data buffer </td></tr>
    <tr><td class="paramname">srcPos</td><td>position in srcBuffer to beginning swapping </td></tr>
    <tr><td class="paramname">destPos</td><td>position in destBuffer to beginning writing swapped data </td></tr>
    <tr><td class="paramname">len</td><td>length of data in srcBuffer to swap in 32 bit words</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if srcBuffer not in evio format; if destBuffer too small; if bad values for srcPos/destPos/len args; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf40a2dfe3ba46ef019b16c2abcf9aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf40a2dfe3ba46ef019b16c2abcf9aba">&#9670;&nbsp;</a></span>swapAll() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::CompositeData::swapAll </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>srcIsLocal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method converts (swaps) a buffer of EVIO composite type between big &amp; little endian. </p>
<p>It swaps the entire type including the beginning tagsegment header, the following format string it contains, the data's bank header, and finally the data itself. The src array may contain an array of composite type items and all will be swapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source data pointer. </td></tr>
    <tr><td class="paramname">dest</td><td>destination data pointer. </td></tr>
    <tr><td class="paramname">length</td><td>length of data array in 32 bit words. </td></tr>
    <tr><td class="paramname">srcIsLocal</td><td>true if the byte order of src data is the same as the node's.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if src = null; if len is too small </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="../../df/d7a/classevio_1_1_evio_swap.html#aa32ca389e1efa5f06333ee14126c5352">evio::EvioSwap::swapData()</a>, <a class="el" href="../../df/d7a/classevio_1_1_evio_swap.html#a826474578859587bae29394b260142a5">evio::EvioSwap::swapLeafData()</a>, and <a class="el" href="../../d9/ddd/classevio_1_1_base_structure.html#a165601aa2afb10063c6725a54b80f7b5">evio::BaseStructure::write()</a>.</p>

</div>
</div>
<a id="a465184e11d0b2902cf44b634e7c8e7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465184e11d0b2902cf44b634e7c8e7f7">&#9670;&nbsp;</a></span>swapData() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::CompositeData::swapData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>srcBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>destBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ifmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method converts (swaps) EVIO composite type data between Big endian and Little endian. </p>
<p>This data does <b>NOT</b> include the composite type's beginning tagsegment and the format string it contains. It also does <b>NOT</b> include the data's bank header words. Caller must be sure the endian value of the srcBuf is set properly before the call.</p>
<p>The destBuf can be the same as srcBuf in which case data is swapped in place and the srcBuf byte order is switched in this method. Swap starts at srcBuf's current position. If data is swapped in place, destBuf pos is set to srcBuf pos.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcBuf</td><td>source data buffer. </td></tr>
    <tr><td class="paramname">destBuf</td><td>destination data buffer. </td></tr>
    <tr><td class="paramname">nBytes</td><td>length of data to swap in bytes </td></tr>
    <tr><td class="paramname">ifmt</td><td>format list as produced by <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#abf415d7d278a0f0bff5945712cb3d258">compositeFormatToInt(const std::string &amp;, std::vector&lt;uint16_t&gt; &amp;)</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if ifmt empty or nBytes &lt; 8; srcBuf or destBuf limit/position combo too small; if src &amp; dest not identical but overlap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41f9c073bb8eb07f6c5bcb021effffa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f9c073bb8eb07f6c5bcb021effffa2">&#9670;&nbsp;</a></span>swapData() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::CompositeData::swapData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>srcBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>destBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>destPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ifmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method converts (swaps) EVIO composite type data between Big endian and Little endian. </p>
<p>This data does <b>NOT</b> include the composite type's beginning tagsegment and the format string it contains. It also does <b>NOT</b> include the data's bank header words. Caller must be sure the endian value of the srcBuf is set properly before the call.</p>
<p>The destBuf can be the same as srcBuf in which case data is swapped in place and the srcBuf byte order is switched in this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcBuf</td><td>source data buffer. </td></tr>
    <tr><td class="paramname">destBuf</td><td>destination data buffer. </td></tr>
    <tr><td class="paramname">srcPos</td><td>position in srcBuf to beginning swapping </td></tr>
    <tr><td class="paramname">destPos</td><td>position in destBuf to beginning writing swapped data unless data is swapped in place (then set to srcPos). </td></tr>
    <tr><td class="paramname">nBytes</td><td>length of data to swap in bytes (be sure to account for padding) </td></tr>
    <tr><td class="paramname">ifmt</td><td>format list as produced by <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#abf415d7d278a0f0bff5945712cb3d258">compositeFormatToInt(const std::string &amp;, std::vector&lt;uint16_t&gt; &amp;)</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if ifmt empty or nBytes &lt; 8; srcBuf or destBuf limit/position combo too small; if src &amp; dest not identical but overlap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a7ab62439d624c9951124f3e8cbfbaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7ab62439d624c9951124f3e8cbfbaf">&#9670;&nbsp;</a></span>swapData() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::CompositeData::swapData </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>iarr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nwrd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ifmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method converts (swaps) an array of EVIO composite type data between IEEE (big endian) and DECS (little endian) in place. </p>
<p>This data does <b>NOT</b> include the composite type's beginning tagsegment and the format string it contains. It also does <b>NOT</b> include the data's bank header words.</p>
<p>Converts the data of array (iarr[i], i=0...nwrd-1) using the format code (ifmt[j], j=0...nfmt-1) .</p>
<p>Algorithm description:</p>
<p><a class="el" href="../../d0/d19/classevio_1_1_composite_data_1_1_data.html" title="This class is used to provide all data when constructing a CompositeData object.">Data</a> processed inside while (ib &lt; nwrd) loop, where 'ib' is iarr[] index; loop breaks when 'ib' reaches the number of elements in iarr[]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iarr</td><td>pointer to data to be swapped. </td></tr>
    <tr><td class="paramname">nwrd</td><td>number of data words (32-bit ints) to be swapped. </td></tr>
    <tr><td class="paramname">ifmt</td><td>unsigned short vector holding translated format. </td></tr>
    <tr><td class="paramname">padding</td><td>number of bytes to ignore in last data word (starting from data end).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if ifmt empty or nwrd &lt; 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8471f9f68caf00e713970ef755de2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8471f9f68caf00e713970ef755de2dd">&#9670;&nbsp;</a></span>swapData() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::CompositeData::swapData </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nwrd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ifmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>padding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>srcIsLocal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method converts (swaps) EVIO composite type data between Big endian and Little endian. </p>
<p>This data does <b>NOT</b> include the composite type's beginning tagsegment and the format string it contains. It also does <b>NOT</b> include the data's bank header words. The dest can be the same as src in which case data is swapped in place.</p>
<p>Converts the data of array (src[i], i=0...nwrd-1) using the format code (ifmt[j], j=0...nfmt-1) .</p>
<p>Algorithm description:</p>
<p><a class="el" href="../../d0/d19/classevio_1_1_composite_data_1_1_data.html" title="This class is used to provide all data when constructing a CompositeData object.">Data</a> processed inside while (ib &lt; nwrd) loop, where 'ib' is src[] index; loop breaks when 'ib' reaches the number of elements in src[]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>data source data pointer. </td></tr>
    <tr><td class="paramname">dest</td><td>destination pointer or can be null if swapping in place. </td></tr>
    <tr><td class="paramname">nwrd</td><td>number of data words (32-bit ints) to be swapped. </td></tr>
    <tr><td class="paramname">ifmt</td><td>format list as produced by <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#abf415d7d278a0f0bff5945712cb3d258">compositeFormatToInt(const std::string &amp;, std::vector&lt;uint16_t&gt; &amp;)</a>. </td></tr>
    <tr><td class="paramname">padding</td><td>number of bytes to ignore in last data word (starting from data end). </td></tr>
    <tr><td class="paramname">srcIsLocal</td><td>true if src is local endian, else false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if ifmt empty or nwrd &lt; 2; src pointer is null; if src &amp; dest are not identical but overlap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adaa73ee1c055d2ae17fd0b927c12db9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa73ee1c055d2ae17fd0b927c12db9c">&#9670;&nbsp;</a></span>swapData() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void evio::CompositeData::swapData </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>srcBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>destBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>destPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ifmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method converts (swaps) EVIO composite type data between Big endian and Little endian. </p>
<p>This data does <b>NOT</b> include the composite type's beginning tagsegment and the format string it contains. It also does <b>NOT</b> include the data's bank header words. Caller must be sure the endian value of the srcBuf is set properly before the call.</p>
<p>The destBuf can be the same as srcBuf in which case data is swapped in place and the srcBuf byte order is switched in this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcBuf</td><td>source data buffer. </td></tr>
    <tr><td class="paramname">destBuf</td><td>destination data buffer. </td></tr>
    <tr><td class="paramname">srcPos</td><td>position in srcBuf to beginning swapping </td></tr>
    <tr><td class="paramname">destPos</td><td>position in destBuf to beginning writing swapped data unless data is swapped in place (then set to srcPos). </td></tr>
    <tr><td class="paramname">nBytes</td><td>length of data to swap in bytes (be sure to account for padding) </td></tr>
    <tr><td class="paramname">ifmt</td><td>format list as produced by <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html#abf415d7d278a0f0bff5945712cb3d258">compositeFormatToInt(const std::string &amp;, std::vector&lt;uint16_t&gt; &amp;)</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if ifmt empty or nBytes &lt; 8; srcBuf or destBuf limit/position combo too small; if src &amp; dest not identical but overlap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a867123b42afb4031262debfa4f5f3075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867123b42afb4031262debfa4f5f3075">&#9670;&nbsp;</a></span>toString() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string evio::CompositeData::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a string representation of the composite data. </p>
<dl class="section return"><dt>Returns</dt><dd>a string representation of the composite data. </dd></dl>

</div>
</div>
<a id="aaceb035845b0a7b47120d9797c8aebae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaceb035845b0a7b47120d9797c8aebae">&#9670;&nbsp;</a></span>toString() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string evio::CompositeData::toString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns a string representation of this <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> object suitable for displaying in org.jlab.coda.jevio.graphics.EventTreeFrame gui. </p>
<p>Each data item is separated from those before and after by a line. Non-parenthesis repeats are printed together.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hex</td><td>if <code>true</code> then print integers in hexadecimal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string representation of this <a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html" title="COMPOSITE DATA:">CompositeData</a> object. </dd></dl>

</div>
</div>
<a id="ac22cbe87e198afe3318679a5866803aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22cbe87e198afe3318679a5866803aa">&#9670;&nbsp;</a></span>toString() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string evio::CompositeData::toString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a string representation of the composite data. </p>
<p>This string has an indent inserted in front of each group of 5 items. After each group of 5, a newline is inserted. Useful for writing data in xml format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indent</td><td>a string to insert in front of each group of 5 items </td></tr>
    <tr><td class="paramname">hex</td><td>if true, display numbers in hexadecimal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string representation of the composite data. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="../../d6/d36/_composite_data_8h.html">CompositeData.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d9/deb/namespaceevio.html">evio</a></li><li class="navelem"><a class="el" href="../../d5/d4b/classevio_1_1_composite_data.html">CompositeData</a></li>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
