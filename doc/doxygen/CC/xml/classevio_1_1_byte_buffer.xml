<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.20" xml:lang="en-US">
  <compounddef id="classevio_1_1_byte_buffer" kind="class" language="C++" prot="public">
    <compoundname>evio::ByteBuffer</compoundname>
    <includes refid="_byte_buffer_8h" local="no">ByteBuffer.h</includes>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classevio_1_1_byte_buffer_1ae9542e4886512189c89306856bc50c15" prot="private" static="no" mutable="yes">
        <type>size_t</type>
        <definition>size_t evio::ByteBuffer::pos</definition>
        <argsstring></argsstring>
        <name>pos</name>
        <initializer>= 0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This is the current position in data buffer. Making it mutable means the value can be altered even if an object of this class is const. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="48" column="24" bodyfile="src/libsrc/ByteBuffer.h" bodystart="48" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classevio_1_1_byte_buffer_1a6ec37389c7974a12e8db8263a40283e6" prot="private" static="no" mutable="yes">
        <type>size_t</type>
        <definition>size_t evio::ByteBuffer::lim</definition>
        <argsstring></argsstring>
        <name>lim</name>
        <initializer>= 0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Limit is the position just past the last valid data byte. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="51" column="24" bodyfile="src/libsrc/ByteBuffer.h" bodystart="51" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classevio_1_1_byte_buffer_1a0a3a62e2c7825511cce3dea7300557a3" prot="private" static="no" mutable="yes">
        <type>ssize_t</type>
        <definition>ssize_t evio::ByteBuffer::mrk</definition>
        <argsstring></argsstring>
        <name>mrk</name>
        <initializer>= -1</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Mark is set to mark a position in the buffer. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="54" column="25" bodyfile="src/libsrc/ByteBuffer.h" bodystart="54" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classevio_1_1_byte_buffer_1aeeb577ac18593fe7608fe63fd3c29b5e" prot="private" static="no" mutable="no">
        <type>size_t</type>
        <definition>size_t evio::ByteBuffer::off</definition>
        <argsstring></argsstring>
        <name>off</name>
        <initializer>= 0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Offset is the offset into the buffer (used when calling <ref refid="classevio_1_1_byte_buffer_1a0cb359c2dc87ca43893c2e489d625ee8" kindref="member">slice()</ref>) at which position is defined to be 0. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="58" column="16" bodyfile="src/libsrc/ByteBuffer.h" bodystart="58" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classevio_1_1_byte_buffer_1ad2ff4aed1dc76efa1574c5a3a8445bb6" prot="private" static="no" mutable="no">
        <type>size_t</type>
        <definition>size_t evio::ByteBuffer::cap</definition>
        <argsstring></argsstring>
        <name>cap</name>
        <initializer>= 0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Capacity is the total size of this buffer&apos;s available data in bytes. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="61" column="16" bodyfile="src/libsrc/ByteBuffer.h" bodystart="61" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classevio_1_1_byte_buffer_1a13f23c358712a350917dd6b7b5ba0284" prot="private" static="no" mutable="no">
        <type>size_t</type>
        <definition>size_t evio::ByteBuffer::totalSize</definition>
        <argsstring></argsstring>
        <name>totalSize</name>
        <initializer>= 0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Total size is the original capacity of this buffer&apos;s available data in bytes when the initial <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> was created and without <ref refid="classevio_1_1_byte_buffer_1a0cb359c2dc87ca43893c2e489d625ee8" kindref="member">slice()</ref> having been called. If slice has been called, a new, and possibly smaller capacity has been set. We need to remember the original size in order to properly copy this object when necessary. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="68" column="16" bodyfile="src/libsrc/ByteBuffer.h" bodystart="68" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classevio_1_1_byte_buffer_1a9a57015e3032c286dfb3ee1b9cbce6aa" prot="private" static="no" mutable="no">
        <type>std::shared_ptr&lt; uint8_t &gt;</type>
        <definition>std::shared_ptr&lt;uint8_t&gt; evio::ByteBuffer::buf</definition>
        <argsstring></argsstring>
        <name>buf</name>
        <initializer>= nullptr</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This buffer is implemented with an array. Has shared pointer access in order to implement the <ref refid="classevio_1_1_byte_buffer_1aab31b6bac664b8cf8bd9dbba1d319045" kindref="member">duplicate()</ref> method. Note that a shared pointer to vector is not used since in one constructor, the underlying array is passed in as an arg. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="74" column="25" bodyfile="src/libsrc/ByteBuffer.h" bodystart="74" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classevio_1_1_byte_buffer_1ab3e07fdbeb88cf4f0790a3c656bd1c45" prot="private" static="no" mutable="no">
        <type><ref refid="classevio_1_1_byte_order" kindref="compound">ByteOrder</ref></type>
        <definition>ByteOrder evio::ByteBuffer::byteOrder</definition>
        <argsstring></argsstring>
        <name>byteOrder</name>
        <initializer>{<ref refid="classevio_1_1_byte_order_1ae4055f708921d4e6540ab4662d27147c" kindref="member">ByteOrder::ENDIAN_LOCAL</ref>}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Byte order of data. In java, default is big endian. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="77" column="19" bodyfile="src/libsrc/ByteBuffer.h" bodystart="77" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classevio_1_1_byte_buffer_1a82254bedbea33c36b56c69e6a92bcdd4" prot="private" static="no" mutable="no">
        <type>bool</type>
        <definition>bool evio::ByteBuffer::isHostEndian</definition>
        <argsstring></argsstring>
        <name>isHostEndian</name>
        <initializer>= false</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Is the data the same endian as the host? Convenience variable. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="80" column="14" bodyfile="src/libsrc/ByteBuffer.h" bodystart="80" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classevio_1_1_byte_buffer_1a9a27c5c5aebe2bea21de96747b4bab5a" prot="private" static="no" mutable="no">
        <type>bool</type>
        <definition>bool evio::ByteBuffer::isLittleEndian</definition>
        <argsstring></argsstring>
        <name>isLittleEndian</name>
        <initializer>= false</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Is the data little endian? Convenience variable. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="83" column="14" bodyfile="src/libsrc/ByteBuffer.h" bodystart="83" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classevio_1_1_byte_buffer_1ae91cbc6297d2f687e902de4be8559ef8" prot="private" static="no" mutable="no">
        <type>bool</type>
        <definition>bool evio::ByteBuffer::isMappedMemory</definition>
        <argsstring></argsstring>
        <name>isMappedMemory</name>
        <initializer>= false</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Is the pointer pased to the constructor pointed to file mapped memory? I.e. does it need to be unmapped by destructor? </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="88" column="14" bodyfile="src/libsrc/ByteBuffer.h" bodystart="88" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a21a35de5b7fe72d9bc695d07ed9787ba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>evio::ByteBuffer::ByteBuffer</definition>
        <argsstring>()</argsstring>
        <name>ByteBuffer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Default constructor, size of 4096 bytes. <linebreak/>
 </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="92" column="9" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="22" bodyend="22"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a9ebf5183862cb118242a27dfca41e0e4" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>evio::ByteBuffer::ByteBuffer</definition>
        <argsstring>(size_t size)</argsstring>
        <name>ByteBuffer</name>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Constructor. Reserves specified size in internal array. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>size (in bytes) of space to preallocate internally. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="93" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="29" bodyend="37"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a6aee163fd7b9fc5fc6365ec6c80bb16e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>evio::ByteBuffer::ByteBuffer</definition>
        <argsstring>(const ByteBuffer &amp;srcBuf)</argsstring>
        <name>ByteBuffer</name>
        <param>
          <type>const <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
          <declname>srcBuf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copy constructor. Not available in Java, but useful in C++. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>srcBuf</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> to copy. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="94" column="9" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="44" bodyend="46"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a57526704c3701fdabe67cdfb7ac79abd" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>evio::ByteBuffer::ByteBuffer</definition>
        <argsstring>(ByteBuffer &amp;&amp;srcBuf) noexcept</argsstring>
        <name>ByteBuffer</name>
        <param>
          <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;&amp;</type>
          <declname>srcBuf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Move constructor. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>srcBuf</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> to move. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="95" column="9" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="53" bodyend="57"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a7146d4da4460b561c97aed8a914870cf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>evio::ByteBuffer::ByteBuffer</definition>
        <argsstring>(char *byteArray, size_t len, bool isMappedMem=false)</argsstring>
        <name>ByteBuffer</name>
        <param>
          <type>char *</type>
          <declname>byteArray</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>len</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>isMappedMem</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This constructor is equivalent to the ByteBuffer.wrap() method in Java.</para>
<para>The byteArray arg needs to be created as a result to calling &quot;new&quot; as it&apos;s made part of a shared pointer! There is also some risk here if caller continues to use byteArray pointer independently of this object. <bold>Don&apos;t do it!</bold></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>byteArray</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to array which this object will wrap. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>len</parametername>
</parameternamelist>
<parameterdescription>
<para>length of array in bytes. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>isMappedMem</parametername>
</parameternamelist>
<parameterdescription>
<para>is the byteArray arg a pointer obtained through mmap (file memory mapping)?. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="96" column="9" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="72" bodyend="74"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a8c574342930aa9f1538ac075e6c9c290" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>evio::ByteBuffer::ByteBuffer</definition>
        <argsstring>(uint8_t *byteArray, size_t len, bool isMappedMem=false)</argsstring>
        <name>ByteBuffer</name>
        <param>
          <type>uint8_t *</type>
          <declname>byteArray</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>len</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>isMappedMem</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This constructor is equivalent to the ByteBuffer.wrap() method in Java.</para>
<para>The byteArray arg needs to be created as a result to calling &quot;new&quot; as it&apos;s made part of a shared pointer! There is also some risk here if caller continues to use byteArray pointer independently of this object. <bold>Don&apos;t do it!</bold></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>byteArray</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to array which this object will wrap. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>len</parametername>
</parameternamelist>
<parameterdescription>
<para>length of array in bytes. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>isMappedMem</parametername>
</parameternamelist>
<parameterdescription>
<para>is the byteArray arg a pointer obtained through mmap (file memory mapping)?. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="97" column="9" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="89" bodyend="104"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1af9ec8f0b3b128d1ac3d0c7f8929c65c4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>evio::ByteBuffer::~ByteBuffer</definition>
        <argsstring>()</argsstring>
        <name>~ByteBuffer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Destructor. Be sure to unmap any memory mapped file. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="99" column="9" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="108" bodyend="113"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a06e9cde40e38a126d4ff6be6eec6b521" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool evio::ByteBuffer::operator==</definition>
        <argsstring>(const ByteBuffer &amp;rhs) noexcept</argsstring>
        <name>operator==</name>
        <param>
          <type>const <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Equality operator. Way of checking if the 2 buffers are pointing to the same data. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rhs</parametername>
</parameternamelist>
<parameterdescription>
<para>right side object. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if equal. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="101" column="14" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="180" bodyend="182"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a6248ee54a6d862b6ba10be3c9487594f" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool evio::ByteBuffer::operator!=</definition>
        <argsstring>(const ByteBuffer &amp;rhs) noexcept</argsstring>
        <name>operator!=</name>
        <param>
          <type>const <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Inequality operator. Way of checking if the 2 buffers are not pointing to the same data. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rhs</parametername>
</parameternamelist>
<parameterdescription>
<para>right side object. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>false if equal. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="102" column="14" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="191" bodyend="193"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a1fb10fe73d64976534fc05f858f3fd8d" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::operator=</definition>
        <argsstring>(ByteBuffer &amp;&amp;other) noexcept</argsstring>
        <name>operator=</name>
        <param>
          <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;&amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Move assignment operator. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>other</parametername>
</parameternamelist>
<parameterdescription>
<para>right side object. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>left side object. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="103" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="121" bodyend="145"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a7a2fe124866819be3ab9d721533c7e25" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::operator=</definition>
        <argsstring>(const ByteBuffer &amp;other)</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Assignment operator. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>other</parametername>
</parameternamelist>
<parameterdescription>
<para>right side object. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>left side object. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="104" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="153" bodyend="171"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a881fa9f9c9d29c76fe2f767aba9de1dc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>uint8_t &amp;</type>
        <definition>uint8_t &amp; evio::ByteBuffer::operator[]</definition>
        <argsstring>(size_t index)</argsstring>
        <name>operator[]</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Subscript operator for absolute access to data bytes without limit check. This has no Java counterpart. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>index into internal data vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>reference to internal byte in data vector at the given index. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="105" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="202" bodyend="204"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a2444abec9d57c10b1eff8e1dcdc0b4ff" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>uint8_t</type>
        <definition>uint8_t evio::ByteBuffer::operator[]</definition>
        <argsstring>(size_t index) const</argsstring>
        <name>operator[]</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Subscript operator for absolute access to data bytes of const ByteBuffers without limit check. This has no Java counterpart. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>index into internal data vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>reference to internal byte in data vector at the given index. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="106" column="22" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="213" bodyend="215"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a76149a2cbcf34ff02edfb7a0e106abf5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::compact</definition>
        <argsstring>()</argsstring>
        <name>compact</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This method compacts this buffer. The bytes between the buffer&apos;s position and its limit, if any, are copied to the beginning of the buffer. That is, the byte at index p = <ref refid="classevio_1_1_byte_buffer_1a88f84e6b1757db70542eac13294fc80e" kindref="member">position()</ref> is copied to index zero, the byte at index p + 1 is copied to index one, and so forth until the byte at index <ref refid="classevio_1_1_byte_buffer_1afb08d1dbc5fbf780afd27617a67eb750" kindref="member">limit()</ref> - 1 is copied to index n = <ref refid="classevio_1_1_byte_buffer_1afb08d1dbc5fbf780afd27617a67eb750" kindref="member">limit()</ref> - 1 - p. The buffer&apos;s position is then set to n+1 and its limit is set to its capacity. The mark, if defined, is discarded. The buffer&apos;s position is set to the number of bytes copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative put method.</para>
<para><simplesect kind="return"><para>reference to this <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="107" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="339" bodyend="373"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a3c003df1d0c570105762f192c1719a38" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::zero</definition>
        <argsstring>()</argsstring>
        <name>zero</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This method writes zeroes into the buffer memory (from pos = 0 to capacity). If this <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> was obtained through calling <ref refid="classevio_1_1_byte_buffer_1a7ba11eafdb29604bdfbd4ee0a339be4b" kindref="member">slice</ref>, the underlying data array may not be fully zeroed as position = 0 may occur at a non-zero offset and the capacity may be less than the array&apos;s total size. Although this method does not exist in the original Java <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> class, in Java, all objects have their memory zeroed so this may be useful.</para>
<para><simplesect kind="return"><para>reference to this <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="108" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="319" bodyend="322"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1aa5e949edce35266d7f5fdbf958c5906c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void evio::ByteBuffer::copyData</definition>
        <argsstring>(const std::shared_ptr&lt; const ByteBuffer &gt; &amp;srcBuf, size_t pos, size_t limit)</argsstring>
        <name>copyData</name>
        <param>
          <type>const std::shared_ptr&lt; const <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &gt; &amp;</type>
          <declname>srcBuf</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>pos</declname>
          <defname>position</defname>
        </param>
        <param>
          <type>size_t</type>
          <declname>limit</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copy the source buffer&apos;s data (position to limit) into this buffer starting at local position 0. Limit and capacity are set to the &quot;limit - position&quot; bytes of srcBuf. This can reallocate memory if more is needed and can therefore resize this buffer. Existing data in this buffer will be overwritten. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>srcBuf</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> to copy data from. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>position</parametername>
</parameternamelist>
<parameterdescription>
<para>position in srcByf to start from. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>limit</parametername>
</parameternamelist>
<parameterdescription>
<para>position in srcByf to end at. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="111" column="14" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="283" bodyend="306"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a4ebef95e32ea1879af124171c45f2c1a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void evio::ByteBuffer::copy</definition>
        <argsstring>(const ByteBuffer &amp;srcBuf)</argsstring>
        <name>copy</name>
        <param>
          <type>const <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
          <declname>srcBuf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copy data and everything else from arg. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>srcBuf</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> to copy. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="112" column="14" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="222" bodyend="240"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a28778844f5a9fb1eaf40e955086b7fd7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void evio::ByteBuffer::copy</definition>
        <argsstring>(const std::shared_ptr&lt; const ByteBuffer &gt; &amp;srcBuf)</argsstring>
        <name>copy</name>
        <param>
          <type>const std::shared_ptr&lt; const <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &gt; &amp;</type>
          <declname>srcBuf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copy data and everything else from arg. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>srcBuf</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> to copy. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="113" column="14" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="247" bodyend="249"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a7ef866cbbf1604a31d7f6920bf89a173" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool evio::ByteBuffer::equals</definition>
        <argsstring>(const ByteBuffer &amp;other)</argsstring>
        <name>equals</name>
        <param>
          <type>const <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This method tests for data equivilancy. Two byte buffers are equal if, and only if, they have the same number of remaining elements, and the two sequences of remaining elements, considered independently of their starting positions, are pointwise equal.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>other</parametername>
</parameternamelist>
<parameterdescription>
<para>A reference to a <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> to compare to this one </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the internal buffers match, otherwise False. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="114" column="14" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="411" bodyend="428"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1ac07ae24bab386451176df095a376d330" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void evio::ByteBuffer::expand</definition>
        <argsstring>(size_t newSize)</argsstring>
        <name>expand</name>
        <param>
          <type>size_t</type>
          <declname>newSize</declname>
          <defname>size</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This method expands the size of this buffer if it&apos;s less than the given size. Note that all ByteBuffers that currently share memory with this object, either through being assigned, by calling <ref refid="classevio_1_1_byte_buffer_1a769cd08ef3d2320b1f21d33c528dc054" kindref="member">duplicate</ref>, or by calling <ref refid="classevio_1_1_byte_buffer_1a7ba11eafdb29604bdfbd4ee0a339be4b" kindref="member">slice</ref>, will no longer share memory. New memory is allocated. Useful in C++, but has no counterpart in Java. Bytes up to limit are copied. New memory past limit is not zeroed. All other internals are kept the same, including all data within the limit. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>new size (in bytes) of space to allocate internally. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="115" column="14" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="386" bodyend="400"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a5a0d7cac7719263bc39be8e6aed0fffb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool evio::ByteBuffer::isDirect</definition>
        <argsstring>() const</argsstring>
        <name>isDirect</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This method has no relevance to this C++ library. This always returns false since it is backed by an array. <simplesect kind="return"><para>false. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="117" column="14" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="436" bodyend="436"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a39605fc83d34737d5b78b36cb37f32fb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool evio::ByteBuffer::hasArray</definition>
        <argsstring>() const</argsstring>
        <name>hasArray</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Tells whether or not this buffer is backed by an array. This always returns true since it is backed by an array. <simplesect kind="return"><para>true. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="118" column="14" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="444" bodyend="444"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a355a856eaf702e4a804ee94752e3cc46" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool evio::ByteBuffer::hasRemaining</definition>
        <argsstring>() const</argsstring>
        <name>hasRemaining</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns whether there are bytes remaining between the position and limit, i.e. <ref refid="classevio_1_1_byte_buffer_1a88f84e6b1757db70542eac13294fc80e" kindref="member">position()</ref> &lt; <ref refid="classevio_1_1_byte_buffer_1afb08d1dbc5fbf780afd27617a67eb750" kindref="member">limit()</ref>. <simplesect kind="return"><para>position &lt; limit. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="119" column="14" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="452" bodyend="452"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a4c9251c141f20b99410106fd4d4df3b8" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool evio::ByteBuffer::isReadOnly</definition>
        <argsstring>() const</argsstring>
        <name>isReadOnly</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns whether this buffer is read only. Always returns false; <simplesect kind="return"><para>false. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="120" column="14" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="459" bodyend="459"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a3d5f0120189717ffc8d2d480d89cb91a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classevio_1_1_byte_order" kindref="compound">ByteOrder</ref> &amp;</type>
        <definition>const ByteOrder &amp; evio::ByteBuffer::order</definition>
        <argsstring>() const</argsstring>
        <name>order</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the byte order of the data. <simplesect kind="return"><para>byte order of the data. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="121" column="26" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="466" bodyend="466"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1aa0e335238a57eaa0bffee8f968e5995f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>uint8_t *</type>
        <definition>uint8_t * evio::ByteBuffer::array</definition>
        <argsstring>() const</argsstring>
        <name>array</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get a pointer to this buffer&apos;s backing array which contains the data. Note, there may be a non-zero offset which can be found by calling <ref refid="classevio_1_1_byte_buffer_1abf7abf99aa7544601997f40eba298648" kindref="member">arrayOffset</ref>. Do not free or delete this array! <simplesect kind="return"><para>pointer to the data array. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="122" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="475" bodyend="475"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1aa8572a89b0b6adacd3363c4fcda258eb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; uint8_t &gt;</type>
        <definition>std::shared_ptr&lt; uint8_t &gt; evio::ByteBuffer::getData</definition>
        <argsstring>() const</argsstring>
        <name>getData</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get a shared pointer to this buffer&apos;s backing array which contains the data. Note, there may be a non-zero offset which can be found by calling <ref refid="classevio_1_1_byte_buffer_1abf7abf99aa7544601997f40eba298648" kindref="member">arrayOffset</ref>. <simplesect kind="return"><para>shared pointer to the data array. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="123" column="25" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="483" bodyend="483"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1abf7abf99aa7544601997f40eba298648" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t evio::ByteBuffer::arrayOffset</definition>
        <argsstring>() const</argsstring>
        <name>arrayOffset</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the offset within this buffer&apos;s backing array of the first element of the buffer. <simplesect kind="return"><para>offset within this buffer&apos;s backing array of the first element of the buffer. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="125" column="16" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="490" bodyend="490"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a32b043081cd3a62187f2577ce2966e7d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t evio::ByteBuffer::remaining</definition>
        <argsstring>() const</argsstring>
        <name>remaining</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the number of bytes from the current position to the end of the data. <simplesect kind="return"><para>Number of bytes from position(<ref refid="classevio_1_1_byte_buffer_1a88f84e6b1757db70542eac13294fc80e" kindref="member">position()</ref>) to the end (<ref refid="classevio_1_1_byte_buffer_1afb08d1dbc5fbf780afd27617a67eb750" kindref="member">limit()</ref>). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="126" column="16" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="497" bodyend="497"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a6496a99b06b5ed67b8c93b148fd87323" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t evio::ByteBuffer::capacity</definition>
        <argsstring>() const</argsstring>
        <name>capacity</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the total available bytes in this buffer. <simplesect kind="return"><para>the total available bytes in this buffer. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="127" column="16" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="504" bodyend="504"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1afb08d1dbc5fbf780afd27617a67eb750" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t evio::ByteBuffer::limit</definition>
        <argsstring>() const</argsstring>
        <name>limit</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the limit, the position of the last valid data byte. <simplesect kind="return"><para>the position of the last valid data byte. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="128" column="16" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="511" bodyend="511"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a88f84e6b1757db70542eac13294fc80e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t evio::ByteBuffer::position</definition>
        <argsstring>() const</argsstring>
        <name>position</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the position of the buffer. <simplesect kind="return"><para>the position of the buffer. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="129" column="16" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="518" bodyend="518"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a0b0efc8946d9db1c2a4c2864702bd00c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::mark</definition>
        <argsstring>()</argsstring>
        <name>mark</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sets the buffer&apos;s mark at its position. <simplesect kind="return"><para>this buffer. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="131" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="525" bodyend="528"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a11a85b28fd30c969f567c8c7f5848275" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::clear</definition>
        <argsstring>()</argsstring>
        <name>clear</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Clears this buffer. The position is set to 0, the limit is set to the capacity, and the mark is discarded. Data remains untouched. <simplesect kind="return"><para>this buffer. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="132" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="536" bodyend="541"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1aed6fb0a09f6320dfc89196e6c7d03191" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::flip</definition>
        <argsstring>()</argsstring>
        <name>flip</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Flips this buffer. The limit is set to the current position and then the position is set to 0. The mark is discarded. Gets buffer ready for reading. <simplesect kind="return"><para>this buffer. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="133" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="549" bodyend="554"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a78a69a5db426df0ecdc994874219a2cd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::reset</definition>
        <argsstring>()</argsstring>
        <name>reset</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Resets this buffer&apos;s position to the previously-marked position. <simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername><ref refid="classevio_1_1_evio_exception" kindref="compound">EvioException</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>if mark &lt; 0. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="134" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="562" bodyend="569"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1af153687725d1aff72fac2c28aaee70d8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::rewind</definition>
        <argsstring>()</argsstring>
        <name>rewind</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Rewinds this buffer. The position is set to 0 and the mark is discarded. <simplesect kind="return"><para>this buffer. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="135" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="576" bodyend="580"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a8d6c9a521a64e6fb5ee3eef3b4288abd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::position</definition>
        <argsstring>(size_t p)</argsstring>
        <name>position</name>
        <param>
          <type>size_t</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sets the position of the buffer. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>position of the buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername><ref refid="classevio_1_1_evio_exception" kindref="compound">EvioException</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>if p &gt; capacity. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="136" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="589" bodyend="598"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a22a6d6c228004b1c0156143e43d16991" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::limit</definition>
        <argsstring>(size_t l)</argsstring>
        <name>limit</name>
        <param>
          <type>size_t</type>
          <declname>l</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sets the limit of the buffer. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>l</parametername>
</parameternamelist>
<parameterdescription>
<para>limit of the buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername><ref refid="classevio_1_1_evio_exception" kindref="compound">EvioException</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>if l &gt; capacity. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="137" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="607" bodyend="621"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a424b67644964be8ca45eb6d4060fd8b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::order</definition>
        <argsstring>(ByteOrder const &amp;order)</argsstring>
        <name>order</name>
        <param>
          <type><ref refid="classevio_1_1_byte_order" kindref="compound">ByteOrder</ref> const &amp;</type>
          <declname>order</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sets the byte order of the data. It does <bold>NOT</bold> do any byte swapping. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>order</parametername>
</parameternamelist>
<parameterdescription>
<para>actual byte order of the data. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="139" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="629" bodyend="634"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a769cd08ef3d2320b1f21d33c528dc054" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::duplicate</definition>
        <argsstring>(ByteBuffer &amp;destBuf)</argsstring>
        <name>duplicate</name>
        <param>
          <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
          <declname>destBuf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns a byte buffer that shares this buffer&apos;s content.</para>
<para>The content of the returned buffer will be that of this buffer. Changes to this buffer&apos;s content will be visible in the returned buffer, and vice versa; the two buffers&apos; position, limit, and mark values will be independent.</para>
<para>The returned buffer&apos;s capacity, limit, position, and mark values will initially be identical to those of this buffer. </para>
<para>The C++ version of this method departs from the Java which has no argument. To implement this method, one could return a unique pointer to a locally created <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> object which would eliminate the need for an argument. However, handling the new buffer would be different from handling those created by the constructor since the caller would have a unique pointer instead of a <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> reference.</para>
<para>A cleaner way to do this is for the caller to create their own, new <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> object and pass it in as an argument. This method then makes it identical to this buffer and the data (implemented as a shared pointer) is shared between the objects. The buffer passed in as an argument is also the one returned.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>destBuf</parametername>
</parameternamelist>
<parameterdescription>
<para>byte buffer to be made a duplicate of this one. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the same byte buffer as passed in as the argument. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="140" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="662" bodyend="677"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a647bf609c9b5c19403938ef2bbe7f0bc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &gt; &amp;</type>
        <definition>std::shared_ptr&lt; ByteBuffer &gt; &amp; evio::ByteBuffer::duplicate</definition>
        <argsstring>(std::shared_ptr&lt; ByteBuffer &gt; &amp;destBuf)</argsstring>
        <name>duplicate</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &gt; &amp;</type>
          <declname>destBuf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns a byte buffer that shares this buffer&apos;s content.</para>
<para>The content of the returned buffer will be that of this buffer. Changes to this buffer&apos;s content will be visible in the returned buffer, and vice versa; the two buffers&apos; position, limit, and mark values will be independent.</para>
<para>The returned buffer&apos;s capacity, limit, position, and mark values will initially be identical to those of this buffer. </para>
<para>The C++ version of this method departs from the Java which has no argument. To implement this method, one could return a unique pointer to a locally created <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> object which would eliminate the need for an argument. However, handling the new buffer would be different from handling those created by the constructor since the caller would have a unique pointer instead of a <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> reference.</para>
<para>A cleaner way to do this is for the caller to create their own, new <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> object and pass it in as an argument. This method then makes it identical to this buffer and the data (implemented as a shared pointer) is shared between the objects. The buffer passed in as an argument is also the one returned.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>destBuf</parametername>
</parameternamelist>
<parameterdescription>
<para>byte buffer to be made a duplicate of this one. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the same byte buffer as passed in as the argument. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="141" column="26" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="705" bodyend="709"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1aab31b6bac664b8cf8bd9dbba1d319045" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &gt;</type>
        <definition>std::shared_ptr&lt; ByteBuffer &gt; evio::ByteBuffer::duplicate</definition>
        <argsstring>()</argsstring>
        <name>duplicate</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns a byte buffer that shares this buffer&apos;s content.</para>
<para>The content of the returned buffer will be that of this buffer. Changes to this buffer&apos;s content will be visible in the returned buffer, and vice versa; the two buffers&apos; position, limit, and mark values will be independent.</para>
<para>The returned buffer&apos;s capacity, limit, position, and mark values will initially be identical to those of this buffer. </para>
<para>The C++ version of this method departs from the Java which has no argument. To implement this method, one could return a unique pointer to a locally created <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> object which would eliminate the need for an argument. However, handling the new buffer would be different from handling those created by the constructor since the caller would have a unique pointer instead of a <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> reference.</para>
<para>A cleaner way to do this is for the caller to create their own, new <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> object and pass it in as an argument. This method then makes it identical to this buffer and the data (implemented as a shared pointer) is shared between the objects. The buffer passed in as an argument is also the one returned.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>destBuf</parametername>
</parameternamelist>
<parameterdescription>
<para>byte buffer to be made a duplicate of this one. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the same byte buffer as passed in as the argument. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="142" column="25" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="737" bodyend="752"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a7ba11eafdb29604bdfbd4ee0a339be4b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::slice</definition>
        <argsstring>(ByteBuffer &amp;destBuf)</argsstring>
        <name>slice</name>
        <param>
          <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
          <declname>destBuf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The given (and returned) byte buffer is one whose content is a shared subsequence of this buffer&apos;s content.</para>
<para>The content of the given buffer will start at this buffer&apos;s current position. Changes to this buffer&apos;s content will be visible in the given buffer, and vice versa; the two buffers&apos; position, limit, and mark values will be independent.</para>
<para>The given buffer&apos;s position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, and its mark will be undefined.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>destBuf</parametername>
</parameternamelist>
<parameterdescription>
<para>byte buffer to be made a slice of this one. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the same byte buffer as passed in as the argument. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="143" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="808" bodyend="826"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1ae07e0ddf47ddb91406631f1ac513a9e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &gt; &amp;</type>
        <definition>std::shared_ptr&lt; ByteBuffer &gt; &amp; evio::ByteBuffer::slice</definition>
        <argsstring>(std::shared_ptr&lt; ByteBuffer &gt; &amp;destBuf)</argsstring>
        <name>slice</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &gt; &amp;</type>
          <declname>destBuf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The given (and returned) byte buffer is one whose content is a shared subsequence of this buffer&apos;s content.</para>
<para>The content of the given buffer will start at this buffer&apos;s current position. Changes to this buffer&apos;s content will be visible in the given buffer, and vice versa; the two buffers&apos; position, limit, and mark values will be independent.</para>
<para>The given buffer&apos;s position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, and its mark will be undefined.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>destBuf</parametername>
</parameternamelist>
<parameterdescription>
<para>byte buffer to be made a slice of this one. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the same byte buffer as passed in as the argument. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="144" column="26" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="845" bodyend="849"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a0cb359c2dc87ca43893c2e489d625ee8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &gt;</type>
        <definition>std::shared_ptr&lt; ByteBuffer &gt; evio::ByteBuffer::slice</definition>
        <argsstring>()</argsstring>
        <name>slice</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a new byte buffer whose content is a shared subsequence of this buffer&apos;s content.</para>
<para>The content of the new buffer will start at this buffer&apos;s current position. Changes to this buffer&apos;s content will be visible in the new buffer, and vice versa; the two buffers&apos; position, limit, and mark values will be independent.</para>
<para>The new buffer&apos;s position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, and its mark will be undefined.</para>
<para><simplesect kind="return"><para>The new byte buffer. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="145" column="25" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="770" bodyend="789"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a1b23b4b4951162b9fd09453735ee71ee" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>const ByteBuffer &amp; evio::ByteBuffer::getBytes</definition>
        <argsstring>(uint8_t *dst, size_t length) const</argsstring>
        <name>getBytes</name>
        <param>
          <type>uint8_t *</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>length</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative bulk <emphasis>get</emphasis> method.</para>
<para>This method transfers bytes from this buffer into the given destination array. If there are fewer bytes remaining in the buffer than are required to satisfy the request, then no bytes are transferred and an underflow_error is thrown.</para>
<para>Otherwise, this method copies <computeroutput>length</computeroutput> bytes from this buffer into the given array, starting at the current position of this buffer and at the given pointer. The position of this buffer is then incremented by <computeroutput>length</computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>array into which bytes are to be written. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>number of bytes to be written to the given array; must be no larger than dst size - offset. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if fewer than <computeroutput>length</computeroutput> bytes remaining in buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="149" column="27" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="877" bodyend="885"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1adb57510fe193a79746eb5c4f35d1a01f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>const ByteBuffer &amp; evio::ByteBuffer::getBytes</definition>
        <argsstring>(std::vector&lt; uint8_t &gt; &amp;dst, size_t offset, size_t length) const</argsstring>
        <name>getBytes</name>
        <param>
          <type>std::vector&lt; uint8_t &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>length</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative bulk <emphasis>get</emphasis> method.</para>
<para>This method transfers bytes from this buffer into the given destination vector. If there are fewer bytes remaining in the buffer than are required to satisfy the request, then no bytes are transferred and an underflow_error is thrown.</para>
<para>Otherwise, this method copies <computeroutput>length</computeroutput> bytes from this buffer into the given array, starting at the current position of this buffer and at the given offset in the array. The position of this buffer is then incremented by <computeroutput>length</computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>vector into which bytes are to be written. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>offset (bytes) within the vector of the first byte to be written. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>number of bytes to be written to the given vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if fewer than <computeroutput>length</computeroutput> bytes remaining in buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="150" column="27" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="907" bodyend="916"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a59b9183ed5119a8cf8051bf01ea91734" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>uint8_t</type>
        <definition>uint8_t evio::ByteBuffer::peek</definition>
        <argsstring>() const</argsstring>
        <name>peek</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative <emphasis>get</emphasis> method. Reads the byte at this buffer&apos;s current position, but does not increments the position.</para>
<para><simplesect kind="return"><para>byte at buffer&apos;s current position. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if buffer&apos;s current position is not smaller than its limit. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="152" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="926" bodyend="926"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a822845f421867ea1e93993f749c0d056" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>uint8_t</type>
        <definition>uint8_t evio::ByteBuffer::getByte</definition>
        <argsstring>() const</argsstring>
        <name>getByte</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative <emphasis>get</emphasis> method. Reads the byte at this buffer&apos;s current position, and then increments the position.</para>
<para><simplesect kind="return"><para>byte at buffer&apos;s current position. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if buffer&apos;s current position is not smaller than its limit. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="153" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="936" bodyend="936"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1aea41d062520e973c301e4e42201ed0af" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>uint8_t</type>
        <definition>uint8_t evio::ByteBuffer::getByte</definition>
        <argsstring>(size_t index) const</argsstring>
        <name>getByte</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Absolute <emphasis>get</emphasis> method. Reads the byte at the given index.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>index from which the byte will be read </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>byte at the given index </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if index is not smaller than buffer&apos;s limit. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="154" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="946" bodyend="946"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a4d8c5becf53b830e5b4b0f8a953d3092" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>wchar_t</type>
        <definition>wchar_t evio::ByteBuffer::getChar</definition>
        <argsstring>() const</argsstring>
        <name>getChar</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative <emphasis>get</emphasis> method for reading a 16-bit unicode character value which is by nature unsigned. Keeping the name as &quot;getChar&quot; makes it compatible with Java, but be aware it does NOT get a 8-bit &quot;char&quot; type. This method reads the next two bytes at this buffer&apos;s current position, composing them into a wchar_t value according to the current byte order, and then increments the position by two.</para>
<para><simplesect kind="return"><para>wchar_t value at buffer&apos;s current position </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if fewer than two bytes remaining in buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="156" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="961" bodyend="961"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1aad1fd77bbfc86cc6df5856e63687ed83" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>wchar_t</type>
        <definition>wchar_t evio::ByteBuffer::getChar</definition>
        <argsstring>(size_t index) const</argsstring>
        <name>getChar</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Absolute <emphasis>get</emphasis> method for reading a 16-bit unicode character value which is by nature unsigned. Reads at the given index. Keeping the name as &quot;getChar&quot; makes it compatible with Java, but be aware it does NOT get a 8-bit &quot;char&quot; type. This method reads the next two bytes at the given index, composing them into a wchar_t value according to the current byte order, and then increments the position by two.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>index from which the bytes will be read. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>wchar_t value at the given index. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if fewer than two bytes remaining in buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="157" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="977" bodyend="977"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a52ce23d6735060439f6e3965b866247e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int16_t</type>
        <definition>int16_t evio::ByteBuffer::getShort</definition>
        <argsstring>() const</argsstring>
        <name>getShort</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative <emphasis>get</emphasis> method for reading a short value. Reads the next two bytes at this buffer&apos;s current position, composing them into a short value according to the current byte order, and then increments the position by two.</para>
<para><simplesect kind="return"><para>short value at buffer&apos;s current position. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if fewer than two bytes remaining in buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="159" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="989" bodyend="998"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1af38ed12e610a90edddc20eb4d4a72fc2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int16_t</type>
        <definition>int16_t evio::ByteBuffer::getShort</definition>
        <argsstring>(size_t index) const</argsstring>
        <name>getShort</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Absolute <emphasis>get</emphasis> method for reading a short value. Reads two bytes at the given index, composing them into a short value according to the current byte order.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>index from which the bytes will be read. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>short value at the given index. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if <computeroutput>index</computeroutput> is not smaller than buffer&apos;s limit, minus one. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="160" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1011" bodyend="1019"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a58f0bd2a0bf3263be899445c0c3de757" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>uint16_t</type>
        <definition>uint16_t evio::ByteBuffer::getUShort</definition>
        <argsstring>() const</argsstring>
        <name>getUShort</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative <emphasis>get</emphasis> method for reading an unsigned short value. Reads the next two bytes at this buffer&apos;s current position, composing them into an unsigned short value according to the current byte order, and then increments the position by two.</para>
<para>This method is not defined in the Java version.</para>
<para><simplesect kind="return"><para>unsigned short value at buffer&apos;s current position. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if fewer than two bytes remaining in buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="161" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1032" bodyend="1040"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a9f0a1ce0012cefa29867fdaedc7cb86a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>uint16_t</type>
        <definition>uint16_t evio::ByteBuffer::getUShort</definition>
        <argsstring>(size_t index) const</argsstring>
        <name>getUShort</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Absolute <emphasis>get</emphasis> method for reading an unsigned short value. Reads two bytes at the given index, composing them into an unsigned short value according to the current byte order.</para>
<para>This method is not defined in the Java version.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>index from which the bytes will be read. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>unsigned short value at the given index. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if <computeroutput>index</computeroutput> is not smaller than buffer&apos;s limit, minus one. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="162" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1054" bodyend="1062"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a01783f61f04c093b71f58cd1adbde2fa" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int32_t</type>
        <definition>int32_t evio::ByteBuffer::getInt</definition>
        <argsstring>() const</argsstring>
        <name>getInt</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative <emphasis>get</emphasis> method for reading an int value. Reads the next four bytes at this buffer&apos;s current position, composing them into an int value according to the current byte order, and then increments the position by four.</para>
<para><simplesect kind="return"><para>int value at buffer&apos;s current position. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if fewer than four bytes remaining in buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="164" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1074" bodyend="1082"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1ab4cc0b9f2b54eeb4b48edf0bec85acfb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int32_t</type>
        <definition>int32_t evio::ByteBuffer::getInt</definition>
        <argsstring>(size_t index) const</argsstring>
        <name>getInt</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Absolute <emphasis>get</emphasis> method for reading an int value. Reads four bytes at the given index, composing them into an int value according to the current byte order.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>index from which the bytes will be read. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>int value at the given index. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if <computeroutput>index</computeroutput> is not smaller than buffer&apos;s limit, minus three. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="165" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1095" bodyend="1103"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a586571da6b6789902ecb5a67c319b34a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>uint32_t</type>
        <definition>uint32_t evio::ByteBuffer::getUInt</definition>
        <argsstring>() const</argsstring>
        <name>getUInt</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative <emphasis>get</emphasis> method for reading an unsigned int value. Reads the next four bytes at this buffer&apos;s current position, composing them into an unsigned int value according to the current byte order, and then increments the position by four.</para>
<para><simplesect kind="return"><para>unsigned int value at buffer&apos;s current position. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if fewer than four bytes remaining in buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="166" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1115" bodyend="1123"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1afd3c22fc6ecfebdf7b825187ea520030" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>uint32_t</type>
        <definition>uint32_t evio::ByteBuffer::getUInt</definition>
        <argsstring>(size_t index) const</argsstring>
        <name>getUInt</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Absolute <emphasis>get</emphasis> method for reading an unsigned int value. Reads four bytes at the given index, composing them into an unsigned int value according to the current byte order.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>index from which the bytes will be read. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>unsigned int value at the given index. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if <computeroutput>index</computeroutput> is not smaller than buffer&apos;s limit, minus three. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="167" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1136" bodyend="1144"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a085757efaf22f29f6383d391498408a9" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int64_t</type>
        <definition>int64_t evio::ByteBuffer::getLong</definition>
        <argsstring>() const</argsstring>
        <name>getLong</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative <emphasis>get</emphasis> method for reading a long long value. Reads the next eight bytes at this buffer&apos;s current position, composing them into a long long value according to the current byte order, and then increments the position by eight.</para>
<para><simplesect kind="return"><para>long long value at buffer&apos;s current position. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if fewer than eight bytes remaining in buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="169" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1156" bodyend="1164"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1aff0ff612c69277edeb667b031f396b81" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int64_t</type>
        <definition>int64_t evio::ByteBuffer::getLong</definition>
        <argsstring>(size_t index) const</argsstring>
        <name>getLong</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Absolute <emphasis>get</emphasis> method for reading a long long value. Reads eight bytes at the given index, composing them into a long long value according to the current byte order.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>index from which the bytes will be read. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>long long value at the given index. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if <computeroutput>index</computeroutput> is not smaller than buffer&apos;s limit, minus seven. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="170" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1177" bodyend="1185"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a02740710e7ee0f4fea666b95302414bf" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>uint64_t</type>
        <definition>uint64_t evio::ByteBuffer::getULong</definition>
        <argsstring>() const</argsstring>
        <name>getULong</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative <emphasis>get</emphasis> method for reading an unsigned long long value. Reads the next eight bytes at this buffer&apos;s current position, composing them into an unsigned long long value according to the current byte order, and then increments the position by eight.</para>
<para><simplesect kind="return"><para>unsigned long long value at buffer&apos;s current position. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if fewer than eight bytes remaining in buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="171" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1197" bodyend="1205"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1afe43738176d0c9c7a18de3a3fbc25983" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>uint64_t</type>
        <definition>uint64_t evio::ByteBuffer::getULong</definition>
        <argsstring>(size_t index) const</argsstring>
        <name>getULong</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Absolute <emphasis>get</emphasis> method for reading an unsigned long long value. Reads eight bytes at the given index, composing them into an unsigned long long value according to the current byte order.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>index from which the bytes will be read. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>unsigned long long value at the given index. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if <computeroutput>index</computeroutput> is not smaller than buffer&apos;s limit, minus seven. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="172" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1218" bodyend="1226"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1aed6c141ba0589c64122ed8b7f9dd86dd" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>float</type>
        <definition>float evio::ByteBuffer::getFloat</definition>
        <argsstring>() const</argsstring>
        <name>getFloat</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative <emphasis>get</emphasis> method for reading a float value. Reads the next four bytes at this buffer&apos;s current position, composing them into a float value according to the current byte order, and then increments the position by four.</para>
<para><simplesect kind="return"><para>float value at buffer&apos;s current position. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if fewer than four bytes remaining in buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="174" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1238" bodyend="1243"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a4d9828b3b4f908969bec7a9ef5fe2168" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>float</type>
        <definition>float evio::ByteBuffer::getFloat</definition>
        <argsstring>(size_t index) const</argsstring>
        <name>getFloat</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Absolute <emphasis>get</emphasis> method for reading a float value. Reads four bytes at the given index, composing them into a float value according to the current byte order.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>index from which the bytes will be read. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>float value at the given index. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if <computeroutput>index</computeroutput> is not smaller than buffer&apos;s limit, minus three. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="175" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1256" bodyend="1261"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a67dcdbbffad8bdd205358924f829ee73" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double evio::ByteBuffer::getDouble</definition>
        <argsstring>() const</argsstring>
        <name>getDouble</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative <emphasis>get</emphasis> method for reading a double value. Reads the next eight bytes at this buffer&apos;s current position, composing them into a double value according to the current byte order, and then increments the position by eight.</para>
<para><simplesect kind="return"><para>double value at buffer&apos;s current position. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if fewer than eight bytes remaining in buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="176" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1273" bodyend="1278"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a692201c1391d0cf31f083b378c6537e4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double evio::ByteBuffer::getDouble</definition>
        <argsstring>(size_t index) const</argsstring>
        <name>getDouble</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Absolute <emphasis>get</emphasis> method for reading a double value. Reads eight bytes at the given index, composing them into a double value according to the current byte order.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>index from which the bytes will be read. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>double value at the given index. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>underflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if <computeroutput>index</computeroutput> is not smaller than buffer&apos;s limit, minus seven. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="177" column="18" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1291" bodyend="1296"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1ab864753c79b9a896ae8ff2e09ebfc44f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::put</definition>
        <argsstring>(const ByteBuffer &amp;src)</argsstring>
        <name>put</name>
        <param>
          <type>const <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
          <declname>src</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative bulk <emphasis>put</emphasis> method.</para>
<para>This method transfers the bytes remaining in the given source buffer into this buffer. If there are more bytes remaining in the source buffer than in this buffer, that is, if <computeroutput>src.remaining()</computeroutput><nonbreakablespace/><computeroutput>&gt;</computeroutput><nonbreakablespace/><computeroutput><ref refid="classevio_1_1_byte_buffer_1a32b043081cd3a62187f2577ce2966e7d" kindref="member">remaining()</ref></computeroutput>, then no bytes are transferred and a <ref refid="classevio_1_1_evio_exception" kindref="compound">EvioException</ref> is thrown.</para>
<para>Otherwise, this method copies <emphasis>n</emphasis><nonbreakablespace/>=<nonbreakablespace/><computeroutput>src.remaining()</computeroutput> bytes from the given buffer into this buffer, starting at each buffer&apos;s current position. The positions of both buffers are then incremented by <emphasis>n</emphasis>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>source buffer from which bytes are to be read; must not be this buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername><ref refid="classevio_1_1_evio_exception" kindref="compound">EvioException</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>if source buffer is this buffer. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>overflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if insufficient space in this buffer for the remaining bytes in the source buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="182" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1325" bodyend="1340"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1af44afd1af753a793b33e4c88062d107e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::put</definition>
        <argsstring>(const std::shared_ptr&lt; ByteBuffer &gt; &amp;src)</argsstring>
        <name>put</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative bulk <emphasis>put</emphasis> method.</para>
<para>This method transfers the bytes remaining in the given source buffer into this buffer. If there are more bytes remaining in the source buffer than in this buffer, that is, if <computeroutput>src.remaining()</computeroutput><nonbreakablespace/><computeroutput>&gt;</computeroutput><nonbreakablespace/><computeroutput><ref refid="classevio_1_1_byte_buffer_1a32b043081cd3a62187f2577ce2966e7d" kindref="member">remaining()</ref></computeroutput>, then no bytes are transferred and a <ref refid="classevio_1_1_evio_exception" kindref="compound">EvioException</ref> is thrown.</para>
<para>Otherwise, this method copies <emphasis>n</emphasis><nonbreakablespace/>=<nonbreakablespace/><computeroutput>src.remaining()</computeroutput> bytes from the given buffer into this buffer, starting at each buffer&apos;s current position. The positions of both buffers are then incremented by <emphasis>n</emphasis>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>source buffer from which bytes are to be read; must not be this buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername><ref refid="classevio_1_1_evio_exception" kindref="compound">EvioException</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>if source buffer is this buffer. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>overflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if insufficient space in this buffer for the remaining bytes in the source buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="183" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1364" bodyend="1366"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a2e400079ea669e53552281b6df6f2c4a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::put</definition>
        <argsstring>(const uint8_t *src, size_t length)</argsstring>
        <name>put</name>
        <param>
          <type>const uint8_t *</type>
          <declname>src</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>length</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative bulk <emphasis>put</emphasis> method.</para>
<para>This method transfers bytes into this buffer from the given source array. If there are more bytes to be copied from the array than remain in this buffer, that is, if <computeroutput>length</computeroutput><nonbreakablespace/><computeroutput>&gt;</computeroutput><nonbreakablespace/><computeroutput><ref refid="classevio_1_1_byte_buffer_1a32b043081cd3a62187f2577ce2966e7d" kindref="member">remaining()</ref></computeroutput>, then no bytes are transferred and a <ref refid="classevio_1_1_evio_exception" kindref="compound">EvioException</ref> is thrown.</para>
<para>Otherwise, this method copies <computeroutput>length</computeroutput> bytes from the given array into this buffer, starting at the given pointer and at the current position of this buffer. The position of this buffer is then incremented by <computeroutput>length</computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>array from which bytes are to be read </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>number of bytes to be read from the given array; must be no larger than src array&apos;s size - offset. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer.</para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>overflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if insufficient space in this buffer </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="184" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1394" bodyend="1402"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a0a46e0b9fb1f03fd381085a684f4efd9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::put</definition>
        <argsstring>(const std::vector&lt; uint8_t &gt; &amp;src, size_t offset, size_t length)</argsstring>
        <name>put</name>
        <param>
          <type>const std::vector&lt; uint8_t &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>length</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative bulk <emphasis>put</emphasis> method.</para>
<para>This method transfers bytes into this buffer from the given vector. If there are more bytes to be copied from the vector than remain in this buffer, that is, if <computeroutput>length</computeroutput><nonbreakablespace/><computeroutput>&gt;</computeroutput><nonbreakablespace/><computeroutput><ref refid="classevio_1_1_byte_buffer_1a32b043081cd3a62187f2577ce2966e7d" kindref="member">remaining()</ref></computeroutput>, then no bytes are transferred and a <ref refid="classevio_1_1_evio_exception" kindref="compound">EvioException</ref> is thrown.</para>
<para>Otherwise, this method copies <computeroutput>length</computeroutput> bytes from the given array into this buffer, starting at the given offset in the array and at the current position of this buffer. The position of this buffer is then incremented by <computeroutput>length</computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>array from which bytes are to be read </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>offset (bytes) within the array of the first byte to be read; must be no larger than src array&apos;s size. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>number of bytes to be read from the given array; must be no larger than src array&apos;s size - offset. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer.</para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>overflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if insufficient space in this buffer </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="185" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1428" bodyend="1436"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a50f51685f7dc1e42be37da93a9e0a1b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::put</definition>
        <argsstring>(uint8_t val)</argsstring>
        <name>put</name>
        <param>
          <type>uint8_t</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative <emphasis>put</emphasis> method. Writes the given byte into this buffer at the current position, and then increments the position by one.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>byte value to be written. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>overflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if buffer&apos;s current position is not smaller than its limit </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="187" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1448" bodyend="1451"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a18fd6f5ea6e6527fd856a19d90e0fa81" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::put</definition>
        <argsstring>(size_t index, uint8_t val)</argsstring>
        <name>put</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <param>
          <type>uint8_t</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Absolute <emphasis>put</emphasis> method. Writes the given byte into this buffer at the given index.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>index at which the byte will be written. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>byte value to be written. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>overflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if buffer&apos;s current position is not smaller than its limit </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="188" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1463" bodyend="1466"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1aae4810bbbf42469d0e635b8fe0ce10a0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::putChar</definition>
        <argsstring>(wchar_t val)</argsstring>
        <name>putChar</name>
        <param>
          <type>wchar_t</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative <emphasis>put</emphasis> method for writing a wide char value. Writes two bytes containing the given char value, in the current byte order, into this buffer at the current position, and then increments the position by two.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>char value to be written. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>overflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if there are fewer than two bytes remaining in this buffer, i.e. not smaller than the buffer&apos;s limit, minus one. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="190" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1480" bodyend="1489"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1aee3bd457888150213a4e2b599f8d6c90" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::putChar</definition>
        <argsstring>(size_t index, wchar_t val)</argsstring>
        <name>putChar</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <param>
          <type>wchar_t</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Absolute <emphasis>put</emphasis> method for writing a wide char value. Writes two bytes containing the given char value, in the current byte order, into this buffer at the given index.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>index at which the bytes will be written. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>char value to be written. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>overflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if there are fewer than two bytes remaining in this buffer, i.e. not smaller than the buffer&apos;s limit, minus one. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="191" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1503" bodyend="1512"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a49e1d59fb665b50a9b3d117ef4bc2ff6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::putShort</definition>
        <argsstring>(uint16_t val)</argsstring>
        <name>putShort</name>
        <param>
          <type>uint16_t</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative <emphasis>put</emphasis> method for writing a short value. Writes two bytes containing the given short value, in the current byte order, into this buffer at the current position, and then increments the position by two.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>short value to be written. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>overflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if there are fewer than two bytes remaining in this buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="193" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1525" bodyend="1534"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1acb93633349dc300d4b2f622748d0e52d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::putShort</definition>
        <argsstring>(size_t index, uint16_t val)</argsstring>
        <name>putShort</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <param>
          <type>uint16_t</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Absolute <emphasis>put</emphasis> method for writing a short value. Writes two bytes containing the given short value, in the current byte order, into this buffer at the given index.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>index at which the bytes will be written. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>short value to be written. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>overflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if there are fewer than two bytes remaining in this buffer, i.e. not smaller than the buffer&apos;s limit, minus one. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="194" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1548" bodyend="1557"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a8bc5745c6525ec0e5bfaee09db9b5c60" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::putInt</definition>
        <argsstring>(uint32_t val)</argsstring>
        <name>putInt</name>
        <param>
          <type>uint32_t</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative <emphasis>put</emphasis> method for writing an int value. Writes four bytes containing the given int value, in the current byte order, into this buffer at the current position, and then increments the position by four.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>int value to be written. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>overflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if there are fewer than four bytes remaining in this buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="196" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1570" bodyend="1579"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a33dca3468280cf5f0b3f6c969436a5f6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::putInt</definition>
        <argsstring>(size_t index, uint32_t val)</argsstring>
        <name>putInt</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Absolute <emphasis>put</emphasis> method for writing an int value. Writes four bytes containing the given int value, in the current byte order, into this buffer at the given index.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>index at which the bytes will be written. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>int value to be written. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>overflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if there are fewer than four bytes remaining in this buffer, i.e. not smaller than the buffer&apos;s limit, minus three. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="197" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1593" bodyend="1602"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a0f3ae4b0b792506bb6ea752edb028dc3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::putLong</definition>
        <argsstring>(uint64_t val)</argsstring>
        <name>putLong</name>
        <param>
          <type>uint64_t</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative <emphasis>put</emphasis> method for writing a long long value. Writes eight bytes containing the given long long value, in the current byte order, into this buffer at the current position, and then increments the position by eight.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>long long value to be written. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>overflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if there are fewer than eight bytes remaining in this buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="199" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1615" bodyend="1624"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1ac8e82bf3900caa8ec8f3364fc7042532" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::putLong</definition>
        <argsstring>(size_t index, uint64_t val)</argsstring>
        <name>putLong</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <param>
          <type>uint64_t</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Absolute <emphasis>put</emphasis> method for writing a long long value. Writes eight bytes containing the given long long value, in the current byte order, into this buffer at the given index.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>index at which the bytes will be written. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>long long value to be written. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>overflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if there are fewer than eight bytes remaining in this buffer, i.e. not smaller than the buffer&apos;s limit, minus seven. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="200" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1638" bodyend="1647"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a6ec6454d1dda555d99b9701e5e9fe0b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::putFloat</definition>
        <argsstring>(float val)</argsstring>
        <name>putFloat</name>
        <param>
          <type>float</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative <emphasis>put</emphasis> method for writing a float value. Writes four bytes containing the given float value, in the current byte order, into this buffer at the current position, and then increments the position by four.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>float value to be written. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>overflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if there are fewer than four bytes remaining in this buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="202" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1660" bodyend="1669"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a3ed126bc49f87a62b92f325db5426885" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::putFloat</definition>
        <argsstring>(size_t index, float val)</argsstring>
        <name>putFloat</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <param>
          <type>float</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Absolute <emphasis>put</emphasis> method for writing a float value. Writes four bytes containing the given float value, in the current byte order, into this buffer at the given index.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>index at which the bytes will be written. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>float value to be written. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>overflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if there are fewer than four bytes remaining in this buffer, i.e. not smaller than the buffer&apos;s limit, minus three. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="203" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1683" bodyend="1692"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a4fd73c016a4204558255bd09d86f5499" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::putDouble</definition>
        <argsstring>(double val)</argsstring>
        <name>putDouble</name>
        <param>
          <type>double</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Relative <emphasis>put</emphasis> method for writing a double value. Writes eight bytes containing the given double value, in the current byte order, into this buffer at the current position, and then increments the position by eight.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>double value to be written. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>overflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if there are fewer than eight bytes remaining in this buffer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="205" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1705" bodyend="1714"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a54d6fcf78dbd1a6a962636ccf0902a31" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &amp;</type>
        <definition>ByteBuffer &amp; evio::ByteBuffer::putDouble</definition>
        <argsstring>(size_t index, double val)</argsstring>
        <name>putDouble</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <param>
          <type>double</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Absolute <emphasis>put</emphasis> method for writing a double value. Writes eight bytes containing the given double value, in the current byte order, into this buffer at the given index.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>index</parametername>
</parameternamelist>
<parameterdescription>
<para>index at which the bytes will be written. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>double value to be written. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>this buffer. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>overflow_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if there are fewer than eight bytes remaining in this buffer, i.e. not smaller than the buffer&apos;s limit, minus seven. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="206" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1728" bodyend="1737"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a080cb49cb33238fe74d54b0fc33f9990" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void evio::ByteBuffer::printBytes</definition>
        <argsstring>(size_t offset, size_t bytes, std::string const &amp;label)</argsstring>
        <name>printBytes</name>
        <param>
          <type>size_t</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>bytes</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>label</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This method prints out the desired number of data bytes starting from the given index without regard to the limit.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>offset</parametername>
</parameternamelist>
<parameterdescription>
<para>offset into data </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bytes</parametername>
</parameternamelist>
<parameterdescription>
<para>number of bytes to print in hex </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>label</parametername>
</parameternamelist>
<parameterdescription>
<para>a label to print as header </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="209" column="14" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1753" bodyend="1770"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a4b05d435a6cbdf90a99e0c5c3ed535e1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string evio::ByteBuffer::toString</definition>
        <argsstring>() const</argsstring>
        <name>toString</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Obtain a string representation of the buffer. <simplesect kind="return"><para>a string representation of the buffer. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="210" column="21" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="1777" bodyend="1788"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1af9d6a1e1f2dcadef542a8716e9f66d54" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &gt;</type>
        <definition>std::shared_ptr&lt; ByteBuffer &gt; evio::ByteBuffer::copyBuffer</definition>
        <argsstring>(const std::shared_ptr&lt; const ByteBuffer &gt; &amp;srcBuf)</argsstring>
        <name>copyBuffer</name>
        <param>
          <type>const std::shared_ptr&lt; const <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> &gt; &amp;</type>
          <declname>srcBuf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copy the given buffer into a new buffer which is accessed thru shared pointer. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>srcBuf</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> to copy. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>new <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="110" column="32" bodyfile="src/libsrc/ByteBuffer.cpp" bodystart="257" bodyend="271"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a84db46e0190950b52a31e69d984181df" prot="private" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T evio::ByteBuffer::read</definition>
        <argsstring>() const</argsstring>
        <name>read</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Template for relative read methods. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="215" column="22" bodyfile="src/libsrc/ByteBuffer.h" bodystart="215" bodyend="219"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1ad29aa589785e40fcdd08b4584a8a89ee" prot="private" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T evio::ByteBuffer::read</definition>
        <argsstring>(size_t index) const</argsstring>
        <name>read</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Template for absolute read methods. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="222" column="22" bodyfile="src/libsrc/ByteBuffer.h" bodystart="222" bodyend="228"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a2c89e34983c4333edcaa96afc38f4b29" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void evio::ByteBuffer::write</definition>
        <argsstring>(T &amp;data)</argsstring>
        <name>write</name>
        <param>
          <type>T &amp;</type>
          <declname>data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Template for relative write methods. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="231" column="25" bodyfile="src/libsrc/ByteBuffer.h" bodystart="231" bodyend="241"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a2ac53b607fb7f9a6a95f467651f39e62" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void evio::ByteBuffer::write</definition>
        <argsstring>(T &amp;data, size_t index)</argsstring>
        <name>write</name>
        <param>
          <type>T &amp;</type>
          <declname>data</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Template for absolute write methods. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="244" column="25" bodyfile="src/libsrc/ByteBuffer.h" bodystart="244" bodyend="251"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a04c43732ddcc24b8af6893a8ca00dbf2" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void evio::ByteBuffer::write</definition>
        <argsstring>(uint8_t &amp;data)</argsstring>
        <name>write</name>
        <param>
          <type>uint8_t &amp;</type>
          <declname>data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write 1 byte unsigned int at current position then increment position. More efficient than the templated method of this class. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>reference to byte to write. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="260" column="14" bodyfile="src/libsrc/ByteBuffer.h" bodystart="260" bodyend="265"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a92101e4c656c3c264f8c8769fb13ab8b" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void evio::ByteBuffer::write</definition>
        <argsstring>(char &amp;data)</argsstring>
        <name>write</name>
        <param>
          <type>char &amp;</type>
          <declname>data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write 1 byte char at current position then increment position. More efficient than the templated method of this class. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>reference to char to write. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="272" column="14" bodyfile="src/libsrc/ByteBuffer.h" bodystart="272" bodyend="277"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1ae258f507798ef0970176d7089d167ebe" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void evio::ByteBuffer::write</definition>
        <argsstring>(uint8_t &amp;data, size_t index)</argsstring>
        <name>write</name>
        <param>
          <type>uint8_t &amp;</type>
          <declname>data</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="279" column="14" bodyfile="src/libsrc/ByteBuffer.h" bodystart="279" bodyend="284"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1a3207689ca6d7f4b27fa52de4568eaaa1" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void evio::ByteBuffer::write</definition>
        <argsstring>(char &amp;data, size_t index)</argsstring>
        <name>write</name>
        <param>
          <type>char &amp;</type>
          <declname>data</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="286" column="14" bodyfile="src/libsrc/ByteBuffer.h" bodystart="286" bodyend="291"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1ac3318f48a43e876c0ebb8521aabc91ec" prot="private" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>uint8_t</type>
        <definition>uint8_t evio::ByteBuffer::read</definition>
        <argsstring>() const</argsstring>
        <name>read</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="294" column="17" bodyfile="src/libsrc/ByteBuffer.h" bodystart="294" bodyend="299"/>
      </memberdef>
      <memberdef kind="function" id="classevio_1_1_byte_buffer_1ab016c03c6b84369dddad1b33630c82f4" prot="private" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>uint8_t</type>
        <definition>uint8_t evio::ByteBuffer::read</definition>
        <argsstring>(size_t index) const</argsstring>
        <name>read</name>
        <param>
          <type>size_t</type>
          <declname>index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/libsrc/ByteBuffer.h" line="301" column="17" bodyfile="src/libsrc/ByteBuffer.h" bodystart="301" bodyend="306"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>This class is copied from one of the same name in the Java programming language. It wraps an array or buffer of data and is extremely useful in reading and writing data. It&apos;s particularly useful when converting Java code to C++. For more info, read the Java <ref refid="classevio_1_1_byte_buffer" kindref="compound">ByteBuffer</ref> documentation.</para>
<para><simplesect kind="date"><para>04/18/2018 </para>
</simplesect>
<simplesect kind="author"><para>timmer </para>
</simplesect>
</para>
    </detaileddescription>
    <location file="src/libsrc/ByteBuffer.h" line="42" column="5" bodyfile="src/libsrc/ByteBuffer.h" bodystart="42" bodyend="308"/>
    <listofallmembers>
      <member refid="classevio_1_1_byte_buffer_1aa0e335238a57eaa0bffee8f968e5995f" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>array</name></member>
      <member refid="classevio_1_1_byte_buffer_1abf7abf99aa7544601997f40eba298648" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>arrayOffset</name></member>
      <member refid="classevio_1_1_byte_buffer_1a9a57015e3032c286dfb3ee1b9cbce6aa" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>buf</name></member>
      <member refid="classevio_1_1_byte_buffer_1a21a35de5b7fe72d9bc695d07ed9787ba" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>ByteBuffer</name></member>
      <member refid="classevio_1_1_byte_buffer_1a9ebf5183862cb118242a27dfca41e0e4" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>ByteBuffer</name></member>
      <member refid="classevio_1_1_byte_buffer_1a6aee163fd7b9fc5fc6365ec6c80bb16e" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>ByteBuffer</name></member>
      <member refid="classevio_1_1_byte_buffer_1a57526704c3701fdabe67cdfb7ac79abd" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>ByteBuffer</name></member>
      <member refid="classevio_1_1_byte_buffer_1a7146d4da4460b561c97aed8a914870cf" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>ByteBuffer</name></member>
      <member refid="classevio_1_1_byte_buffer_1a8c574342930aa9f1538ac075e6c9c290" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>ByteBuffer</name></member>
      <member refid="classevio_1_1_byte_buffer_1ab3e07fdbeb88cf4f0790a3c656bd1c45" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>byteOrder</name></member>
      <member refid="classevio_1_1_byte_buffer_1ad2ff4aed1dc76efa1574c5a3a8445bb6" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>cap</name></member>
      <member refid="classevio_1_1_byte_buffer_1a6496a99b06b5ed67b8c93b148fd87323" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>capacity</name></member>
      <member refid="classevio_1_1_byte_buffer_1a11a85b28fd30c969f567c8c7f5848275" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>clear</name></member>
      <member refid="classevio_1_1_byte_buffer_1a76149a2cbcf34ff02edfb7a0e106abf5" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>compact</name></member>
      <member refid="classevio_1_1_byte_buffer_1a4ebef95e32ea1879af124171c45f2c1a" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>copy</name></member>
      <member refid="classevio_1_1_byte_buffer_1a28778844f5a9fb1eaf40e955086b7fd7" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>copy</name></member>
      <member refid="classevio_1_1_byte_buffer_1af9d6a1e1f2dcadef542a8716e9f66d54" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>copyBuffer</name></member>
      <member refid="classevio_1_1_byte_buffer_1aa5e949edce35266d7f5fdbf958c5906c" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>copyData</name></member>
      <member refid="classevio_1_1_byte_buffer_1a769cd08ef3d2320b1f21d33c528dc054" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>duplicate</name></member>
      <member refid="classevio_1_1_byte_buffer_1a647bf609c9b5c19403938ef2bbe7f0bc" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>duplicate</name></member>
      <member refid="classevio_1_1_byte_buffer_1aab31b6bac664b8cf8bd9dbba1d319045" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>duplicate</name></member>
      <member refid="classevio_1_1_byte_buffer_1a7ef866cbbf1604a31d7f6920bf89a173" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>equals</name></member>
      <member refid="classevio_1_1_byte_buffer_1ac07ae24bab386451176df095a376d330" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>expand</name></member>
      <member refid="classevio_1_1_byte_buffer_1aed6fb0a09f6320dfc89196e6c7d03191" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>flip</name></member>
      <member refid="classevio_1_1_byte_buffer_1a822845f421867ea1e93993f749c0d056" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getByte</name></member>
      <member refid="classevio_1_1_byte_buffer_1aea41d062520e973c301e4e42201ed0af" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getByte</name></member>
      <member refid="classevio_1_1_byte_buffer_1a1b23b4b4951162b9fd09453735ee71ee" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getBytes</name></member>
      <member refid="classevio_1_1_byte_buffer_1adb57510fe193a79746eb5c4f35d1a01f" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getBytes</name></member>
      <member refid="classevio_1_1_byte_buffer_1a4d8c5becf53b830e5b4b0f8a953d3092" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getChar</name></member>
      <member refid="classevio_1_1_byte_buffer_1aad1fd77bbfc86cc6df5856e63687ed83" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getChar</name></member>
      <member refid="classevio_1_1_byte_buffer_1aa8572a89b0b6adacd3363c4fcda258eb" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getData</name></member>
      <member refid="classevio_1_1_byte_buffer_1a67dcdbbffad8bdd205358924f829ee73" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getDouble</name></member>
      <member refid="classevio_1_1_byte_buffer_1a692201c1391d0cf31f083b378c6537e4" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getDouble</name></member>
      <member refid="classevio_1_1_byte_buffer_1aed6c141ba0589c64122ed8b7f9dd86dd" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getFloat</name></member>
      <member refid="classevio_1_1_byte_buffer_1a4d9828b3b4f908969bec7a9ef5fe2168" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getFloat</name></member>
      <member refid="classevio_1_1_byte_buffer_1a01783f61f04c093b71f58cd1adbde2fa" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getInt</name></member>
      <member refid="classevio_1_1_byte_buffer_1ab4cc0b9f2b54eeb4b48edf0bec85acfb" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getInt</name></member>
      <member refid="classevio_1_1_byte_buffer_1a085757efaf22f29f6383d391498408a9" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getLong</name></member>
      <member refid="classevio_1_1_byte_buffer_1aff0ff612c69277edeb667b031f396b81" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getLong</name></member>
      <member refid="classevio_1_1_byte_buffer_1a52ce23d6735060439f6e3965b866247e" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getShort</name></member>
      <member refid="classevio_1_1_byte_buffer_1af38ed12e610a90edddc20eb4d4a72fc2" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getShort</name></member>
      <member refid="classevio_1_1_byte_buffer_1a586571da6b6789902ecb5a67c319b34a" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getUInt</name></member>
      <member refid="classevio_1_1_byte_buffer_1afd3c22fc6ecfebdf7b825187ea520030" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getUInt</name></member>
      <member refid="classevio_1_1_byte_buffer_1a02740710e7ee0f4fea666b95302414bf" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getULong</name></member>
      <member refid="classevio_1_1_byte_buffer_1afe43738176d0c9c7a18de3a3fbc25983" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getULong</name></member>
      <member refid="classevio_1_1_byte_buffer_1a58f0bd2a0bf3263be899445c0c3de757" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getUShort</name></member>
      <member refid="classevio_1_1_byte_buffer_1a9f0a1ce0012cefa29867fdaedc7cb86a" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>getUShort</name></member>
      <member refid="classevio_1_1_byte_buffer_1a39605fc83d34737d5b78b36cb37f32fb" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>hasArray</name></member>
      <member refid="classevio_1_1_byte_buffer_1a355a856eaf702e4a804ee94752e3cc46" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>hasRemaining</name></member>
      <member refid="classevio_1_1_byte_buffer_1a5a0d7cac7719263bc39be8e6aed0fffb" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>isDirect</name></member>
      <member refid="classevio_1_1_byte_buffer_1a82254bedbea33c36b56c69e6a92bcdd4" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>isHostEndian</name></member>
      <member refid="classevio_1_1_byte_buffer_1a9a27c5c5aebe2bea21de96747b4bab5a" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>isLittleEndian</name></member>
      <member refid="classevio_1_1_byte_buffer_1ae91cbc6297d2f687e902de4be8559ef8" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>isMappedMemory</name></member>
      <member refid="classevio_1_1_byte_buffer_1a4c9251c141f20b99410106fd4d4df3b8" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>isReadOnly</name></member>
      <member refid="classevio_1_1_byte_buffer_1a6ec37389c7974a12e8db8263a40283e6" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>lim</name></member>
      <member refid="classevio_1_1_byte_buffer_1afb08d1dbc5fbf780afd27617a67eb750" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>limit</name></member>
      <member refid="classevio_1_1_byte_buffer_1a22a6d6c228004b1c0156143e43d16991" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>limit</name></member>
      <member refid="classevio_1_1_byte_buffer_1a0b0efc8946d9db1c2a4c2864702bd00c" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>mark</name></member>
      <member refid="classevio_1_1_byte_buffer_1a0a3a62e2c7825511cce3dea7300557a3" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>mrk</name></member>
      <member refid="classevio_1_1_byte_buffer_1aeeb577ac18593fe7608fe63fd3c29b5e" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>off</name></member>
      <member refid="classevio_1_1_byte_buffer_1a6248ee54a6d862b6ba10be3c9487594f" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>operator!=</name></member>
      <member refid="classevio_1_1_byte_buffer_1a1fb10fe73d64976534fc05f858f3fd8d" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>operator=</name></member>
      <member refid="classevio_1_1_byte_buffer_1a7a2fe124866819be3ab9d721533c7e25" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>operator=</name></member>
      <member refid="classevio_1_1_byte_buffer_1a06e9cde40e38a126d4ff6be6eec6b521" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>operator==</name></member>
      <member refid="classevio_1_1_byte_buffer_1a881fa9f9c9d29c76fe2f767aba9de1dc" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>operator[]</name></member>
      <member refid="classevio_1_1_byte_buffer_1a2444abec9d57c10b1eff8e1dcdc0b4ff" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>operator[]</name></member>
      <member refid="classevio_1_1_byte_buffer_1a3d5f0120189717ffc8d2d480d89cb91a" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>order</name></member>
      <member refid="classevio_1_1_byte_buffer_1a424b67644964be8ca45eb6d4060fd8b1" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>order</name></member>
      <member refid="classevio_1_1_byte_buffer_1a59b9183ed5119a8cf8051bf01ea91734" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>peek</name></member>
      <member refid="classevio_1_1_byte_buffer_1ae9542e4886512189c89306856bc50c15" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>pos</name></member>
      <member refid="classevio_1_1_byte_buffer_1a88f84e6b1757db70542eac13294fc80e" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>position</name></member>
      <member refid="classevio_1_1_byte_buffer_1a8d6c9a521a64e6fb5ee3eef3b4288abd" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>position</name></member>
      <member refid="classevio_1_1_byte_buffer_1a080cb49cb33238fe74d54b0fc33f9990" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>printBytes</name></member>
      <member refid="classevio_1_1_byte_buffer_1ab864753c79b9a896ae8ff2e09ebfc44f" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>put</name></member>
      <member refid="classevio_1_1_byte_buffer_1af44afd1af753a793b33e4c88062d107e" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>put</name></member>
      <member refid="classevio_1_1_byte_buffer_1a2e400079ea669e53552281b6df6f2c4a" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>put</name></member>
      <member refid="classevio_1_1_byte_buffer_1a0a46e0b9fb1f03fd381085a684f4efd9" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>put</name></member>
      <member refid="classevio_1_1_byte_buffer_1a50f51685f7dc1e42be37da93a9e0a1b4" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>put</name></member>
      <member refid="classevio_1_1_byte_buffer_1a18fd6f5ea6e6527fd856a19d90e0fa81" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>put</name></member>
      <member refid="classevio_1_1_byte_buffer_1aae4810bbbf42469d0e635b8fe0ce10a0" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>putChar</name></member>
      <member refid="classevio_1_1_byte_buffer_1aee3bd457888150213a4e2b599f8d6c90" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>putChar</name></member>
      <member refid="classevio_1_1_byte_buffer_1a4fd73c016a4204558255bd09d86f5499" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>putDouble</name></member>
      <member refid="classevio_1_1_byte_buffer_1a54d6fcf78dbd1a6a962636ccf0902a31" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>putDouble</name></member>
      <member refid="classevio_1_1_byte_buffer_1a6ec6454d1dda555d99b9701e5e9fe0b1" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>putFloat</name></member>
      <member refid="classevio_1_1_byte_buffer_1a3ed126bc49f87a62b92f325db5426885" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>putFloat</name></member>
      <member refid="classevio_1_1_byte_buffer_1a8bc5745c6525ec0e5bfaee09db9b5c60" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>putInt</name></member>
      <member refid="classevio_1_1_byte_buffer_1a33dca3468280cf5f0b3f6c969436a5f6" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>putInt</name></member>
      <member refid="classevio_1_1_byte_buffer_1a0f3ae4b0b792506bb6ea752edb028dc3" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>putLong</name></member>
      <member refid="classevio_1_1_byte_buffer_1ac8e82bf3900caa8ec8f3364fc7042532" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>putLong</name></member>
      <member refid="classevio_1_1_byte_buffer_1a49e1d59fb665b50a9b3d117ef4bc2ff6" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>putShort</name></member>
      <member refid="classevio_1_1_byte_buffer_1acb93633349dc300d4b2f622748d0e52d" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>putShort</name></member>
      <member refid="classevio_1_1_byte_buffer_1a84db46e0190950b52a31e69d984181df" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>read</name></member>
      <member refid="classevio_1_1_byte_buffer_1ad29aa589785e40fcdd08b4584a8a89ee" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>read</name></member>
      <member refid="classevio_1_1_byte_buffer_1ac3318f48a43e876c0ebb8521aabc91ec" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>read</name></member>
      <member refid="classevio_1_1_byte_buffer_1ab016c03c6b84369dddad1b33630c82f4" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>read</name></member>
      <member refid="classevio_1_1_byte_buffer_1a32b043081cd3a62187f2577ce2966e7d" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>remaining</name></member>
      <member refid="classevio_1_1_byte_buffer_1a78a69a5db426df0ecdc994874219a2cd" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>reset</name></member>
      <member refid="classevio_1_1_byte_buffer_1af153687725d1aff72fac2c28aaee70d8" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>rewind</name></member>
      <member refid="classevio_1_1_byte_buffer_1a7ba11eafdb29604bdfbd4ee0a339be4b" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>slice</name></member>
      <member refid="classevio_1_1_byte_buffer_1ae07e0ddf47ddb91406631f1ac513a9e4" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>slice</name></member>
      <member refid="classevio_1_1_byte_buffer_1a0cb359c2dc87ca43893c2e489d625ee8" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>slice</name></member>
      <member refid="classevio_1_1_byte_buffer_1a4b05d435a6cbdf90a99e0c5c3ed535e1" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>toString</name></member>
      <member refid="classevio_1_1_byte_buffer_1a13f23c358712a350917dd6b7b5ba0284" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>totalSize</name></member>
      <member refid="classevio_1_1_byte_buffer_1a2c89e34983c4333edcaa96afc38f4b29" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>write</name></member>
      <member refid="classevio_1_1_byte_buffer_1a2ac53b607fb7f9a6a95f467651f39e62" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>write</name></member>
      <member refid="classevio_1_1_byte_buffer_1a04c43732ddcc24b8af6893a8ca00dbf2" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>write</name></member>
      <member refid="classevio_1_1_byte_buffer_1a92101e4c656c3c264f8c8769fb13ab8b" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>write</name></member>
      <member refid="classevio_1_1_byte_buffer_1ae258f507798ef0970176d7089d167ebe" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>write</name></member>
      <member refid="classevio_1_1_byte_buffer_1a3207689ca6d7f4b27fa52de4568eaaa1" prot="private" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>write</name></member>
      <member refid="classevio_1_1_byte_buffer_1a3c003df1d0c570105762f192c1719a38" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>zero</name></member>
      <member refid="classevio_1_1_byte_buffer_1af9ec8f0b3b128d1ac3d0c7f8929c65c4" prot="public" virt="non-virtual"><scope>evio::ByteBuffer</scope><name>~ByteBuffer</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
