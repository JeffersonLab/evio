diff -Naru -x .git ../Disruptor-cpp/.idea/workspace.xml ./.idea/workspace.xml
--- ../Disruptor-cpp/.idea/workspace.xml	1969-12-31 19:00:00.000000000 -0500
+++ ./.idea/workspace.xml	2021-01-21 14:31:14.000000000 -0500
@@ -0,0 +1,263 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="CMakeRunConfigurationManager" shouldGenerate="true" shouldDeleteObsolete="true">
+    <generated>
+      <config projectName="Disruptor" targetName="uninstall" />
+      <config projectName="Disruptor" targetName="DisruptorShared" />
+      <config projectName="Disruptor" targetName="DisruptorStatic" />
+      <config projectName="Disruptor" targetName="distr" />
+    </generated>
+  </component>
+  <component name="CMakeSettings">
+    <configurations>
+      <configuration PROFILE_NAME="Debug" CONFIG_NAME="Debug" />
+    </configurations>
+  </component>
+  <component name="ChangeListManager">
+    <list default="true" id="62a0e36e-c204-466f-8864-d20c98a17428" name="Default Changelist" comment="">
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/CMakeLists.txt" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/EventCountingQueueProcessor.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/EventCountingQueueProcessor.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/EventCountingWorkHandler.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/EventCountingWorkHandler.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/ExecutorService.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/FizzBuzzEvent.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/FizzBuzzEvent.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/FizzBuzzEventHandler.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/FizzBuzzEventHandler.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/FizzBuzzStep.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/FunctionEvent.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/FunctionEvent.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/FunctionEventHandler.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/FunctionEventHandler.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/FunctionStep.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/ILatencyTest.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/IThroughputTest.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/LatencyTestSession.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/LatencyTestSession.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/LatencyTestSessionResult.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/LatencyTestSessionResult.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/LongArrayEventHandler.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/LongArrayEventHandler.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/MultiBufferBatchEventProcessor.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/MutableLong.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/MutableLong.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToOneRawBatchThroughputTest.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToOneRawBatchThroughputTest.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToOneRawThroughputTest.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToOneRawThroughputTest.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToOneSequencedBatchThroughputTest.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToOneSequencedBatchThroughputTest.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToOneSequencedLongArrayThroughputTest.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToOneSequencedLongArrayThroughputTest.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToOneSequencedPollerThroughputTest.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToOneSequencedPollerThroughputTest.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToOneSequencedThroughputTest.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToOneSequencedThroughputTest.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToOneTranslatorThroughputTest.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToOneTranslatorThroughputTest.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToThreeDiamondSequencedThroughputTest.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToThreeDiamondSequencedThroughputTest.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToThreePipelineSequencedThroughputTest.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToThreePipelineSequencedThroughputTest.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToThreeReleasingWorkerPoolThroughputTest.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToThreeReleasingWorkerPoolThroughputTest.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToThreeSequencedThroughputTest.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToThreeSequencedThroughputTest.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToThreeWorkerPoolThroughputTest.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/OneToThreeWorkerPoolThroughputTest.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/Operation.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/Operation.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/PaddedLong.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/PerfTestUtil.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/PerfTestUtil.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/PingPongSequencedLatencyTest.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/PingPongSequencedLatencyTest.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/TestFactory.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/TestRepository.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/TestRepository.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/ThreeToOneSequencedBatchThroughputTest.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/ThreeToOneSequencedBatchThroughputTest.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/ThreeToOneSequencedThroughputTest.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/ThreeToOneSequencedThroughputTest.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/ThreeToThreeSequencedThroughputTest.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/ThreeToThreeSequencedThroughputTest.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/ThroughputTestSession.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/ThroughputTestSession.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/ThroughputTestSessionResult.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/ThroughputTestSessionResult.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/TwoToTwoWorkProcessorThroughputTest.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/TwoToTwoWorkProcessorThroughputTest.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/ValueAdditionEventHandler.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/ValueAdditionEventHandler.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/ValueEvent.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/ValueEvent.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/ValueMutationEventHandler.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/ValueMutationEventHandler.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/main.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/stdafx.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/stdafx.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.PerfTests/targetver.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.TestTools/CMakeLists.txt" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.TestTools/CountdownEvent.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.TestTools/CountdownEvent.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.TestTools/DurationHumanizer.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.TestTools/DurationUnit.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.TestTools/HumanNumberFacet.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.TestTools/LatencyRecorder.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.TestTools/LatencyRecorder.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.TestTools/ManualResetEvent.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.TestTools/ManualResetEvent.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.TestTools/ResetEvent.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.TestTools/ResetEvent.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.TestTools/ScopeExitFunctor.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.TestTools/ScopeExitFunctor.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.TestTools/Stopwatch.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.TestTools/Stopwatch.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.TestTools/stdafx.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.TestTools/stdafx.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.TestTools/targetver.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/AggregateEventHandlerTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/AggregateEventHandlerTestsFixture.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/AggregateEventHandlerTestsFixture.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/AtomicReference.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/BatchEventProcessorTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/BatchEventProcessorTestsFixture.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/BatchEventProcessorTestsFixture.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/BatchHandlerMock.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/BatchingTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/BusySpinWaitStrategyTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/CMakeLists.txt" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/ConsumerRepositoryTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/ConsumerRepositoryTestsFixture.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/ConsumerRepositoryTestsFixture.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/DataProviderMock.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/DelayedEventHandler.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/DelayedEventHandler.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/DisruptorFixture.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/DisruptorFixture.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/DisruptorStressTest.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/DisruptorTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/DummySequenceBarrier.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/DummySequenceBarrier.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/EventHandlerStub.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/EventPollerTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/EventProcessorMock.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/EventPublisherTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/ExceptionHandlerMock.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/ExceptionThrowingEventHandler.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/ExceptionThrowingEventHandler.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/FatalExceptionHandlerTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/FixedSequenceGroupTest.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/IgnoreExceptionHandlerTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/LifecycleAwareEventHandlerMock.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/LifecycleAwareTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/LongEvent.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/MultiProducerSequencerTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/RingBufferTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/RingBufferTestsFixture.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/RingBufferTestsFixture.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/RingBufferWithMocksTest.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/SequenceBarrierMock.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/SequenceBarrierTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/SequenceBarrierTestsFixture.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/SequenceBarrierTestsFixture.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/SequenceReportingCallbackTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/SequenceUpdater.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/SequenceUpdater.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/SequencerFixture.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/SequencerMock.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/SequencerTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/SleepingEventHandler.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/SleepingEventHandler.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/SleepingWaitStrategyTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/SpinWaitWaitStrategyTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/StubEvent.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/StubEvent.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/StubExceptionHandler.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/StubExecutor.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/StubExecutor.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/StubPublisher.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/StubPublisher.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/TestEvent.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/TestWaiter.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/TestWaiter.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/TestWorkHandler.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/TestWorkHandler.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/TimeoutBlockingWaitStrategyTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/UtilTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/WaitStrategyMock.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/WaitStrategyTestUtil.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/WaitStrategyTestUtil.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/WorkerPoolTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/YieldingWaitStrategyTests.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/main.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/postbuild.bat" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/stdafx.cpp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/stdafx.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor.Tests/targetver.h" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Disruptor/CMakeLists.txt" beforeDir="false" afterPath="$PROJECT_DIR$/Disruptor/CMakeLists.txt" afterDir="false" />
+    </list>
+    <option name="SHOW_DIALOG" value="false" />
+    <option name="HIGHLIGHT_CONFLICTS" value="true" />
+    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
+    <option name="LAST_RESOLUTION" value="IGNORE" />
+  </component>
+  <component name="ClangdSettings">
+    <option name="formatViaClangd" value="false" />
+  </component>
+  <component name="ExecutionTargetManager" SELECTED_TARGET="CMakeBuildProfile:Debug" />
+  <component name="Git.Settings">
+    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
+  </component>
+  <component name="ProjectId" id="1mvZuBVKr2RAQgxM2VgHMXpWuiL" />
+  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
+  <component name="ProjectViewState">
+    <option name="hideEmptyMiddlePackages" value="true" />
+    <option name="showLibraryContents" value="true" />
+  </component>
+  <component name="PropertiesComponent">
+    <property name="RunOnceActivity.OpenProjectViewOnStart" value="true" />
+    <property name="WebServerToolWindowFactoryState" value="false" />
+    <property name="cf.first.check.clang-format" value="false" />
+  </component>
+  <component name="RunManager" selected="CMake Application.distr">
+    <configuration name="DisruptorShared" type="CMakeRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="Disruptor" TARGET_NAME="DisruptorShared" CONFIG_NAME="Debug">
+      <method v="2">
+        <option name="com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="DisruptorStatic" type="CMakeRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="Disruptor" TARGET_NAME="DisruptorStatic" CONFIG_NAME="Debug">
+      <method v="2">
+        <option name="com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
+      </method>
+    </configuration>
+    <configuration default="true" type="CMakeRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" PASS_PARENT_ENVS_2="true">
+      <method v="2">
+        <option name="com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="distr" type="CMakeRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="Disruptor" TARGET_NAME="distr" CONFIG_NAME="Debug">
+      <method v="2">
+        <option name="com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="uninstall" type="CMakeRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="Disruptor" TARGET_NAME="uninstall" CONFIG_NAME="Debug">
+      <method v="2">
+        <option name="com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
+      </method>
+    </configuration>
+    <configuration default="true" type="GradleAppRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" PASS_PARENT_ENVS_2="true">
+      <method v="2">
+        <option name="com.jetbrains.cidr.cpp.gradle.execution.GradleNativeBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
+      </method>
+    </configuration>
+    <list>
+      <item itemvalue="CMake Application.distr" />
+      <item itemvalue="CMake Application.uninstall" />
+      <item itemvalue="CMake Application.DisruptorShared" />
+      <item itemvalue="CMake Application.DisruptorStatic" />
+    </list>
+  </component>
+  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
+</project>
\ No newline at end of file
diff -Naru -x .git ../Disruptor-cpp/Disruptor/CMakeLists.txt ./Disruptor/CMakeLists.txt
--- ../Disruptor-cpp/Disruptor/CMakeLists.txt	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor/CMakeLists.txt	2021-01-22 12:25:17.000000000 -0500
@@ -22,6 +22,7 @@
     Sequence.cpp
     SequenceGroups.cpp
     SleepingWaitStrategy.cpp
+    SpinCountBackoffWaitStrategy.cpp
     SpinWait.cpp
     SpinWaitWaitStrategy.cpp
     stdafx.cpp
@@ -100,6 +101,7 @@
     Sequencer.h
     SingleProducerSequencer.h
     SleepingWaitStrategy.h
+    SpinCountBackoffWaitStrategy.h
     SpinWait.h
     SpinWaitWaitStrategy.h
     ThreadPerTaskScheduler.h
diff -Naru -x .git ../Disruptor-cpp/Disruptor/SpinCountBackoffWaitStrategy.cpp ./Disruptor/SpinCountBackoffWaitStrategy.cpp
--- ../Disruptor-cpp/Disruptor/SpinCountBackoffWaitStrategy.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ./Disruptor/SpinCountBackoffWaitStrategy.cpp	2021-01-22 12:25:08.000000000 -0500
@@ -0,0 +1,71 @@
+#include "stdafx.h"
+#include "SpinCountBackoffWaitStrategy.h"
+#include "BlockingWaitStrategy.h"
+
+#include <ostream>
+#include <iostream>
+
+#include "ISequenceBarrier.h"
+#include "Sequence.h"
+
+
+namespace Disruptor
+{
+
+    SpinCountBackoffWaitStrategy::SpinCountBackoffWaitStrategy()
+    {
+        this->SPIN_TRIES = 10000;
+        this->fallbackStrategy = std::make_shared< BlockingWaitStrategy >();
+    }
+
+    SpinCountBackoffWaitStrategy::SpinCountBackoffWaitStrategy(std::uint32_t spinTries,
+                                                               std::shared_ptr<IWaitStrategy> fallbackStrategy)
+    {
+        this->SPIN_TRIES = spinTries;
+        if (spinTries < 1) {
+            this->SPIN_TRIES = 1;
+        }
+
+        this->fallbackStrategy = fallbackStrategy;
+        if (fallbackStrategy == nullptr) {
+            this->fallbackStrategy = std::make_shared< BlockingWaitStrategy >();
+        }
+    }
+
+
+    std::int64_t SpinCountBackoffWaitStrategy::waitFor(std::int64_t sequence,
+                                                       Sequence& cursor,
+                                                       ISequence& dependentSequence,
+                                                       ISequenceBarrier& barrier)
+    {
+        std::int64_t availableSequence;
+        std::uint32_t counter = SPIN_TRIES;
+
+        do {
+            if ((availableSequence = dependentSequence.value()) >= sequence) {
+                return availableSequence;
+            }
+
+            if (0 == --counter) {
+                return fallbackStrategy->waitFor(sequence, cursor, dependentSequence, barrier);
+            }
+            //std::cout << " " <<  counter;
+            barrier.checkAlert();
+            //spinWait.spinOnce();
+
+        } while (true);
+    }
+
+    void SpinCountBackoffWaitStrategy::signalAllWhenBlocking()
+    {
+        fallbackStrategy->signalAllWhenBlocking();
+    }
+
+    void SpinCountBackoffWaitStrategy::writeDescriptionTo(std::ostream& stream) const
+    {
+        stream << "SpinCountBackoffWaitStrategy";
+    }
+
+
+} // namespace Disruptor
+
diff -Naru -x .git ../Disruptor-cpp/Disruptor/SpinCountBackoffWaitStrategy.h ./Disruptor/SpinCountBackoffWaitStrategy.h
--- ../Disruptor-cpp/Disruptor/SpinCountBackoffWaitStrategy.h	1969-12-31 19:00:00.000000000 -0500
+++ ./Disruptor/SpinCountBackoffWaitStrategy.h	2021-01-22 12:25:08.000000000 -0500
@@ -0,0 +1,57 @@
+#pragma once
+
+#include <boost/thread.hpp>
+
+#include "Disruptor/IWaitStrategy.h"
+
+
+namespace Disruptor
+{
+
+    /**
+     * <p>The SpinCountBackoffWait strategy spins for a given number of times then
+     * waits using the configured fallback WaitStrategy.</p>
+     * This combination wait strategy worked well in Java with the fallback being BlockingWaitStrategy,
+     * so that's the default here.
+     *
+     * @author timmer
+     * @date 2/18/2020
+     */
+    class SpinCountBackoffWaitStrategy : public IWaitStrategy
+    {
+
+    public:
+
+        /** Constructor defaulting to 10,000 spins and BlockingWaitStrategy when finished spinning. */
+        SpinCountBackoffWaitStrategy();
+
+        /**
+         * Constructor specifying number of spins and the back up wait strategy it switches to after spinning.
+         * @param spinTries number of spins.
+         * @param fallbackStrategy back up wait strategy.
+         */
+        SpinCountBackoffWaitStrategy(std::uint32_t spinTries, std::shared_ptr<IWaitStrategy> fallbackStrategy);
+
+        /**
+         * \see IWaitStrategy::waitFor
+         */
+        std::int64_t waitFor(std::int64_t sequence,
+                             Sequence& cursor,
+                             ISequence& dependentSequence,
+                             ISequenceBarrier& barrier) override;
+
+        /**
+         * \see IWaitStrategy::signalAllWhenBlocking
+         */
+        void signalAllWhenBlocking() override;
+
+        void writeDescriptionTo(std::ostream& stream) const override;
+
+    private:
+
+        std::uint32_t SPIN_TRIES;
+        std::shared_ptr<IWaitStrategy> fallbackStrategy;
+
+    };
+
+} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/CMakeLists.txt ./Disruptor.PerfTests/CMakeLists.txt
--- ../Disruptor-cpp/Disruptor.PerfTests/CMakeLists.txt	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/CMakeLists.txt	1969-12-31 19:00:00.000000000 -0500
@@ -1,60 +0,0 @@
-project(Disruptor.PerfTests)
-cmake_minimum_required(VERSION 2.6)
-
-
-find_package(Boost COMPONENTS system thread date_time)
-if(Boost_FOUND)
-    include_directories(${Boost_INCLUDE_DIRS})
-    link_directories(${Boost_LIBRARY_DIRS})
-endif()
-
-include_directories("..")
-
-
-set(DisruptorPerfTests_sources
-
-    main.cpp
-
-    EventCountingQueueProcessor.cpp
-    EventCountingWorkHandler.cpp
-    FizzBuzzEvent.cpp
-    FizzBuzzEventHandler.cpp
-    FunctionEvent.cpp
-    FunctionEventHandler.cpp
-    LatencyTestSession.cpp
-    LatencyTestSessionResult.cpp
-    LongArrayEventHandler.cpp
-    MutableLong.cpp
-    OneToOneRawBatchThroughputTest.cpp
-    OneToOneRawThroughputTest.cpp
-    OneToOneSequencedBatchThroughputTest.cpp
-    OneToOneSequencedLongArrayThroughputTest.cpp
-    OneToOneSequencedPollerThroughputTest.cpp
-    OneToOneSequencedThroughputTest.cpp
-    OneToOneTranslatorThroughputTest.cpp
-    OneToThreeDiamondSequencedThroughputTest.cpp
-    OneToThreePipelineSequencedThroughputTest.cpp
-    OneToThreeReleasingWorkerPoolThroughputTest.cpp
-    OneToThreeSequencedThroughputTest.cpp
-    OneToThreeWorkerPoolThroughputTest.cpp
-    Operation.cpp
-    PerfTestUtil.cpp
-    PingPongSequencedLatencyTest.cpp
-    TestRepository.cpp
-    ThreeToOneSequencedBatchThroughputTest.cpp
-    ThreeToOneSequencedThroughputTest.cpp
-    ThreeToThreeSequencedThroughputTest.cpp
-    ThroughputTestSession.cpp
-    ThroughputTestSessionResult.cpp
-    TwoToTwoWorkProcessorThroughputTest.cpp
-    ValueAdditionEventHandler.cpp
-    ValueEvent.cpp
-    ValueMutationEventHandler.cpp
-)
-
-add_definitions(-DBOOST_TEST_DYN_LINK)
-
-add_executable(Disruptor.PerfTests ${DisruptorPerfTests_sources})
-target_link_libraries(Disruptor.PerfTests DisruptorStatic Disruptor.TestTools ${Boost_LIBRARIES} pthread)
-
-add_custom_target(performance_test ${CMAKE_CURRENT_BINARY_DIR}/Disruptor.PerfTests)
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/EventCountingQueueProcessor.cpp ./Disruptor.PerfTests/EventCountingQueueProcessor.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/EventCountingQueueProcessor.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/EventCountingQueueProcessor.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,39 +0,0 @@
-#include "stdafx.h"
-#include "EventCountingQueueProcessor.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    EventCountingQueueProcessor::EventCountingQueueProcessor(const std::shared_ptr< BlockingQueue< std::int64_t > >& blockingQueue,
-                                                             const std::vector< std::shared_ptr< PaddedLong > >& counters,
-                                                             std::int32_t index)
-        : m_running(false)
-        , m_blockingQueue(blockingQueue)
-        , m_counters(counters)
-        , m_index(index)
-    {
-    }
-
-    void EventCountingQueueProcessor::halt()
-    {
-        m_running = false;
-    }
-
-    void EventCountingQueueProcessor::run()
-    {
-        m_running = true;
-        while (m_running)
-        {
-            std::int64_t item;
-            if (!m_blockingQueue->timedWaitAndPop(item, std::chrono::microseconds(100)))
-                continue;
-
-            m_counters[m_index]->value = m_counters[m_index]->value + 1L;
-        }
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/EventCountingQueueProcessor.h ./Disruptor.PerfTests/EventCountingQueueProcessor.h
--- ../Disruptor-cpp/Disruptor.PerfTests/EventCountingQueueProcessor.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/EventCountingQueueProcessor.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,37 +0,0 @@
-#pragma once
-
-#include <atomic>
-#include <cstdint>
-#include <memory>
-#include <vector>
-
-#include "Disruptor/BlockingQueue.h"
-
-#include "Disruptor.PerfTests/PaddedLong.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class EventCountingQueueProcessor
-    {
-    public:
-        EventCountingQueueProcessor(const std::shared_ptr< BlockingQueue< std::int64_t > >& blockingQueue,
-                                    const std::vector< std::shared_ptr< PaddedLong > >& counters,
-                                    std::int32_t index);
-
-        void halt();
-
-        void run();
-
-    private:
-        std::atomic< bool > m_running;
-        std::shared_ptr< BlockingQueue< std::int64_t > > m_blockingQueue;
-        std::vector< std::shared_ptr< PaddedLong > > m_counters;
-        std::int32_t m_index;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/EventCountingWorkHandler.cpp ./Disruptor.PerfTests/EventCountingWorkHandler.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/EventCountingWorkHandler.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/EventCountingWorkHandler.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,22 +0,0 @@
-#include "stdafx.h"
-#include "EventCountingWorkHandler.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    EventCountingWorkHandler::EventCountingWorkHandler(const std::vector< std::shared_ptr< PaddedLong > >& counters, std::int32_t index)
-        : m_counters(counters)
-        , m_index(index)
-    {
-    }
-
-    void EventCountingWorkHandler::onEvent(ValueEvent& /*evt*/)
-    {
-        m_counters[m_index]->value = m_counters[m_index]->value + 1L;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/EventCountingWorkHandler.h ./Disruptor.PerfTests/EventCountingWorkHandler.h
--- ../Disruptor-cpp/Disruptor.PerfTests/EventCountingWorkHandler.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/EventCountingWorkHandler.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,31 +0,0 @@
-#pragma once
-
-#include <cstdint>
-#include <memory>
-#include <vector>
-
-#include "Disruptor/IWorkHandler.h"
-
-#include "Disruptor.PerfTests/PaddedLong.h"
-#include "Disruptor.PerfTests/ValueEvent.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class EventCountingWorkHandler : public IWorkHandler< ValueEvent >
-    {
-    public:
-        EventCountingWorkHandler(const std::vector< std::shared_ptr< PaddedLong > >& counters, std::int32_t index);
-
-        void onEvent(ValueEvent& evt) override;
-
-    private:
-        std::vector< std::shared_ptr< PaddedLong > > m_counters;
-        std::int32_t m_index;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/ExecutorService.h ./Disruptor.PerfTests/ExecutorService.h
--- ../Disruptor-cpp/Disruptor.PerfTests/ExecutorService.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/ExecutorService.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,25 +0,0 @@
-#pragma once
-
-#include <future>
-#include <memory>
-
-#include "Disruptor/BatchEventProcessor.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    template <class T>
-    class ExecutorService
-    {
-    public:
-        std::future< void > submit(const std::shared_ptr< BatchEventProcessor< T > >& eventProcessor)
-        {
-            return std::async(std::launch::async, [eventProcessor] { eventProcessor->run(); });
-        }
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/FizzBuzzEvent.cpp ./Disruptor.PerfTests/FizzBuzzEvent.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/FizzBuzzEvent.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/FizzBuzzEvent.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,24 +0,0 @@
-#include "stdafx.h"
-#include "FizzBuzzEvent.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    void FizzBuzzEvent::reset()
-    {
-        value = 0;
-        fizz = false;
-        buzz = false;
-    }
-
-    const std::function< FizzBuzzEvent() >& FizzBuzzEvent::eventFactory()
-    {
-        static std::function< FizzBuzzEvent() > result([] { return FizzBuzzEvent(); });
-        return result;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/FizzBuzzEvent.h ./Disruptor.PerfTests/FizzBuzzEvent.h
--- ../Disruptor-cpp/Disruptor.PerfTests/FizzBuzzEvent.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/FizzBuzzEvent.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,26 +0,0 @@
-#pragma once
-
-#include <cstdint>
-#include <functional>
-#include <memory>
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class FizzBuzzEvent
-    {
-    public:
-        void reset();
-
-        static const std::function< FizzBuzzEvent() >& eventFactory();
-
-        std::int64_t value = 0;
-        bool fizz = false;
-        bool buzz = false;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/FizzBuzzEventHandler.cpp ./Disruptor.PerfTests/FizzBuzzEventHandler.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/FizzBuzzEventHandler.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/FizzBuzzEventHandler.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,54 +0,0 @@
-#include "stdafx.h"
-#include "FizzBuzzEventHandler.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    FizzBuzzEventHandler::FizzBuzzEventHandler(FizzBuzzStep fizzBuzzStep)
-        : m_fizzBuzzStep(fizzBuzzStep)
-    {
-    }
-
-    std::int64_t FizzBuzzEventHandler::fizzBuzzCounter() const
-    {
-        return m_fizzBuzzCounter.value;
-    }
-
-    void FizzBuzzEventHandler::reset(const std::shared_ptr< Tests::ManualResetEvent >& latch, std::int64_t iterations)
-    {
-        m_fizzBuzzCounter.value = 0;
-        m_iterations = iterations;
-        m_latch = latch;
-    }
-
-    void FizzBuzzEventHandler::onEvent(FizzBuzzEvent& data, std::int64_t sequence, bool)
-    {
-        switch (m_fizzBuzzStep)
-        {
-        case FizzBuzzStep::Fizz:
-            data.fizz = data.value % 3 == 0;
-            break;
-
-        case FizzBuzzStep::Buzz:
-            data.buzz = data.value % 5 == 0;
-            break;
-
-        case FizzBuzzStep::FizzBuzz:
-            if (data.fizz && data.buzz)
-            {
-                m_fizzBuzzCounter.value = m_fizzBuzzCounter.value + 1;
-            }
-            break;
-        }
-
-        if (sequence == m_iterations - 1)
-        {
-            m_latch->set();
-        }
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/FizzBuzzEventHandler.h ./Disruptor.PerfTests/FizzBuzzEventHandler.h
--- ../Disruptor-cpp/Disruptor.PerfTests/FizzBuzzEventHandler.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/FizzBuzzEventHandler.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,36 +0,0 @@
-#pragma once
-
-#include "Disruptor/IEventHandler.h"
-
-#include "Disruptor.TestTools/ManualResetEvent.h"
-
-#include "Disruptor.PerfTests/FizzBuzzEvent.h"
-#include "Disruptor.PerfTests/FizzBuzzStep.h"
-#include "Disruptor.PerfTests/PaddedLong.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class FizzBuzzEventHandler : public IEventHandler< FizzBuzzEvent >
-    {
-    public:
-        explicit FizzBuzzEventHandler(FizzBuzzStep fizzBuzzStep);
-
-        std::int64_t fizzBuzzCounter() const;
-
-        void reset(const std::shared_ptr< Tests::ManualResetEvent >& latch, std::int64_t iterations);
-
-        void onEvent(FizzBuzzEvent& data, std::int64_t sequence, bool /*endOfBatch*/) override;
-
-    private:
-        FizzBuzzStep m_fizzBuzzStep;
-        std::int64_t m_iterations = 0;
-        std::shared_ptr< Tests::ManualResetEvent > m_latch;
-        PaddedLong m_fizzBuzzCounter;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/FizzBuzzStep.h ./Disruptor.PerfTests/FizzBuzzStep.h
--- ../Disruptor-cpp/Disruptor.PerfTests/FizzBuzzStep.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/FizzBuzzStep.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,17 +0,0 @@
-#pragma once
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    enum class FizzBuzzStep
-    {
-        Fizz,
-        Buzz,
-        FizzBuzz,
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/FunctionEvent.cpp ./Disruptor.PerfTests/FunctionEvent.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/FunctionEvent.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/FunctionEvent.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,17 +0,0 @@
-#include "stdafx.h"
-#include "FunctionEvent.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    const std::function< FunctionEvent() >& FunctionEvent::eventFactory()
-    {
-        static std::function< FunctionEvent() > result([] { return FunctionEvent(); });
-        return result;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/FunctionEvent.h ./Disruptor.PerfTests/FunctionEvent.h
--- ../Disruptor-cpp/Disruptor.PerfTests/FunctionEvent.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/FunctionEvent.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,24 +0,0 @@
-#pragma once
-
-#include <functional>
-#include <memory>
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class FunctionEvent
-    {
-    public:
-        static const std::function< FunctionEvent() >& eventFactory();
-
-        std::int64_t operandOne = 0;
-        std::int64_t operandTwo = 0;
-        std::int64_t stepOneResult = 0;
-        std::int64_t stepTwoResult = 0;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/FunctionEventHandler.cpp ./Disruptor.PerfTests/FunctionEventHandler.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/FunctionEventHandler.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/FunctionEventHandler.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,54 +0,0 @@
-#include "stdafx.h"
-#include "FunctionEventHandler.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    FunctionEventHandler::FunctionEventHandler(FunctionStep functionStep)
-        : m_functionStep(functionStep)
-    {
-    }
-
-    std::int64_t FunctionEventHandler::stepThreeCounter() const
-    {
-        return m_counter.value;
-    }
-
-    void FunctionEventHandler::reset(const std::shared_ptr< Tests::ManualResetEvent >& latch, std::int64_t iterations)
-    {
-        m_counter.value = 0;
-        m_iterations = iterations;
-        m_latch = latch;
-    }
-
-    void FunctionEventHandler::onEvent(FunctionEvent& data, std::int64_t sequence, bool /*endOfBatch*/)
-    {
-        switch (m_functionStep)
-        {
-        case FunctionStep::One:
-            data.stepOneResult = data.operandOne + data.operandTwo;
-            break;
-
-        case FunctionStep::Two:
-            data.stepTwoResult = data.stepOneResult + 3L;
-            break;
-
-        case FunctionStep::Three:
-            if ((data.stepTwoResult & 4L) == 4L)
-            {
-                m_counter.value = m_counter.value + 1;
-            }
-            break;
-        }
-
-        if (sequence == m_iterations - 1)
-        {
-            m_latch->set();
-        }
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/FunctionEventHandler.h ./Disruptor.PerfTests/FunctionEventHandler.h
--- ../Disruptor-cpp/Disruptor.PerfTests/FunctionEventHandler.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/FunctionEventHandler.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,38 +0,0 @@
-#pragma once
-
-#include <memory>
-
-#include "Disruptor/IEventHandler.h"
-
-#include "Disruptor.TestTools/ManualResetEvent.h"
-
-#include "Disruptor.PerfTests/FunctionEvent.h"
-#include "Disruptor.PerfTests/FunctionStep.h"
-#include "Disruptor.PerfTests/PaddedLong.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class FunctionEventHandler : public IEventHandler< FunctionEvent >
-    {
-    public:
-        explicit FunctionEventHandler(FunctionStep functionStep);
-
-        std::int64_t stepThreeCounter() const;
-
-        void reset(const std::shared_ptr< Tests::ManualResetEvent >& latch, std::int64_t iterations);
-
-        void onEvent(FunctionEvent& data, std::int64_t sequence, bool endOfBatch);
-
-    private:
-        FunctionStep m_functionStep;
-        PaddedLong m_counter;
-        std::int64_t m_iterations{0};
-        std::shared_ptr< Tests::ManualResetEvent > m_latch;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/FunctionStep.h ./Disruptor.PerfTests/FunctionStep.h
--- ../Disruptor-cpp/Disruptor.PerfTests/FunctionStep.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/FunctionStep.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,17 +0,0 @@
-#pragma once
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    enum class FunctionStep
-    {
-        One,
-        Two,
-        Three,
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/ILatencyTest.h ./Disruptor.PerfTests/ILatencyTest.h
--- ../Disruptor-cpp/Disruptor.PerfTests/ILatencyTest.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/ILatencyTest.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,25 +0,0 @@
-#pragma once
-
-#include <cstdint>
-
-#include "Disruptor.TestTools/LatencyRecorder.h"
-#include "Disruptor.TestTools/Stopwatch.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class ILatencyTest
-    {
-    public:
-        virtual ~ILatencyTest() = default;
-
-        virtual void run(Stopwatch& stopwatch, const std::shared_ptr< Tests::LatencyRecorder >& latencyRecorder) = 0;
-
-        virtual std::int32_t requiredProcessorCount() const = 0;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/IThroughputTest.h ./Disruptor.PerfTests/IThroughputTest.h
--- ../Disruptor-cpp/Disruptor.PerfTests/IThroughputTest.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/IThroughputTest.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,24 +0,0 @@
-#pragma once
-
-#include <cstdint>
-
-#include "Disruptor.TestTools/Stopwatch.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class IThroughputTest
-    {
-    public:
-        virtual ~IThroughputTest() = default;
-
-        virtual std::int64_t run(Stopwatch& stopwatch) = 0;
-
-        virtual std::int32_t requiredProcessorCount() const = 0;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/LatencyTestSession.cpp ./Disruptor.PerfTests/LatencyTestSession.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/LatencyTestSession.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/LatencyTestSession.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,75 +0,0 @@
-#include "stdafx.h"
-#include "LatencyTestSession.h"
-
-#include "Disruptor.TestTools/LatencyRecorder.h"
-#include "Disruptor.TestTools/Stopwatch.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    LatencyTestSession::LatencyTestSession(const LatencyTestInfo& testInfo)
-    {
-        m_testInfo = testInfo;
-    }
-
-    void LatencyTestSession::run()
-    {
-        auto testInstance = m_testInfo.factory();
-
-        checkProcessorsRequirements(testInstance);
-
-        std::cout << "Latency Test to run => " << m_testInfo.name << ", Runs => " << m_runs << std::endl;
-        std::cout << "Starting latency tests" << std::endl;;
-
-        Stopwatch stopwatch;
-        for (auto i = 0; i < m_runs; ++i)
-        {
-            stopwatch.reset();
-            auto histogram = std::make_shared< Tests::LatencyRecorder >(100000000L);
-
-            try
-            {
-                testInstance->run(stopwatch, histogram);
-            }
-            catch (std::exception& ex)
-            {
-                LatencyTestSessionResult result(ex);
-                std::cout << result.toString() << std::endl;
-                m_results.push_back(result);
-                continue;
-            }
-
-            LatencyTestSessionResult result(histogram, stopwatch.elapsed());
-            std::cout << result.toString() << std::endl;
-            m_results.push_back(result);
-        }
-    }
-
-    void LatencyTestSession::checkProcessorsRequirements(const std::shared_ptr< ILatencyTest >& test)
-    {
-        auto availableProcessors = static_cast< std::int32_t >(std::thread::hardware_concurrency());
-        if (test->requiredProcessorCount() <= availableProcessors)
-            return;
-
-        std::cout << "*** Warning ***: your system has insufficient processors to execute the test efficiently. " << std::endl;
-        std::cout << "Processors required = " << test->requiredProcessorCount() << ", available = " << availableProcessors << std::endl;
-    }
-
-    std::int64_t LatencyTestSession::convertStopwatchTicksToNano(double durationInTicks)
-    {
-        auto clockFrequency = static_cast< double >(ClockConfig::Duration::period::den) / static_cast< double >(ClockConfig::Duration::period::num);
-        auto durationInNano = (durationInTicks / clockFrequency) * std::pow(10, 9);
-        return static_cast< std::int64_t >(durationInNano);
-    }
-
-    double LatencyTestSession::convertNanoToStopwatchTicks(std::int64_t pauseDurationInNanos)
-    {
-        auto clockFrequency = static_cast< double >(ClockConfig::Duration::period::den) / static_cast< double >(ClockConfig::Duration::period::num);
-        return pauseDurationInNanos * std::pow(10, -9) * clockFrequency;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/LatencyTestSession.h ./Disruptor.PerfTests/LatencyTestSession.h
--- ../Disruptor-cpp/Disruptor.PerfTests/LatencyTestSession.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/LatencyTestSession.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,38 +0,0 @@
-#pragma once
-
-#include <memory>
-#include <string>
-
-#include "Disruptor.PerfTests/TestFactory.h"
-#include "LatencyTestSessionResult.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class ILatencyTest;
-
-
-    class LatencyTestSession
-    {
-    public:
-        explicit LatencyTestSession(const LatencyTestInfo& testInfo);
-
-        void run();
-
-        static std::int64_t convertStopwatchTicksToNano(double durationInTicks);
-        static double convertNanoToStopwatchTicks(std::int64_t pauseDurationInNanos);
-
-    private:
-        static void checkProcessorsRequirements(const std::shared_ptr< ILatencyTest >& test);
-
-        const std::int32_t m_runs = 3;
-
-        LatencyTestInfo m_testInfo;
-        std::vector< LatencyTestSessionResult > m_results;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/LatencyTestSessionResult.cpp ./Disruptor.PerfTests/LatencyTestSessionResult.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/LatencyTestSessionResult.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/LatencyTestSessionResult.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,53 +0,0 @@
-#include "stdafx.h"
-#include "LatencyTestSessionResult.h"
-
-#include <iomanip>
-#include <sstream>
-
-#include "Disruptor.TestTools/DurationHumanizer.h"
-#include "Disruptor.TestTools/HumanNumberFacet.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    LatencyTestSessionResult::LatencyTestSessionResult(const std::shared_ptr< Tests::LatencyRecorder >& latencyRecorder, const ClockConfig::Duration& duration)
-        : m_latencyRecorder(latencyRecorder)
-        , m_duration(duration)
-    {
-    }
-
-    LatencyTestSessionResult::LatencyTestSessionResult(const std::exception& exception)
-        : m_exception(exception)
-    {
-    }
-
-    std::string LatencyTestSessionResult::toString()
-    {
-        std::ostringstream result;
-        result.imbue(std::locale(result.getloc(), new Tests::HumanNumberFacet()));
-
-        if (m_exception)
-            result << "Run: FAILED: " << m_exception.get().what();
-        else
-        {
-            auto humanDuration = Tests::DurationHumanizer::deduceHumanDuration(duration());
-
-            result << "Run: "
-                << "Duration (" << humanDuration.shortUnitName << "): " << std::setprecision(3) << humanDuration.value
-                << ", Latency: ";
-            m_latencyRecorder->writeReport(result);
-        }
-
-        return result.str();
-    }
-
-    ClockConfig::Duration LatencyTestSessionResult::duration() const
-    {
-        return m_duration;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/LatencyTestSessionResult.h ./Disruptor.PerfTests/LatencyTestSessionResult.h
--- ../Disruptor-cpp/Disruptor.PerfTests/LatencyTestSessionResult.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/LatencyTestSessionResult.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,36 +0,0 @@
-#pragma once
-
-#include <cstdint>
-#include <exception>
-#include <iosfwd>
-
-#include <boost/optional.hpp>
-
-#include "Disruptor/ClockConfig.h"
-#include "Disruptor.TestTools/LatencyRecorder.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class LatencyTestSessionResult
-    {
-    public:
-        LatencyTestSessionResult(const std::shared_ptr< Tests::LatencyRecorder >& latencyRecorder, const ClockConfig::Duration& duration);
-        
-        explicit LatencyTestSessionResult(const std::exception& exception);
-
-        std::string toString();
-
-        ClockConfig::Duration duration() const;
-
-    private:
-        std::shared_ptr< Tests::LatencyRecorder > m_latencyRecorder;
-        ClockConfig::Duration m_duration;
-        boost::optional< std::exception > m_exception;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/LongArrayEventHandler.cpp ./Disruptor.PerfTests/LongArrayEventHandler.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/LongArrayEventHandler.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/LongArrayEventHandler.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,47 +0,0 @@
-#include "stdafx.h"
-#include "LongArrayEventHandler.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    std::int64_t LongArrayEventHandler::count() const
-    {
-        return m_count;
-    }
-
-    const std::shared_ptr< Tests::ManualResetEvent >& LongArrayEventHandler::signal() const
-    {
-        return m_signal;
-    }
-
-    std::int64_t LongArrayEventHandler::value() const
-    {
-        return m_value->value;
-    }
-
-    void LongArrayEventHandler::reset(const std::shared_ptr< Tests::ManualResetEvent >& signal, std::int64_t expectedCount)
-    {
-        m_value->value = 0L;
-        m_signal = signal;
-        m_count = expectedCount;
-    }
-
-    void LongArrayEventHandler::onEvent(std::vector< std::int64_t >& data, std::int64_t /*sequence*/, bool /*endOfBatch*/)
-    {
-        for (auto i = 0u; i < data.size(); ++i)
-        {
-            m_value->value = m_value->value + data[i];
-        }
-
-        if (--m_count == 0)
-        {
-            if (m_signal != nullptr)
-                m_signal->set();
-        }
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/LongArrayEventHandler.h ./Disruptor.PerfTests/LongArrayEventHandler.h
--- ../Disruptor-cpp/Disruptor.PerfTests/LongArrayEventHandler.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/LongArrayEventHandler.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,38 +0,0 @@
-#pragma once
-
-#include <cstdint>
-#include <vector>
-
-#include "Disruptor/IEventHandler.h"
-
-#include "Disruptor.TestTools/ManualResetEvent.h"
-
-#include "Disruptor.PerfTests/PaddedLong.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class LongArrayEventHandler : public IEventHandler< std::vector< std::int64_t > >
-    {
-    public:
-        std::int64_t count() const;
-
-        const std::shared_ptr< Tests::ManualResetEvent >& signal() const;
-
-        std::int64_t value() const;
-
-        void reset(const std::shared_ptr< Tests::ManualResetEvent >& signal, std::int64_t expectedCount);
-
-        void onEvent(std::vector< std::int64_t >& data, std::int64_t sequence, bool endOfBatch) override;
-
-    private:
-        std::shared_ptr< PaddedLong > m_value = std::make_shared< PaddedLong >();
-        std::int64_t m_count = 0;
-        std::shared_ptr< Tests::ManualResetEvent > m_signal;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/MultiBufferBatchEventProcessor.h ./Disruptor.PerfTests/MultiBufferBatchEventProcessor.h
--- ../Disruptor-cpp/Disruptor.PerfTests/MultiBufferBatchEventProcessor.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/MultiBufferBatchEventProcessor.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,135 +0,0 @@
-#pragma once
-
-#include <atomic>
-#include <iostream>
-#include <memory>
-#include <thread>
-#include <vector>
-
-#include "Disruptor/AlertException.h"
-#include "Disruptor/ArgumentException.h"
-#include "Disruptor/IDataProvider.h"
-#include "Disruptor/IEventHandler.h"
-#include "Disruptor/IEventProcessor.h"
-#include "Disruptor/ISequenceBarrier.h"
-#include "Disruptor/NotSupportedException.h"
-#include "Disruptor/Sequence.h"
-#include "Disruptor/TimeoutException.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    template <class T>
-    class MultiBufferBatchEventProcessor : public IEventProcessor
-    {
-    public:
-        MultiBufferBatchEventProcessor(const std::vector< std::shared_ptr< IDataProvider< T > > >& providers,
-                                       const std::vector< std::shared_ptr< ISequenceBarrier > >& barriers,
-                                       const std::shared_ptr< IEventHandler< T > >& handler)
-        {
-            if (providers.size() != barriers.size())
-                DISRUPTOR_THROW_ARGUMENT_EXCEPTION("Should have as many providers as barriers (" << providers.size() << " != " << barriers.size() << ")");
-
-            m_providers = providers;
-            m_barriers = barriers;
-            m_handler = handler;
-
-            m_sequences.resize(m_providers.size());
-            for (auto i = 0u; i < m_sequences.size(); ++i)
-            {
-                m_sequences[i] = std::make_shared< Sequence >();
-            }
-        }
-
-        void run() override
-        {
-            if (std::atomic_exchange(&m_isRunning, 1) != 0)
-                throw std::runtime_error("Already running");
-
-            for (auto&& barrier : m_barriers)
-            {
-                barrier->clearAlert();
-            }
-
-            auto barrierLength = m_barriers.size();
-
-            while (true)
-            {
-                try
-                {
-                    for (auto i = 0u; i < barrierLength; ++i)
-                    {
-                        auto available = m_barriers[i]->waitFor(-1);
-                        auto sequence = m_sequences[i];
-
-                        auto nextSequence = sequence->value() + 1;
-
-                        for (auto l = nextSequence; l <= available; ++l)
-                        {
-                            m_handler->onEvent((*m_providers[i])[l], l, nextSequence == available);
-                        }
-
-                        sequence->setValue(available);
-
-                        m_count += available - nextSequence + 1;
-                    }
-
-                    std::this_thread::yield();
-                }
-                catch (AlertException&)
-                {
-                    if (m_isRunning == 0)
-                        break;
-                }
-                catch (TimeoutException& ex)
-                {
-                    std::cout << ex.what() << std::endl;
-                }
-                catch (std::exception& ex)
-                {
-                    std::cout << ex.what() << std::endl;
-                    break;
-                }
-            }
-        }
-
-        std::shared_ptr< ISequence > sequence() const override
-        {
-            DISRUPTOR_THROW_NOT_SUPPORTED_EXCEPTION();
-        }
-
-        std::int64_t count() const
-        {
-            return m_count;
-        }
-
-        const std::vector< std::shared_ptr< ISequence > >& getSequences() const
-        {
-            return m_sequences;
-        }
-
-        void halt() override
-        {
-            m_isRunning = 0;
-            m_barriers[0]->alert();
-        }
-
-        bool isRunning() const override
-        {
-            return m_isRunning == 1;
-        }
-        
-    private:
-        std::atomic< std::int32_t > m_isRunning{0};
-        std::vector< std::shared_ptr< IDataProvider< T > > > m_providers;
-        std::vector< std::shared_ptr< ISequenceBarrier > > m_barriers;
-        std::shared_ptr< IEventHandler< T > > m_handler;
-        std::vector< std::shared_ptr< ISequence > > m_sequences;
-        std::int64_t m_count = 0;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/MutableLong.cpp ./Disruptor.PerfTests/MutableLong.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/MutableLong.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/MutableLong.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,16 +0,0 @@
-#include "stdafx.h"
-#include "MutableLong.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    MutableLong::MutableLong(std::int64_t value)
-        : value(value)
-    {
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/MutableLong.h ./Disruptor.PerfTests/MutableLong.h
--- ../Disruptor-cpp/Disruptor.PerfTests/MutableLong.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/MutableLong.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,20 +0,0 @@
-#pragma once
-
-#include <cstdint>
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class MutableLong
-    {
-    public:
-        explicit MutableLong(std::int64_t value);
-
-        std::int64_t value;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToOneRawBatchThroughputTest.cpp ./Disruptor.PerfTests/OneToOneRawBatchThroughputTest.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToOneRawBatchThroughputTest.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToOneRawBatchThroughputTest.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,88 +0,0 @@
-#include "stdafx.h"
-#include "OneToOneRawBatchThroughputTest.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    OneToOneRawBatchThroughputTest::OneToOneRawBatchThroughputTest()
-    {
-        m_myRunnable = std::make_shared< MyRunnable >(m_sequencer);
-        m_sequencer->addGatingSequences({ m_myRunnable->sequence });
-    }
-
-    std::int64_t OneToOneRawBatchThroughputTest::run(Stopwatch& stopwatch)
-    {
-        std::int32_t batchSize = 10;
-        auto latch = std::make_shared< Tests::ManualResetEvent >(false);
-        auto expectedCount = m_myRunnable->sequence->value() + m_iterations * batchSize;
-        m_myRunnable->reset(latch, expectedCount);
-        std::thread([this] { m_myRunnable->run(); }).detach();
-        stopwatch.start();
-
-        auto sequencer = m_sequencer;
-
-        for (std::int64_t i = 0; i < m_iterations; i++)
-        {
-            auto next = sequencer->next(batchSize);
-            sequencer->publish(next - (batchSize - 1), next);
-        }
-
-        latch->waitOne();
-        stopwatch.stop();
-        waitForEventProcessorSequence(expectedCount);
-
-        return m_iterations * batchSize;
-    }
-
-    std::int32_t OneToOneRawBatchThroughputTest::requiredProcessorCount() const
-    {
-        return 2;
-    }
-
-    void OneToOneRawBatchThroughputTest::waitForEventProcessorSequence(std::int64_t expectedCount)
-    {
-        while (m_myRunnable->sequence->value() != expectedCount)
-        {
-            std::this_thread::sleep_for(std::chrono::milliseconds(1));
-        }
-    }
-
-    OneToOneRawBatchThroughputTest::MyRunnable::MyRunnable(const std::shared_ptr< ISequencer< boost::any > >& sequencer)
-    {
-        m_barrier = sequencer->newBarrier({});
-    }
-
-    void OneToOneRawBatchThroughputTest::MyRunnable::reset(const std::shared_ptr< Tests::ManualResetEvent >& latch, std::int64_t expectedCount)
-    {
-        m_latch = latch;
-        m_expectedCount = expectedCount;
-    }
-
-    void OneToOneRawBatchThroughputTest::MyRunnable::run()
-    {
-        auto expected = m_expectedCount;
-
-        try
-        {
-            std::int64_t processed;
-            do
-            {
-                processed = m_barrier->waitFor(sequence->value() + 1);
-                sequence->setValue(processed);
-            }
-            while (processed < expected);
-
-            m_latch->set();
-            sequence->setValue(processed);
-        }
-        catch (std::exception& ex)
-        {
-            std::cout << ex.what() << std::endl;
-        }
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToOneRawBatchThroughputTest.h ./Disruptor.PerfTests/OneToOneRawBatchThroughputTest.h
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToOneRawBatchThroughputTest.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToOneRawBatchThroughputTest.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,102 +0,0 @@
-#pragma once
-
-#include <boost/any.hpp>
-
-#include "Disruptor/ISequencer.h"
-#include "Disruptor/Sequence.h"
-#include "Disruptor/SingleProducerSequencer.h"
-#include "Disruptor/YieldingWaitStrategy.h"
-
-#include "Disruptor.TestTools/ManualResetEvent.h"
-#include "Disruptor.TestTools/Stopwatch.h"
-
-#include "Disruptor.PerfTests/IThroughputTest.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    /**
-     * UniCast a series of items between 1 publisher and 1 event processor.
-     * +----+    +-----+
-     * | P1 |--->| EP1 |
-     * +----+    +-----+
-     * 
-     * Queue Based:
-     * ============
-     * 
-     *        put take
-     * +----+    +====+    +-----+
-     * | P1 |---\| Q1 |/---| EP1 |
-     * +----+    +====+    +-----+
-     * 
-     * P1  - Publisher 1
-     * Q1  - Queue 1
-     * EP1 - EventProcessor 1
-     * 
-     * Disruptor:
-     * ==========
-     *              track to prevent wrap
-     *              +------------------+
-     *              |                  |
-     *              |                  v
-     * +----+    +====+    +====+   +-----+
-     * | P1 |--->| RB |/---| SB |   | EP1 |
-     * +----+    +====+    +====+   +-----+
-     *      claim get    ^        |
-     *                        |        |
-     *                        +--------+
-     *                          waitFor
-     * P1  - Publisher 1
-     * RB  - RingBuffer
-     * SB  - SequenceBarrier
-     * EP1 - EventProcessor 1
-     *
-     */
-    class OneToOneRawBatchThroughputTest : public IThroughputTest
-    {
-        class MyRunnable;
-
-    public:
-        OneToOneRawBatchThroughputTest();
-
-        std::int64_t run(Stopwatch& stopwatch) override;
-        std::int32_t requiredProcessorCount() const override;
-
-    private:
-        void waitForEventProcessorSequence(std::int64_t expectedCount);
-
-        const std::int32_t m_bufferSize = 1024 * 64;
-
-#ifdef _DEBUG
-        const std::int64_t m_iterations = 100L * 100L * 20L;
-#else
-        const std::int64_t m_iterations = 1000L * 1000L * 200L;
-#endif
-
-        std::shared_ptr< ISequencer< boost::any > > m_sequencer = std::make_shared< SingleProducerSequencer< boost::any > >(m_bufferSize, std::make_shared< YieldingWaitStrategy >());
-        std::shared_ptr< MyRunnable > m_myRunnable;
-    };
-
-
-    class OneToOneRawBatchThroughputTest::MyRunnable
-    {
-    public:
-        explicit MyRunnable(const std::shared_ptr< ISequencer< boost::any > >& sequencer);
-
-        void reset(const std::shared_ptr< Tests::ManualResetEvent >& latch, std::int64_t expectedCount);
-
-        void run();
-
-        std::shared_ptr< Sequence > sequence = std::make_shared< Sequence >(-1);
-
-    private:
-        std::shared_ptr< Tests::ManualResetEvent > m_latch;
-        std::int64_t m_expectedCount;
-        std::shared_ptr< ISequenceBarrier > m_barrier;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToOneRawThroughputTest.cpp ./Disruptor.PerfTests/OneToOneRawThroughputTest.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToOneRawThroughputTest.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToOneRawThroughputTest.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,106 +0,0 @@
-#include "stdafx.h"
-#include "OneToOneRawThroughputTest.h"
-
-#include "Disruptor.TestTools/ScopeExitFunctor.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    OneToOneRawThroughputTest::OneToOneRawThroughputTest()
-    {
-        m_myRunnable = std::make_shared< MyRunnable >(m_sequencer);
-        m_sequencer->addGatingSequences({ m_myRunnable->sequence });
-        m_taskScheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
-    }
-
-    std::int64_t OneToOneRawThroughputTest::run(Stopwatch& stopwatch)
-    {
-        m_taskScheduler->start(requiredProcessorCount());
-        TestTools::ScopeExitFunctor atScopeExit([this] { m_taskScheduler->stop(); });
-
-        auto latch = std::make_shared< Tests::ManualResetEvent >(false);
-        const auto expectedCount = m_myRunnable->sequence->value() + m_iterations;
-        m_myRunnable->reset(latch, expectedCount);
-
-        auto consumerTask = m_taskScheduler->scheduleAndStart(std::packaged_task< void() >([this] { m_myRunnable->run(); }));
-        stopwatch.start();
-
-        auto sequencer = m_sequencer;
-
-        auto producerTask = m_taskScheduler->scheduleAndStart(std::packaged_task< void() >([this, sequencer, latch]
-        {
-            auto& s = *sequencer;
-            for (std::int64_t i = 0; i < m_iterations; ++i)
-            {
-                auto next = s.next();
-                s.publish(next);
-            }
-
-            latch->waitOne();
-        }));
-
-        producerTask.wait();
-        stopwatch.stop();
-        waitForEventProcessorSequence(expectedCount);
-
-        consumerTask.wait();
-
-        return m_iterations;
-    }
-
-    std::int32_t OneToOneRawThroughputTest::requiredProcessorCount() const
-    {
-        return 2;
-    }
-
-    void OneToOneRawThroughputTest::waitForEventProcessorSequence(std::int64_t expectedCount) const
-    {
-        while (m_myRunnable->sequence->value() != expectedCount)
-        {
-            std::this_thread::sleep_for(std::chrono::milliseconds(1));
-        }
-    }
-
-    OneToOneRawThroughputTest::MyRunnable::MyRunnable(const std::shared_ptr< ISequencer< boost::any > >& sequencer)
-    {
-        m_barrier = sequencer->newBarrier({});
-    }
-
-    void OneToOneRawThroughputTest::MyRunnable::reset(const std::shared_ptr< Tests::ManualResetEvent >& latch, std::int64_t expectedCount)
-    {
-        m_latch = latch;
-        m_expectedCount = expectedCount;
-    }
-
-    void OneToOneRawThroughputTest::MyRunnable::run() const
-    {
-        auto expected = m_expectedCount;
-
-        auto& b = *m_barrier;
-        auto& s = *sequence;
-
-        try
-        {
-            std::int64_t processed;
-
-            do
-            {
-                processed = b.waitFor(s.value() + 1);
-                s.setValue(processed);
-            }
-            while (processed < expected);
-
-            m_latch->set();
-            s.setValue(processed);
-        }
-        catch (std::exception& ex)
-        {
-            std::cout << ex.what() << std::endl;
-        }
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToOneRawThroughputTest.h ./Disruptor.PerfTests/OneToOneRawThroughputTest.h
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToOneRawThroughputTest.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToOneRawThroughputTest.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,105 +0,0 @@
-#pragma once
-
-#include <boost/any.hpp>
-
-#include "Disruptor/ISequencer.h"
-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
-#include "Disruptor/Sequence.h"
-#include "Disruptor/SingleProducerSequencer.h"
-#include "Disruptor/YieldingWaitStrategy.h"
-
-#include "Disruptor.TestTools/ManualResetEvent.h"
-#include "Disruptor.TestTools/Stopwatch.h"
-
-#include "Disruptor.PerfTests/IThroughputTest.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    /**
-     *  UniCast a series of items between 1 publisher and 1 event processor.
-     *  +----+    +-----+
-     *  | P1 |--->| EP1 |
-     *  +----+    +-----+
-     *  
-     *  Queue Based:
-     *  ============
-     *  
-     *         put take
-     *  +----+    +====+    +-----+
-     *  | P1 |---\| Q1 |/---| EP1 |
-     *  +----+    +====+    +-----+
-     *  
-     *  P1  - Publisher 1
-     *  Q1  - Queue 1
-     *  EP1 - EventProcessor 1
-     *  
-     *  Disruptor:
-     *  ==========
-     *               track to prevent wrap
-     *               +------------------+
-     *               |                  |
-     *               |                  v
-     *  +----+    +====+    +====+   +-----+
-     *  | P1 |--->| RB |/---| SB |   | EP1 |
-     *  +----+    +====+    +====+   +-----+
-     *       claim get    ^        |
-     *                         |        |
-     *                         +--------+
-     *                           waitFor
-     *  P1  - Publisher 1
-     *  RB  - RingBuffer
-     *  SB  - SequenceBarrier
-     *  EP1 - EventProcessor 1
-     * 
-     */
-    class OneToOneRawThroughputTest : public IThroughputTest
-    {
-        //C# Run: Ops:  140 078 898 - Duration: 1428 (ms)
-        class MyRunnable;
-
-    public:
-        OneToOneRawThroughputTest();
-
-        std::int64_t run(Stopwatch& stopwatch) override;
-        std::int32_t requiredProcessorCount() const override;
-
-    private:
-        void waitForEventProcessorSequence(std::int64_t expectedCount) const;
-
-        const std::int32_t m_bufferSize = 1024 * 64;
-
-//#ifdef _DEBUG
-//        const std::int64_t m_iterations = 100L * 100L * 20L;
-//#else
-        const std::int64_t m_iterations = 1000L * 1000L * 200L;
-//#endif
-
-        std::shared_ptr< ISequencer< boost::any > > m_sequencer = std::make_shared< SingleProducerSequencer< boost::any > >(m_bufferSize, std::make_shared< YieldingWaitStrategy >());
-        std::shared_ptr< MyRunnable > m_myRunnable;
-        std::shared_ptr< RoundRobinThreadAffinedTaskScheduler > m_taskScheduler;
-    };
-
-
-    class OneToOneRawThroughputTest::MyRunnable
-    {
-    public:
-        explicit MyRunnable(const std::shared_ptr< ISequencer< boost::any > >& sequencer);
-
-        void reset(const std::shared_ptr< Tests::ManualResetEvent >& latch, std::int64_t expectedCount);
-
-        void run() const;
-
-        std::shared_ptr< Sequence > sequence = std::make_shared< Sequence >(-1);
-
-    private:
-        std::shared_ptr< Tests::ManualResetEvent > m_latch;
-        std::int64_t m_expectedCount = 0;
-        std::shared_ptr< ISequenceBarrier > m_barrier;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToOneSequencedBatchThroughputTest.cpp ./Disruptor.PerfTests/OneToOneSequencedBatchThroughputTest.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToOneSequencedBatchThroughputTest.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToOneSequencedBatchThroughputTest.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,70 +0,0 @@
-#include "stdafx.h"
-#include "OneToOneSequencedBatchThroughputTest.h"
-
-#include "Disruptor/BasicExecutor.h"
-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
-#include "Disruptor/YieldingWaitStrategy.h"
-
-#include "Disruptor.TestTools/ScopeExitFunctor.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    OneToOneSequencedBatchThroughputTest::OneToOneSequencedBatchThroughputTest()
-    {
-        m_taskScheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
-        m_executor = std::make_shared< BasicExecutor >(m_taskScheduler);
-
-        m_ringBuffer = RingBuffer< ValueEvent >::createSingleProducer(ValueEvent::eventFactory(), m_bufferSize, std::make_shared< YieldingWaitStrategy >());
-        auto sequenceBarrier = m_ringBuffer->newBarrier();
-        m_handler = std::make_shared< ValueAdditionEventHandler >();
-        m_batchEventProcessor = std::make_shared< BatchEventProcessor< ValueEvent > >(m_ringBuffer, sequenceBarrier, m_handler);
-        m_ringBuffer->addGatingSequences({ m_batchEventProcessor->sequence() });
-    }
-
-    std::int64_t OneToOneSequencedBatchThroughputTest::run(Stopwatch& stopwatch)
-    {
-        m_taskScheduler->start(requiredProcessorCount());
-        TestTools::ScopeExitFunctor atScopeExit([this] { m_taskScheduler->stop(); });
-
-        auto signal = std::make_shared< Tests::ManualResetEvent >(false);
-        auto expectedCount = m_batchEventProcessor->sequence()->value() + m_iterations * m_batchSize;
-        m_handler->reset(signal, expectedCount);
-        auto processorTask = m_executor->execute([this] { m_batchEventProcessor->run(); });
-        stopwatch.start();
-
-        auto&& rb = *m_ringBuffer;
-
-        for (auto i = 0; i < m_iterations; ++i)
-        {
-            auto hi = rb.next(m_batchSize);
-            auto lo = hi - (m_batchSize - 1);
-            for (auto l = lo; l <= hi; ++l)
-            {
-                rb[l].value = (i);
-            }
-            rb.publish(lo, hi);
-        }
-
-        signal->waitOne();
-        stopwatch.stop();
-        PerfTestUtil::waitForEventProcessorSequence(expectedCount, m_batchEventProcessor);
-        m_batchEventProcessor->halt();
-        processorTask.wait_for(std::chrono::milliseconds(2000));
-
-        PerfTestUtil::failIfNot(m_expectedResult, m_handler->value(),
-                                "Handler should have processed " + std::to_string(m_expectedResult) + " events, but was: " + std::to_string(m_handler->value()));
-
-        return m_batchSize * m_iterations;
-    }
-
-    std::int32_t OneToOneSequencedBatchThroughputTest::requiredProcessorCount() const
-    {
-        return 2;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToOneSequencedBatchThroughputTest.h ./Disruptor.PerfTests/OneToOneSequencedBatchThroughputTest.h
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToOneSequencedBatchThroughputTest.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToOneSequencedBatchThroughputTest.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,75 +0,0 @@
-#pragma once
-
-#include "Disruptor/BatchEventProcessor.h"
-#include "Disruptor/IExecutor.h"
-#include "Disruptor/ITaskScheduler.h"
-#include "Disruptor/RingBuffer.h"
-
-#include "Disruptor.PerfTests/IThroughputTest.h"
-#include "Disruptor.PerfTests/PerfTestUtil.h"
-#include "Disruptor.PerfTests/ValueAdditionEventHandler.h"
-#include "Disruptor.PerfTests/ValueEvent.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    /**
-     * UniCast a series of items between 1 publisher and 1 event processor
-     * 
-     * +----+    +-----+
-     * | P1 |--->| EP1 |
-     * +----+    +-----+
-     * 
-     * Disruptor:
-     * ==========
-     *              track to prevent wrap
-     *              +------------------+
-     *              |                  |
-     *              |                  v
-     * +----+    +====+    +====+   +-----+
-     * | P1 |---| RB |---| SB |   | EP1 |
-     * +----+    +====+    +====+   +-----+
-     *      claim      get    ^        |
-     *                        |        |
-     *                        +--------+
-     *                          waitFor
-     * 
-     * P1  - Publisher 1
-     * RB  - RingBuffer
-     * SB  - SequenceBarrier
-     * EP1 - EventProcessor 1
-     * 
-     **/
-    class OneToOneSequencedBatchThroughputTest : public IThroughputTest
-    {
-    public:
-        OneToOneSequencedBatchThroughputTest();
-
-        std::int64_t run(Stopwatch& stopwatch) override;
-
-        std::int32_t requiredProcessorCount() const override;
-
-    private:
-        const std::int32_t m_batchSize = 10;
-        const std::int32_t m_bufferSize = 1024 * 64;
-
-#ifdef _DEBUG
-        const std::int64_t m_iterations = 100L * 100L * 10L;
-#else
-        const std::int64_t m_iterations = 1000L * 1000L * 100L;
-#endif
-
-        std::shared_ptr< IExecutor > m_executor;
-        const std::int64_t m_expectedResult = PerfTestUtil::accumulatedAddition(m_iterations) * m_batchSize;
-
-        std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer;
-        std::shared_ptr< ValueAdditionEventHandler > m_handler;
-        std::shared_ptr< BatchEventProcessor< ValueEvent > > m_batchEventProcessor;
-        std::shared_ptr< ITaskScheduler > m_taskScheduler;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToOneSequencedLongArrayThroughputTest.cpp ./Disruptor.PerfTests/OneToOneSequencedLongArrayThroughputTest.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToOneSequencedLongArrayThroughputTest.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToOneSequencedLongArrayThroughputTest.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,82 +0,0 @@
-#include "stdafx.h"
-#include "OneToOneSequencedLongArrayThroughputTest.h"
-
-#include "Disruptor/BasicExecutor.h"
-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
-#include "Disruptor/YieldingWaitStrategy.h"
-
-#include "Disruptor.TestTools/ScopeExitFunctor.h"
-
-#include "PerfTestUtil.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    OneToOneSequencedLongArrayThroughputTest::OneToOneSequencedLongArrayThroughputTest()
-    {
-        m_taskScheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
-        m_executor = std::make_shared< BasicExecutor >(m_taskScheduler);
-
-        m_ringBuffer = RingBuffer< std::vector< std::int64_t > >::createSingleProducer([&] { return std::vector< std::int64_t >(m_arraySize); },
-                                                                                       m_bufferSize,
-                                                                                       std::make_shared< YieldingWaitStrategy >());
-        auto sequenceBarrier = m_ringBuffer->newBarrier();
-        m_handler = std::make_shared< LongArrayEventHandler >();
-        m_batchEventProcessor = std::make_shared< BatchEventProcessor< std::vector< std::int64_t > > >(m_ringBuffer, sequenceBarrier, m_handler);
-        m_ringBuffer->addGatingSequences({ m_batchEventProcessor->sequence() });
-    }
-
-    std::int64_t OneToOneSequencedLongArrayThroughputTest::run(Stopwatch& stopwatch)
-    {
-        m_taskScheduler->start(requiredProcessorCount());
-        TestTools::ScopeExitFunctor atScopeExit([this] { m_taskScheduler->stop(); });
-
-        auto signal = std::make_shared< Tests::ManualResetEvent >(false);
-        auto expectedCount = m_batchEventProcessor->sequence()->value() + m_iterations;
-        m_handler->reset(signal, m_iterations);
-        auto processorTask = m_executor->execute([this] { m_batchEventProcessor->run(); });
-
-        auto& rb = *m_ringBuffer;
-
-        stopwatch.start();
-
-        for (auto i = 0; i < m_iterations; ++i)
-        {
-            auto next = rb.next();
-            auto& event = rb[next];
-            for (auto j = 0u; j < event.size(); ++j)
-            {
-                event[j] = i;
-            }
-            rb.publish(next);
-        }
-
-        signal->waitOne();
-        stopwatch.stop();
-        waitForEventProcessorSequence(expectedCount);
-        m_batchEventProcessor->halt();
-        processorTask.wait_for(std::chrono::seconds(10));
-
-        PerfTestUtil::failIf(0, m_handler->value(), "Handler has not processed any event");
-
-        return m_iterations * m_arraySize;
-    }
-
-    std::int32_t OneToOneSequencedLongArrayThroughputTest::requiredProcessorCount() const
-    {
-        return 2;
-    }
-
-    void OneToOneSequencedLongArrayThroughputTest::waitForEventProcessorSequence(std::int64_t expectedCount)
-    {
-        while (m_batchEventProcessor->sequence()->value() != expectedCount)
-        {
-            std::this_thread::sleep_for(std::chrono::milliseconds(1));
-        }
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToOneSequencedLongArrayThroughputTest.h ./Disruptor.PerfTests/OneToOneSequencedLongArrayThroughputTest.h
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToOneSequencedLongArrayThroughputTest.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToOneSequencedLongArrayThroughputTest.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,72 +0,0 @@
-#pragma once
-
-#include "Disruptor/BatchEventProcessor.h"
-#include "Disruptor/IExecutor.h"
-#include "Disruptor/ITaskScheduler.h"
-#include "Disruptor/RingBuffer.h"
-
-#include "Disruptor.PerfTests/IThroughputTest.h"
-#include "Disruptor.PerfTests/LongArrayEventHandler.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    /**
-     * UniCast a series of items between 1 publisher and 1 event processor.
-     *
-     * +----+    +-----+
-     * | P1 |--->| EP1 |
-     * +----+    +-----+
-     * Disruptor:
-     * ==========
-     *              track to prevent wrap
-     *              +------------------+
-     *              |                  |
-     *              |                  v
-     * +----+    +====+    +====+   +-----+
-     * | P1 |---| RB |---| SB |   | EP1 |
-     * +----+    +====+    +====+   +-----+
-     *      claim      get    ^        |
-     *                        |        |
-     *                        +--------+
-     *                          waitFor
-     * P1  - Publisher 1
-     * RB  - RingBuffer
-     * SB  - SequenceBarrier
-     * EP1 - EventProcessor 1
-     *
-     */
-    class OneToOneSequencedLongArrayThroughputTest : public IThroughputTest
-    {
-    public:
-        OneToOneSequencedLongArrayThroughputTest();
-
-        std::int64_t run(Stopwatch& stopwatch) override;
-
-        std::int32_t requiredProcessorCount() const override;
-
-    private:
-        void waitForEventProcessorSequence(std::int64_t expectedCount);
-
-        const std::int32_t m_bufferSize = 1024 * 1;
-
-#ifdef _DEBUG
-        const std::int64_t m_iterations = 100L * 100L * 1L;
-#else
-        const std::int64_t m_iterations = 1000L * 1000L * 1L;
-#endif
-
-        const std::int32_t m_arraySize = 2 * 1024;
-
-        std::shared_ptr< ITaskScheduler > m_taskScheduler;
-        std::shared_ptr< IExecutor > m_executor;
-        std::shared_ptr< RingBuffer< std::vector< std::int64_t > > > m_ringBuffer;
-        std::shared_ptr< LongArrayEventHandler > m_handler;
-        std::shared_ptr< BatchEventProcessor< std::vector< std::int64_t > > > m_batchEventProcessor;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToOneSequencedPollerThroughputTest.cpp ./Disruptor.PerfTests/OneToOneSequencedPollerThroughputTest.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToOneSequencedPollerThroughputTest.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToOneSequencedPollerThroughputTest.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,130 +0,0 @@
-#include "stdafx.h"
-#include "OneToOneSequencedPollerThroughputTest.h"
-
-#include "Disruptor/BasicExecutor.h"
-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
-#include "Disruptor/YieldingWaitStrategy.h"
-
-#include "Disruptor.TestTools/ScopeExitFunctor.h"
-#include "Disruptor.TestTools/ManualResetEvent.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    OneToOneSequencedPollerThroughputTest::OneToOneSequencedPollerThroughputTest()
-    {
-        m_scheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
-        m_executor = std::make_shared< BasicExecutor >(m_scheduler);
-
-        m_ringBuffer = RingBuffer< ValueEvent >::createSingleProducer(ValueEvent::eventFactory(), m_bufferSize, std::make_shared< YieldingWaitStrategy >());
-        m_poller = m_ringBuffer->newPoller();
-        m_ringBuffer->addGatingSequences({ m_poller->sequence() });
-        m_pollRunnable = std::make_shared< PollRunnable >(m_poller);
-    }
-
-    std::int64_t OneToOneSequencedPollerThroughputTest::run(Stopwatch& stopwatch)
-    {
-        m_scheduler->start(requiredProcessorCount());
-        TestTools::ScopeExitFunctor atScopeExit([this] { m_scheduler->stop(); });
-
-        auto latch = std::make_shared< Tests::ManualResetEvent >(false);
-        auto expectedCount = m_poller->sequence()->value() + m_iterations;
-        m_pollRunnable->reset(latch, expectedCount);
-        auto processorTask = m_executor->execute([this] { m_pollRunnable->run(); });
-        stopwatch.start();
-
-        auto& rb = *m_ringBuffer;
-        for (auto i = 0; i < m_iterations; ++i)
-        {
-            auto next = rb.next();
-            rb[next].value = i;
-            rb.publish(next);
-        }
-
-        latch->waitOne();
-        stopwatch.stop();
-        waitForEventProcessorSequence(expectedCount);
-        m_pollRunnable->halt();
-        processorTask.wait_for(std::chrono::milliseconds(2000));
-
-        PerfTestUtil::failIfNot(m_expectedResult, m_pollRunnable->value(),
-                                "Poll runnable should have processed " + std::to_string(m_expectedResult) + ", but was: " + std::to_string(m_pollRunnable->value()));
-
-        return m_iterations;
-    }
-
-    std::int32_t OneToOneSequencedPollerThroughputTest::requiredProcessorCount() const
-    {
-        return 2;
-    }
-
-    void OneToOneSequencedPollerThroughputTest::waitForEventProcessorSequence(std::int64_t expectedCount)
-    {
-        while (m_poller->sequence()->value() != expectedCount)
-        {
-            std::this_thread::sleep_for(std::chrono::milliseconds(1));
-        }
-    }
-
-    OneToOneSequencedPollerThroughputTest::PollRunnable::PollRunnable(const std::shared_ptr< EventPoller< ValueEvent > >& poller)
-        : m_poller(poller)
-    {
-        m_eventHandler = [this](ValueEvent& event, std::int64_t sequence, bool endOfBatch)
-        {
-            return this->onEvent(event, sequence, endOfBatch);
-        };
-    }
-
-    std::int64_t OneToOneSequencedPollerThroughputTest::PollRunnable::value() const
-    {
-        return m_value->value;
-    }
-
-    void OneToOneSequencedPollerThroughputTest::PollRunnable::run()
-    {
-        try
-        {
-            while (m_running == 1)
-            {
-                if (PollState::Processing != m_poller->poll(m_eventHandler))
-                {
-                    std::this_thread::sleep_for(std::chrono::milliseconds(0));
-                }
-            }
-        }
-        catch (std::exception& ex)
-        {
-            std::cout << ex.what() << std::endl;
-        }
-    }
-
-    void OneToOneSequencedPollerThroughputTest::PollRunnable::halt()
-    {
-        std::atomic_exchange(&m_running, 0);
-    }
-
-    void OneToOneSequencedPollerThroughputTest::PollRunnable::reset(const std::shared_ptr< Tests::ManualResetEvent >& signal, std::int64_t expectedCount)
-    {
-        m_value->value = 0L;
-        m_signal = signal;
-        m_count = expectedCount;
-        m_running = 1;
-    }
-
-    bool OneToOneSequencedPollerThroughputTest::PollRunnable::onEvent(ValueEvent& event, std::int64_t sequence, bool /*endOfBatch*/)
-    {
-        m_value->value = m_value->value + event.value;
-
-        if (m_count == sequence)
-        {
-            m_signal->set();
-        }
-
-        return true;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToOneSequencedPollerThroughputTest.h ./Disruptor.PerfTests/OneToOneSequencedPollerThroughputTest.h
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToOneSequencedPollerThroughputTest.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToOneSequencedPollerThroughputTest.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,75 +0,0 @@
-#pragma once
-
-#include "Disruptor/IExecutor.h"
-#include "Disruptor/ITaskScheduler.h"
-#include "Disruptor/RingBuffer.h"
-
-#include "Disruptor.TestTools/ManualResetEvent.h"
-
-#include "Disruptor.PerfTests/IThroughputTest.h"
-#include "Disruptor.PerfTests/PaddedLong.h"
-#include "Disruptor.PerfTests/PerfTestUtil.h"
-#include "Disruptor.PerfTests/ValueEvent.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class OneToOneSequencedPollerThroughputTest : public IThroughputTest
-    {
-        class PollRunnable;
-
-    public:
-        OneToOneSequencedPollerThroughputTest();
-
-        std::int64_t run(Stopwatch& stopwatch) override;
-
-        std::int32_t requiredProcessorCount() const override;
-
-    private:
-        void waitForEventProcessorSequence(std::int64_t expectedCount);
-
-        const std::int32_t m_bufferSize = 1024 * 64;
-
-#ifdef _DEBUG
-        const std::int64_t m_iterations = 100L * 100L * 10L;
-#else
-        const std::int64_t m_iterations = 1000L * 1000L * 100L;
-#endif
-
-        std::shared_ptr< IExecutor > m_executor;
-        std::shared_ptr< ITaskScheduler > m_scheduler;
-
-        std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer;
-        std::shared_ptr< EventPoller< ValueEvent > > m_poller;
-        std::shared_ptr< PollRunnable > m_pollRunnable;
-        const std::int64_t m_expectedResult = PerfTestUtil::accumulatedAddition(m_iterations);
-    };
-
-
-    class OneToOneSequencedPollerThroughputTest::PollRunnable
-    {
-    public:
-        explicit PollRunnable(const std::shared_ptr< EventPoller< ValueEvent > >& poller);
-
-        std::int64_t value() const;
-
-        void run();
-        void halt();
-        void reset(const std::shared_ptr< Tests::ManualResetEvent >& signal, std::int64_t expectedCount);
-
-    private:
-        bool onEvent(ValueEvent& event, std::int64_t sequence, bool endOfBatch);
-
-        std::shared_ptr< EventPoller< ValueEvent > > m_poller;
-        std::function< bool(ValueEvent&, std::int64_t, bool) > m_eventHandler;
-        std::atomic< std::int32_t > m_running {1};
-        std::shared_ptr< PaddedLong > m_value = std::make_shared< PaddedLong >();
-        std::shared_ptr< Tests::ManualResetEvent > m_signal;
-        std::int64_t m_count;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToOneSequencedThroughputTest.cpp ./Disruptor.PerfTests/OneToOneSequencedThroughputTest.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToOneSequencedThroughputTest.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToOneSequencedThroughputTest.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,69 +0,0 @@
-#include "stdafx.h"
-#include "OneToOneSequencedThroughputTest.h"
-
-#include "Disruptor/BasicExecutor.h"
-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
-#include "Disruptor/YieldingWaitStrategy.h"
-
-#include "Disruptor.TestTools/ScopeExitFunctor.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    OneToOneSequencedThroughputTest::OneToOneSequencedThroughputTest()
-    {
-        m_taskScheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
-        m_executor = std::make_shared< BasicExecutor >(m_taskScheduler);
-
-        m_latch = std::make_shared< Tests::ManualResetEvent >(false);
-        m_eventHandler = std::make_shared< ValueAdditionEventHandler >();
-        m_ringBuffer = RingBuffer< ValueEvent >::createSingleProducer(ValueEvent::eventFactory(), m_bufferSize, std::make_shared< YieldingWaitStrategy >());
-        auto sequenceBarrier = m_ringBuffer->newBarrier();
-        m_batchEventProcessor = std::make_shared< BatchEventProcessor< ValueEvent > >(m_ringBuffer, sequenceBarrier, m_eventHandler);
-        m_ringBuffer->addGatingSequences({ m_batchEventProcessor->sequence() });
-    }
-
-    std::int64_t OneToOneSequencedThroughputTest::run(Stopwatch& stopwatch)
-    {
-        m_taskScheduler->start(requiredProcessorCount());
-        TestTools::ScopeExitFunctor atScopeExit([this] { m_taskScheduler->stop(); });
-
-        auto expectedCount = m_batchEventProcessor->sequence()->value() + m_iterations;
-
-        m_latch->reset();
-        m_eventHandler->reset(m_latch, expectedCount);
-
-        auto processorTask = m_executor->execute([this] { m_batchEventProcessor->run(); });
-        stopwatch.start();
-
-        auto&& rb = *m_ringBuffer;
-
-        for (auto i = 0; i < m_iterations; ++i)
-        {
-            auto sequence = rb.next();
-            rb[sequence].value = i;
-            rb.publish(sequence);
-        }
-
-        m_latch->waitOne();
-        stopwatch.stop();
-        PerfTestUtil::waitForEventProcessorSequence(expectedCount, m_batchEventProcessor);
-        m_batchEventProcessor->halt();
-        processorTask.wait_for(std::chrono::seconds(10));
-
-        PerfTestUtil::failIfNot(m_expectedResult, m_eventHandler->value(),
-                                "Handler should have processed " + std::to_string(m_expectedResult) + " events, but was: " + std::to_string(m_eventHandler->value()));
-
-        return m_iterations;
-    }
-
-    std::int32_t OneToOneSequencedThroughputTest::requiredProcessorCount() const
-    {
-        return 2;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToOneSequencedThroughputTest.h ./Disruptor.PerfTests/OneToOneSequencedThroughputTest.h
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToOneSequencedThroughputTest.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToOneSequencedThroughputTest.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,76 +0,0 @@
-#pragma once
-
-#include "Disruptor/BatchEventProcessor.h"
-#include "Disruptor/IExecutor.h"
-#include "Disruptor/ITaskScheduler.h"
-#include "Disruptor/RingBuffer.h"
-
-#include "Disruptor.TestTools/ManualResetEvent.h"
-
-#include "Disruptor.PerfTests/IThroughputTest.h"
-#include "Disruptor.PerfTests/PerfTestUtil.h"
-#include "Disruptor.PerfTests/ValueAdditionEventHandler.h"
-#include "Disruptor.PerfTests/ValueEvent.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    /**
-     * UniCast a series of items between 1 publisher and 1 event processor.
-     *
-     * +----+    +-----+
-     * | P1 |--->| EP1 |
-     * +----+    +-----+
-     *
-     * Disruptor:
-     * ==========
-     *              track to prevent wrap
-     *              +------------------+
-     *              |                  |
-     *              |                  v
-     * +----+    +====+    +====+   +-----+
-     * | P1 |---\| RB |/---| SB |   | EP1 |
-     * +----+    +====+    +====+   +-----+
-     *      claim       get   ^        |
-     *                        |        |
-     *                        +--------+
-     *                          waitFor
-     *
-     * P1  - Publisher 1
-     * RB  - RingBuffer
-     * SB  - SequenceBarrier
-     * EP1 - EventProcessor 1
-     *
-     */
-    class OneToOneSequencedThroughputTest : public IThroughputTest
-    {
-    public:
-        OneToOneSequencedThroughputTest();
-
-        std::int64_t run(Stopwatch& stopwatch) override;
-
-        std::int32_t requiredProcessorCount() const override;
-
-    private:
-        const std::int32_t m_bufferSize = 1024 * 64;
-
-#ifdef _DEBUG
-        const std::int64_t m_iterations = 100L * 100L * 10L;
-#else
-        const std::int64_t m_iterations = 1000L * 1000L * 100L;
-#endif
-
-        std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer;
-        std::shared_ptr< ValueAdditionEventHandler > m_eventHandler;
-        std::shared_ptr< Tests::ManualResetEvent > m_latch;
-        const std::int64_t m_expectedResult = PerfTestUtil::accumulatedAddition(m_iterations);
-        std::shared_ptr< BatchEventProcessor< ValueEvent > > m_batchEventProcessor;
-        std::shared_ptr< IExecutor > m_executor;
-        std::shared_ptr< ITaskScheduler > m_taskScheduler;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToOneTranslatorThroughputTest.cpp ./Disruptor.PerfTests/OneToOneTranslatorThroughputTest.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToOneTranslatorThroughputTest.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToOneTranslatorThroughputTest.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,82 +0,0 @@
-#include "stdafx.h"
-#include "OneToOneTranslatorThroughputTest.h"
-
-#include "Disruptor/Disruptor.h"
-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
-#include "Disruptor/YieldingWaitStrategy.h"
-
-#include "Disruptor.TestTools/ScopeExitFunctor.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    std::int64_t OneToOneTranslatorThroughputTest::run(Stopwatch& stopwatch)
-    {
-        m_taskScheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
-        m_taskScheduler->start(requiredProcessorCount());
-        TestTools::ScopeExitFunctor stopTaskSchedulerAtScopeExit([this] { m_taskScheduler->stop(); });
-
-        m_disruptor = std::make_shared< ::Disruptor::disruptor< ValueEvent > >(ValueEvent::eventFactory(),
-                                                                                  m_bufferSize,
-                                                                                  m_taskScheduler,
-                                                                                  ProducerType::Single,
-                                                                                  std::make_shared< YieldingWaitStrategy >());
-        TestTools::ScopeExitFunctor stopDisruptorAtScopeExit([this] { m_disruptor->shutdown(std::chrono::seconds(10)); });
-
-        m_disruptor->handleEventsWith(m_handler);
-        m_ringBuffer = m_disruptor->start();
-
-        auto& value = m_value;
-
-        auto latch = std::make_shared< Tests::ManualResetEvent >(false);
-        auto expectedCount = m_ringBuffer->getMinimumGatingSequence() + m_iterations;
-
-        m_handler->reset(latch, expectedCount);
-        stopwatch.start();
-
-        auto& rb = *m_ringBuffer;
-
-        for (std::int64_t l = 0; l < m_iterations; ++l)
-        {
-            value.value = l;
-            rb.publishEvent(Translator::instance(), value);
-        }
-
-        latch->waitOne();
-        stopwatch.stop();
-        waitForEventProcessorSequence(expectedCount);
-
-        PerfTestUtil::failIfNot(m_expectedResult, m_handler->value());
-
-        return m_iterations;
-    }
-
-    std::int32_t OneToOneTranslatorThroughputTest::requiredProcessorCount() const
-    {
-        return 2;
-    }
-
-    void OneToOneTranslatorThroughputTest::waitForEventProcessorSequence(std::int64_t expectedCount)
-    {
-        while (m_ringBuffer->getMinimumGatingSequence() != expectedCount)
-        {
-            std::this_thread::sleep_for(std::chrono::milliseconds(1));
-        }
-    }
-
-    const std::shared_ptr< OneToOneTranslatorThroughputTest::Translator >& OneToOneTranslatorThroughputTest::Translator::instance()
-    {
-        static std::shared_ptr< Translator > result(std::make_shared< Translator >());
-        return result;
-    }
-
-    void OneToOneTranslatorThroughputTest::Translator::translateTo(ValueEvent& event, std::int64_t /*sequence*/, const MutableLong& arg0)
-    {
-        event.value = arg0.value;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToOneTranslatorThroughputTest.h ./Disruptor.PerfTests/OneToOneTranslatorThroughputTest.h
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToOneTranslatorThroughputTest.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToOneTranslatorThroughputTest.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,85 +0,0 @@
-#pragma once
-
-#include "Disruptor/Disruptor.h"
-#include "Disruptor/ITaskScheduler.h"
-#include "Disruptor/RingBuffer.h"
-
-#include "Disruptor.PerfTests/IThroughputTest.h"
-#include "Disruptor.PerfTests/MutableLong.h"
-#include "Disruptor.PerfTests/PerfTestUtil.h"
-#include "Disruptor.PerfTests/ValueAdditionEventHandler.h"
-#include "Disruptor.PerfTests/ValueEvent.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    /**
-     *
-     *     UniCast a series of items between 1 publisher and 1 event processor using the EventTranslator API
-     *
-     *     +----+    +-----+
-     *     | P1 |--->| EP1 |
-     *     +----+    +-----+
-     *
-     *     Disruptor:
-     *     ==========
-     *     track to prevent wrap
-     *     +------------------+
-     *     |                  |
-     *     |                  v
-     *     +----+    +====+    +====+   +-----+
-     *     | P1 |--->| RB |/---| SB |   | EP1 |
-     *     +----+    +====+    +====+   +-----+
-     *     claim      get    ^        |
-     *     |        |
-     *     +--------+
-     *     waitFor
-     *
-     *     P1  - Publisher 1
-     *     RB  - RingBuffer
-     *     SB  - SequenceBarrier
-     *     EP1 - EventProcessor 1
-     *
-     */
-    class OneToOneTranslatorThroughputTest : public IThroughputTest
-    {
-        class Translator;
-
-    public:
-        std::int64_t run(Stopwatch& stopwatch) override;
-
-        std::int32_t requiredProcessorCount() const override;
-
-    private:
-        void waitForEventProcessorSequence(std::int64_t expectedCount);
-
-        const std::int32_t m_bufferSize = 1024 * 64;
-
-#ifdef _DEBUG
-        const std::int64_t m_iterations = 100L * 100L * 10L;
-#else
-        const std::int64_t m_iterations = 1000L * 1000L * 100L;
-#endif
-
-        const std::int64_t m_expectedResult = PerfTestUtil::accumulatedAddition(m_iterations);
-        std::shared_ptr< ValueAdditionEventHandler > m_handler = std::make_shared< ValueAdditionEventHandler >();
-        std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer;
-        MutableLong m_value = MutableLong(0);
-        std::shared_ptr< ITaskScheduler > m_taskScheduler;
-        std::shared_ptr< disruptor< ValueEvent > > m_disruptor;
-    };
-
-
-    class OneToOneTranslatorThroughputTest::Translator : public IEventTranslatorVararg< ValueEvent, MutableLong >
-    {
-    public:
-        static const std::shared_ptr< Translator >& instance();
-
-        void translateTo(ValueEvent& event, std::int64_t sequence, const MutableLong& arg0) override;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToThreeDiamondSequencedThroughputTest.cpp ./Disruptor.PerfTests/OneToThreeDiamondSequencedThroughputTest.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToThreeDiamondSequencedThroughputTest.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToThreeDiamondSequencedThroughputTest.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,84 +0,0 @@
-#include "stdafx.h"
-#include "OneToThreeDiamondSequencedThroughputTest.h"
-
-#include "PerfTestUtil.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    OneToThreeDiamondSequencedThroughputTest::OneToThreeDiamondSequencedThroughputTest()
-    {
-        auto sequenceBarrier = m_ringBuffer->newBarrier();
-
-        auto fizzHandler = std::make_shared< FizzBuzzEventHandler >(FizzBuzzStep::Fizz);
-        m_batchProcessorFizz = std::make_shared< BatchEventProcessor< FizzBuzzEvent > >(m_ringBuffer, sequenceBarrier, fizzHandler);
-
-        auto buzzHandler = std::make_shared< FizzBuzzEventHandler >(FizzBuzzStep::Buzz);
-        m_batchProcessorBuzz = std::make_shared< BatchEventProcessor< FizzBuzzEvent > >(m_ringBuffer, sequenceBarrier, buzzHandler);
-
-        auto sequenceBarrierFizzBuzz = m_ringBuffer->newBarrier({ m_batchProcessorFizz->sequence(), m_batchProcessorBuzz->sequence() });
-
-        m_fizzBuzzHandler = std::make_shared< FizzBuzzEventHandler >(FizzBuzzStep::FizzBuzz);
-        m_batchProcessorFizzBuzz = std::make_shared< BatchEventProcessor< FizzBuzzEvent > >(m_ringBuffer, sequenceBarrierFizzBuzz, m_fizzBuzzHandler);
-
-        std::int64_t temp = 0;
-        for (std::int64_t i = 0; i < m_iterations; ++i)
-        {
-            auto fizz = 0 == (i % 3L);
-            auto buzz = 0 == (i % 5L);
-
-            if (fizz && buzz)
-            {
-                ++temp;
-            }
-        }
-        m_expectedResult = temp;
-
-        m_ringBuffer->addGatingSequences({ m_batchProcessorFizzBuzz->sequence() });
-    }
-
-    std::int64_t OneToThreeDiamondSequencedThroughputTest::run(Stopwatch& stopwatch)
-    {
-        auto latch = std::make_shared< Tests::ManualResetEvent >(false);
-        m_fizzBuzzHandler->reset(latch, m_batchProcessorFizzBuzz->sequence()->value() + m_iterations);
-
-        auto processorTask1 = std::async(std::launch::async, [this] { m_batchProcessorFizz->run(); });
-        auto processorTask2 = std::async(std::launch::async, [this] { m_batchProcessorBuzz->run(); });
-        auto processorTask3 = std::async(std::launch::async, [this] { m_batchProcessorFizzBuzz->run(); });
-
-        stopwatch.start();
-
-        auto& rb = *m_ringBuffer;
-        for (std::int64_t i = 0; i < m_iterations; ++i)
-        {
-            auto sequence = rb.next();
-            rb[sequence].value = i;
-            rb.publish(sequence);
-        }
-
-        latch->waitOne();
-        stopwatch.stop();
-
-        m_batchProcessorFizz->halt();
-        m_batchProcessorBuzz->halt();
-        m_batchProcessorFizzBuzz->halt();
-        
-        processorTask1.wait();
-        processorTask2.wait();
-        processorTask3.wait();
-
-        PerfTestUtil::failIfNot(m_expectedResult, m_fizzBuzzHandler->fizzBuzzCounter());
-
-        return m_iterations;
-    }
-
-    std::int32_t OneToThreeDiamondSequencedThroughputTest::requiredProcessorCount() const
-    {
-        return 4;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToThreeDiamondSequencedThroughputTest.h ./Disruptor.PerfTests/OneToThreeDiamondSequencedThroughputTest.h
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToThreeDiamondSequencedThroughputTest.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToThreeDiamondSequencedThroughputTest.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,86 +0,0 @@
-#pragma once
-
-#include "Disruptor/BatchEventProcessor.h"
-#include "Disruptor/RingBuffer.h"
-#include "Disruptor/YieldingWaitStrategy.h"
-
-#include "Disruptor.PerfTests/FizzBuzzEvent.h"
-#include "Disruptor.PerfTests/FizzBuzzEventHandler.h"
-#include "Disruptor.PerfTests/IThroughputTest.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    /**
-     * Produce an event replicated to two event proces
-     *           +-----+
-     *    +----->| EP1 |------+
-     *    |      +-----+      |
-     *    |                   v
-     * +----+              +-----+
-     * | P1 |              | EP3 |
-     * +----+              +-----+
-     *    |                   ^
-     *    |      +-----+      |
-     *    +----->| EP2 |------+
-     *           +-----+
-     * Disruptor:
-     * ==========
-     *                    track to prevent wrap
-     *              +-------------------------------+
-     *              |                               |
-     *              |                               v
-     * +----+    +====+               +=====+    +----
-     * | P1 |---\| RB |/--------------| SB2 |/---| EP3
-     * +----+    +====+               +=====+    +----
-     *      claim   ^  get               |   waitFor
-     *              |                    |
-     *           +=====+    +-----+      |
-     *           | SB1 |/---| EP1 |/-----+
-     *           +=====+    +-----+      |
-     *              ^                    |
-     *              |       +-----+      |
-     *              +-------| EP2 |/-----+
-     *             waitFor  +-----+
-     *
-     * P1  - Publisher 1
-     * RB  - RingBuffer
-     * SB1 - SequenceBarrier 1
-     * EP1 - EventProcessor 1
-     * EP2 - EventProcessor 2
-     * SB2 - SequenceBarrier 2
-     * EP3 - EventProcessor 3
-     *
-     */
-    class OneToThreeDiamondSequencedThroughputTest : public IThroughputTest
-    {
-    public:
-        OneToThreeDiamondSequencedThroughputTest();
-
-        std::int64_t run(Stopwatch& stopwatch) override;
-
-        std::int32_t requiredProcessorCount() const override;
-
-    private:
-        const std::int32_t m_bufferSize = 1024 * 8;
-
-#ifdef _DEBUG
-        const std::int64_t m_iterations = 100L * 100L * 10L;
-#else
-        const std::int64_t m_iterations = 1000L * 1000L * 100L;
-#endif
-
-        std::int64_t m_expectedResult;
-
-        std::shared_ptr< RingBuffer< FizzBuzzEvent > > m_ringBuffer = RingBuffer< FizzBuzzEvent >::createSingleProducer(FizzBuzzEvent::eventFactory(), m_bufferSize, std::make_shared< YieldingWaitStrategy >());
-        std::shared_ptr< BatchEventProcessor< FizzBuzzEvent > > m_batchProcessorFizz;
-        std::shared_ptr< BatchEventProcessor< FizzBuzzEvent > > m_batchProcessorBuzz;
-        std::shared_ptr< BatchEventProcessor< FizzBuzzEvent > > m_batchProcessorFizzBuzz;
-        std::shared_ptr< FizzBuzzEventHandler > m_fizzBuzzHandler;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToThreePipelineSequencedThroughputTest.cpp ./Disruptor.PerfTests/OneToThreePipelineSequencedThroughputTest.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToThreePipelineSequencedThroughputTest.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToThreePipelineSequencedThroughputTest.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,90 +0,0 @@
-#include "stdafx.h"
-#include "OneToThreePipelineSequencedThroughputTest.h"
-
-#include "PerfTestUtil.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    OneToThreePipelineSequencedThroughputTest::OneToThreePipelineSequencedThroughputTest()
-    {
-        auto stepOneFunctionHandler = std::make_shared< FunctionEventHandler >(FunctionStep::One);
-        auto stepTwoFunctionHandler = std::make_shared< FunctionEventHandler >(FunctionStep::Two);
-        m_stepThreeFunctionHandler = std::make_shared< FunctionEventHandler >(FunctionStep::Three);
-
-        auto stepOneSequenceBarrier = m_ringBuffer->newBarrier();
-        m_stepOneBatchProcessor = std::make_shared< BatchEventProcessor< FunctionEvent > >(m_ringBuffer, stepOneSequenceBarrier, stepOneFunctionHandler);
-
-        auto stepTwoSequenceBarrier = m_ringBuffer->newBarrier({ m_stepOneBatchProcessor->sequence() });
-        m_stepTwoBatchProcessor = std::make_shared< BatchEventProcessor< FunctionEvent > >(m_ringBuffer, stepTwoSequenceBarrier, stepTwoFunctionHandler);
-
-        auto stepThreeSequenceBarrier = m_ringBuffer->newBarrier({ m_stepTwoBatchProcessor->sequence() });
-        m_stepThreeBatchProcessor = std::make_shared< BatchEventProcessor< FunctionEvent > >(m_ringBuffer, stepThreeSequenceBarrier, m_stepThreeFunctionHandler);
-
-        std::int64_t temp = 0;
-        auto operandTwo = m_operandTwoInitialValue;
-
-        for (std::int64_t i = 0; i < m_iterations; ++i)
-        {
-            auto stepOneResult = i + operandTwo--;
-            auto stepTwoResult = stepOneResult + 3;
-
-            if ((stepTwoResult & 4L) == 4L)
-            {
-                ++temp;
-            }
-        }
-        m_expectedResult = temp;
-
-        m_ringBuffer->addGatingSequences({ m_stepThreeBatchProcessor->sequence() });
-    }
-
-    std::int64_t OneToThreePipelineSequencedThroughputTest::run(Stopwatch& stopwatch)
-    {
-        auto latch = std::make_shared< Tests::ManualResetEvent >(false);
-        m_stepThreeFunctionHandler->reset(latch, m_stepThreeBatchProcessor->sequence()->value() + m_iterations);
-
-        auto processorTask1 = m_executor->submit(m_stepOneBatchProcessor);
-        auto processorTask2 = m_executor->submit(m_stepTwoBatchProcessor);
-        auto processorTask3 = m_executor->submit(m_stepThreeBatchProcessor);
-
-        auto& rb = *m_ringBuffer;
-
-        stopwatch.start();
-
-        auto operandTwo = m_operandTwoInitialValue;
-        for (std::int64_t i = 0; i < m_iterations; ++i)
-        {
-            auto sequence = rb.next();
-            auto& event = rb[sequence];
-            event.operandOne = i;
-            event.operandTwo = operandTwo--;
-            rb.publish(sequence);
-        }
-
-        latch->waitOne();
-        stopwatch.stop();
-
-        m_stepOneBatchProcessor->halt();
-        m_stepTwoBatchProcessor->halt();
-        m_stepThreeBatchProcessor->halt();
-
-        processorTask1.wait();
-        processorTask2.wait();
-        processorTask3.wait();
-
-        PerfTestUtil::failIfNot(m_expectedResult, m_stepThreeFunctionHandler->stepThreeCounter());
-
-        return m_iterations;
-    }
-
-    std::int32_t OneToThreePipelineSequencedThroughputTest::requiredProcessorCount() const
-    {
-        return 4;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToThreePipelineSequencedThroughputTest.h ./Disruptor.PerfTests/OneToThreePipelineSequencedThroughputTest.h
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToThreePipelineSequencedThroughputTest.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToThreePipelineSequencedThroughputTest.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,80 +0,0 @@
-#pragma once
-
-#include "Disruptor/RingBuffer.h"
-#include "Disruptor/YieldingWaitStrategy.h"
-
-#include "Disruptor.PerfTests/ExecutorService.h"
-#include "Disruptor.PerfTests/FunctionEvent.h"
-#include "Disruptor.PerfTests/FunctionEventHandler.h"
-#include "Disruptor.PerfTests/IThroughputTest.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    /**
-     * Pipeline a series of stages from a publisher to ultimate event processor.
-     * Each event processor depends on the output of the event processor.
-     * 
-     * +----+    +-----+    +-----+    +-----+
-     * | P1 |--->| EP1 |--->| EP2 |--->| EP3 |
-     * +----+    +-----+    +-----+    +-----+
-     * 
-     * Disruptor:
-     * ==========
-     *                           track to prevent wrap
-     *              +----------------------------------------------------------------+
-     *              |                                                                |
-     *              |                                                                v
-     * +----+    +====+    +=====+    +-----+    +=====+    +-----+    +=====+    +-----+
-     * | P1 |--->| RB |    | SB1 |/---| EP1 |/---| SB2 |/---| EP2 |/---| SB3 |/---| EP3 |
-     * +----+    +====+    +=====+    +-----+    +=====+    +-----+    +=====+    +-----+
-     *      claim   ^  get    |   waitFor           |   waitFor           |  waitFor
-     *              |         |                     |                     |
-     *              +---------+---------------------+---------------------+
-     *        
-     * P1  - Publisher 1
-     * RB  - RingBuffer
-     * SB1 - SequenceBarrier 1
-     * EP1 - EventProcessor 1
-     * SB2 - SequenceBarrier 2
-     * EP2 - EventProcessor 2
-     * SB3 - SequenceBarrier 3
-     * EP3 - EventProcessor 3
-     * 
-     */
-    class OneToThreePipelineSequencedThroughputTest : public IThroughputTest
-    {
-    public:
-        OneToThreePipelineSequencedThroughputTest();
-
-        std::int64_t run(Stopwatch& stopwatch) override;
-
-        std::int32_t requiredProcessorCount() const override;
-
-    private:
-        const std::int32_t m_bufferSize = 1024 * 8;
-
-#ifdef _DEBUG
-        const std::int64_t m_iterations = 100L * 100L * 10L;
-#else
-        const std::int64_t m_iterations = 1000L * 1000L * 100L;
-#endif
-
-        std::shared_ptr< ExecutorService< FunctionEvent > > m_executor = std::make_shared< ExecutorService< FunctionEvent > >();
-
-        const std::int64_t m_operandTwoInitialValue = 777L;
-        std::int64_t m_expectedResult;
-
-        std::shared_ptr< RingBuffer< FunctionEvent > > m_ringBuffer = RingBuffer< FunctionEvent >::createSingleProducer(FunctionEvent::eventFactory(), m_bufferSize, std::make_shared< YieldingWaitStrategy >());
-
-        std::shared_ptr< BatchEventProcessor< FunctionEvent > > m_stepOneBatchProcessor;
-        std::shared_ptr< BatchEventProcessor< FunctionEvent > > m_stepTwoBatchProcessor;
-        std::shared_ptr< BatchEventProcessor< FunctionEvent > > m_stepThreeBatchProcessor;
-        std::shared_ptr< FunctionEventHandler > m_stepThreeFunctionHandler;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToThreeReleasingWorkerPoolThroughputTest.cpp ./Disruptor.PerfTests/OneToThreeReleasingWorkerPoolThroughputTest.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToThreeReleasingWorkerPoolThroughputTest.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToThreeReleasingWorkerPoolThroughputTest.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,105 +0,0 @@
-#include "stdafx.h"
-#include "OneToThreeReleasingWorkerPoolThroughputTest.h"
-
-#include "Disruptor/BasicExecutor.h"
-#include "Disruptor/FatalExceptionHandler.h"
-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
-
-#include "Disruptor.TestTools/ScopeExitFunctor.h"
-
-#include "PerfTestUtil.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    OneToThreeReleasingWorkerPoolThroughputTest::OneToThreeReleasingWorkerPoolThroughputTest()
-    {
-        for (auto i = 0; i < m_numWorkers; ++i)
-        {
-            m_counters[i] = std::make_shared< PaddedLong >();
-        }
-
-        for (auto i = 0; i < m_numWorkers; ++i)
-        {
-            m_handlers[i] = std::make_shared< EventCountingAndReleasingWorkHandler >(m_counters, i);
-        }
-
-        m_workerPool = std::make_shared< WorkerPool< ValueEvent > >(m_ringBuffer, m_ringBuffer->newBarrier(), std::make_shared< FatalExceptionHandler< ValueEvent > >(), m_handlers);
-
-        m_ringBuffer->addGatingSequences({ m_workerPool->getWorkerSequences() });
-    }
-
-    std::int64_t OneToThreeReleasingWorkerPoolThroughputTest::run(Stopwatch& stopwatch)
-    {
-        auto scheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
-        scheduler->start(requiredProcessorCount());
-        TestTools::ScopeExitFunctor atScopeExit([scheduler] { scheduler->stop(); });
-
-        resetCounters();
-        auto& ringBuffer = *m_workerPool->start(std::make_shared< BasicExecutor >(scheduler));
-        stopwatch.start();
-
-        for (std::int64_t i = 0; i < m_iterations; ++i)
-        {
-            std::int64_t sequence = ringBuffer.next();
-            ringBuffer[sequence].value = i;
-            ringBuffer.publish(sequence);
-        }
-
-        m_workerPool->drainAndHalt();
-
-        // Workaround to ensure that the last worker(s) have completed after releasing their events
-        std::this_thread::sleep_for(std::chrono::milliseconds(1));
-        stopwatch.stop();
-
-        PerfTestUtil::failIfNot(m_iterations, sumCounters());
-
-        return m_iterations;
-    }
-
-    std::int32_t OneToThreeReleasingWorkerPoolThroughputTest::requiredProcessorCount() const
-    {
-        return 4;
-    }
-
-    void OneToThreeReleasingWorkerPoolThroughputTest::resetCounters()
-    {
-        for (auto i = 0; i < m_numWorkers; ++i)
-        {
-            m_counters[i]->value = 0L;
-        }
-    }
-
-    std::int64_t OneToThreeReleasingWorkerPoolThroughputTest::sumCounters()
-    {
-        std::int64_t sumJobs = 0L;
-        for (auto i = 0; i < m_numWorkers; ++i)
-        {
-            sumJobs += m_counters[i]->value;
-        }
-
-        return sumJobs;
-    }
-
-    OneToThreeReleasingWorkerPoolThroughputTest::EventCountingAndReleasingWorkHandler::EventCountingAndReleasingWorkHandler(const std::vector< std::shared_ptr< PaddedLong > >& counters, std::int32_t index)
-        : m_counters(counters)
-        , m_index(index)
-    {
-    }
-
-    void OneToThreeReleasingWorkerPoolThroughputTest::EventCountingAndReleasingWorkHandler::onEvent(ValueEvent& /*evt*/)
-    {
-        m_eventReleaser->release();
-        m_counters[m_index]->value = m_counters[m_index]->value + 1L;
-    }
-
-    void OneToThreeReleasingWorkerPoolThroughputTest::EventCountingAndReleasingWorkHandler::setEventReleaser(const std::shared_ptr< IEventReleaser >& eventReleaser)
-    {
-        m_eventReleaser = eventReleaser;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToThreeReleasingWorkerPoolThroughputTest.h ./Disruptor.PerfTests/OneToThreeReleasingWorkerPoolThroughputTest.h
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToThreeReleasingWorkerPoolThroughputTest.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToThreeReleasingWorkerPoolThroughputTest.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,68 +0,0 @@
-#pragma once
-
-#include "Disruptor/IWorkHandler.h"
-#include "Disruptor/RingBuffer.h"
-#include "Disruptor/WorkerPool.h"
-#include "Disruptor/YieldingWaitStrategy.h"
-
-#include "Disruptor.PerfTests/EventCountingQueueProcessor.h"
-#include "Disruptor.PerfTests/EventCountingWorkHandler.h"
-#include "Disruptor.PerfTests/IThroughputTest.h"
-#include "Disruptor.PerfTests/PaddedLong.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class OneToThreeReleasingWorkerPoolThroughputTest : public IThroughputTest
-    {
-        class EventCountingAndReleasingWorkHandler;
-
-    public:
-        OneToThreeReleasingWorkerPoolThroughputTest();
-
-        std::int64_t run(Stopwatch& stopwatch) override;
-
-        std::int32_t requiredProcessorCount() const override;
-
-    private:
-        void resetCounters();
-        std::int64_t sumCounters();
-
-        const std::int32_t m_numWorkers = 3;
-        const std::int32_t m_bufferSize = 1024 * 8;
-
-#ifdef _DEBUG
-        const std::int64_t m_iterations = 100L * 100L * 1L;
-#else
-        const std::int64_t m_iterations = 1000L * 1000L * 10L;
-#endif
-
-        std::vector< std::shared_ptr< PaddedLong > > m_counters = std::vector< std::shared_ptr< PaddedLong > >(m_numWorkers);
-        std::vector< std::shared_ptr< IWorkHandler< ValueEvent > > > m_handlers = std::vector< std::shared_ptr< IWorkHandler< ValueEvent > > >(m_numWorkers);
-        std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer = RingBuffer< ValueEvent >::createSingleProducer(ValueEvent::eventFactory(),
-                                                                                                                  m_bufferSize,
-                                                                                                                  std::make_shared< YieldingWaitStrategy >());
-        std::shared_ptr< WorkerPool< ValueEvent > > m_workerPool;
-    };
-
-
-    class OneToThreeReleasingWorkerPoolThroughputTest::EventCountingAndReleasingWorkHandler : public IWorkHandler< ValueEvent >, public IEventReleaseAware
-    {
-    public:
-        EventCountingAndReleasingWorkHandler(const std::vector< std::shared_ptr< PaddedLong > >& counters, std::int32_t index);
-
-        void onEvent(ValueEvent& evt) override;
-
-        void setEventReleaser(const std::shared_ptr< IEventReleaser >& eventReleaser) override;
-
-    private:
-        std::vector< std::shared_ptr< PaddedLong > > m_counters;
-        std::int32_t m_index;
-        std::shared_ptr< IEventReleaser > m_eventReleaser;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToThreeSequencedThroughputTest.cpp ./Disruptor.PerfTests/OneToThreeSequencedThroughputTest.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToThreeSequencedThroughputTest.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToThreeSequencedThroughputTest.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,97 +0,0 @@
-#include "stdafx.h"
-#include "OneToThreeSequencedThroughputTest.h"
-
-#include "Disruptor/BasicExecutor.h"
-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
-#include "Disruptor/YieldingWaitStrategy.h"
-
-#include "Disruptor.TestTools/ScopeExitFunctor.h"
-#include "Disruptor/BatchEventProcessor.h"
-#include "PerfTestUtil.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    OneToThreeSequencedThroughputTest::OneToThreeSequencedThroughputTest()
-    {
-        m_taskScheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
-        m_executor = std::make_shared< BasicExecutor >(m_taskScheduler);
-
-        for (std::int64_t i = 0; i < m_iterations; ++i)
-        {
-            m_results[0] = OperationExtensions::Op(Operation::Addition, m_results[0], i);
-            m_results[1] = OperationExtensions::Op(Operation::Subtraction, m_results[1], i);
-            m_results[2] = OperationExtensions::Op(Operation::And, m_results[2], i);
-        }
-
-        m_ringBuffer = RingBuffer< ValueEvent >::createSingleProducer(ValueEvent::eventFactory(), m_bufferSize, std::make_shared< YieldingWaitStrategy >());
-        auto sequenceBarrier = m_ringBuffer->newBarrier();
-
-        m_handlers[0] = std::make_shared< ValueMutationEventHandler >(Operation::Addition);
-        m_handlers[1] = std::make_shared< ValueMutationEventHandler >(Operation::Subtraction);
-        m_handlers[2] = std::make_shared< ValueMutationEventHandler >(Operation::And);
-
-        for (auto i = 0; i < m_numEventProcessors; ++i)
-        {
-            m_batchEventProcessors[i] = std::make_shared< BatchEventProcessor< ValueEvent > >(m_ringBuffer, sequenceBarrier, m_handlers[i]);
-        }
-
-        std::vector< std::shared_ptr< ISequence > > sequences;
-        for (auto&& processor : m_batchEventProcessors)
-        {
-            sequences.push_back(processor->sequence());
-        }
-        m_ringBuffer->addGatingSequences(sequences);
-    }
-
-    std::int64_t OneToThreeSequencedThroughputTest::run(Stopwatch& stopwatch)
-    {
-        m_taskScheduler->start(requiredProcessorCount());
-        TestTools::ScopeExitFunctor atScopeExit([this] { m_taskScheduler->stop(); });
-
-        auto latch = std::make_shared< boost::barrier >(m_numEventProcessors + 1);
-
-        std::vector< std::future< void > > processorTasks;
-        for (auto i = 0; i < m_numEventProcessors; ++i)
-        {
-            m_handlers[i]->reset(latch, m_batchEventProcessors[i]->sequence()->value() + m_iterations);
-            processorTasks.push_back(m_executor->execute([this, i] { m_batchEventProcessors[i]->run(); }));
-        }
-
-        auto& rb = *m_ringBuffer;
-
-        stopwatch.start();
-
-        for (std::int64_t i = 0; i < m_iterations; ++i)
-        {
-            auto sequence = rb.next();
-            rb[sequence].value = i;
-            rb.publish(sequence);
-        }
-
-        latch->wait();
-        stopwatch.stop();
-
-        for (auto i = 0; i < m_numEventProcessors; ++i)
-        {
-            m_batchEventProcessors[i]->halt();
-            PerfTestUtil::failIfNot(m_results[i], m_handlers[i]->value(),
-                                    "Result " + std::to_string(m_results[i]) + " != " + std::to_string(m_handlers[i]->value()));
-        }
-
-        for (auto&& task : processorTasks)
-            task.wait();
-
-        return m_numEventProcessors * m_iterations;
-    }
-
-    std::int32_t OneToThreeSequencedThroughputTest::requiredProcessorCount() const
-    {
-        return 4;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToThreeSequencedThroughputTest.h ./Disruptor.PerfTests/OneToThreeSequencedThroughputTest.h
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToThreeSequencedThroughputTest.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToThreeSequencedThroughputTest.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,81 +0,0 @@
-#pragma once
-
-#include "Disruptor/BatchEventProcessor.h"
-#include "Disruptor/IExecutor.h"
-#include "Disruptor/ITaskScheduler.h"
-#include "Disruptor/RingBuffer.h"
-
-#include "Disruptor.PerfTests/IThroughputTest.h"
-#include "Disruptor.PerfTests/ValueEvent.h"
-#include "Disruptor.PerfTests/ValueMutationEventHandler.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    /**
-     * MultiCast a series of items between 1 publisher and 3 event processors.
-     *           +-----+
-     *    +----->| EP1 |
-     *    |      +-----+
-     *    |
-     * +----+    +-----+
-     * | P1 |--->| EP2 |
-     * +----+    +-----+
-     *    |
-     *    |      +-----+
-     *    +----->| EP3 |
-     *           +-----+
-     * Disruptor:
-     * ==========
-     *                             track to prevent wrap
-     *             +--------------------+----------+----------+
-     *             |                    |          |          |
-     *             |                    v          v          v
-     * +----+    +====+    +====+    +-----+    +-----+    +-----+
-     * | P1 |---\| RB |/---| SB |    | EP1 |    | EP2 |    | EP3 |
-     * +----+    +====+    +====+    +-----+    +-----+    +-----+
-     *      claim      get    ^         |          |          |
-     *                        |         |          |          |
-     *                        +---------+----------+----------+
-     *                                      waitFor
-     * P1  - Publisher 1
-     * RB  - RingBuffer
-     * SB  - SequenceBarrier
-     * EP1 - EventProcessor 1
-     * EP2 - EventProcessor 2
-     * EP3 - EventProcessor 3
-     *
-     */
-    class OneToThreeSequencedThroughputTest : public IThroughputTest
-    {
-    public:
-        OneToThreeSequencedThroughputTest();
-
-        std::int64_t run(Stopwatch& stopwatch) override;
-
-        std::int32_t requiredProcessorCount() const override;
-
-    private:
-        const std::int32_t m_numEventProcessors = 3;
-        const std::int32_t m_bufferSize = 1024 * 8;
-
-#ifdef _DEBUG
-        const std::int64_t m_iterations = 100L * 100L * 10L;
-#else
-        const std::int64_t m_iterations = 1000L * 1000L * 100L;
-#endif
-
-        std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer;
-        std::vector< std::shared_ptr< BatchEventProcessor< ValueEvent > > > m_batchEventProcessors = std::vector< std::shared_ptr< BatchEventProcessor< ValueEvent > > >(m_numEventProcessors);
-        std::vector< std::int64_t > m_results = std::vector< std::int64_t >(m_numEventProcessors);
-        std::vector< std::shared_ptr< ValueMutationEventHandler > > m_handlers = std::vector< std::shared_ptr< ValueMutationEventHandler > >(m_numEventProcessors);
-        
-        std::shared_ptr< IExecutor > m_executor;
-        std::shared_ptr< ITaskScheduler > m_taskScheduler;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToThreeWorkerPoolThroughputTest.cpp ./Disruptor.PerfTests/OneToThreeWorkerPoolThroughputTest.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToThreeWorkerPoolThroughputTest.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToThreeWorkerPoolThroughputTest.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,93 +0,0 @@
-#include "stdafx.h"
-#include "OneToThreeWorkerPoolThroughputTest.h"
-
-#include "Disruptor/BasicExecutor.h"
-#include "Disruptor/FatalExceptionHandler.h"
-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
-
-#include "Disruptor.TestTools/ScopeExitFunctor.h"
-
-#include "PerfTestUtil.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    OneToThreeWorkerPoolThroughputTest::OneToThreeWorkerPoolThroughputTest()
-    {
-        for (auto i = 0; i < m_numWorkers; ++i)
-        {
-            m_counters[i] = std::make_shared< PaddedLong >();
-        }
-
-        for (auto i = 0; i < m_numWorkers; ++i)
-        {
-            m_queueWorkers[i] = std::make_shared< EventCountingQueueProcessor >(m_blockingQueue, m_counters, i);
-        }
-
-        for (auto i = 0; i < m_numWorkers; ++i)
-        {
-            m_handlers[i] = std::make_shared< EventCountingWorkHandler >(m_counters, i);
-        }
-
-        m_workerPool = std::make_shared< WorkerPool< ValueEvent > >(m_ringBuffer, m_ringBuffer->newBarrier(), std::make_shared< FatalExceptionHandler< ValueEvent > >(), m_handlers);
-
-        m_ringBuffer->addGatingSequences({ m_workerPool->getWorkerSequences() });
-    }
-
-    std::int64_t OneToThreeWorkerPoolThroughputTest::run(Stopwatch& stopwatch)
-    {
-        auto scheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
-        scheduler->start(requiredProcessorCount());
-        TestTools::ScopeExitFunctor atScopeExit([scheduler] { scheduler->stop(); });
-
-        resetCounters();
-        auto& ringBuffer = *m_workerPool->start(std::make_shared< BasicExecutor >(scheduler));
-        stopwatch.start();
-
-        for (std::int64_t i = 0; i < m_iterations; ++i)
-        {
-            std::int64_t sequence = ringBuffer.next();
-            ringBuffer[sequence].value = i;
-            ringBuffer.publish(sequence);
-        }
-
-        m_workerPool->drainAndHalt();
-
-        // Workaround to ensure that the last worker(s) have completed after releasing their events
-        std::this_thread::sleep_for(std::chrono::milliseconds(1));
-        stopwatch.stop();
-
-        PerfTestUtil::failIfNot(m_iterations, sumCounters());
-
-        return m_iterations;
-    }
-
-    std::int32_t OneToThreeWorkerPoolThroughputTest::requiredProcessorCount() const
-    {
-        return 4;
-    }
-
-    void OneToThreeWorkerPoolThroughputTest::resetCounters()
-    {
-        for (auto i = 0; i < m_numWorkers; ++i)
-        {
-            m_counters[i]->value = 0L;
-        }
-    }
-
-    std::int64_t OneToThreeWorkerPoolThroughputTest::sumCounters()
-    {
-        std::int64_t sumJobs = 0L;
-        for (auto i = 0; i < m_numWorkers; ++i)
-        {
-            sumJobs += m_counters[i]->value;
-        }
-
-        return sumJobs;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/OneToThreeWorkerPoolThroughputTest.h ./Disruptor.PerfTests/OneToThreeWorkerPoolThroughputTest.h
--- ../Disruptor-cpp/Disruptor.PerfTests/OneToThreeWorkerPoolThroughputTest.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/OneToThreeWorkerPoolThroughputTest.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,56 +0,0 @@
-#pragma once
-
-#include "Disruptor/BlockingQueue.h"
-#include "Disruptor/IWorkHandler.h"
-#include "Disruptor/RingBuffer.h"
-#include "Disruptor/WorkerPool.h"
-#include "Disruptor/YieldingWaitStrategy.h"
-
-#include "Disruptor.PerfTests/EventCountingQueueProcessor.h"
-#include "Disruptor.PerfTests/EventCountingWorkHandler.h"
-#include "Disruptor.PerfTests/IThroughputTest.h"
-#include "Disruptor.PerfTests/PaddedLong.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class OneToThreeWorkerPoolThroughputTest : public IThroughputTest
-    {
-    public:
-        OneToThreeWorkerPoolThroughputTest();
-
-        std::int64_t run(Stopwatch& stopwatch) override;
-
-        std::int32_t requiredProcessorCount() const override;
-
-    private:
-        void resetCounters();
-        std::int64_t sumCounters();
-
-        const std::int32_t m_numWorkers = 3;
-        const std::int32_t m_bufferSize = 1024 * 8;
-
-#ifdef _DEBUG
-        const std::int64_t m_iterations = 100L * 100L * 10L;
-#else
-        const std::int64_t m_iterations = 1000L * 1000L * 100L;
-#endif
-
-        std::vector< std::shared_ptr< PaddedLong > > m_counters = std::vector< std::shared_ptr< PaddedLong > >(m_numWorkers);
-
-        std::shared_ptr< BlockingQueue< std::int64_t > > m_blockingQueue = std::make_shared< BlockingQueue< std::int64_t > >();
-        std::vector< std::shared_ptr< EventCountingQueueProcessor > > m_queueWorkers = std::vector< std::shared_ptr< EventCountingQueueProcessor > >(m_numWorkers);
-        std::vector< std::shared_ptr< IWorkHandler< ValueEvent > > > m_handlers = std::vector< std::shared_ptr< IWorkHandler< ValueEvent > > >(m_numWorkers);
-
-        std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer = RingBuffer< ValueEvent >::createSingleProducer(ValueEvent::eventFactory(),
-                                                                                                                  m_bufferSize,
-                                                                                                                  std::make_shared< YieldingWaitStrategy >());
-
-        std::shared_ptr< WorkerPool< ValueEvent > > m_workerPool;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/Operation.cpp ./Disruptor.PerfTests/Operation.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/Operation.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/Operation.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,31 +0,0 @@
-#include "stdafx.h"
-#include "Operation.h"
-
-#include "Disruptor/ArgumentOutOfRangeException.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-namespace OperationExtensions
-{
-
-    std::int64_t Op(Operation operation, std::int64_t lhs, std::int64_t rhs)
-    {
-        switch (operation)
-        {
-        case Operation::Addition:
-            return lhs + rhs;
-        case Operation::Subtraction:
-            return lhs - rhs;
-        case Operation::And:
-            return lhs & rhs;
-        default:
-            DISRUPTOR_THROW_ARGUMENT_OUT_OF_RANGE_EXCEPTION("The variable 'operation' (" << static_cast< int >(operation) << ") is out of range");
-        }
-    }
-
-} // namespace OperationExtensions
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/Operation.h ./Disruptor.PerfTests/Operation.h
--- ../Disruptor-cpp/Disruptor.PerfTests/Operation.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/Operation.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,25 +0,0 @@
-#pragma once
-
-#include <cstdint>
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    enum class Operation
-    {
-        Addition,
-        Subtraction,
-        And
-    };
-
-namespace OperationExtensions
-{
-
-    std::int64_t Op(Operation operation, std::int64_t lhs, std::int64_t rhs);
-
-} // namespace OperationExtensions
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/PaddedLong.h ./Disruptor.PerfTests/PaddedLong.h
--- ../Disruptor-cpp/Disruptor.PerfTests/PaddedLong.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/PaddedLong.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,18 +0,0 @@
-#pragma once
-
-#include <cstdint>
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    struct PaddedLong
-    {
-        std::int64_t value = 0;
-        char _padding[54];
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/PerfTestUtil.cpp ./Disruptor.PerfTests/PerfTestUtil.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/PerfTestUtil.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/PerfTestUtil.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,60 +0,0 @@
-#include "stdafx.h"
-#include "PerfTestUtil.h"
-
-#include <boost/date_time.hpp>
-
-#include "Disruptor/IEventProcessor.h"
-#include "Disruptor/ISequence.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-namespace PerfTestUtil
-{
-
-    std::int64_t accumulatedAddition(std::int64_t iterations)
-    {
-        std::int64_t temp = 0L;
-        for (std::int64_t i = 0L; i < iterations; i++)
-        {
-            temp += i;
-        }
-
-        return temp;
-    }
-
-    void failIf(std::int64_t a, std::int64_t b, const std::string& message)
-    {
-        if (a == b)
-        {
-            throw std::runtime_error(message.empty() ? "Test failed " + std::to_string(a) + " == " + std::to_string(b) : message);
-        }
-    }
-
-    void failIfNot(std::int64_t a, std::int64_t b, const std::string& message)
-    {
-        if (a != b)
-        {
-            throw std::runtime_error(message.empty() ? "Test failed " + std::to_string(a) + " != " + std::to_string(b) : message);
-        }
-    }
-
-    void waitForEventProcessorSequence(std::int64_t expectedCount, const std::shared_ptr< IEventProcessor >& batchEventProcessor)
-    {
-        while (batchEventProcessor->sequence()->value() != expectedCount)
-        {
-            std::this_thread::sleep_for(std::chrono::milliseconds(1));
-        }
-    }
-
-    std::string utcDateToString()
-    {
-        auto t(boost::posix_time::second_clock::universal_time());
-        return to_simple_string(t);
-    }
-
-} // namespace PerfTestUtil
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/PerfTestUtil.h ./Disruptor.PerfTests/PerfTestUtil.h
--- ../Disruptor-cpp/Disruptor.PerfTests/PerfTestUtil.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/PerfTestUtil.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,29 +0,0 @@
-#pragma once
-
-#include <cstdint>
-#include <string>
-
-
-namespace Disruptor
-{
-
-    class IEventProcessor;
-
-namespace PerfTests
-{
-namespace PerfTestUtil
-{
-
-    std::int64_t accumulatedAddition(std::int64_t iterations);
-
-    void failIf(std::int64_t a, std::int64_t b, const std::string& message = std::string());
-
-    void failIfNot(std::int64_t a, std::int64_t b, const std::string& message = std::string());
-
-    void waitForEventProcessorSequence(std::int64_t expectedCount, const std::shared_ptr< IEventProcessor >& batchEventProcessor);
-
-    std::string utcDateToString();
-    
-} // namespace PerfTestUtil
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/PingPongSequencedLatencyTest.cpp ./Disruptor.PerfTests/PingPongSequencedLatencyTest.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/PingPongSequencedLatencyTest.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/PingPongSequencedLatencyTest.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,161 +0,0 @@
-#include "stdafx.h"
-#include "PingPongSequencedLatencyTest.h"
-
-#include "Disruptor/BasicExecutor.h"
-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
-
-#include "Disruptor.TestTools/ScopeExitFunctor.h"
-#include "LatencyTestSession.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    PingPongSequencedLatencyTest::PingPongSequencedLatencyTest()
-    {
-        m_taskScheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
-        m_executor = std::make_shared< BasicExecutor >(m_taskScheduler);
-
-        m_pingBuffer = RingBuffer< ValueEvent >::createSingleProducer(ValueEvent::eventFactory(), m_bufferSize, std::make_shared< BlockingWaitStrategy >());
-        m_pongBuffer = RingBuffer< ValueEvent >::createSingleProducer(ValueEvent::eventFactory(), m_bufferSize, std::make_shared< BlockingWaitStrategy >());
-
-        m_pingBarrier = m_pingBuffer->newBarrier();
-        m_pongBarrier = m_pongBuffer->newBarrier();
-
-        m_pinger = std::make_shared< Pinger >(m_pingBuffer, m_iterations, m_pauseDurationInNanos);
-        m_ponger = std::make_shared< Ponger >(m_pongBuffer);
-
-        m_pingProcessor = std::make_shared< BatchEventProcessor< ValueEvent > >(m_pongBuffer, m_pongBarrier, m_pinger);
-        m_pongProcessor = std::make_shared< BatchEventProcessor< ValueEvent > >(m_pingBuffer, m_pingBarrier, m_ponger);
-
-        m_pingBuffer->addGatingSequences({ m_pongProcessor->sequence() });
-        m_pongBuffer->addGatingSequences({ m_pingProcessor->sequence() });
-    }
-
-    std::int32_t PingPongSequencedLatencyTest::requiredProcessorCount() const
-    {
-        return 2;
-    }
-
-    void PingPongSequencedLatencyTest::run(Stopwatch& stopwatch, const std::shared_ptr< Tests::LatencyRecorder >& latencyRecorder)
-    {
-        m_taskScheduler->start(requiredProcessorCount());
-        TestTools::ScopeExitFunctor atScopeExit([this] { m_taskScheduler->stop(); });
-
-        auto globalSignal = std::make_shared< Tests::CountdownEvent >(3);
-        auto signal = std::make_shared< Tests::ManualResetEvent >(false);
-        m_pinger->reset(globalSignal, signal, latencyRecorder);
-        m_ponger->reset(globalSignal);
-
-        auto processorTask1 = m_executor->execute([this] { m_pongProcessor->run(); });
-        auto processorTask2 = m_executor->execute([this] { m_pingProcessor->run(); });
-
-        globalSignal->signal();
-        globalSignal->wait();
-        stopwatch.start();
-        // running here
-        signal->waitOne();
-        stopwatch.stop();
-
-        m_pingProcessor->halt();
-        m_pongProcessor->halt();
-
-        processorTask1.wait();
-        processorTask2.wait();
-    }
-
-
-    PingPongSequencedLatencyTest::Pinger::Pinger(const std::shared_ptr< RingBuffer< ValueEvent > >& buffer, std::int64_t maxEvents, std::int32_t pauseDurationInNanos)
-        : m_buffer(buffer)
-        , m_maxEvents(maxEvents)
-        , m_pauseDurationInNanos(pauseDurationInNanos)
-    {
-        m_pauseDurationInStopwatchTicks = (std::int64_t)LatencyTestSession::convertNanoToStopwatchTicks(pauseDurationInNanos);
-    }
-
-    void PingPongSequencedLatencyTest::Pinger::onEvent(ValueEvent& data, std::int64_t /*sequence*/, bool /*endOfBatch*/)
-    {
-        auto t1 = Stopwatch::getTimestamp();
-
-        m_latencyRecorder->record(LatencyTestSession::convertStopwatchTicksToNano((double)(t1 - m_t0)));
-
-        if (data.value < m_maxEvents)
-        {
-            while (m_pauseDurationInNanos > (Stopwatch::getTimestamp() - t1))
-            {
-                std::this_thread::sleep_for(std::chrono::milliseconds(0));
-            }
-
-            send();
-        }
-        else
-        {
-            m_signal->set();
-        }
-    }
-
-    void PingPongSequencedLatencyTest::Pinger::onStart()
-    {
-        m_globalSignal->signal();
-        m_globalSignal->wait();
-
-        send();
-    }
-
-    void PingPongSequencedLatencyTest::Pinger::onShutdown()
-    {
-    }
-
-    void PingPongSequencedLatencyTest::Pinger::reset(const std::shared_ptr< Tests::CountdownEvent >& globalSignal,
-                                                     const std::shared_ptr< Tests::ManualResetEvent >& signal,
-                                                     const std::shared_ptr< Tests::LatencyRecorder >& latencyRecorder)
-    {
-        m_latencyRecorder = latencyRecorder;
-        m_globalSignal = globalSignal;
-        m_signal = signal;
-
-        m_counter = 0;
-    }
-
-    void PingPongSequencedLatencyTest::Pinger::send()
-    {
-        m_t0 = Stopwatch::getTimestamp();
-        auto next = m_buffer->next();
-        (*m_buffer)[next].value = m_counter;
-        m_buffer->publish(next);
-
-        ++m_counter;
-    }
-
-
-    PingPongSequencedLatencyTest::Ponger::Ponger(const std::shared_ptr< RingBuffer< ValueEvent > >& buffer)
-        : m_buffer(buffer)
-    {
-    }
-
-    void PingPongSequencedLatencyTest::Ponger::onEvent(ValueEvent& data, std::int64_t /*sequence*/, bool /*endOfBatch*/)
-    {
-        auto next = m_buffer->next();
-        (*m_buffer)[next].value = data.value;
-        m_buffer->publish(next);
-    }
-
-    void PingPongSequencedLatencyTest::Ponger::onStart()
-    {
-        m_globalSignal->signal();
-        m_globalSignal->wait();
-    }
-
-    void PingPongSequencedLatencyTest::Ponger::onShutdown()
-    {
-    }
-
-    void PingPongSequencedLatencyTest::Ponger::reset(const std::shared_ptr< Tests::CountdownEvent >& globalSignal)
-    {
-        m_globalSignal = globalSignal;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/PingPongSequencedLatencyTest.h ./Disruptor.PerfTests/PingPongSequencedLatencyTest.h
--- ../Disruptor-cpp/Disruptor.PerfTests/PingPongSequencedLatencyTest.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/PingPongSequencedLatencyTest.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,109 +0,0 @@
-#pragma once
-
-#include "Disruptor/BatchEventProcessor.h"
-#include "Disruptor/IEventHandler.h"
-#include "Disruptor/IExecutor.h"
-#include "Disruptor/RingBuffer.h"
-#include "Disruptor/ILifecycleAware.h"
-#include "Disruptor/ITaskScheduler.h"
-
-#include "Disruptor.TestTools/CountdownEvent.h"
-#include "Disruptor.TestTools/ManualResetEvent.h"
-#include "Disruptor.TestTools/Stopwatch.h"
-
-#include "Disruptor.PerfTests/ILatencyTest.h"
-#include "Disruptor.PerfTests/ValueEvent.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class PingPongSequencedLatencyTest : public ILatencyTest
-    {
-        class Pinger;
-        class Ponger;
-
-    public:
-        PingPongSequencedLatencyTest();
-
-        std::int32_t requiredProcessorCount() const override;
-
-        void run(Stopwatch& stopwatch, const std::shared_ptr< Tests::LatencyRecorder >& latencyRecorder) override;
-
-    private:
-        const std::int32_t m_bufferSize = 1024;
-
-#ifdef _DEBUG
-        const std::int64_t m_iterations = 10L * 100L * 3L;
-#else
-        const std::int64_t m_iterations = 100L * 1000L * 30L;
-#endif
-
-        const std::int32_t m_pauseDurationInNanos = 1000;
-
-        std::shared_ptr< RingBuffer< ValueEvent > > m_pingBuffer;
-        std::shared_ptr< RingBuffer< ValueEvent > > m_pongBuffer;
-
-        std::shared_ptr< ISequenceBarrier > m_pongBarrier;
-        std::shared_ptr< Pinger > m_pinger;
-        std::shared_ptr< BatchEventProcessor< ValueEvent > > m_pingProcessor;
-
-        std::shared_ptr< ISequenceBarrier > m_pingBarrier;
-        std::shared_ptr< Ponger > m_ponger;
-        std::shared_ptr< BatchEventProcessor< ValueEvent > > m_pongProcessor;
-
-        std::shared_ptr< IExecutor > m_executor;
-        std::shared_ptr< ITaskScheduler > m_taskScheduler;
-    };
-
-
-    class PingPongSequencedLatencyTest::Pinger : public IEventHandler< ValueEvent >, public ILifecycleAware
-    {
-    public:
-        Pinger(const std::shared_ptr< RingBuffer< ValueEvent > >& buffer, std::int64_t maxEvents, std::int32_t pauseDurationInNanos);
-
-        void onEvent(ValueEvent& data, std::int64_t sequence, bool endOfBatch) override;
-
-        void onStart() override;
-        void onShutdown() override;
-
-        void reset(const std::shared_ptr< Tests::CountdownEvent >& globalSignal,
-                   const std::shared_ptr< Tests::ManualResetEvent >& signal,
-                   const std::shared_ptr< Tests::LatencyRecorder >& latencyRecorder);
-
-    private:
-        void send();
-
-        std::shared_ptr< RingBuffer< ValueEvent > > m_buffer;
-        std::int64_t m_maxEvents;
-        std::int32_t m_pauseDurationInNanos;
-        std::int64_t m_pauseDurationInStopwatchTicks;
-        std::shared_ptr< Tests::LatencyRecorder > m_latencyRecorder;
-        std::int64_t m_t0;
-        std::int64_t m_counter;
-        std::shared_ptr< Tests::CountdownEvent > m_globalSignal;
-        std::shared_ptr< Tests::ManualResetEvent > m_signal;
-    };
-
-
-    class PingPongSequencedLatencyTest::Ponger : public IEventHandler< ValueEvent >, public ILifecycleAware
-    {
-    public:
-        explicit Ponger(const std::shared_ptr< RingBuffer< ValueEvent > >& buffer);
-
-        void onEvent(ValueEvent& data, std::int64_t sequence, bool endOfBatch) override;
-
-        void onStart() override;
-        void onShutdown() override;
-
-        void reset(const std::shared_ptr< Tests::CountdownEvent >& globalSignal);
-
-    private:
-        std::shared_ptr< RingBuffer< ValueEvent > > m_buffer;
-        std::shared_ptr< Tests::CountdownEvent > m_globalSignal;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/TestFactory.h ./Disruptor.PerfTests/TestFactory.h
--- ../Disruptor-cpp/Disruptor.PerfTests/TestFactory.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/TestFactory.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,26 +0,0 @@
-#pragma once
-
-#include <string>
-
-#include "Disruptor.PerfTests/ILatencyTest.h"
-#include "Disruptor.PerfTests/IThroughputTest.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    template <class TTest>
-    struct TestFactory
-    {
-        std::string name;
-        std::function<std::shared_ptr< TTest >()> factory;
-    };
-
-
-    using ThroughputTestInfo = TestFactory< IThroughputTest >;
-    using LatencyTestInfo = TestFactory< ILatencyTest >;
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/TestRepository.cpp ./Disruptor.PerfTests/TestRepository.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/TestRepository.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/TestRepository.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,140 +0,0 @@
-#include "stdafx.h"
-#include "TestRepository.h"
-
-#include <boost/algorithm/string.hpp>
-
-// Raw
-#include "OneToOneRawBatchThroughputTest.h"
-#include "OneToOneRawThroughputTest.h"
-
-// Sequenced
-#include "OneToOneSequencedBatchThroughputTest.h"
-#include "OneToOneSequencedLongArrayThroughputTest.h"
-#include "OneToOneSequencedPollerThroughputTest.h"
-#include "OneToOneSequencedThroughputTest.h"
-#include "OneToThreeDiamondSequencedThroughputTest.h"
-#include "OneToThreePipelineSequencedThroughputTest.h"
-#include "OneToThreeSequencedThroughputTest.h"
-#include "PingPongSequencedLatencyTest.h"
-#include "ThreeToOneSequencedBatchThroughputTest.h"
-#include "ThreeToOneSequencedThroughputTest.h"
-#include "ThreeToThreeSequencedThroughputTest.h"
-
-// Translator
-#include "OneToOneTranslatorThroughputTest.h"
-
-// WorkHandler
-#include "OneToThreeReleasingWorkerPoolThroughputTest.h"
-#include "OneToThreeWorkerPoolThroughputTest.h"
-#include "TwoToTwoWorkProcessorThroughputTest.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    TestRepository::TestRepository()
-    {
-        // Raw
-        registerTest< OneToOneRawBatchThroughputTest >();
-        registerTest< OneToOneRawThroughputTest >();
-
-        // Sequenced
-        registerTest< OneToOneSequencedBatchThroughputTest >();
-        registerTest< OneToOneSequencedLongArrayThroughputTest >();
-        registerTest< OneToOneSequencedPollerThroughputTest >();
-        registerTest< OneToOneSequencedThroughputTest >();
-        registerTest< OneToThreeDiamondSequencedThroughputTest >();
-        registerTest< OneToThreePipelineSequencedThroughputTest >();
-        registerTest< OneToThreeSequencedThroughputTest >();
-        registerTest< PingPongSequencedLatencyTest >();
-        registerTest< ThreeToOneSequencedBatchThroughputTest >();
-        registerTest< ThreeToOneSequencedThroughputTest >();
-        registerTest< ThreeToThreeSequencedThroughputTest >();
-
-        // Translator
-        registerTest< OneToOneTranslatorThroughputTest >();
-
-        // WorkHandler
-        registerTest< OneToThreeReleasingWorkerPoolThroughputTest >();
-        registerTest< OneToThreeWorkerPoolThroughputTest >();
-        registerTest< TwoToTwoWorkProcessorThroughputTest >();
-    }
-
-    void TestRepository::registerTest(const TypeInfo& typeInfo, const std::function<std::shared_ptr< IThroughputTest >()>& testFactory)
-    {
-        ThroughputTestInfo info{ typeInfo.name(), testFactory };
-
-        m_throughputTestInfosByName.insert(std::make_pair(boost::algorithm::to_lower_copy(typeInfo.fullyQualifiedName()), info));
-        m_throughputTestInfosByName.insert(std::make_pair(boost::algorithm::to_lower_copy(typeInfo.name()), info));
-    }
-
-    void TestRepository::registerTest(const TypeInfo& typeInfo, const std::function<std::shared_ptr< ILatencyTest >()>& testFactory)
-    {
-        LatencyTestInfo info{ typeInfo.name(), testFactory };
-
-        m_latencyTestInfosByName.insert(std::make_pair(boost::algorithm::to_lower_copy(typeInfo.fullyQualifiedName()), info));
-        m_latencyTestInfosByName.insert(std::make_pair(boost::algorithm::to_lower_copy(typeInfo.name()), info));
-    }
-
-    const TestRepository& TestRepository::instance()
-    {
-        static TestRepository instance;
-        return instance;
-    }
-
-    std::vector< ThroughputTestInfo > TestRepository::allThrougputTests() const
-    {
-        std::vector< ThroughputTestInfo > result;
-        std::set< std::string > testNames;
-
-        for (auto&& x : m_throughputTestInfosByName)
-        {
-            if (testNames.count(x.second.name) > 0)
-                continue;
-
-            testNames.insert(x.second.name);
-            result.push_back(x.second);
-        }
-        return result;
-    }
-
-    bool TestRepository::tryGetThroughputTest(const std::string& testName, ThroughputTestInfo& testInfo) const
-    {
-        auto it = m_throughputTestInfosByName.find(boost::algorithm::to_lower_copy(testName));
-        if (it == m_throughputTestInfosByName.end())
-            return false;
-
-        testInfo = it->second;
-        return true;
-    }
-
-    std::vector< LatencyTestInfo > TestRepository::allLatencyTests() const
-    {
-        std::vector< LatencyTestInfo > result;
-        std::set< std::string > testNames;
-
-        for (auto&& x : m_latencyTestInfosByName)
-        {
-            if (testNames.count(x.second.name) > 0)
-                continue;
-
-            testNames.insert(x.second.name);
-            result.push_back(x.second);
-        }
-        return result;
-    }
-
-    bool TestRepository::tryGetLatencyTest(const std::string& testName, LatencyTestInfo& testInfo) const
-    {
-        auto it = m_latencyTestInfosByName.find(boost::algorithm::to_lower_copy(testName));
-        if (it == m_latencyTestInfosByName.end())
-            return false;
-
-        testInfo = it->second;
-        return true;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/TestRepository.h ./Disruptor.PerfTests/TestRepository.h
--- ../Disruptor-cpp/Disruptor.PerfTests/TestRepository.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/TestRepository.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,53 +0,0 @@
-#pragma once
-
-#include <map>
-#include <memory>
-#include <string>
-
-#include "Disruptor/TypeInfo.h"
-
-#include "Disruptor.PerfTests/TestFactory.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class TestRepository
-    {
-    public:
-        static const TestRepository& instance();
-
-        std::vector< ThroughputTestInfo > allThrougputTests() const;
-        bool tryGetThroughputTest(const std::string& testName, ThroughputTestInfo& testInfo) const;
-
-        std::vector< LatencyTestInfo > allLatencyTests() const;
-        bool tryGetLatencyTest(const std::string& testName, LatencyTestInfo& testInfo) const;
-
-    private:
-        TestRepository();
-
-        template <class TTest>
-        void registerTest()
-        {
-            static_assert(std::is_base_of< IThroughputTest, TTest >::value || std::is_base_of< ILatencyTest, TTest >::value,
-                          "TTest should implement IThroughputTest or ILatencyTest");
-
-            std::function<std::shared_ptr<TTest>()>&& factory = []() -> std::shared_ptr<TTest>
-            {
-                return std::make_shared<TTest>();
-            };
-
-            registerTest(Utils::getMetaTypeInfo< TTest >(), factory);
-        }
-
-        void registerTest(const TypeInfo& typeInfo, const std::function<std::shared_ptr< IThroughputTest >()>& testFactory);
-        void registerTest(const TypeInfo& typeInfo, const std::function<std::shared_ptr< ILatencyTest >()>& testFactory);
-
-        std::map< std::string, ThroughputTestInfo > m_throughputTestInfosByName;
-        std::map< std::string, LatencyTestInfo > m_latencyTestInfosByName;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/ThreeToOneSequencedBatchThroughputTest.cpp ./Disruptor.PerfTests/ThreeToOneSequencedBatchThroughputTest.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/ThreeToOneSequencedBatchThroughputTest.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/ThreeToOneSequencedBatchThroughputTest.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,92 +0,0 @@
-#include "stdafx.h"
-#include "ThreeToOneSequencedBatchThroughputTest.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    ThreeToOneSequencedBatchThroughputTest::ThreeToOneSequencedBatchThroughputTest()
-    {
-        auto sequenceBarrier = m_ringBuffer->newBarrier();
-        for (auto i = 0; i < m_numPublishers; ++i)
-        {
-            m_valuePublishers[i] = std::make_shared< ValueBatchPublisher >(m_cyclicBarrier, m_ringBuffer, m_iterations / m_numPublishers, 10);
-        }
-
-        m_batchEventProcessor = std::make_shared< BatchEventProcessor< ValueEvent > >(m_ringBuffer, sequenceBarrier, m_handler);
-        m_ringBuffer->addGatingSequences({ m_batchEventProcessor->sequence() });
-    }
-
-    std::int64_t ThreeToOneSequencedBatchThroughputTest::run(Stopwatch& stopwatch)
-    {
-        m_cyclicBarrier->reset();
-
-        auto latch = std::make_shared< Tests::ManualResetEvent >(false);
-        m_handler->reset(latch, m_batchEventProcessor->sequence()->value() + ((m_iterations / m_numPublishers) * m_numPublishers));
-
-        std::vector< std::future< void > > futures(m_numPublishers);
-        for (auto i = 0; i < m_numPublishers; ++i)
-        {
-            auto index = i;
-            futures[i] = std::async(std::launch::async, [this, index] { m_valuePublishers[index]->run(); });
-        }
-        auto processorTask = std::async(std::launch::async, [this] { m_batchEventProcessor->run(); });
-
-        stopwatch.start();
-        m_cyclicBarrier->signal();
-        m_cyclicBarrier->wait();
-
-        for (auto i = 0; i < m_numPublishers; ++i)
-        {
-            futures[i].wait();
-        }
-
-        latch->waitOne();
-
-        stopwatch.stop();
-        m_batchEventProcessor->halt();
-        processorTask.wait_for(std::chrono::milliseconds(2000));
-
-        return m_iterations;
-    }
-
-    std::int32_t ThreeToOneSequencedBatchThroughputTest::requiredProcessorCount() const
-    {
-        return 4;
-    }
-
-    ThreeToOneSequencedBatchThroughputTest::ValueBatchPublisher::ValueBatchPublisher(const std::shared_ptr< Tests::CountdownEvent >& cyclicBarrier,
-                                                                                     const std::shared_ptr< RingBuffer< ValueEvent > >& ringBuffer,
-                                                                                     std::int64_t iterations,
-                                                                                     std::int32_t batchSize)
-        : m_cyclicBarrier(cyclicBarrier)
-        , m_ringBuffer(ringBuffer)
-        , m_iterations(iterations)
-        , m_batchSize(batchSize)
-    {
-    }
-
-    void ThreeToOneSequencedBatchThroughputTest::ValueBatchPublisher::run()
-    {
-        auto& rb = *m_ringBuffer;
-
-        m_cyclicBarrier->signal();
-        m_cyclicBarrier->wait();
-
-        for (std::int64_t i = 0; i < m_iterations; i += m_batchSize)
-        {
-            auto hi = m_ringBuffer->next(m_batchSize);
-            auto lo = hi - (m_batchSize - 1);
-            for (auto l = lo; l <= hi; ++l)
-            {
-                auto& event = rb[l];
-                event.value = l;
-            }
-            m_ringBuffer->publish(lo, hi);
-        }
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/ThreeToOneSequencedBatchThroughputTest.h ./Disruptor.PerfTests/ThreeToOneSequencedBatchThroughputTest.h
--- ../Disruptor-cpp/Disruptor.PerfTests/ThreeToOneSequencedBatchThroughputTest.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/ThreeToOneSequencedBatchThroughputTest.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,101 +0,0 @@
-#pragma once
-
-#include "Disruptor/BatchEventProcessor.h"
-#include "Disruptor/BusySpinWaitStrategy.h"
-#include "Disruptor/RingBuffer.h"
-
-#include "Disruptor.TestTools/CountdownEvent.h"
-
-#include "Disruptor.PerfTests/IThroughputTest.h"
-#include "Disruptor.PerfTests/ValueAdditionEventHandler.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    /**
-     * Sequence a series of events from multiple publishers going to one event processor.
-     * +----+
-     * | P1 |------+
-     * +----+      |
-     *             v
-     * +----+    +-----+
-     * | P1 |--->| EP1 |
-     * +----+    +-----+
-     *             ^
-     * +----+      |
-     * | P3 |------+
-     * +----+
-     * Disruptor:
-     * ==========
-     *             track to prevent wrap
-     *             +--------------------+
-     *             |                    |
-     *             |                    v
-     * +----+    +====+    +====+    +-----+
-     * | P1 |--->| RB |/---| SB |    | EP1 |
-     * +----+    +====+    +====+    +-----+
-     *             ^   get    ^         |
-     * +----+      |          |         |
-     * | P2 |------+          +---------+
-     * +----+      |            waitFor
-     *             |
-     * +----+      |
-     * | P3 |------+
-     * +----+
-     * P1  - Publisher 1
-     * P2  - Publisher 2
-     * P3  - Publisher 3
-     * RB  - RingBuffer
-     * SB  - SequenceBarrier
-     * EP1 - EventProcessor 1
-     * 
-     */
-    class ThreeToOneSequencedBatchThroughputTest : public IThroughputTest
-    {
-        class ValueBatchPublisher
-        {
-        public:
-            ValueBatchPublisher(const std::shared_ptr< Tests::CountdownEvent >& cyclicBarrier,
-                                const std::shared_ptr< RingBuffer< ValueEvent > >& ringBuffer,
-                                std::int64_t iterations,
-                                std::int32_t batchSize);
-
-            void run();
-
-        private:
-            std::shared_ptr< Tests::CountdownEvent > m_cyclicBarrier;
-            std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer;
-            std::int64_t m_iterations;
-            std::int32_t m_batchSize;
-        };
-
-    public:
-        ThreeToOneSequencedBatchThroughputTest();
-
-        std::int64_t run(Stopwatch& stopwatch) override;
-
-        std::int32_t requiredProcessorCount() const override;
-
-    private:
-        const std::int32_t m_numPublishers = 3;
-        const std::int32_t m_bufferSize = 1024 * 64;
-
-#ifdef _DEBUG
-        const std::int64_t m_iterations = 100L * 100L * 10L;
-#else
-        const std::int64_t m_iterations = 1000L * 1000L * 100L;
-#endif
-
-        std::shared_ptr< Tests::CountdownEvent > m_cyclicBarrier = std::make_shared< Tests::CountdownEvent >(m_numPublishers + 1);
-
-        std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer = RingBuffer< ValueEvent >::createMultiProducer(ValueEvent::eventFactory(), m_bufferSize, std::make_shared< BusySpinWaitStrategy >());
-        std::shared_ptr< ValueAdditionEventHandler > m_handler = std::make_shared< ValueAdditionEventHandler >();
-        std::shared_ptr< BatchEventProcessor< ValueEvent > > m_batchEventProcessor;
-        std::vector< std::shared_ptr< ValueBatchPublisher > > m_valuePublishers = std::vector< std::shared_ptr< ValueBatchPublisher > >(m_numPublishers);
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/ThreeToOneSequencedThroughputTest.cpp ./Disruptor.PerfTests/ThreeToOneSequencedThroughputTest.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/ThreeToOneSequencedThroughputTest.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/ThreeToOneSequencedThroughputTest.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,87 +0,0 @@
-#include "stdafx.h"
-#include "ThreeToOneSequencedThroughputTest.h"
-
-#include "Disruptor.TestTools/ScopeExitFunctor.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    ThreeToOneSequencedThroughputTest::ThreeToOneSequencedThroughputTest()
-    {
-        m_sequenceBarrier = m_ringBuffer->newBarrier();
-        m_batchEventProcessor = std::make_shared< BatchEventProcessor< ValueEvent > >(m_ringBuffer, m_sequenceBarrier, m_handler);
-        for (auto i = 0; i < m_numPublishers; ++i)
-        {
-            m_valuePublishers[i] = [this](const std::shared_ptr< Tests::CountdownEvent >& countdownEvent,
-                                          const std::shared_ptr< RingBuffer< ValueEvent > >& ringBuffer,
-                                          std::int64_t iterations)
-            {
-                this->valuePublisher(countdownEvent, ringBuffer, iterations);
-            };
-        }
-        m_ringBuffer->addGatingSequences({ m_batchEventProcessor->sequence() });
-    }
-
-    std::int64_t ThreeToOneSequencedThroughputTest::run(Stopwatch& stopwatch)
-    {
-        m_scheduler->start(5);
-        TestTools::ScopeExitFunctor atScopeExit([this] { m_scheduler->stop(); });
-
-        m_cyclicBarrier->reset();
-        auto latch = std::make_shared< Tests::ManualResetEvent >(false);
-        m_handler->reset(latch, m_batchEventProcessor->sequence()->value() + ((m_iterations / m_numPublishers) * m_numPublishers));
-
-        std::vector< std::future< void > > futures(m_numPublishers);
-        for (auto i = 0; i < m_numPublishers; ++i)
-        {
-            auto index = i;
-            futures[i] = m_scheduler->scheduleAndStart(std::packaged_task< void() >([this, index] { m_valuePublishers[index](m_cyclicBarrier, m_ringBuffer, m_iterations); }));
-        }
-        auto processorTask = m_scheduler->scheduleAndStart(std::packaged_task< void() >([this] { m_batchEventProcessor->run(); }));
-
-        stopwatch.start();
-        m_cyclicBarrier->signal();
-        m_cyclicBarrier->wait();
-
-        for (auto i = 0; i < m_numPublishers; ++i)
-        {
-            futures[i].wait();
-        }
-
-        latch->waitOne();
-
-        stopwatch.stop();
-        m_batchEventProcessor->halt();
-        processorTask.wait_for(std::chrono::milliseconds(2000));
-
-        return m_iterations;
-    }
-
-    std::int32_t ThreeToOneSequencedThroughputTest::requiredProcessorCount() const
-    {
-        return 4;
-    }
-
-    void ThreeToOneSequencedThroughputTest::valuePublisher(const std::shared_ptr< Tests::CountdownEvent >& countdownEvent,
-                                                           const std::shared_ptr< RingBuffer< ValueEvent > >& ringBuffer,
-                                                           std::int64_t iterations)
-    {
-        auto& rb = *ringBuffer;
-
-        countdownEvent->signal();
-        countdownEvent->wait();
-
-        for (std::int64_t i = 0; i < iterations; ++i)
-        {
-            auto sequence = rb.next();
-            auto& eventData = rb[sequence];
-            eventData.value = i;
-            rb.publish(sequence);
-        }
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/ThreeToOneSequencedThroughputTest.h ./Disruptor.PerfTests/ThreeToOneSequencedThroughputTest.h
--- ../Disruptor-cpp/Disruptor.PerfTests/ThreeToOneSequencedThroughputTest.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/ThreeToOneSequencedThroughputTest.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,97 +0,0 @@
-#pragma once
-
-#include "Disruptor/BatchEventProcessor.h"
-#include "Disruptor/BusySpinWaitStrategy.h"
-#include "Disruptor/ITaskScheduler.h"
-#include "Disruptor/RingBuffer.h"
-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
-
-#include "Disruptor.TestTools/CountdownEvent.h"
-
-#include "Disruptor.PerfTests/IThroughputTest.h"
-#include "Disruptor.PerfTests/ValueEvent.h"
-#include "Disruptor.PerfTests/ValueAdditionEventHandler.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    /**
-     * Sequence a series of events from multiple publishers going to one event processor.
-     * 
-     * +----+
-     * | P1 |------+
-     * +----+      |
-     *             v
-     * +----+    +-----+
-     * | P1 |--->| EP1 |
-     * +----+    +-----+
-     *             ^
-     * +----+      |
-     * | P3 |------+
-     * +----+
-     * Disruptor:
-     * ==========
-     *             track to prevent wrap
-     *             +--------------------+
-     *             |                    |
-     *             |                    v
-     * +----+    +====+    +====+    +-----+
-     * | P1 |--->| RB |/---| SB |    | EP1 |
-     * +----+    +====+    +====+    +-----+
-     *             ^   get    ^         |
-     * +----+      |          |         |
-     * | P2 |------+          +---------+
-     * +----+      |            waitFor
-     *             |
-     * +----+      |
-     * | P3 |------+
-     * +----+
-     * 
-     * P1  - Publisher 1
-     * P2  - Publisher 2
-     * P3  - Publisher 3
-     * RB  - RingBuffer
-     * SB  - SequenceBarrier
-     * EP1 - EventProcessor 1
-     * 
-     */
-    class ThreeToOneSequencedThroughputTest : public IThroughputTest
-    {
-        using ValuePublisher = std::function< void(const std::shared_ptr< Tests::CountdownEvent >&, const std::shared_ptr< RingBuffer< ValueEvent > >&, std::int64_t) >;
-
-    public:
-        ThreeToOneSequencedThroughputTest();
-
-        std::int64_t run(Stopwatch& stopwatch) override;
-
-        std::int32_t requiredProcessorCount() const override;
-
-    private:
-        static void valuePublisher(const std::shared_ptr< Tests::CountdownEvent >& countdownEvent,
-                                   const std::shared_ptr< RingBuffer< ValueEvent > >& ringBuffer,
-                                   std::int64_t iterations);
-
-        const std::int32_t m_numPublishers = 3;
-        const std::int32_t m_bufferSize = 1024 * 64;
-
-#ifdef _DEBUG
-        const std::int64_t m_iterations = 100L * 100L * 2L;
-#else
-        const std::int64_t m_iterations = 1000L * 1000L * 20L;
-#endif
-
-        std::shared_ptr< Tests::CountdownEvent > m_cyclicBarrier = std::make_shared< Tests::CountdownEvent >(m_numPublishers + 1);
-        std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer = RingBuffer< ValueEvent >::createMultiProducer(ValueEvent::eventFactory(), m_bufferSize, std::make_shared< BusySpinWaitStrategy >());
-
-        std::shared_ptr< ITaskScheduler > m_scheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
-        std::shared_ptr< ISequenceBarrier > m_sequenceBarrier;
-        std::shared_ptr< ValueAdditionEventHandler > m_handler = std::make_shared< ValueAdditionEventHandler >();
-        std::shared_ptr< BatchEventProcessor< ValueEvent > > m_batchEventProcessor;
-        std::vector< ValuePublisher > m_valuePublishers = std::vector< ValuePublisher >(m_numPublishers);
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/ThreeToThreeSequencedThroughputTest.cpp ./Disruptor.PerfTests/ThreeToThreeSequencedThroughputTest.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/ThreeToThreeSequencedThroughputTest.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/ThreeToThreeSequencedThroughputTest.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,101 +0,0 @@
-#include "stdafx.h"
-#include "ThreeToThreeSequencedThroughputTest.h"
-
-#include "Disruptor/YieldingWaitStrategy.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    ThreeToThreeSequencedThroughputTest::ThreeToThreeSequencedThroughputTest()
-    {
-        for (auto i = 0; i < m_numPublishers; ++i)
-        {
-            m_buffers[i] = RingBuffer< std::vector< std::int64_t > >::createSingleProducer([this] {return std::vector< std::int64_t >(m_arraySize); },
-                                                                                           m_bufferSize,
-                                                                                           std::make_shared< YieldingWaitStrategy >());
-            m_barriers[i] = m_buffers[i]->newBarrier();
-            m_valuePublishers[i] = [this](const std::shared_ptr< Tests::CountdownEvent >& countdownEvent,
-                                          const std::shared_ptr< RingBuffer< std::vector< std::int64_t > > >& ringBuffer,
-                                          std::int64_t iterations,
-                                          std::int32_t arraySize)
-            {
-                this->valuePublisher(countdownEvent, ringBuffer, iterations, arraySize);
-            };
-        }
-
-        std::vector< std::shared_ptr< IDataProvider< std::vector< std::int64_t > > > > providers;
-        std::copy(m_buffers.begin(), m_buffers.end(), std::back_inserter(providers));
-
-        m_batchEventProcessor = std::make_shared< MultiBufferBatchEventProcessor< std::vector< std::int64_t > > >(providers, m_barriers, m_handler);
-
-        for (auto i = 0; i < m_numPublishers; ++i)
-        {
-            m_buffers[i]->addGatingSequences({ m_batchEventProcessor->getSequences()[i] });
-        }
-    }
-
-    std::int64_t ThreeToThreeSequencedThroughputTest::run(Stopwatch& stopwatch)
-    {
-        m_cyclicBarrier->reset();
-
-        auto latch = std::make_shared< Tests::ManualResetEvent >(false);
-        m_handler->reset(latch, m_iterations);
-
-        std::vector< std::future< void > > futures(m_numPublishers);
-        for (auto i = 0; i < m_numPublishers; ++i)
-        {
-            auto index = i;
-            futures[i] = std::async(std::launch::async, [this, index] { this->m_valuePublishers[index](m_cyclicBarrier, m_buffers[index], m_iterations / m_numPublishers, m_arraySize); });
-        }
-        auto processorTask = std::async(std::launch::async, [this] { this->m_batchEventProcessor->run(); });
-
-        stopwatch.start();
-        m_cyclicBarrier->signal();
-        m_cyclicBarrier->wait();
-
-        for (auto i = 0; i < m_numPublishers; ++i)
-        {
-            futures[i].wait();
-        }
-
-        latch->waitOne();
-
-        stopwatch.stop();
-        m_batchEventProcessor->halt();
-        processorTask.wait_for(std::chrono::milliseconds(2000));
-
-        return m_iterations * m_arraySize;
-    }
-
-    std::int32_t ThreeToThreeSequencedThroughputTest::requiredProcessorCount() const
-    {
-        return 4;
-    }
-
-    void ThreeToThreeSequencedThroughputTest::valuePublisher(const std::shared_ptr< Tests::CountdownEvent >& countdownEvent,
-                                                             const std::shared_ptr< RingBuffer< std::vector< std::int64_t > > >& ringBuffer,
-                                                             std::int64_t iterations,
-                                                             std::int32_t arraySize)
-    {
-        auto& rb = *ringBuffer;
-
-        countdownEvent->signal();
-        countdownEvent->wait();
-
-        for (std::int64_t i = 0; i < iterations; ++i)
-        {
-            auto sequence = rb.next();
-            auto& eventData = rb[sequence];
-            for (auto j = 0; j < arraySize; ++j)
-            {
-                eventData[j] = i + j;
-            }
-            rb.publish(sequence);
-        }
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/ThreeToThreeSequencedThroughputTest.h ./Disruptor.PerfTests/ThreeToThreeSequencedThroughputTest.h
--- ../Disruptor-cpp/Disruptor.PerfTests/ThreeToThreeSequencedThroughputTest.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/ThreeToThreeSequencedThroughputTest.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,89 +0,0 @@
-#pragma once
-
-#include "Disruptor/RingBuffer.h"
-
-#include "Disruptor.TestTools/CountdownEvent.h"
-
-#include "Disruptor.PerfTests/IThroughputTest.h"
-#include "Disruptor.PerfTests/LongArrayEventHandler.h"
-#include "Disruptor.PerfTests/MultiBufferBatchEventProcessor.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    /**
-     *
-     * Sequence a series of events from multiple publishers going to one event processor.
-     * 
-     * Disruptor:
-     * ==========
-     *             track to prevent wrap
-     *             +--------------------+
-     *             |                    |
-     *             |                    |
-     * +----+    +====+    +====+       |
-     * | P1 |--->| RB |--->| SB |--+    |
-     * +----+    +====+    +====+  |    |
-     *                             |    v
-     * +----+    +====+    +====+  | +----+
-     * | P2 |--->| RB |--->| SB |--+>| EP |
-     * +----+    +====+    +====+  | +----+
-     *                             |
-     * +----+    +====+    +====+  |
-     * | P3 |--->| RB |--->| SB |--+
-     * +----+    +====+    +====+
-     *
-     *
-     * P1 - Publisher 1
-     * P2 - Publisher 2
-     * P3 - Publisher 3
-     * RB - RingBuffer
-     * SB - SequenceBarrier
-     * EP - EventProcessor
-     *
-     */
-    class ThreeToThreeSequencedThroughputTest : public IThroughputTest
-    {
-        using LongArrayPublisher = std::function< void(const std::shared_ptr< Tests::CountdownEvent >&,
-                                                       const std::shared_ptr< RingBuffer< std::vector< std::int64_t > > >&,
-                                                       std::int64_t,
-                                                       std::int32_t) >;
-
-    public:
-        ThreeToThreeSequencedThroughputTest();
-
-        std::int64_t run(Stopwatch& stopwatch) override;
-
-        std::int32_t requiredProcessorCount() const override;
-
-    private:
-        static void valuePublisher(const std::shared_ptr< Tests::CountdownEvent >& countdownEvent,
-                                   const std::shared_ptr< RingBuffer< std::vector< std::int64_t > > >& ringBuffer,
-                                   std::int64_t iterations,
-                                   std::int32_t arraySize);
-
-        const std::int32_t m_numPublishers = 3;
-        const std::int32_t m_arraySize = 3;
-        const std::int32_t m_bufferSize = 1024 * 64;
-
-#ifdef _DEBUG
-        const std::int64_t m_iterations = 100L * 100L * 18L;
-#else
-        const std::int64_t m_iterations = 1000L * 1000L * 180L;
-#endif
-
-        std::shared_ptr< Tests::CountdownEvent > m_cyclicBarrier = std::make_shared< Tests::CountdownEvent >(m_numPublishers + 1);
-
-        std::vector< std::shared_ptr< RingBuffer< std::vector< std::int64_t > > > > m_buffers = std::vector< std::shared_ptr< RingBuffer< std::vector< std::int64_t > > > >(m_numPublishers);
-        std::vector< std::shared_ptr< ISequenceBarrier > > m_barriers = std::vector< std::shared_ptr< ISequenceBarrier > >(m_numPublishers);
-        std::vector< LongArrayPublisher > m_valuePublishers = std::vector< LongArrayPublisher >(m_numPublishers);
-        
-        std::shared_ptr< LongArrayEventHandler > m_handler = std::make_shared< LongArrayEventHandler >();
-        std::shared_ptr< MultiBufferBatchEventProcessor< std::vector< std::int64_t > > > m_batchEventProcessor;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/ThroughputTestSession.cpp ./Disruptor.PerfTests/ThroughputTestSession.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/ThroughputTestSession.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/ThroughputTestSession.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,86 +0,0 @@
-#include "stdafx.h"
-#include "ThroughputTestSession.h"
-
-#include <numeric>
-#include <sstream>
-
-#include <boost/filesystem.hpp>
-
-#include "Disruptor.TestTools/Stopwatch.h"
-
-#include "Disruptor.PerfTests/PerfTestUtil.h"
-#include "Disruptor.PerfTests/ThroughputTestSessionResult.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    ThroughputTestSession::ThroughputTestSession(const ThroughputTestInfo& testInfo)
-    {
-        m_testInfo = testInfo;
-    }
-
-    void ThroughputTestSession::run()
-    {
-        auto testInstance = m_testInfo.factory();
-
-        checkProcessorsRequirements(testInstance);
-
-        std::cout << "Throughput Test to run => " << m_testInfo.name << ", Runs => " << m_runs << std::endl;
-        std::cout << "Starting throughput tests" << std::endl;
-
-        Stopwatch stopwatch;
-
-        for (auto i = 0; i < m_runs; i++)
-        {
-            stopwatch.reset();
-
-            std::int64_t totalOperationsInRun;
-
-            try
-            {
-                totalOperationsInRun = testInstance->run(stopwatch);
-            }
-            catch (std::exception& ex)
-            {
-                ThroughputTestSessionResult result(ex);
-                std::cout << result.toString() << std::endl;
-
-                m_results.push_back(result);
-                continue;
-            }
-
-            ThroughputTestSessionResult result(totalOperationsInRun, stopwatch.elapsed());
-            std::cout << result.toString() << std::endl;
-
-            m_results.push_back(result);
-        }
-    }
-
-    std::int64_t ThroughputTestSession::getAverageThroughput()
-    {
-        double averageThroughput = 0;
-        for (auto&& x : m_results)
-        {
-            auto totalSeconds = std::chrono::duration_cast< std::chrono::seconds >(x.duration());
-            averageThroughput += static_cast< double >(x.totalOperationsInRun()) / totalSeconds.count();
-        }
-
-        return static_cast< std::int64_t >(averageThroughput / static_cast< double >(m_results.size()));
-    }
-
-
-    void ThroughputTestSession::checkProcessorsRequirements(const std::shared_ptr<IThroughputTest>& test)
-    {
-        auto availableProcessors = static_cast< std::int32_t >(std::thread::hardware_concurrency());
-        if (test->requiredProcessorCount() <= availableProcessors)
-            return;
-
-        std::cout << "*** Warning ***: your system has insufficient processors to execute the test efficiently. " << std::endl;
-        std::cout << "Processors required = " << test->requiredProcessorCount() << ", available = " << availableProcessors << std::endl;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/ThroughputTestSession.h ./Disruptor.PerfTests/ThroughputTestSession.h
--- ../Disruptor-cpp/Disruptor.PerfTests/ThroughputTestSession.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/ThroughputTestSession.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,37 +0,0 @@
-#pragma once
-
-#include "Disruptor.PerfTests/TestFactory.h"
-#include "Disruptor.PerfTests/ThroughputTestSessionResult.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class IThroughputTest;
-
-
-    class ThroughputTestSession
-    {
-    public:
-        explicit ThroughputTestSession(const ThroughputTestInfo& testInfo);
-
-        void run();
-
-    private:
-        static void checkProcessorsRequirements(const std::shared_ptr<IThroughputTest>& test);
-        std::int64_t getAverageThroughput();
-
-#ifdef _DEBUG
-        const std::int32_t m_runs = 3;
-#else
-        const std::int32_t m_runs = 7;
-#endif
-
-        std::vector< ThroughputTestSessionResult > m_results;
-        ThroughputTestInfo m_testInfo;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/ThroughputTestSessionResult.cpp ./Disruptor.PerfTests/ThroughputTestSessionResult.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/ThroughputTestSessionResult.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/ThroughputTestSessionResult.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,88 +0,0 @@
-#include "stdafx.h"
-#include "ThroughputTestSessionResult.h"
-
-#include <iomanip>
-#include <sstream>
-
-#include "Disruptor.TestTools/DurationHumanizer.h"
-#include "Disruptor.TestTools/HumanNumberFacet.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    ThroughputTestSessionResult::ThroughputTestSessionResult(std::int64_t totalOperationsInRun, ClockConfig::Duration duration)
-        : m_totalOperationsInRun(totalOperationsInRun)
-        , m_duration(duration)
-    {}
-
-    ThroughputTestSessionResult::ThroughputTestSessionResult(const std::exception& exception)
-        : m_exception(exception)
-    {}
-
-    void ThroughputTestSessionResult::appendDetailedHtmlReport(std::int32_t runId, std::ostringstream& os)
-    {
-        if (m_exception)
-        {
-            os
-                << " <tr>" << std::endl
-                << "     <td>" << runId << "</td>" << std::endl
-                << "     <td>FAILED</td>" << std::endl
-                << "     <td>" << m_exception.get().what() << "</td>" << std::endl
-                << "</tr>" << std::endl;
-        }
-        else
-        {
-            os
-                << "<tr>" << std::endl
-                << "     <td>" << runId << "</td>" << std::endl
-                << "     <td>" << ops() << "</td>" << std::endl
-                << "     <td>" << durationInMilliseconds() << "</td>" << std::endl
-                << "</tr>" << std::endl;
-        }
-    }
-
-    std::string ThroughputTestSessionResult::toString()
-    {
-        std::ostringstream result;
-        result.imbue(std::locale(result.getloc(), new Tests::HumanNumberFacet()));
-
-        if (m_exception)
-            result << "Run: FAILED: " << m_exception.get().what();
-        else
-        {
-            auto humanDuration = Tests::DurationHumanizer::deduceHumanDuration(duration());
-
-            result << "Run: Ops: " << ops()
-                   << " - Duration (" << humanDuration.shortUnitName << "): " << std::setprecision(3) << humanDuration.value;
-        }
-
-        return result.str();
-    }
-
-    std::int64_t ThroughputTestSessionResult::totalOperationsInRun() const
-    {
-        return m_totalOperationsInRun;
-    }
-
-    ClockConfig::Duration ThroughputTestSessionResult::duration() const
-    {
-        return m_duration;
-    }
-
-    std::int64_t ThroughputTestSessionResult::ops() const
-    {
-        auto elapsed = std::chrono::duration_cast< std::chrono::microseconds >(m_duration).count();
-        return static_cast< std::int64_t >(static_cast< double >(1000 * 1000 * m_totalOperationsInRun) / elapsed);
-    }
-
-    std::int64_t ThroughputTestSessionResult::durationInMilliseconds() const
-    {
-        auto totalMilliseconds = std::chrono::duration_cast< std::chrono::milliseconds >(m_duration);
-        return static_cast< std::int64_t >(totalMilliseconds.count());
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/ThroughputTestSessionResult.h ./Disruptor.PerfTests/ThroughputTestSessionResult.h
--- ../Disruptor-cpp/Disruptor.PerfTests/ThroughputTestSessionResult.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/ThroughputTestSessionResult.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,40 +0,0 @@
-#pragma once
-
-#include <cstdint>
-#include <exception>
-#include <iosfwd>
-
-#include <boost/optional.hpp>
-
-#include "Disruptor/ClockConfig.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class ThroughputTestSessionResult
-    {
-    public:
-        ThroughputTestSessionResult(std::int64_t totalOperationsInRun, ClockConfig::Duration duration);
-
-        explicit ThroughputTestSessionResult(const std::exception& exception);
-
-        void appendDetailedHtmlReport(std::int32_t runId, std::ostringstream& stringBuilder);
-        std::string toString();
-
-        std::int64_t totalOperationsInRun() const;
-        ClockConfig::Duration duration() const;
-
-        std::int64_t ops() const;
-        std::int64_t durationInMilliseconds() const;
-
-    private:
-        std::int64_t m_totalOperationsInRun = 0;
-        ClockConfig::Duration m_duration;
-        boost::optional< std::exception > m_exception;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/TwoToTwoWorkProcessorThroughputTest.cpp ./Disruptor.PerfTests/TwoToTwoWorkProcessorThroughputTest.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/TwoToTwoWorkProcessorThroughputTest.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/TwoToTwoWorkProcessorThroughputTest.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,113 +0,0 @@
-#include "stdafx.h"
-#include "TwoToTwoWorkProcessorThroughputTest.h"
-
-#include "Disruptor/IgnoreExceptionHandler.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    TwoToTwoWorkProcessorThroughputTest::TwoToTwoWorkProcessorThroughputTest()
-    {
-        auto sequenceBarrier = m_ringBuffer->newBarrier();
-        m_handlers[0] = std::make_shared< ValueAdditionWorkHandler >();
-        m_handlers[1] = std::make_shared< ValueAdditionWorkHandler >();
-
-        m_workProcessors[0] = WorkProcessor< ValueEvent >::create(m_ringBuffer, sequenceBarrier, m_handlers[0], std::make_shared< IgnoreExceptionHandler< ValueEvent > >(), m_workSequence);
-        m_workProcessors[1] = WorkProcessor< ValueEvent >::create(m_ringBuffer, sequenceBarrier, m_handlers[1], std::make_shared< IgnoreExceptionHandler< ValueEvent > >(), m_workSequence);
-
-        for (auto i = 0; i < m_numPublishers; ++i)
-        {
-            m_valuePublishers[i] = std::make_shared< ValuePublisher >(m_cyclicBarrier, m_ringBuffer, m_iterations);
-        }
-
-        m_ringBuffer->addGatingSequences({ m_workProcessors[0]->sequence(), m_workProcessors[1]->sequence() });
-    }
-
-    std::int64_t TwoToTwoWorkProcessorThroughputTest::run(Stopwatch& stopwatch)
-    {
-        m_cyclicBarrier->reset();
-
-        auto expected = m_ringBuffer->cursor() + (m_numPublishers * m_iterations);
-        auto futures = std::vector< std::future< void > >(m_numPublishers);
-        for (auto i = 0; i < m_numPublishers; ++i)
-        {
-            auto index = i;
-            futures[i] = std::async(std::launch::async, [this, index] { m_valuePublishers[index]->run(); });
-        }
-
-        for (auto&& processor : m_workProcessors)
-        {
-            std::thread([processor] { processor->run(); }).detach();
-        }
-
-        stopwatch.start();
-        m_cyclicBarrier->signal();
-        m_cyclicBarrier->wait();
-
-        for (auto i = 0; i < m_numPublishers; ++i)
-        {
-            futures[i].wait();
-        }
-
-        while (m_workSequence->value() < expected)
-        {
-            std::this_thread::yield();
-        }
-
-        stopwatch.stop();
-
-        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
-
-        for (auto&& processor : m_workProcessors)
-        {
-            processor->halt();
-        }
-
-        return m_iterations;
-    }
-
-    std::int32_t TwoToTwoWorkProcessorThroughputTest::requiredProcessorCount() const
-    {
-        return 4;
-    }
-
-
-    TwoToTwoWorkProcessorThroughputTest::ValuePublisher::ValuePublisher(const std::shared_ptr< Tests::CountdownEvent >& cyclicBarrier,  
-                                                                        const std::shared_ptr< RingBuffer< ValueEvent > >& ringBuffer,
-                                                                        std::int64_t iterations)
-        : m_cyclicBarrier(cyclicBarrier)
-        , m_ringBuffer(ringBuffer)
-        , m_iterations(iterations)
-    {
-    }
-
-    void TwoToTwoWorkProcessorThroughputTest::ValuePublisher::run()
-    {
-        m_cyclicBarrier->signal();
-        m_cyclicBarrier->wait();
-
-        for (std::int64_t i = 0; i < m_iterations; ++i)
-        {
-            auto sequence = m_ringBuffer->next();
-            auto& event = (*m_ringBuffer)[sequence];
-            event.value = i;
-            m_ringBuffer->publish(sequence);
-        }
-    }
-
-    void TwoToTwoWorkProcessorThroughputTest::ValueAdditionWorkHandler::onEvent(ValueEvent& evt)
-    {
-        auto value = evt.value;
-        m_total += value;
-    }
-
-    std::int64_t TwoToTwoWorkProcessorThroughputTest::ValueAdditionWorkHandler::total() const
-    {
-        return m_total;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/TwoToTwoWorkProcessorThroughputTest.h ./Disruptor.PerfTests/TwoToTwoWorkProcessorThroughputTest.h
--- ../Disruptor-cpp/Disruptor.PerfTests/TwoToTwoWorkProcessorThroughputTest.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/TwoToTwoWorkProcessorThroughputTest.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,98 +0,0 @@
-#pragma once
-
-#include "Disruptor/BusySpinWaitStrategy.h"
-#include "Disruptor/IWorkHandler.h"
-#include "Disruptor/RingBuffer.h"
-#include "Disruptor/WorkProcessor.h"
-
-#include "Disruptor.TestTools/CountdownEvent.h"
-
-#include "Disruptor.PerfTests/IThroughputTest.h"
-#include "Disruptor.PerfTests/ValueEvent.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    /**
-     *
-     * Sequence a series of events from multiple publishers going to multiple work processors.
-     * 
-     * +----+                  +-----+
-     * | P1 |---+          +-->| WP1 |
-     * +----+   |  +-----+ |   +-----+
-     *          +->| RB1 |-+
-     * +----+   |  +-----+ |   +-----+
-     * | P2 |---+          +-->| WP2 |
-     * +----+                  +-----+
-     * 
-     * P1  - Publisher 1
-     * P2  - Publisher 2
-     * RB  - RingBuffer
-     * WP1 - EventProcessor 1
-     * WP2 - EventProcessor 2
-     * 
-     */
-    class TwoToTwoWorkProcessorThroughputTest : public IThroughputTest
-    {
-        class ValuePublisher;
-        class ValueAdditionWorkHandler;
-
-    public:
-        TwoToTwoWorkProcessorThroughputTest();
-
-        std::int64_t run(Stopwatch& stopwatch) override;
-
-        std::int32_t requiredProcessorCount() const override;
-
-    private:
-        const std::int32_t m_numPublishers = 2;
-        const std::int32_t m_bufferSize = 1024 * 64;
-
-#ifdef _DEBUG
-        const std::int64_t m_iterations = 100L * 100L * 1L;
-#else
-        const std::int64_t m_iterations = 1000L * 1000L * 1L;
-#endif
-
-        std::shared_ptr< Tests::CountdownEvent > m_cyclicBarrier = std::make_shared< Tests::CountdownEvent >(m_numPublishers + 1);
-
-        std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer = RingBuffer< ValueEvent >::createMultiProducer(ValueEvent::eventFactory(), m_bufferSize, std::make_shared< BusySpinWaitStrategy >());
-        std::shared_ptr< Sequence > m_workSequence = std::make_shared< Sequence >();
-        std::vector< std::shared_ptr< ValueAdditionWorkHandler > > m_handlers = std::vector< std::shared_ptr< ValueAdditionWorkHandler > >(2);
-        std::vector< std::shared_ptr< WorkProcessor< ValueEvent > > > m_workProcessors = std::vector< std::shared_ptr< WorkProcessor< ValueEvent > > >(2);
-        std::vector< std::shared_ptr< ValuePublisher > > m_valuePublishers = std::vector< std::shared_ptr< ValuePublisher > >(m_numPublishers);
-    };
-
-
-    class TwoToTwoWorkProcessorThroughputTest::ValuePublisher
-    {
-    public:
-        ValuePublisher(const std::shared_ptr< Tests::CountdownEvent >& cyclicBarrier,
-                       const std::shared_ptr< RingBuffer< ValueEvent > >& ringBuffer,
-                       std::int64_t iterations);
-
-        void run();
-
-    private:
-        std::shared_ptr< Tests::CountdownEvent > m_cyclicBarrier;
-        const std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer;
-        const std::int64_t m_iterations;
-    };
-
-
-    class TwoToTwoWorkProcessorThroughputTest::ValueAdditionWorkHandler : public IWorkHandler< ValueEvent >
-    {
-    public:
-        void onEvent(ValueEvent& evt) override;
-
-        std::int64_t total() const;
-
-    private:
-        std::int64_t m_total = 0;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/ValueAdditionEventHandler.cpp ./Disruptor.PerfTests/ValueAdditionEventHandler.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/ValueAdditionEventHandler.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/ValueAdditionEventHandler.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,39 +0,0 @@
-#include "stdafx.h"
-#include "ValueAdditionEventHandler.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    void ValueAdditionEventHandler::reset(const std::shared_ptr< Tests::ManualResetEvent >& latch, std::int64_t expectedCount)
-    {
-        m_value.value = 0;
-        m_latch = latch;
-        m_count = expectedCount;
-    }
-
-    void ValueAdditionEventHandler::onEvent(ValueEvent& value, std::int64_t sequence, bool)
-    {
-        m_value.value = m_value.value + value.value;
-
-        if (count() == sequence)
-        {
-            if (m_latch != nullptr)
-                m_latch->set();
-        }
-    }
-
-    std::int64_t ValueAdditionEventHandler::count() const
-    {
-        return m_count;
-    }
-
-    std::int64_t ValueAdditionEventHandler::value() const
-    {
-        return m_value.value;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/ValueAdditionEventHandler.h ./Disruptor.PerfTests/ValueAdditionEventHandler.h
--- ../Disruptor-cpp/Disruptor.PerfTests/ValueAdditionEventHandler.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/ValueAdditionEventHandler.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,36 +0,0 @@
-#pragma once
-
-#include <memory>
-
-#include "Disruptor/IEventHandler.h"
-
-#include "Disruptor.TestTools/ManualResetEvent.h"
-
-#include "Disruptor.PerfTests/PaddedLong.h"
-#include "Disruptor.PerfTests/ValueEvent.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class ValueAdditionEventHandler : public IEventHandler< ValueEvent >
-    {
-    public:
-        void reset(const std::shared_ptr< Tests::ManualResetEvent >& latch, std::int64_t expectedCount);
-
-        void onEvent(ValueEvent& value, std::int64_t sequence, bool /*endOfBatch*/) override;
-
-        std::int64_t count() const;
-
-        std::int64_t value() const;
-
-    private:
-        PaddedLong m_value;
-        std::int64_t m_count = 0;
-        std::shared_ptr< Tests::ManualResetEvent > m_latch;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/ValueEvent.cpp ./Disruptor.PerfTests/ValueEvent.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/ValueEvent.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/ValueEvent.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,17 +0,0 @@
-#include "stdafx.h"
-#include "ValueEvent.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    const std::function< ValueEvent() >& ValueEvent::eventFactory()
-    {
-        static std::function< ValueEvent() > result([] { return ValueEvent(); });
-        return result;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/ValueEvent.h ./Disruptor.PerfTests/ValueEvent.h
--- ../Disruptor-cpp/Disruptor.PerfTests/ValueEvent.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/ValueEvent.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,20 +0,0 @@
-#pragma once
-
-#include <cstdint>
-#include <functional>
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class ValueEvent
-    {
-    public:
-        static const std::function< ValueEvent() >& eventFactory();
-
-        std::int64_t value;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/ValueMutationEventHandler.cpp ./Disruptor.PerfTests/ValueMutationEventHandler.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/ValueMutationEventHandler.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/ValueMutationEventHandler.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,38 +0,0 @@
-#include "stdafx.h"
-#include "ValueMutationEventHandler.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    ValueMutationEventHandler::ValueMutationEventHandler(Operation operation)
-        : m_operation(operation)
-    {
-    }
-
-    std::int64_t ValueMutationEventHandler::value() const
-    {
-        return m_value.value;
-    }
-
-    void ValueMutationEventHandler::reset(const std::shared_ptr< boost::barrier >& latch, std::int64_t expectedCount)
-    {
-        m_value.value = 0L;
-        m_latch = latch;
-        m_iterations = expectedCount;
-    }
-
-    void ValueMutationEventHandler::onEvent(ValueEvent& data, std::int64_t sequence, bool /*endOfBatch*/)
-    {
-        m_value.value = OperationExtensions::Op(m_operation, m_value.value, data.value);
-
-        if (sequence == m_iterations)
-        {
-            m_latch->wait();
-        }
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/ValueMutationEventHandler.h ./Disruptor.PerfTests/ValueMutationEventHandler.h
--- ../Disruptor-cpp/Disruptor.PerfTests/ValueMutationEventHandler.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/ValueMutationEventHandler.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,36 +0,0 @@
-#pragma once
-
-#include <boost/thread/barrier.hpp>
-
-#include "Disruptor/IEventHandler.h"
-
-#include "Disruptor.PerfTests/Operation.h"
-#include "Disruptor.PerfTests/PaddedLong.h"
-#include "Disruptor.PerfTests/ValueEvent.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class ValueMutationEventHandler : public IEventHandler< ValueEvent >
-    {
-    public:
-        explicit ValueMutationEventHandler(Operation operation);
-
-        std::int64_t value() const;
-
-        void reset(const std::shared_ptr< boost::barrier >& latch, std::int64_t expectedCount);
-
-        void onEvent(ValueEvent& data, std::int64_t sequence, bool endOfBatch);
-
-    private:
-        Operation m_operation;
-        PaddedLong m_value;
-        std::int64_t m_iterations = 0;
-        std::shared_ptr< boost::barrier > m_latch;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/main.cpp ./Disruptor.PerfTests/main.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/main.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/main.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,70 +0,0 @@
-#include "stdafx.h"
-
-#include <boost/algorithm/string.hpp>
-
-#include "LatencyTestSession.h"
-#include "TestRepository.h"
-#include "ThroughputTestSession.h"
-
-using namespace Disruptor::PerfTests;
-
-void runAllTests(const TestRepository& testRepository);
-void runOneTest(const TestRepository& testRepository, const std::string& testName);
-
-int main(int, char**)
-{
-    auto& testRepository = TestRepository::instance();
-
-    std::string testName;
-
-    std::cout << "Test name (ALL by default):  " << testName << " ?" << std::endl;
-
-    std::getline(std::cin, testName);
-
-    boost::algorithm::trim(testName);
-
-    if (boost::algorithm::iequals(testName, "ALL") || testName.empty())
-    {
-        runAllTests(testRepository);
-    }
-    else
-    {
-        runOneTest(testRepository, testName);
-    }
-
-    return 0;
-}
-
-void runAllTests(const TestRepository& testRepository)
-{
-    for (auto&& info : testRepository.allLatencyTests())
-    {
-        LatencyTestSession session(info);
-        session.run();
-    }
-
-    for (auto&& info : testRepository.allThrougputTests())
-    {
-        ThroughputTestSession session(info);
-        session.run();
-    }
-}
-
-void runOneTest(const TestRepository& testRepository, const std::string& testName)
-{
-    LatencyTestInfo latencyTestInfo;
-    if (testRepository.tryGetLatencyTest(testName, latencyTestInfo))
-    {
-        LatencyTestSession session(latencyTestInfo);
-        session.run();
-    }
-    else
-    {
-        ThroughputTestInfo throughputTestInfo;
-        if (testRepository.tryGetThroughputTest(testName, throughputTestInfo))
-        {
-            ThroughputTestSession session(throughputTestInfo);
-            session.run();
-        }
-    }
-}
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/stdafx.cpp ./Disruptor.PerfTests/stdafx.cpp
--- ../Disruptor-cpp/Disruptor.PerfTests/stdafx.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/stdafx.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,8 +0,0 @@
-// stdafx.cpp : source file that includes just the standard includes
-// disruptorLibTests.pch will be the pre-compiled header
-// stdafx.obj will contain the pre-compiled type information
-
-#include "stdafx.h"
-
-// TODO: reference any additional headers you need in STDAFX.H
-// and not in this file
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/stdafx.h ./Disruptor.PerfTests/stdafx.h
--- ../Disruptor-cpp/Disruptor.PerfTests/stdafx.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/stdafx.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,45 +0,0 @@
-// stdafx.h : include file for standard system include files,
-// or project specific include files that are used frequently, but
-// are changed infrequently
-//
-
-#pragma once
-
-#include <boost/config.hpp>
-
-#if _MSC_VER // only on Windows
-
-# ifndef WIN32_LEAN_AND_MEAN
-#  define WIN32_LEAN_AND_MEAN    // Exclude rarely-used stuff from Windows headers
-# endif
-
-# pragma warning(disable: 4512) // Assignment operator could not be generated
-
-# include "targetver.h"
-# include <tchar.h>
-# include <winsock2.h>
-# include <Windows.h>
-#endif
-
-// STL includes
-#include <algorithm>
-#include <chrono>
-#include <cstdint>
-#include <deque>
-#include <exception>
-#include <functional>
-#include <future>
-#include <iostream>
-#include <limits>
-#include <list>
-#include <map>
-#include <memory>
-#include <queue>
-#include <set>
-#include <stdexcept>
-#include <string>
-#include <thread>
-#include <unordered_set>
-#include <unordered_map>
-#include <thread>
-#include <vector>
\ No newline at end of file
diff -Naru -x .git ../Disruptor-cpp/Disruptor.PerfTests/targetver.h ./Disruptor.PerfTests/targetver.h
--- ../Disruptor-cpp/Disruptor.PerfTests/targetver.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.PerfTests/targetver.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,8 +0,0 @@
-#pragma once
-
-// Including SDKDDKVer.h defines the highest available Windows platform.
-
-// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
-// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.
-
-#include <SDKDDKVer.h>
diff -Naru -x .git ../Disruptor-cpp/Disruptor.TestTools/CMakeLists.txt ./Disruptor.TestTools/CMakeLists.txt
--- ../Disruptor-cpp/Disruptor.TestTools/CMakeLists.txt	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.TestTools/CMakeLists.txt	1969-12-31 19:00:00.000000000 -0500
@@ -1,24 +0,0 @@
-project(Disruptor.TestTools)
-cmake_minimum_required(VERSION 2.6)
-
-
-find_package(Boost COMPONENTS system)
-if(Boost_FOUND)
-    include_directories(${Boost_INCLUDE_DIRS})
-    link_directories(${Boost_LIBRARY_DIRS})
-endif()
-
-include_directories("..")
-
-
-set(DisruptorTestTools_sources
-
-    CountdownEvent.cpp
-    ManualResetEvent.cpp
-    ResetEvent.cpp
-    ScopeExitFunctor.cpp
-    Stopwatch.cpp
-    LatencyRecorder.cpp
-)
-
-add_library(Disruptor.TestTools STATIC ${DisruptorTestTools_sources})
diff -Naru -x .git ../Disruptor-cpp/Disruptor.TestTools/CountdownEvent.cpp ./Disruptor.TestTools/CountdownEvent.cpp
--- ../Disruptor-cpp/Disruptor.TestTools/CountdownEvent.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.TestTools/CountdownEvent.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,57 +0,0 @@
-#include "stdafx.h"
-#include "CountdownEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    CountdownEvent::CountdownEvent(std::uint32_t initialCount)
-        : ResetEvent(initialCount == 0)
-        , m_initialCount(initialCount)
-        , m_currentCount(initialCount)
-    {}
-
-    std::uint32_t CountdownEvent::initialCount() const
-    {
-        return m_initialCount;
-    }
-
-    std::uint32_t CountdownEvent::currentCount() const
-    {
-        return m_currentCount;
-    }
-
-    void CountdownEvent::reset()
-    {
-        m_currentCount = initialCount();
-        ResetEvent::reset();
-    }
-
-    void CountdownEvent::reset(std::uint32_t initialCount)
-    {
-        m_initialCount = initialCount;
-        reset();
-    }
-
-    bool CountdownEvent::wait(ClockConfig::Duration timeDuration)
-    {
-        while (currentCount() != 0)
-        {
-            ResetEvent::reset();
-            ResetEvent::wait(timeDuration);
-        }
-
-        return true;
-    }
-
-    void CountdownEvent::signal()
-    {
-        --m_currentCount;
-        if (currentCount() == 0)
-            set();
-    }
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.TestTools/CountdownEvent.h ./Disruptor.TestTools/CountdownEvent.h
--- ../Disruptor-cpp/Disruptor.TestTools/CountdownEvent.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.TestTools/CountdownEvent.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,35 +0,0 @@
-#pragma once
-
-#include <atomic>
-
-#include "Disruptor/ClockConfig.h"
-#include "Disruptor.TestTools/ResetEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    class CountdownEvent : public ResetEvent
-    {
-    public:
-        explicit CountdownEvent(std::uint32_t initialCount);
-
-        std::uint32_t initialCount() const;
-        std::uint32_t currentCount() const;
-
-        void signal();
-
-        void reset() override;
-        void reset(std::uint32_t initialCount);
-
-        bool wait(ClockConfig::Duration timeDuration = ClockConfig::Duration()) override;
-
-    private:
-        mutable std::atomic< std::uint32_t > m_initialCount;
-        mutable std::atomic< std::uint32_t > m_currentCount;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.TestTools/DurationHumanizer.h ./Disruptor.TestTools/DurationHumanizer.h
--- ../Disruptor-cpp/Disruptor.TestTools/DurationHumanizer.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.TestTools/DurationHumanizer.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,92 +0,0 @@
-#pragma once
-
-#include <string>
-
-#include "DurationUnit.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    struct HumanDuration
-    {
-        double value;
-        DurationUnits::DurationUnit unit;
-        std::string unitName;
-        std::string shortUnitName;
-    };
-
-
-    class DurationHumanizer
-    {
-    public:
-        template <class TDuration>
-        static HumanDuration deduceHumanDuration(const TDuration& duration)
-        {
-            if (isReadable< std::chrono::nanoseconds >(duration))
-                return createHumanDuration< std::chrono::nanoseconds >(duration);
-
-            if (isReadable< std::chrono::microseconds >(duration))
-                return createHumanDuration< std::chrono::microseconds >(duration);
-
-            if (isReadable< std::chrono::milliseconds >(duration))
-                return createHumanDuration< std::chrono::milliseconds >(duration);
-
-            if (isReadable< std::chrono::seconds >(duration))
-                return createHumanDuration< std::chrono::seconds >(duration);
-
-            if (isReadable< std::chrono::minutes >(duration))
-                return createHumanDuration< std::chrono::minutes >(duration);
-
-            return createHumanDuration< std::chrono::hours >(duration);
-        }
-
-        template <class TClosestDuration, class TDuration>
-        static HumanDuration createHumanDuration(const TDuration& duration)
-        {
-            using FloatingPointDuration = std::chrono::duration< float, typename TClosestDuration::period >;
-            auto count = FloatingPointDuration(duration).count();
-
-            HumanDuration result;
-            result.value = static_cast< double >(count);
-            result.unit = DurationToUnit< TClosestDuration >::value;
-            result.unitName = DurationUnitInfo< DurationToUnit< TClosestDuration >::value >::name();
-            result.shortUnitName = DurationUnitInfo< DurationToUnit< TClosestDuration >::value >::shortName();
-
-            return result;
-        }
-
-        template <class TDuration>
-        static HumanDuration createHumanDurationWithUnit(const TDuration& duration, DurationUnits::DurationUnit durationUnit)
-        {
-            switch (durationUnit)
-            {
-            case DurationUnits::Nanoseconds:
-                return createHumanDuration< std::chrono::nanoseconds, TDuration >(duration);
-            case DurationUnits::Microseconds:
-                return createHumanDuration< std::chrono::microseconds, TDuration >(duration);
-            case DurationUnits::Milliseconds:
-                return createHumanDuration< std::chrono::milliseconds, TDuration >(duration);
-            case DurationUnits::Seconds:
-                return createHumanDuration< std::chrono::seconds, TDuration >(duration);
-            case DurationUnits::Minutes:
-                return createHumanDuration< std::chrono::minutes, TDuration >(duration);
-            case DurationUnits::Hours:
-                return createHumanDuration< std::chrono::hours, TDuration >(duration);
-            default:;
-                throw std::exception();
-            }
-        }
-
-    private:
-        template <class TClosestDuration, class TDuration>
-        static bool isReadable(const TDuration& duration)
-        {
-            return std::chrono::duration_cast< TClosestDuration >(duration).count() < 1000;
-        }
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.TestTools/DurationUnit.h ./Disruptor.TestTools/DurationUnit.h
--- ../Disruptor-cpp/Disruptor.TestTools/DurationUnit.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.TestTools/DurationUnit.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,100 +0,0 @@
-#pragma once
-
-#include <chrono>
-#include <string>
-#include <type_traits>
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    namespace DurationUnits
-    {
-        enum DurationUnit
-        {
-            Nanoseconds,
-            Microseconds,
-            Milliseconds,
-            Seconds,
-            Minutes,
-            Hours,
-        };
-    }
-
-    template <DurationUnits::DurationUnit>
-    struct DurationUnitInfo;
-
-    template <>
-    struct DurationUnitInfo< DurationUnits::Nanoseconds >
-    {
-        static std::string name() { return "nanoseconds"; }
-        static std::string shortName() { return "ns"; }
-    };
-
-    template <>
-    struct DurationUnitInfo< DurationUnits::Microseconds >
-    {
-        static std::string name() { return "microseconds"; }
-        static std::string shortName() { return "us"; }
-    };
-
-    template <>
-    struct DurationUnitInfo< DurationUnits::Milliseconds >
-    {
-        static std::string name() { return "milliseconds"; }
-        static std::string shortName() { return "ms"; }
-    };
-
-    template <>
-    struct DurationUnitInfo< DurationUnits::Seconds >
-    {
-        static std::string name() { return "seconds"; }
-        static std::string shortName() { return "s"; }
-    };
-
-    template <>
-    struct DurationUnitInfo< DurationUnits::Minutes >
-    {
-        static std::string name() { return "minutes"; }
-        static std::string shortName() { return "m"; }
-    };
-
-    template <>
-    struct DurationUnitInfo< DurationUnits::Hours >
-    {
-        static std::string name() { return "hours"; }
-        static std::string shortName() { return "h"; }
-    };
-
-
-    template <class TDuration>
-    struct DurationToUnit;
-
-    template <>
-    struct DurationToUnit< std::chrono::nanoseconds > : std::integral_constant< DurationUnits::DurationUnit, DurationUnits::Nanoseconds >
-    {};
-
-    template <>
-    struct DurationToUnit< std::chrono::microseconds > : std::integral_constant< DurationUnits::DurationUnit, DurationUnits::Microseconds >
-    {};
-
-    template <>
-    struct DurationToUnit< std::chrono::milliseconds > : std::integral_constant< DurationUnits::DurationUnit, DurationUnits::Milliseconds >
-    {};
-
-    template <>
-    struct DurationToUnit< std::chrono::seconds > : std::integral_constant< DurationUnits::DurationUnit, DurationUnits::Seconds >
-    {};
-
-    template <>
-    struct DurationToUnit< std::chrono::minutes > : std::integral_constant< DurationUnits::DurationUnit, DurationUnits::Minutes >
-    {};
-
-    template <>
-    struct DurationToUnit< std::chrono::hours > : std::integral_constant< DurationUnits::DurationUnit, DurationUnits::Hours >
-    {};
-    
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.TestTools/HumanNumberFacet.h ./Disruptor.TestTools/HumanNumberFacet.h
--- ../Disruptor-cpp/Disruptor.TestTools/HumanNumberFacet.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.TestTools/HumanNumberFacet.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,25 +0,0 @@
-#pragma once
-
-#include <locale>
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    struct HumanNumberFacet : std::numpunct< char >
-    {
-        char do_thousands_sep() const override
-        {
-            return ' ';
-        }
-
-        std::string do_grouping() const override
-        {
-            return "\3";
-        }
-    };
-    
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.TestTools/LatencyRecorder.cpp ./Disruptor.TestTools/LatencyRecorder.cpp
--- ../Disruptor-cpp/Disruptor.TestTools/LatencyRecorder.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.TestTools/LatencyRecorder.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,58 +0,0 @@
-#include "stdafx.h"
-#include "LatencyRecorder.h"
-
-#include "Disruptor.TestTools/DurationHumanizer.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    struct DurationPrinter
-    {
-        explicit DurationPrinter(std::int64_t nanoseconds)
-            : value(nanoseconds)
-        {
-        }
-
-        std::int64_t value;
-    };
-
-    std::ostream& operator<<(std::ostream& stream, const DurationPrinter& printer)
-    {
-        auto humanDuration = Tests::DurationHumanizer::deduceHumanDuration(std::chrono::nanoseconds(printer.value));
-
-        return stream << humanDuration.value << " " << humanDuration.shortUnitName;
-    }
-
-
-    LatencyRecorder::LatencyRecorder(std::int64_t sampleSize)
-        : m_accumulator(boost::accumulators::tag::tail< boost::accumulators::right >::cache_size = sampleSize)
-    {
-    }
-
-    void LatencyRecorder::record(std::int64_t value)
-    {
-        m_accumulator(value);
-    }
-
-    void LatencyRecorder::writeReport(std::ostream& stream) const
-    {
-        stream
-            << "min: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::min(m_accumulator)))
-            << ", mean: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::mean(m_accumulator)))
-            << ", max: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::max(m_accumulator)))
-            << ", Q99.99: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::quantile(m_accumulator, boost::accumulators::quantile_probability = 0.9999)))
-            << ", Q99.9: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::quantile(m_accumulator, boost::accumulators::quantile_probability = 0.999)))
-            << ", Q99: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::quantile(m_accumulator, boost::accumulators::quantile_probability = 0.99)))
-            << ", Q98: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::quantile(m_accumulator, boost::accumulators::quantile_probability = 0.98)))
-            << ", Q95: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::quantile(m_accumulator, boost::accumulators::quantile_probability = 0.95)))
-            << ", Q93: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::quantile(m_accumulator, boost::accumulators::quantile_probability = 0.93)))
-            << ", Q90: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::quantile(m_accumulator, boost::accumulators::quantile_probability = 0.90)))
-            << ", Q50: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::quantile(m_accumulator, boost::accumulators::quantile_probability = 0.50)))
-            ;
-    }
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.TestTools/LatencyRecorder.h ./Disruptor.TestTools/LatencyRecorder.h
--- ../Disruptor-cpp/Disruptor.TestTools/LatencyRecorder.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.TestTools/LatencyRecorder.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,48 +0,0 @@
-#pragma once
-
-#include <cstdint>
-
-#include "Disruptor/Pragmas.h"
-
-DISRUPTOR_PRAGMA_PUSH
-DISRUPTOR_PRAGMA_IGNORE_ALL
-DISRUPTOR_PRAGMA_IGNORE_UNREACHABLE_CODE
-DISRUPTOR_PRAGMA_IGNORE_DEPRECATED_DECLARATIONS
-#include <boost/accumulators/accumulators.hpp>
-#include <boost/accumulators/statistics.hpp>
-DISRUPTOR_PRAGMA_POP
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    class LatencyRecorder
-    {
-        using Accumulator = boost::accumulators::accumulator_set
-        <
-            double,
-            boost::accumulators::stats
-            <
-                boost::accumulators::tag::mean,
-                boost::accumulators::tag::max,
-                boost::accumulators::tag::min,
-                boost::accumulators::tag::variance,
-                boost::accumulators::tag::tail_quantile< boost::accumulators::right >
-            >
-        >;
-
-    public:
-        explicit LatencyRecorder(std::int64_t sampleSize);
-        
-        void record(std::int64_t value);
-
-        void writeReport(std::ostream& stream) const;
-
-    private:
-        Accumulator m_accumulator;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.TestTools/ManualResetEvent.cpp ./Disruptor.TestTools/ManualResetEvent.cpp
--- ../Disruptor-cpp/Disruptor.TestTools/ManualResetEvent.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.TestTools/ManualResetEvent.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,41 +0,0 @@
-#include "stdafx.h"
-#include "ManualResetEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    ManualResetEvent::ManualResetEvent(bool signaled)
-        : ResetEvent(signaled)
-    {
-    }
-
-    void ManualResetEvent::set(bool ensureWaitIsTriggered)
-    {
-        ResetEvent::set(ensureWaitIsTriggered);
-    }
-
-    void ManualResetEvent::reset()
-    {
-        ResetEvent::reset();
-    }
-
-    bool ManualResetEvent::isSet() const
-    {
-        return ResetEvent::isSet();
-    }
-
-    bool ManualResetEvent::waitOne()
-    {
-        return wait(std::chrono::hours());
-    }
-
-    bool ManualResetEvent::wait(ClockConfig::Duration timeDuration)
-    {
-        return ResetEvent::wait(timeDuration);
-    }
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.TestTools/ManualResetEvent.h ./Disruptor.TestTools/ManualResetEvent.h
--- ../Disruptor-cpp/Disruptor.TestTools/ManualResetEvent.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.TestTools/ManualResetEvent.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,28 +0,0 @@
-#pragma once
-
-#include "Disruptor/ClockConfig.h"
-
-#include "Disruptor.TestTools/ResetEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    class ManualResetEvent : public ResetEvent
-    {
-    public:
-        explicit ManualResetEvent(bool signaled = false);
-
-        bool isSet() const override;
-
-        void set(bool ensureWaitIsTriggered = false) override;
-        void reset() override;
-
-        bool waitOne();
-        bool wait(ClockConfig::Duration timeDuration) override;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.TestTools/ResetEvent.cpp ./Disruptor.TestTools/ResetEvent.cpp
--- ../Disruptor-cpp/Disruptor.TestTools/ResetEvent.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.TestTools/ResetEvent.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,79 +0,0 @@
-#include "stdafx.h"
-#include "ResetEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    ResetEvent::ResetEvent(bool signaled)
-        : m_signaled(signaled)
-        , m_mutex()
-        , m_conditionVariable()
-        , m_waitCount(0)
-    {
-    }
-
-    void ResetEvent::set(bool ensureWaitIsTriggered)
-    {
-        {
-            std::unique_lock< decltype(m_mutex) > lock(m_mutex);
-            m_signaled = true;
-        }
-        m_conditionVariable.notify_all();
-
-        while (ensureWaitIsTriggered && m_waitCount > 0)
-            std::this_thread::yield();
-    }
-
-    void ResetEvent::reset()
-    {
-        std::unique_lock< decltype(m_mutex) > lock(m_mutex);
-        m_signaled = false;
-    }
-
-    bool ResetEvent::internalWait(ClockConfig::Duration timeDuration)
-    {
-        std::unique_lock< decltype(m_mutex) > lock(m_mutex);
-
-        auto hasReceivedSignal = false;
-
-        if (!m_signaled)
-        {
-            ++m_waitCount;
-
-            if (timeDuration == ClockConfig::Duration())
-            {
-                do
-                {
-                    m_conditionVariable.wait(lock);
-                }
-                while (!m_signaled);
-
-                hasReceivedSignal = true;
-            }
-            else
-            {
-                hasReceivedSignal = m_conditionVariable.wait_for(lock, timeDuration, [this] { return this->m_signaled; });
-            }
-
-            --m_waitCount;
-        }
-
-        return hasReceivedSignal || m_signaled;
-    }
-
-    bool ResetEvent::wait(ClockConfig::Duration timeDuration)
-    {
-        return internalWait(timeDuration);
-    }
-
-    bool ResetEvent::isSet() const
-    {
-        std::lock_guard< decltype(m_mutex) > lock(m_mutex);
-        return m_signaled;
-    }
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.TestTools/ResetEvent.h ./Disruptor.TestTools/ResetEvent.h
--- ../Disruptor-cpp/Disruptor.TestTools/ResetEvent.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.TestTools/ResetEvent.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,40 +0,0 @@
-#pragma once
-
-#include <mutex>
-#include <condition_variable>
-
-#include "Disruptor/ClockConfig.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    class ResetEvent
-    {
-    public:
-        explicit ResetEvent(bool signaled = false);
-        virtual ~ResetEvent() = default;
-
-        ResetEvent(const ResetEvent&) = delete;
-
-    protected:
-        virtual bool isSet() const;
-
-        virtual void set(bool ensureWaitIsTriggered = false);
-        virtual void reset();
-
-        virtual bool wait(ClockConfig::Duration timeDuration);
-
-    private:
-        bool internalWait(ClockConfig::Duration timeDuration);
-
-        bool m_signaled;
-        mutable std::mutex m_mutex;
-        std::condition_variable m_conditionVariable;
-        int m_waitCount;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.TestTools/ScopeExitFunctor.cpp ./Disruptor.TestTools/ScopeExitFunctor.cpp
--- ../Disruptor-cpp/Disruptor.TestTools/ScopeExitFunctor.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.TestTools/ScopeExitFunctor.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,22 +0,0 @@
-#include "stdafx.h"
-#include "ScopeExitFunctor.h"
-
-
-namespace Disruptor
-{
-namespace TestTools
-{
-
-    ScopeExitFunctor::ScopeExitFunctor(const std::function< void() >& func)
-        : m_func(func)
-    {
-    }
-
-    ScopeExitFunctor::~ScopeExitFunctor()
-    {
-        if (m_func)
-            m_func();
-    }
-
-} // namespace TestTools
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.TestTools/ScopeExitFunctor.h ./Disruptor.TestTools/ScopeExitFunctor.h
--- ../Disruptor-cpp/Disruptor.TestTools/ScopeExitFunctor.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.TestTools/ScopeExitFunctor.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,23 +0,0 @@
-#pragma once
-
-#include <functional>
-
-
-namespace Disruptor
-{
-namespace TestTools
-{
-
-    class ScopeExitFunctor
-    {
-    public:
-        explicit ScopeExitFunctor(const std::function< void() >& func);
-
-        ~ScopeExitFunctor();
-
-    private:
-        std::function< void() > m_func;
-    };
-    
-} // namespace TestTools
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.TestTools/Stopwatch.cpp ./Disruptor.TestTools/Stopwatch.cpp
--- ../Disruptor-cpp/Disruptor.TestTools/Stopwatch.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.TestTools/Stopwatch.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,76 +0,0 @@
-#include "stdafx.h"
-#include "Stopwatch.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    Stopwatch::Stopwatch()
-        : m_isRunning(false)
-    {
-        m_begin = m_end = ClockConfig::Clock::now();
-    }
-
-    ClockConfig::Duration Stopwatch::elapsed() const
-    {
-        if (isRunning())
-            m_end = ClockConfig::Clock::now();
-
-        return m_end - m_begin;
-    }
-
-    bool Stopwatch::isRunning() const
-    {
-        return !!m_isRunning && m_isRunning.get();
-    }
-
-    void Stopwatch::reset()
-    {
-        stop();
-        m_begin = m_end;
-        m_isRunning.reset();
-    }
-
-    ClockConfig::TimePoint Stopwatch::restart()
-    {
-        reset();
-        start();
-
-        return m_begin;
-    }
-
-    void Stopwatch::start()
-    {
-        // Should we resume or start the StopWatch?
-        if (!m_isRunning)
-        {
-            m_isRunning = true;
-            m_begin = ClockConfig::Clock::now();
-        }
-        else
-            m_isRunning = true;
-    }
-
-    Stopwatch Stopwatch::startNew()
-    {
-        Stopwatch stopwatch;
-        stopwatch.start();
-
-        return stopwatch;
-    }
-
-    std::int64_t Stopwatch::getTimestamp()
-    {
-        return static_cast< std::int64_t >(ClockConfig::Clock::now().time_since_epoch().count());
-    }
-
-    void Stopwatch::stop()
-    {
-        m_end = ClockConfig::Clock::now();
-        m_isRunning = false;
-    }
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.TestTools/Stopwatch.h ./Disruptor.TestTools/Stopwatch.h
--- ../Disruptor-cpp/Disruptor.TestTools/Stopwatch.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.TestTools/Stopwatch.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,41 +0,0 @@
-#pragma once
-
-#include <chrono>
-#include <boost/optional.hpp>
-
-#include "Disruptor/ClockConfig.h"
-
-
-namespace Disruptor
-{
-namespace PerfTests
-{
-
-    class Stopwatch
-    {
-    public:
-        Stopwatch();
-
-        ClockConfig::Duration elapsed() const;
-
-        bool isRunning() const;
-
-        static Stopwatch startNew();
-
-        static std::int64_t getTimestamp();
-
-        void start();
-        void stop();
-
-        void reset();
-
-        ClockConfig::TimePoint restart();
-
-    private:
-        boost::optional< bool > m_isRunning;
-        ClockConfig::TimePoint m_begin;
-        mutable ClockConfig::TimePoint m_end;
-    };
-
-} // namespace PerfTests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.TestTools/stdafx.cpp ./Disruptor.TestTools/stdafx.cpp
--- ../Disruptor-cpp/Disruptor.TestTools/stdafx.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.TestTools/stdafx.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,8 +0,0 @@
-// stdafx.cpp : source file that includes just the standard includes
-// disruptorLib.pch will be the pre-compiled header
-// stdafx.obj will contain the pre-compiled type information
-
-#include "stdafx.h"
-
-// TODO: reference any additional headers you need in STDAFX.H
-// and not in this file
diff -Naru -x .git ../Disruptor-cpp/Disruptor.TestTools/stdafx.h ./Disruptor.TestTools/stdafx.h
--- ../Disruptor-cpp/Disruptor.TestTools/stdafx.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.TestTools/stdafx.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,44 +0,0 @@
-// stdafx.h : include file for standard system include files,
-// or project specific include files that are used frequently, but
-// are changed infrequently
-//
-
-#pragma once
-
-#include <boost/config.hpp>
-
-#if _MSC_VER // only on Windows
-
-# ifndef WIN32_LEAN_AND_MEAN
-#  define WIN32_LEAN_AND_MEAN    // Exclude rarely-used stuff from Windows headers
-# endif
-
-# pragma warning(disable: 4512) // Assignment operator could not be generated
-
-# include "targetver.h"
-# include <tchar.h>
-# include <winsock2.h>
-# include <Windows.h>
-#endif
-
-// STL includes
-#include <algorithm>
-#include <chrono>
-#include <cstdint>
-#include <deque>
-#include <exception>
-#include <functional>
-#include <iostream>
-#include <limits>
-#include <list>
-#include <map>
-#include <memory>
-#include <queue>
-#include <set>
-#include <stdexcept>
-#include <string>
-#include <thread>
-#include <unordered_set>
-#include <unordered_map>
-#include <thread>
-#include <vector>
\ No newline at end of file
diff -Naru -x .git ../Disruptor-cpp/Disruptor.TestTools/targetver.h ./Disruptor.TestTools/targetver.h
--- ../Disruptor-cpp/Disruptor.TestTools/targetver.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.TestTools/targetver.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,8 +0,0 @@
-#pragma once
-
-// Including SDKDDKVer.h defines the highest available Windows platform.
-
-// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
-// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.
-
-#include <SDKDDKVer.h>
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/AggregateEventHandlerTests.cpp ./Disruptor.Tests/AggregateEventHandlerTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/AggregateEventHandlerTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/AggregateEventHandlerTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,56 +0,0 @@
-#include "stdafx.h"
-
-#include "Disruptor/AggregateEventHandler.h"
-
-#include "AggregateEventHandlerTestsFixture.h"
-#include "SequencerFixture.h"
-
-
-using namespace Disruptor;
-using namespace Disruptor::Tests;
-
-
-BOOST_AUTO_TEST_SUITE(AggregateEventHandlerTests)
-
-BOOST_FIXTURE_TEST_CASE(ShouldCallOnEventInSequence, AggregateEventHandlerTestsFixture)
-{
-    auto evt = 7;
-    const std::int64_t sequence = 3;
-    const auto endOfBatch = true;
-
-    EXPECT_CALL(*m_eventHandlerMock1, onEvent(evt, sequence, endOfBatch)).Times(1);
-    EXPECT_CALL(*m_eventHandlerMock2, onEvent(evt, sequence, endOfBatch)).Times(1);
-    EXPECT_CALL(*m_eventHandlerMock3, onEvent(evt, sequence, endOfBatch)).Times(1);
-
-    m_aggregateEventHandler->onEvent(evt, sequence, endOfBatch);
-}
-
-BOOST_FIXTURE_TEST_CASE(ShouldCallOnStartInSequence, AggregateEventHandlerTestsFixture)
-{
-    EXPECT_CALL(*m_eventHandlerMock1, onStart()).Times(1);
-    EXPECT_CALL(*m_eventHandlerMock2, onStart()).Times(1);
-    EXPECT_CALL(*m_eventHandlerMock3, onStart()).Times(1);
-
-    m_aggregateEventHandler->onStart();
-}
-
-BOOST_FIXTURE_TEST_CASE(ShouldCallOnShutdownInSequence, AggregateEventHandlerTestsFixture)
-{
-    EXPECT_CALL(*m_eventHandlerMock1, onShutdown()).Times(1);
-    EXPECT_CALL(*m_eventHandlerMock2, onShutdown()).Times(1);
-    EXPECT_CALL(*m_eventHandlerMock3, onShutdown()).Times(1);
-
-    m_aggregateEventHandler->onShutdown();
-}
-
-BOOST_FIXTURE_TEST_CASE(ShouldHandleEmptyListOfEventHandlers, AggregateEventHandlerTestsFixture)
-{
-    auto newAggregateEventHandler = std::make_shared< AggregateEventHandler< std::int32_t > >();
-
-    auto v = 7;
-    BOOST_CHECK_NO_THROW(newAggregateEventHandler->onEvent(v, 0, true));
-    BOOST_CHECK_NO_THROW(newAggregateEventHandler->onStart());
-    BOOST_CHECK_NO_THROW(newAggregateEventHandler->onShutdown());
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/AggregateEventHandlerTestsFixture.cpp ./Disruptor.Tests/AggregateEventHandlerTestsFixture.cpp
--- ../Disruptor-cpp/Disruptor.Tests/AggregateEventHandlerTestsFixture.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/AggregateEventHandlerTestsFixture.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,21 +0,0 @@
-#include "stdafx.h"
-#include "AggregateEventHandlerTestsFixture.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    AggregateEventHandlerTestsFixture::AggregateEventHandlerTestsFixture()
-    {
-        m_eventHandlerMock1 = std::make_shared< testing::NiceMock< LifecycleAwareEventHandlerMock< std::int32_t > > >();
-        m_eventHandlerMock2 = std::make_shared< testing::NiceMock< LifecycleAwareEventHandlerMock< std::int32_t > > >();
-        m_eventHandlerMock3 = std::make_shared< testing::NiceMock< LifecycleAwareEventHandlerMock< std::int32_t > > >();
-
-        std::vector< std::shared_ptr< IEventHandler< std::int32_t > > > v = {m_eventHandlerMock1, m_eventHandlerMock2, m_eventHandlerMock3};
-        m_aggregateEventHandler = std::make_shared< AggregateEventHandler< std::int32_t > >(v);
-    }
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/AggregateEventHandlerTestsFixture.h ./Disruptor.Tests/AggregateEventHandlerTestsFixture.h
--- ../Disruptor-cpp/Disruptor.Tests/AggregateEventHandlerTestsFixture.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/AggregateEventHandlerTestsFixture.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,28 +0,0 @@
-#pragma once
-
-#include <cstdint>
-#include <memory>
-
-#include "Disruptor/AggregateEventHandler.h"
-
-#include "Disruptor.Tests/LifecycleAwareEventHandlerMock.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    struct AggregateEventHandlerTestsFixture
-    {
-        AggregateEventHandlerTestsFixture();
-
-        std::shared_ptr< LifecycleAwareEventHandlerMock< std::int32_t > > m_eventHandlerMock1;
-        std::shared_ptr< LifecycleAwareEventHandlerMock< std::int32_t > > m_eventHandlerMock2;
-        std::shared_ptr< LifecycleAwareEventHandlerMock< std::int32_t > > m_eventHandlerMock3;
-
-        std::shared_ptr< AggregateEventHandler< std::int32_t > > m_aggregateEventHandler;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/AtomicReference.h ./Disruptor.Tests/AtomicReference.h
--- ../Disruptor-cpp/Disruptor.Tests/AtomicReference.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/AtomicReference.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,35 +0,0 @@
-#pragma once
-
-#include <boost/optional.hpp>
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    template <class T>
-    class AtomicReference
-    {
-    public:
-        explicit AtomicReference(const boost::optional< T >& value = boost::none)
-            : m_value(value)
-        {
-        }
-
-        boost::optional< T > read()
-        {
-            return m_value;
-        }
-
-        void write(const boost::optional< T >& value)
-        {
-            m_value = value;
-        }
-
-    private:
-        boost::optional< T > m_value;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/BatchEventProcessorTests.cpp ./Disruptor.Tests/BatchEventProcessorTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/BatchEventProcessorTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/BatchEventProcessorTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,78 +0,0 @@
-#include "stdafx.h"
-
-#include "BatchEventProcessorTestsFixture.h"
-
-
-using namespace Disruptor;
-using namespace Disruptor::Tests;
-
-
-BOOST_AUTO_TEST_SUITE(BatchEventProcessorTests);
-
-BOOST_FIXTURE_TEST_CASE(ShouldThrowExceptionOnSettingNullExceptionHandler, BatchEventProcessorTestsFixture)
-{
-    BOOST_CHECK_THROW(m_batchEventProcessor->setExceptionHandler(nullptr), ArgumentNullException);
-}
-
-BOOST_FIXTURE_TEST_CASE(ShouldCallMethodsInLifecycleOrder, BatchEventProcessorTestsFixture)
-{
-    EXPECT_CALL(*m_batchHandlerMock, onEvent((*m_ringBuffer)[0], 0, true)).WillOnce(testing::Invoke([this](StubEvent&, std::int64_t, bool)
-    {
-        m_countDownEvent.signal();
-    }));
-
-    std::thread thread([this] { m_batchEventProcessor->run(); });
-
-    BOOST_CHECK_EQUAL(-1, m_batchEventProcessor->sequence()->value());
-
-    m_ringBuffer->publish(m_ringBuffer->next());
-
-    BOOST_CHECK_EQUAL(m_countDownEvent.wait(std::chrono::milliseconds(50)), true);
-    m_batchEventProcessor->halt();
-    thread.join();
-}
-
-BOOST_FIXTURE_TEST_CASE(ShouldCallMethodsInLifecycleOrderForBatch, BatchEventProcessorTestsFixture)
-{
-    EXPECT_CALL(*m_batchHandlerMock, onEvent((*m_ringBuffer)[0], 0, false)).Times(1);
-    EXPECT_CALL(*m_batchHandlerMock, onEvent((*m_ringBuffer)[1], 1, false)).Times(1);
-    EXPECT_CALL(*m_batchHandlerMock, onEvent((*m_ringBuffer)[2], 2, true)).WillOnce(testing::Invoke([this](StubEvent&, std::int64_t, bool)
-    {
-        m_countDownEvent.signal();
-    }));
-
-    m_ringBuffer->publish(m_ringBuffer->next());
-    m_ringBuffer->publish(m_ringBuffer->next());
-    m_ringBuffer->publish(m_ringBuffer->next());
-
-    std::thread thread([this] { m_batchEventProcessor->run(); });
-
-    BOOST_CHECK_EQUAL(m_countDownEvent.wait(std::chrono::milliseconds(50)), true);
-    m_batchEventProcessor->halt();
-    thread.join();
-}
-
-BOOST_FIXTURE_TEST_CASE(ShouldCallExceptionHandlerOnUncaughtException, BatchEventProcessorTestsFixture)
-{
-    InvalidOperationException ex("BatchEventProcessorTests.ShouldCallExceptionHandlerOnUncaughtException");
-    m_batchEventProcessor->setExceptionHandler(m_excpetionHandlerMock);
-    
-    EXPECT_CALL(*m_batchHandlerMock, onEvent((*m_ringBuffer)[0], 0, true)).WillRepeatedly(testing::Throw(ex));
-
-    EXPECT_CALL(*m_excpetionHandlerMock, handleEventException(testing::_, 0, (*m_ringBuffer)[0]))
-        .WillRepeatedly(testing::Invoke([&](const std::exception& lException, std::int64_t, StubEvent&)
-        {
-            BOOST_CHECK_EQUAL(lException.what(), ex.what());
-            m_countDownEvent.signal();
-        }));
-
-    std::thread thread([this] { m_batchEventProcessor->run(); });
-
-    m_ringBuffer->publish(m_ringBuffer->next());
-
-    BOOST_CHECK_EQUAL(m_countDownEvent.wait(std::chrono::milliseconds(50)), true);
-    m_batchEventProcessor->halt();
-    thread.join();
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/BatchEventProcessorTestsFixture.cpp ./Disruptor.Tests/BatchEventProcessorTestsFixture.cpp
--- ../Disruptor-cpp/Disruptor.Tests/BatchEventProcessorTestsFixture.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/BatchEventProcessorTestsFixture.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,24 +0,0 @@
-#include "stdafx.h"
-#include "BatchEventProcessorTestsFixture.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    BatchEventProcessorTestsFixture::BatchEventProcessorTestsFixture()
-        : m_countDownEvent(1)
-    {
-        auto eventFactory = []() { return StubEvent(-1); };
-
-        m_ringBuffer = std::make_shared< RingBuffer< StubEvent > >(eventFactory, 16);
-        m_sequenceBarrier = m_ringBuffer->newBarrier();
-
-        m_batchHandlerMock = std::make_shared< testing::NiceMock< BatchHandlerMock< StubEvent > > >();
-        m_excpetionHandlerMock = std::make_shared< testing::NiceMock< ExceptionHandlerMock< StubEvent > > >();
-        m_batchEventProcessor = std::make_shared< BatchEventProcessor< StubEvent > >(m_ringBuffer, m_sequenceBarrier, m_batchHandlerMock);
-    }
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/BatchEventProcessorTestsFixture.h ./Disruptor.Tests/BatchEventProcessorTestsFixture.h
--- ../Disruptor-cpp/Disruptor.Tests/BatchEventProcessorTestsFixture.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/BatchEventProcessorTestsFixture.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,32 +0,0 @@
-#pragma once
-
-#include "Disruptor/BatchEventProcessor.h"
-#include "Disruptor/ISequenceBarrier.h"
-#include "Disruptor/RingBuffer.h"
-
-#include "Disruptor.TestTools/CountdownEvent.h"
-
-#include "Disruptor.Tests/BatchHandlerMock.h"
-#include "Disruptor.Tests/ExceptionHandlerMock.h"
-#include "Disruptor.Tests/StubEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    struct BatchEventProcessorTestsFixture
-    {
-        BatchEventProcessorTestsFixture();
-
-        std::shared_ptr< RingBuffer< StubEvent > > m_ringBuffer;
-        std::shared_ptr< ISequenceBarrier > m_sequenceBarrier;
-        std::shared_ptr< BatchHandlerMock< StubEvent > > m_batchHandlerMock;
-        std::shared_ptr< ExceptionHandlerMock< StubEvent > > m_excpetionHandlerMock;
-        std::shared_ptr< BatchEventProcessor< StubEvent > > m_batchEventProcessor;
-        CountdownEvent m_countDownEvent;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/BatchHandlerMock.h ./Disruptor.Tests/BatchHandlerMock.h
--- ../Disruptor-cpp/Disruptor.Tests/BatchHandlerMock.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/BatchHandlerMock.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,24 +0,0 @@
-#pragma once
-
-#include <cstdint>
-#include <memory>
-
-#include <gmock/gmock.h>
-
-#include "Disruptor/IEventHandler.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    template <class T>
-    class BatchHandlerMock : public IEventHandler< T >
-    {
-    public:
-        MOCK_METHOD3_T(onEvent, void(T& data, std::int64_t sequence, bool endOfBatch));
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/BatchingTests.cpp ./Disruptor.Tests/BatchingTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/BatchingTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/BatchingTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,123 +0,0 @@
-#include "stdafx.h"
-
-#include <boost/mpl/vector.hpp>
-
-#include "Disruptor/Disruptor.h"
-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
-#include "Disruptor/SleepingWaitStrategy.h"
-
-#include "LongEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    class ParallelEventHandler : public IEventHandler< LongEvent >
-    {
-    public:
-        ParallelEventHandler(std::int64_t mask, std::int64_t ordinal)
-            : processed(0)
-        {
-            m_mask = mask;
-            m_ordinal = ordinal;
-        }
-    
-        void onEvent(LongEvent& event, std::int64_t sequence, bool endOfBatch) override
-        {
-            if ((sequence & m_mask) == m_ordinal)
-            {
-                eventCount++;
-                tempValue = event.value;
-            }
-            
-            if (endOfBatch || ++batchCount >= m_batchSize)
-            {
-                publishedValue = tempValue;
-                batchCount = 0;
-            }
-            else
-            {
-                std::this_thread::yield();
-            }
-
-            processed = sequence;
-        }
-
-        std::int64_t eventCount = 0;
-        std::int64_t batchCount = 0;
-        std::int64_t publishedValue = 0;
-        std::int64_t tempValue = 0;
-        std::atomic< std::int64_t > processed;
-
-    private:
-        std::int64_t m_mask = 0;
-        std::int64_t m_ordinal = 0;
-        static const std::int32_t m_batchSize = 10;
-    };
-    
-    class EventTranslator : public IEventTranslator< LongEvent >
-    {
-    public:
-        void translateTo(LongEvent& eventData, std::int64_t sequence) override
-        {
-            eventData.value = sequence;
-        }
-    };
-    
-} // namespace Tests
-} // namespace Disruptor
-
-
-using namespace Disruptor;
-using namespace ::Disruptor::Tests;
-
-
-BOOST_AUTO_TEST_SUITE(BatchingTests)
-
-typedef boost::mpl::vector
-<
-    std::integral_constant< ProducerType, ProducerType::Single >,
-    std::integral_constant< ProducerType, ProducerType::Multi >
->
-ProducerTypes;
-
-BOOST_AUTO_TEST_CASE_TEMPLATE(ShouldBatch, TProducerType, ProducerTypes)
-{
-    auto scheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
-    scheduler->start(std::thread::hardware_concurrency());
-
-    auto d = std::make_shared< disruptor< LongEvent > >([] { return LongEvent(); }, 2048, scheduler, TProducerType::value, std::make_shared< SleepingWaitStrategy >());
-
-    auto handler1 = std::make_shared< ParallelEventHandler >(1, 0);
-    auto handler2 = std::make_shared< ParallelEventHandler >(1, 1);
-
-    d->handleEventsWith({ handler1, handler2 });
-
-    auto buffer = d->start();
-
-    auto translator = std::make_shared< EventTranslator >();
-
-    const std::int32_t eventCount = 10000;
-    for (auto i = 0; i < eventCount; ++i)
-    {
-        buffer->publishEvent(translator);
-    }
-
-    while (handler1->processed != eventCount - 1 ||
-           handler2->processed != eventCount - 1)
-    {
-        std::this_thread::sleep_for(std::chrono::milliseconds(1));
-    }
-
-    BOOST_CHECK_EQUAL(handler1->publishedValue, static_cast< std::int64_t >(eventCount) - 2);
-    BOOST_CHECK_EQUAL(handler1->eventCount, static_cast< std::int64_t >(eventCount) / 2);
-    BOOST_CHECK_EQUAL(handler2->publishedValue, static_cast< std::int64_t >(eventCount) - 1);
-    BOOST_CHECK_EQUAL(handler2->eventCount, static_cast< std::int64_t >(eventCount) / 2);
-
-    d->shutdown();
-    scheduler->stop();
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/BusySpinWaitStrategyTests.cpp ./Disruptor.Tests/BusySpinWaitStrategyTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/BusySpinWaitStrategyTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/BusySpinWaitStrategyTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,18 +0,0 @@
-#include "stdafx.h"
-
-#include "Disruptor/BusySpinWaitStrategy.h"
-#include "WaitStrategyTestUtil.h"
-
-
-using namespace Disruptor;
-using namespace Disruptor::Tests;
-
-
-BOOST_AUTO_TEST_SUITE(BusySpinWaitStrategyTests)
-
-BOOST_AUTO_TEST_CASE(ShouldWaitForValue)
-{
-    assertWaitForWithDelayOf(50, std::make_shared< BusySpinWaitStrategy >());
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/CMakeLists.txt ./Disruptor.Tests/CMakeLists.txt
--- ../Disruptor-cpp/Disruptor.Tests/CMakeLists.txt	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/CMakeLists.txt	1969-12-31 19:00:00.000000000 -0500
@@ -1,66 +0,0 @@
-project(Disruptor.Tests)
-cmake_minimum_required(VERSION 2.6)
-
-find_package(Boost COMPONENTS system chrono thread unit_test_framework)
-if(Boost_FOUND)
-    include_directories(${Boost_INCLUDE_DIRS})
-    link_directories(${Boost_LIBRARY_DIRS})
-endif()
-
-ADD_DEFINITIONS(-DBOOST_TEST_DYN_LINK) 
-
-set(DisruptorTests_sources
-
-    main.cpp
-    
-    AggregateEventHandlerTests.cpp
-    AggregateEventHandlerTestsFixture.cpp
-    BatchEventProcessorTests.cpp
-    BatchEventProcessorTestsFixture.cpp
-    BatchingTests.cpp
-    BusySpinWaitStrategyTests.cpp
-    ConsumerRepositoryTests.cpp
-    ConsumerRepositoryTestsFixture.cpp
-    DelayedEventHandler.cpp
-    DisruptorFixture.cpp
-    DisruptorStressTest.cpp
-    DisruptorTests.cpp
-    DummySequenceBarrier.cpp
-    EventPollerTests.cpp
-    EventPublisherTests.cpp
-    ExceptionThrowingEventHandler.cpp
-    FatalExceptionHandlerTests.cpp
-    FixedSequenceGroupTest.cpp
-    IgnoreExceptionHandlerTests.cpp
-    LifecycleAwareTests.cpp
-    MultiProducerSequencerTests.cpp
-    RingBufferTests.cpp
-    RingBufferTestsFixture.cpp
-    RingBufferWithMocksTest.cpp
-    SequenceBarrierTests.cpp
-    SequenceBarrierTestsFixture.cpp
-    SequenceReportingCallbackTests.cpp
-    SequencerTests.cpp
-    SequenceUpdater.cpp
-    SleepingEventHandler.cpp
-    SleepingWaitStrategyTests.cpp
-    SpinWaitWaitStrategyTests.cpp
-    StubEvent.cpp
-    StubExecutor.cpp
-    StubPublisher.cpp
-    TestWaiter.cpp
-    TestWorkHandler.cpp
-    TimeoutBlockingWaitStrategyTests.cpp
-    UtilTests.cpp
-    WaitStrategyTestUtil.cpp
-    WorkerPoolTests.cpp
-    YieldingWaitStrategyTests.cpp
-)
-
-include_directories("..")
-
-add_executable(Disruptor.Tests ${DisruptorTests_sources})
-target_link_libraries(Disruptor.Tests DisruptorStatic Disruptor.TestTools ${Boost_LIBRARIES} gmock)
-
-add_test(cmake_Disruptor.Tests ${CMAKE_CURRENT_BINARY_DIR}/Disruptor.Tests --result_code=no --report_level=no)
-
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/ConsumerRepositoryTests.cpp ./Disruptor.Tests/ConsumerRepositoryTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/ConsumerRepositoryTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/ConsumerRepositoryTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,78 +0,0 @@
-#include "stdafx.h"
-
-#include "ConsumerRepositoryTestsFixture.h"
-
-
-using namespace Disruptor;
-using namespace Disruptor::Tests;
-
-
-BOOST_AUTO_TEST_SUITE(ConsumerRepositoryTests)
-
-BOOST_FIXTURE_TEST_CASE(ShouldGetBarrierByHandler, ConsumerRepositoryTestsFixture)
-{
-    m_consumerRepository.add(m_eventProcessor1, m_handler1, m_barrier1);
-
-    BOOST_CHECK_EQUAL(m_consumerRepository.getBarrierFor(m_handler1), m_barrier1);
-}
-
-BOOST_FIXTURE_TEST_CASE(ShouldReturnNullForBarrierWhenHandlerIsNotRegistered, ConsumerRepositoryTestsFixture)
-{
-    BOOST_CHECK(m_consumerRepository.getBarrierFor(m_handler1) == nullptr);
-}
-
-BOOST_FIXTURE_TEST_CASE(ShouldGetLastEventProcessorsInChain, ConsumerRepositoryTestsFixture)
-{
-    m_consumerRepository.add(m_eventProcessor1, m_handler1, m_barrier1);
-    m_consumerRepository.add(m_eventProcessor2, m_handler2, m_barrier2);
-
-    m_consumerRepository.unMarkEventProcessorsAsEndOfChain({ m_eventProcessor2->sequence() });
-
-    auto lastEventProcessorsInChain = m_consumerRepository.getLastSequenceInChain(true);
-
-    BOOST_CHECK_EQUAL(lastEventProcessorsInChain.size(), 1u);
-    BOOST_CHECK_EQUAL(lastEventProcessorsInChain[0], m_eventProcessor1->sequence());
-}
-
-BOOST_FIXTURE_TEST_CASE(ShouldRetrieveEventProcessorForHandler, ConsumerRepositoryTestsFixture)
-{
-    m_consumerRepository.add(m_eventProcessor1, m_handler1, m_barrier1);
-
-    BOOST_CHECK(m_consumerRepository.getEventProcessorFor(m_handler1) == m_eventProcessor1);
-}
-
-BOOST_FIXTURE_TEST_CASE(ShouldThrowExceptionWhenHandlerIsNotRegistered, ConsumerRepositoryTestsFixture)
-{
-    BOOST_CHECK_THROW(m_consumerRepository.getEventProcessorFor(std::shared_ptr< SleepingEventHandler >()), Disruptor::ArgumentException);
-}
-
-BOOST_FIXTURE_TEST_CASE(ShouldIterateAllEventProcessors, ConsumerRepositoryTestsFixture)
-{
-    m_consumerRepository.add(m_eventProcessor1, m_handler1, m_barrier1);
-    m_consumerRepository.add(m_eventProcessor2, m_handler2, m_barrier2);
-
-    auto seen1 = false;
-    auto seen2 = false;
-    
-    for (auto&& testEntryEventProcessorInfo : m_consumerRepository)
-    {
-        auto eventProcessorInfo = std::dynamic_pointer_cast< EventProcessorInfo< TestEvent > >(testEntryEventProcessorInfo);
-        if (!seen1 && eventProcessorInfo->eventProcessor() == m_eventProcessor1 && eventProcessorInfo->handler() == m_handler1)
-        {
-            seen1 = true;
-        }
-        else if (!seen2 && eventProcessorInfo->eventProcessor() == m_eventProcessor2 && eventProcessorInfo->handler() == m_handler2)
-        {
-            seen2 = true;
-        }
-        else
-        {
-            BOOST_FAIL("Unexpected eventProcessor info");
-        }
-    }
-
-    BOOST_CHECK_EQUAL(seen1, true);
-    BOOST_CHECK_EQUAL(seen2, true);
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/ConsumerRepositoryTestsFixture.cpp ./Disruptor.Tests/ConsumerRepositoryTestsFixture.cpp
--- ../Disruptor-cpp/Disruptor.Tests/ConsumerRepositoryTestsFixture.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/ConsumerRepositoryTestsFixture.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,28 +0,0 @@
-#include "stdafx.h"
-#include "ConsumerRepositoryTestsFixture.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    ConsumerRepositoryTestsFixture::ConsumerRepositoryTestsFixture()
-        : m_eventProcessor1(std::make_shared< testing::NiceMock< EventProcessorMock > >())
-        , m_eventProcessor2(std::make_shared< testing::NiceMock< EventProcessorMock > >())
-        , m_handler1(std::make_shared< SleepingEventHandler >())
-        , m_handler2(std::make_shared< SleepingEventHandler >())
-        , m_barrier1(std::make_shared< testing::NiceMock< SequenceBarrierMock > >())
-        , m_barrier2(std::make_shared< testing::NiceMock< SequenceBarrierMock > >())
-    {
-        auto sequence1 = std::make_shared< Sequence >();
-        auto sequence2 = std::make_shared< Sequence >();
-
-        ON_CALL(*m_eventProcessor1, sequence()).WillByDefault(testing::Return(sequence1));
-        ON_CALL(*m_eventProcessor1, isRunning()).WillByDefault(testing::Return(true));
-        ON_CALL(*m_eventProcessor2, sequence()).WillByDefault(testing::Return(sequence1));
-        ON_CALL(*m_eventProcessor2, isRunning()).WillByDefault(testing::Return(true));
-    }
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/ConsumerRepositoryTestsFixture.h ./Disruptor.Tests/ConsumerRepositoryTestsFixture.h
--- ../Disruptor-cpp/Disruptor.Tests/ConsumerRepositoryTestsFixture.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/ConsumerRepositoryTestsFixture.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,32 +0,0 @@
-#pragma once
-
-#include <gmock/gmock.h>
-
-#include "Disruptor/ConsumerRepository.h"
-#include "Disruptor/Sequence.h"
-
-#include "Disruptor.Tests/EventProcessorMock.h"
-#include "Disruptor.Tests/SequenceBarrierMock.h"
-#include "Disruptor.Tests/SleepingEventHandler.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    struct ConsumerRepositoryTestsFixture
-    {
-        ConsumerRepositoryTestsFixture();
-
-        std::shared_ptr< EventProcessorMock > m_eventProcessor1;
-        std::shared_ptr< EventProcessorMock > m_eventProcessor2;
-        std::shared_ptr< SleepingEventHandler > m_handler1;
-        std::shared_ptr< SleepingEventHandler > m_handler2;
-        std::shared_ptr< SequenceBarrierMock > m_barrier1;
-        std::shared_ptr< SequenceBarrierMock > m_barrier2;
-        ConsumerRepository< TestEvent > m_consumerRepository;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/DataProviderMock.h ./Disruptor.Tests/DataProviderMock.h
--- ../Disruptor-cpp/Disruptor.Tests/DataProviderMock.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/DataProviderMock.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,29 +0,0 @@
-#pragma once
-
-#include <cstdint>
-#include <memory>
-
-#include <gmock/gmock.h>
-
-#include "Disruptor/IDataProvider.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    template <class T>
-    class DataProviderMock : public IDataProvider< T >
-    {
-    public:
-        MOCK_CONST_METHOD1_T(indexer, T&(std::int64_t sequence));
-
-        T& operator[](std::int64_t sequence) const override
-        {
-            return this->indexer(sequence);
-        }
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/DelayedEventHandler.cpp ./Disruptor.Tests/DelayedEventHandler.cpp
--- ../Disruptor-cpp/Disruptor.Tests/DelayedEventHandler.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/DelayedEventHandler.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,68 +0,0 @@
-#include "stdafx.h"
-#include "DelayedEventHandler.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    DelayedEventHandler::DelayedEventHandler() 
-       : DelayedEventHandler(std::make_shared< boost::barrier >(2))
-    {}
-
-    void DelayedEventHandler::onEvent(TestEvent& /*data*/, std::int64_t /*sequence*/, bool /*endOfBatch*/)
-    {
-        waitForAndSetFlag(0);
-    }
-
-    void DelayedEventHandler::processEvent()
-    {
-        waitForAndSetFlag(1);
-    }
-
-    void DelayedEventHandler::stopWaiting()
-    {
-        m_stopped = true;
-    }
-
-    void DelayedEventHandler::onStart()
-    {
-        try
-        {
-            m_barrier->wait();
-        }
-        catch (std::exception& ex)
-        {
-            throw std::runtime_error(ex.what());
-        }
-    }
-
-    void DelayedEventHandler::onShutdown()
-    {
-    }
-
-    void DelayedEventHandler::awaitStart()
-    {
-        m_barrier->wait();
-    }
-
-    DelayedEventHandler::DelayedEventHandler(const std::shared_ptr< boost::barrier >& barrier)
-        : m_readyToProcessEvent(0)
-        , m_stopped(false)
-        , m_barrier(barrier)
-    {
-    }
-
-    void DelayedEventHandler::waitForAndSetFlag(std::int32_t newValue)
-    {
-        //    while (!_stopped && Thread.CurrentThread.IsAlive && Interlocked.Exchange(ref _readyToProcessEvent, newValue) == newValue)
-        while (!m_stopped && std::atomic_exchange(&m_readyToProcessEvent, newValue) == newValue)
-        {
-            std::this_thread::yield();
-        }
-    }
-
-} // namespace Tests
-} // namespace Disruptor
-
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/DelayedEventHandler.h ./Disruptor.Tests/DelayedEventHandler.h
--- ../Disruptor-cpp/Disruptor.Tests/DelayedEventHandler.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/DelayedEventHandler.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,48 +0,0 @@
-#pragma once
-
-#include <atomic>
-#include <cstdint>
-#include <memory>
-
-#include <boost/thread/barrier.hpp>
-
-#include "Disruptor/IEventHandler.h"
-#include "Disruptor/ILifecycleAware.h"
-
-#include "Disruptor.Tests/TestEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    class DelayedEventHandler : public IEventHandler< TestEvent >, public ILifecycleAware
-    {
-    public:
-        DelayedEventHandler();
-
-        void onEvent(TestEvent& data, std::int64_t sequence, bool endOfBatch) override;
-
-        void processEvent();
-
-        void stopWaiting();
-
-        void onStart() override;
-
-        void onShutdown() override;
-
-        void awaitStart();
-
-    private:
-        explicit DelayedEventHandler(const std::shared_ptr< boost::barrier >& barrier);
-
-        void waitForAndSetFlag(std::int32_t newValue);
-
-        std::atomic< std::int32_t > m_readyToProcessEvent;
-        std::atomic< bool > m_stopped;
-        std::shared_ptr< boost::barrier > m_barrier;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/DisruptorFixture.cpp ./Disruptor.Tests/DisruptorFixture.cpp
--- ../Disruptor-cpp/Disruptor.Tests/DisruptorFixture.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/DisruptorFixture.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,163 +0,0 @@
-#include "stdafx.h"
-#include "DisruptorFixture.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    DisruptorFixture::DisruptorFixture()
-    {
-        m_lastPublishedEvent = nullptr;
-        m_ringBuffer = nullptr;
-        m_delayedEventHandlers.clear();
-        m_testWorkHandlers.clear();
-        m_executor = std::make_shared< StubExecutor >();
-        m_disruptor = std::make_shared< disruptor< TestEvent > >([] { return TestEvent(); }, 4, m_executor);
-    }
-
-    DisruptorFixture::~DisruptorFixture()
-    {
-        for (auto&& delayedEventHandler : m_delayedEventHandlers)
-        {
-            delayedEventHandler->stopWaiting();
-        }
-
-        for (auto&& testWorkHandler : m_testWorkHandlers)
-        {
-            testWorkHandler->stopWaiting();
-        }
-
-        m_disruptor->halt();
-        m_executor->joinAllThreads();
-    }
-
-    DisruptorFixture::TempEventHandler::TempEventHandler(const std::shared_ptr< disruptor< TestEvent > >& disruptor,
-                                                         const std::vector< std::shared_ptr< std::int64_t > >& remainingCapacity)
-        : m_disruptor(disruptor)
-        , m_remainingCapacity(remainingCapacity)
-    {
-    }
-
-    void DisruptorFixture::TempEventHandler::onEvent(TestEvent& /*data*/, std::int64_t /*sequence*/, bool /*endOfBatch*/)
-    {
-        *m_remainingCapacity[0] = m_disruptor->ringBuffer()->getRemainingCapacity();
-    }
-
-    DisruptorFixture::EventProcessorFactory::EventProcessorFactory(const std::shared_ptr< disruptor< TestEvent > >& disruptor,
-                                                                   const std::shared_ptr< IEventHandler< TestEvent > >& eventHandler,
-                                                                   std::int32_t sequenceLength)
-        : m_disruptor(disruptor)
-        , m_eventHandler(eventHandler)
-        , m_sequenceLength(sequenceLength)
-    {
-    }
-
-    std::shared_ptr< IEventProcessor > DisruptorFixture::EventProcessorFactory::createEventProcessor(const std::shared_ptr< RingBuffer< TestEvent > >& ringBuffer,
-                                                                                                     const std::vector< std::shared_ptr< ISequence > >& barrierSequences)
-    {
-        BOOST_CHECK_MESSAGE((size_t)m_sequenceLength == barrierSequences.size(), "Should not have had any barrier sequences");
-        return std::make_shared< BatchEventProcessor< TestEvent > >(m_disruptor->ringBuffer(), ringBuffer->newBarrier(barrierSequences), m_eventHandler);
-    }
-
-    std::shared_ptr< TestWorkHandler > DisruptorFixture::createTestWorkHandler()
-    {
-        auto testWorkHandler = std::make_shared< TestWorkHandler >();
-        m_testWorkHandlers.push_back(testWorkHandler);
-        return testWorkHandler;
-    }
-
-    void DisruptorFixture::ensureTwoEventsProcessedAccordingToDependencies(const std::shared_ptr< CountdownEvent >& countDownLatch,
-                                                                           const std::initializer_list< std::shared_ptr< DelayedEventHandler > >& dependencies)
-    {
-        publishEvent();
-        publishEvent();
-
-        for (auto&& dependency : dependencies)
-        {
-            assertThatCountDownLatchEquals(countDownLatch, 2L);
-            dependency->processEvent();
-            dependency->processEvent();
-        }
-
-        assertThatCountDownLatchIsZero(countDownLatch);
-    }
-
-    void DisruptorFixture::assertProducerReaches(const std::shared_ptr< StubPublisher >& stubPublisher, std::int32_t expectedPublicationCount, bool strict)
-    {
-        auto loopStart = ClockConfig::Clock::now();
-        while (stubPublisher->getPublicationCount() < expectedPublicationCount && ClockConfig::Clock::now() - loopStart < std::chrono::milliseconds(5))
-        {
-            std::this_thread::yield();
-        }
-
-        if (strict)
-        {
-            BOOST_CHECK_EQUAL(stubPublisher->getPublicationCount(), expectedPublicationCount);
-        }
-        else
-        {
-            auto actualPublicationCount = stubPublisher->getPublicationCount();
-            BOOST_CHECK_MESSAGE(actualPublicationCount >= expectedPublicationCount,
-                "Producer reached unexpected count. Expected at least " << expectedPublicationCount << " but only reached " << actualPublicationCount);
-        }
-    }
-
-    DisruptorFixture::EventTranslator::EventTranslator(DisruptorFixture& disruptorTests)
-        : m_disruptorTests(disruptorTests)
-    {
-    }
-
-    void DisruptorFixture::EventTranslator::translateTo(TestEvent& eventData, std::int64_t /*sequence*/)
-    {
-        m_disruptorTests.m_lastPublishedEvent = &eventData;
-    }
-
-    TestEvent& DisruptorFixture::publishEvent()
-    {
-        if (m_ringBuffer == nullptr)
-        {
-            m_ringBuffer = m_disruptor->start();
-
-            for (auto&& eventHandler : m_delayedEventHandlers)
-            {
-                eventHandler->awaitStart();
-            }
-        }
-
-        m_disruptor->publishEvent(std::make_shared< EventTranslator >(*this));
-
-        return *m_lastPublishedEvent;
-    }
-
-    std::exception DisruptorFixture::waitFor(const std::shared_ptr< AtomicReference< std::exception > >& reference)
-    {
-        while (!reference->read())
-        {
-            std::this_thread::yield();
-        }
-
-        return reference->read().get();
-    }
-
-    std::shared_ptr< DelayedEventHandler > DisruptorFixture::createDelayedEventHandler()
-    {
-        auto delayedEventHandler = std::make_shared< DelayedEventHandler >();
-        m_delayedEventHandlers.push_back(delayedEventHandler);
-        return delayedEventHandler;
-    }
-
-    void DisruptorFixture::assertThatCountDownLatchEquals(const std::shared_ptr< CountdownEvent >& countDownLatch, std::int64_t expectedCountDownValue) const
-    {
-        BOOST_CHECK_EQUAL(countDownLatch->currentCount(), expectedCountDownValue);
-    }
-
-    void DisruptorFixture::assertThatCountDownLatchIsZero(const std::shared_ptr< CountdownEvent >& countDownLatch) const
-    {
-        auto released = countDownLatch->wait(std::chrono::seconds(m_timeoutInSeconds));
-        BOOST_CHECK_MESSAGE(released == true, "Batch handler did not receive entries: " << countDownLatch->currentCount());
-    }
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/DisruptorFixture.h ./Disruptor.Tests/DisruptorFixture.h
--- ../Disruptor-cpp/Disruptor.Tests/DisruptorFixture.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/DisruptorFixture.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,102 +0,0 @@
-#pragma once
-
-#include <cstdint>
-#include <memory>
-#include <vector>
-
-#include "Disruptor/ClockConfig.h"
-#include "Disruptor/Disruptor.h"
-
-#include "Disruptor.TestTools/CountdownEvent.h"
-
-#include "Disruptor.Tests/AtomicReference.h"
-#include "Disruptor.Tests/DelayedEventHandler.h"
-#include "Disruptor.Tests/StubExecutor.h"
-#include "Disruptor.Tests/StubPublisher.h"
-#include "Disruptor.Tests/TestEvent.h"
-#include "Disruptor.Tests/TestWorkHandler.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    struct DisruptorFixture
-    {
-        class EventProcessorFactory;
-        class EventTranslator;
-        class TempEventHandler;
-
-        DisruptorFixture();
-        ~DisruptorFixture();
-
-        std::shared_ptr< TestWorkHandler > createTestWorkHandler();
-
-        void ensureTwoEventsProcessedAccordingToDependencies(const std::shared_ptr< CountdownEvent >& countDownLatch,
-                                                             const std::initializer_list< std::shared_ptr< DelayedEventHandler > >& dependencies = {});
-
-        static void assertProducerReaches(const std::shared_ptr< StubPublisher >& stubPublisher, std::int32_t expectedPublicationCount, bool strict);
-
-        TestEvent& publishEvent();
-
-        static std::exception waitFor(const std::shared_ptr< AtomicReference< std::exception > >& reference);
-
-        std::shared_ptr< DelayedEventHandler > createDelayedEventHandler();
-
-        void assertThatCountDownLatchEquals(const std::shared_ptr< CountdownEvent >& countDownLatch, std::int64_t expectedCountDownValue) const;
-        void assertThatCountDownLatchIsZero(const std::shared_ptr< CountdownEvent >& countDownLatch) const;
-
-        std::int32_t m_timeoutInSeconds = 2;
-        std::shared_ptr< disruptor< TestEvent > > m_disruptor;
-        std::shared_ptr< StubExecutor > m_executor;
-        std::vector< std::shared_ptr< DelayedEventHandler > > m_delayedEventHandlers;
-        std::vector< std::shared_ptr< TestWorkHandler > > m_testWorkHandlers;
-        std::shared_ptr< RingBuffer< TestEvent > > m_ringBuffer;
-        TestEvent* m_lastPublishedEvent;
-    };
-
-
-    class DisruptorFixture::EventProcessorFactory : public IEventProcessorFactory< TestEvent >
-    {
-    public:
-        EventProcessorFactory(const std::shared_ptr< disruptor< TestEvent > >& disruptor,
-                              const std::shared_ptr< IEventHandler< TestEvent > >& eventHandler,
-                              std::int32_t sequenceLength);
-
-        std::shared_ptr< IEventProcessor > createEventProcessor(const std::shared_ptr< RingBuffer< TestEvent > >& ringBuffer,
-                                                                const std::vector< std::shared_ptr< ISequence > >& barrierSequences) override;
-
-    private:
-        std::shared_ptr< disruptor< TestEvent > > m_disruptor;
-        std::shared_ptr< IEventHandler< TestEvent > > m_eventHandler;
-        std::int32_t m_sequenceLength;
-    };
-
-
-    class DisruptorFixture::EventTranslator : public IEventTranslator< TestEvent >
-    {
-    public:
-        explicit EventTranslator(DisruptorFixture& disruptorTests);
-
-        void translateTo(TestEvent& eventData, std::int64_t sequence) override;
-
-    private:
-        DisruptorFixture& m_disruptorTests;
-    };
-
-
-    class DisruptorFixture::TempEventHandler : public IEventHandler< TestEvent >
-    {
-    public:
-        TempEventHandler(const std::shared_ptr< disruptor< TestEvent > >& disruptor, const std::vector< std::shared_ptr< std::int64_t > >& remainingCapacity);
-
-        void onEvent(TestEvent& data, std::int64_t sequence, bool endOfBatch) override;
-
-    private:
-        std::shared_ptr< disruptor< TestEvent > > m_disruptor;
-        std::vector< std::shared_ptr< std::int64_t > > m_remainingCapacity;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/DisruptorStressTest.cpp ./Disruptor.Tests/DisruptorStressTest.cpp
--- ../Disruptor-cpp/Disruptor.Tests/DisruptorStressTest.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/DisruptorStressTest.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,178 +0,0 @@
-#include "stdafx.h"
-
-#include "Disruptor/BusySpinWaitStrategy.h"
-#include "Disruptor/Disruptor.h"
-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
-
-#include "Disruptor.TestTools/CountdownEvent.h"
-
-
-using namespace Disruptor;
-using namespace ::Disruptor::Tests;
-
-
-BOOST_AUTO_TEST_SUITE(DisruptorStressTest)
-
-struct MyTestEvent
-{
-    std::int64_t sequence;
-    std::int64_t a;
-    std::int64_t b;
-    std::string s;
-};
-
-class TestEventHandler : public IEventHandler< MyTestEvent >
-{
-public:
-    void onEvent(MyTestEvent& event, std::int64_t sequence, bool) override
-    {
-        if (event.sequence != sequence || event.a != sequence + 13 || event.b != sequence - 7)
-        {
-            failureCount++;
-        }
-
-        messagesSeen++;
-    }
-
-    std::int32_t failureCount;
-    std::int32_t messagesSeen;
-};
-
-class Publisher
-{
-public:
-    Publisher(const std::shared_ptr < RingBuffer< MyTestEvent > >& ringBuffer,
-              std::int32_t iterations,
-              const std::shared_ptr< CountdownEvent >& start,
-              const std::shared_ptr< CountdownEvent >& end)
-        : m_ringBuffer(ringBuffer)
-        , m_end(end)
-        , m_start(start)
-        , m_iterations(iterations)
-    {}
-
-    void run()
-    {
-        try
-        {
-            m_start->signal();
-            m_start->wait();
-
-            auto i = m_iterations;
-            while (--i != -1)
-            {
-                auto next = m_ringBuffer->next();
-                auto& testEvent = (*m_ringBuffer)[next];
-                testEvent.sequence = next;
-                testEvent.a = next + 13;
-                testEvent.b = next - 7;
-
-                m_ringBuffer->publish(next);
-            }
-        }
-        catch (...)
-        {
-            failed = true;
-        }
-
-        m_end->signal();
-    }
-
-    bool failed = false;
-
-private:
-    std::shared_ptr< RingBuffer< MyTestEvent > > m_ringBuffer;
-    std::shared_ptr< CountdownEvent > m_end;
-    std::shared_ptr< CountdownEvent > m_start;
-    std::int32_t m_iterations;
-};
-
-std::vector< std::shared_ptr< Publisher > > initialize(size_t size,
-                                                       const std::shared_ptr< RingBuffer< MyTestEvent > >& buffer,
-                                                       int messageCount,
-                                                       const std::shared_ptr< CountdownEvent >& start,
-                                                       const std::shared_ptr< CountdownEvent >& end)
-{
-    std::vector< std::shared_ptr< Publisher > > result;
-
-    for (auto i = 0u; i < size; i++)
-    {
-        result.push_back(std::make_shared< Publisher >(buffer, messageCount, start, end));
-    }
-
-    return result;
-}
-
-std::vector< std::shared_ptr< TestEventHandler > > initialize(const std::shared_ptr< disruptor< MyTestEvent > >& disruptor, size_t size)
-{
-    std::vector< std::shared_ptr< TestEventHandler > > result;
-
-    for (auto i = 0u; i < size; i++)
-    {
-        auto handler = std::make_shared< TestEventHandler >();
-        disruptor->handleEventsWith(handler);
-        result.push_back(handler);
-    }
-
-    return result;
-}
-
-BOOST_AUTO_TEST_CASE(ShouldHandleLotsOfThreads)
-{
-    auto processorsCount = std::thread::hardware_concurrency();
-    processorsCount = std::max(processorsCount / 2, 1u);
-
-    auto scheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
-    scheduler->start(processorsCount);
-
-    auto waitStrategy = std::make_shared< BusySpinWaitStrategy >();
-    auto testDisruptor = std::make_shared< disruptor< MyTestEvent > >([] { return MyTestEvent(); }, 1 << 16, scheduler, ProducerType::Multi, waitStrategy);
-
-    auto ringBuffer = testDisruptor->ringBuffer();
-    testDisruptor->setDefaultExceptionHandler(std::make_shared< FatalExceptionHandler< MyTestEvent > >());
-
-#ifdef _DEBUG
-    const auto iterations = 200000;
-#else
-    const auto iterations = 20000000;
-#endif
-
-    auto publisherCount = processorsCount;
-    auto handlerCount = processorsCount;
-
-    auto end = std::make_shared< CountdownEvent >(publisherCount);
-    auto start = std::make_shared< CountdownEvent >(publisherCount);
-
-    auto handlers = initialize(testDisruptor, handlerCount);
-    auto publishers = initialize(publisherCount, ringBuffer, iterations, start, end);
-
-    testDisruptor->start();
-
-    for (auto&& publisher : publishers)
-    {
-        std::thread([publisher] { publisher->run(); }).detach();
-    }
-
-    end->wait();
-    while (ringBuffer->cursor() < (iterations - 1))
-    {
-        std::this_thread::sleep_for(std::chrono::milliseconds(0)); // LockSupport.parkNanos(1);
-    }
-
-    testDisruptor->shutdown();
-
-    for (auto&& publisher : publishers)
-    {
-        BOOST_CHECK_EQUAL(publisher->failed, false);
-    }
-
-    for (auto&& handler : handlers)
-    {
-        BOOST_CHECK_NE(handler->messagesSeen, 0);
-        BOOST_CHECK_EQUAL(handler->failureCount, 0);
-    }
-
-    scheduler->stop();
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/DisruptorTests.cpp ./Disruptor.Tests/DisruptorTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/DisruptorTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/DisruptorTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,423 +0,0 @@
-#include "stdafx.h"
-
-#include <boost/any.hpp>
-
-#include "Disruptor/Disruptor.h"
-
-#include "Disruptor.TestTools/CountdownEvent.h"
-
-#include "AtomicReference.h"
-#include "DisruptorFixture.h"
-#include "EventHandlerStub.h"
-#include "ExceptionThrowingEventHandler.h"
-#include "SleepingEventHandler.h"
-#include "StubExceptionHandler.h"
-#include "StubPublisher.h"
-
-
-using namespace Disruptor;
-using namespace ::Disruptor::Tests;
-
-
-BOOST_FIXTURE_TEST_SUITE(DisruptorTests, DisruptorFixture)
-
-BOOST_AUTO_TEST_CASE(ShouldCreateEventProcessorGroupForFirstEventProcessors)
-{
-    m_executor->ignoreExecutions();
-    auto eventHandler1 = std::make_shared< SleepingEventHandler >();
-    auto eventHandler2 = std::make_shared< SleepingEventHandler >();
-
-    auto eventHandlerGroup = m_disruptor->handleEventsWith({ eventHandler1, eventHandler2 });
-    m_disruptor->start();
-
-    BOOST_CHECK(eventHandlerGroup != nullptr);
-    BOOST_CHECK_EQUAL(m_executor->getExecutionCount(), 2);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldMakeEntriesAvailableToFirstHandlersImmediately)
-{
-    auto countDownLatch = std::make_shared< CountdownEvent >(2);
-    auto eventHandler = std::make_shared< EventHandlerStub< TestEvent > >(countDownLatch);
-
-    m_disruptor->handleEventsWith({ createDelayedEventHandler(), eventHandler });
-
-    ensureTwoEventsProcessedAccordingToDependencies(countDownLatch);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldWaitUntilAllFirstEventProcessorsProcessEventBeforeMakingItAvailableToDependentEventProcessors)
-{
-    auto eventHandler1 = createDelayedEventHandler();
-
-    auto countDownLatch = std::make_shared< CountdownEvent >(2);
-    auto eventHandler2 = std::make_shared< EventHandlerStub< TestEvent > >(countDownLatch);
-
-    m_disruptor->handleEventsWith(eventHandler1)->then(eventHandler2);
-
-    ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, { eventHandler1 });
-}
-
-BOOST_AUTO_TEST_CASE(ShouldAllowSpecifyingSpecificEventProcessorsToWaitFor)
-{
-    auto handler1 = createDelayedEventHandler();
-    auto handler2 = createDelayedEventHandler();
-
-    auto countDownLatch = std::make_shared< CountdownEvent >(2);
-    auto handlerWithBarrier = std::make_shared< EventHandlerStub< TestEvent > >(countDownLatch);
-
-    m_disruptor->handleEventsWith({ handler1, handler2 });
-    m_disruptor->after({ handler1, handler2 })->handleEventsWith(handlerWithBarrier);
-
-    ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, { handler1, handler2 });
-}
-
-BOOST_AUTO_TEST_CASE(ShouldWaitOnAllProducersJoinedByAnd)
-{
-    auto handler1 = createDelayedEventHandler();
-    auto handler2 = createDelayedEventHandler();
-
-    auto countDownLatch = std::make_shared< CountdownEvent >(2);
-    auto handlerWithBarrier = std::make_shared< EventHandlerStub< TestEvent > >(countDownLatch);
-
-    m_disruptor->handleEventsWith(handler1);
-    auto handler2Group = m_disruptor->handleEventsWith(handler2);
-    m_disruptor->after(handler1)->And(handler2Group)->handleEventsWith(handlerWithBarrier);
-
-    ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, { handler1, handler2 });
-}
-
-BOOST_AUTO_TEST_CASE(ShouldThrowExceptionIfHandlerIsNotAlreadyConsuming)
-{
-    BOOST_CHECK_THROW(m_disruptor->after(createDelayedEventHandler())->handleEventsWith(createDelayedEventHandler()), ArgumentException);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldSupportSpecifyingAExceptionHandlerForEventProcessors)
-{
-    auto eventHandled = std::make_shared< AtomicReference< std::exception > >();
-    auto exceptionHandler = std::make_shared< StubExceptionHandler< TestEvent > >(eventHandled);
-    auto testException = std::exception();
-    auto handler = std::make_shared< ExceptionThrowingEventHandler >(testException);
-
-    m_disruptor->handleExceptionsWith(exceptionHandler);
-    m_disruptor->handleEventsWith(handler);
-
-    publishEvent();
-
-    auto actualException = waitFor(eventHandled);
-    BOOST_CHECK(testException.what() == actualException.what());
-}
-
-BOOST_AUTO_TEST_CASE(ShouldOnlyApplyExceptionsHandlersSpecifiedViaHandleExceptionsWithOnNewEventProcessors)
-{
-    auto eventHandled = std::make_shared< AtomicReference< std::exception > >();
-    auto exceptionHandler = std::make_shared< StubExceptionHandler< TestEvent > >(eventHandled);
-    auto testException = std::exception();
-    auto handler = std::make_shared< ExceptionThrowingEventHandler >(testException);
-
-    m_disruptor->handleExceptionsWith(exceptionHandler);
-    m_disruptor->handleEventsWith(handler);
-    m_disruptor->handleExceptionsWith(std::make_shared< FatalExceptionHandler< TestEvent > >());
-
-    publishEvent();
-
-    auto actualException = waitFor(eventHandled);
-    BOOST_CHECK(testException.what() == actualException.what());
-}
-
-BOOST_AUTO_TEST_CASE(ShouldSupportSpecifyingADefaultExceptionHandlerForEventProcessors)
-{
-    auto eventHandled = std::make_shared< AtomicReference< std::exception > >();
-    auto exceptionHandler = std::make_shared< StubExceptionHandler< TestEvent > >(eventHandled);
-    auto testException = std::exception();
-    auto handler = std::make_shared< ExceptionThrowingEventHandler >(testException);
-
-    m_disruptor->setDefaultExceptionHandler(exceptionHandler);
-    m_disruptor->handleEventsWith(handler);
-
-    publishEvent();
-
-    auto actualException = waitFor(eventHandled);
-    BOOST_CHECK(testException.what() == actualException.what());
-}
-
-BOOST_AUTO_TEST_CASE(ShouldApplyDefaultExceptionHandlerToExistingEventProcessors)
-{
-    auto eventHandled = std::make_shared< AtomicReference< std::exception > >();
-    auto exceptionHandler = std::make_shared< StubExceptionHandler< TestEvent > >(eventHandled);
-    auto testException = std::exception();
-    auto handler = std::make_shared< ExceptionThrowingEventHandler >(testException);
-
-    m_disruptor->handleEventsWith(handler);
-    m_disruptor->setDefaultExceptionHandler(exceptionHandler);
-
-    publishEvent();
-
-    auto actualException = waitFor(eventHandled);
-    BOOST_CHECK(testException.what() == actualException.what());
-}
-
-BOOST_AUTO_TEST_CASE(ShouldBlockProducerUntilAllEventProcessorsHaveAdvanced)
-{
-    auto delayedEventHandler = createDelayedEventHandler();
-    m_disruptor->handleEventsWith(delayedEventHandler);
-
-    auto ringBuffer = m_disruptor->start();
-    delayedEventHandler->awaitStart();
-
-    auto stubPublisher = std::make_shared< StubPublisher >(ringBuffer);
-    try
-    {
-        m_executor->execute([stubPublisher] { stubPublisher->run(); });
-        
-        assertProducerReaches(stubPublisher, 4, true);
-
-        delayedEventHandler->processEvent();
-        delayedEventHandler->processEvent();
-        delayedEventHandler->processEvent();
-        delayedEventHandler->processEvent();
-        delayedEventHandler->processEvent();
-
-        assertProducerReaches(stubPublisher, 5, false);
-    }
-    catch (...)
-    {
-    }
-
-    stubPublisher->halt();
-}
-
-BOOST_AUTO_TEST_CASE(ShouldBeAbleToOverrideTheExceptionHandlerForAEventProcessor)
-{
-    auto testException = std::exception();
-    auto eventHandler = std::make_shared< ExceptionThrowingEventHandler >(testException);
-    m_disruptor->handleEventsWith(eventHandler);
-
-    auto reference = std::make_shared< AtomicReference< std::exception > >();
-    auto exceptionHandler = std::make_shared< StubExceptionHandler< TestEvent > >(reference);
-
-    m_disruptor->handleExceptionsFor(eventHandler)->with(exceptionHandler);
-
-    publishEvent();
-
-    waitFor(reference);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldThrowExceptionWhenAddingEventProcessorsAfterTheProducerBarrierHasBeenCreated)
-{
-    m_executor->ignoreExecutions();
-    m_disruptor->handleEventsWith(std::make_shared< SleepingEventHandler >());
-    m_disruptor->start();
-    BOOST_CHECK_THROW(m_disruptor->handleEventsWith(std::make_shared< SleepingEventHandler >()), InvalidOperationException);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldThrowExceptionIfStartIsCalledTwice)
-{
-    m_executor->ignoreExecutions();
-    m_disruptor->handleEventsWith(std::make_shared< SleepingEventHandler >());
-    m_disruptor->start();
-    BOOST_CHECK_THROW(m_disruptor->start(), InvalidOperationException);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldSupportCustomProcessorsAsDependencies)
-{
-    auto&& ringBuffer = m_disruptor->ringBuffer();
-
-    auto delayedEventHandler = createDelayedEventHandler();
-
-    auto countDownLatch = std::make_shared< CountdownEvent >(2);
-    auto handlerWithBarrier = std::make_shared< EventHandlerStub< TestEvent > >(countDownLatch);
-
-    auto processor = std::make_shared< BatchEventProcessor< TestEvent > >(ringBuffer, ringBuffer->newBarrier(), delayedEventHandler);
-    m_disruptor->handleEventsWith(processor)->then(handlerWithBarrier);
-
-    ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, { delayedEventHandler });
-}
-
-BOOST_AUTO_TEST_CASE(ShouldSupportHandlersAsDependenciesToCustomProcessors)
-{
-    auto delayedEventHandler = createDelayedEventHandler();
-    m_disruptor->handleEventsWith(delayedEventHandler);
-
-    auto ringBuffer = m_disruptor->ringBuffer();
-    auto countDownLatch = std::make_shared< CountdownEvent >(2);
-    auto handlerWithBarrier = std::make_shared< EventHandlerStub< TestEvent > >(countDownLatch);
-
-    auto sequenceBarrier = m_disruptor->after(delayedEventHandler)->asSequenceBarrier();
-    auto processor = std::make_shared< BatchEventProcessor< TestEvent > >(ringBuffer, sequenceBarrier, handlerWithBarrier);
-    m_disruptor->handleEventsWith(processor);
-
-    ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, { delayedEventHandler });
-}
-
-BOOST_AUTO_TEST_CASE(ShouldSupportCustomProcessorsAndHandlersAsDependencies)
-{
-    auto delayedEventHandler1 = createDelayedEventHandler();
-    auto delayedEventHandler2 = createDelayedEventHandler();
-    m_disruptor->handleEventsWith(delayedEventHandler1);
-
-    auto ringBuffer = m_disruptor->ringBuffer();
-    auto countDownLatch = std::make_shared< CountdownEvent >(2);
-    auto handlerWithBarrier = std::make_shared< EventHandlerStub< TestEvent > >(countDownLatch);
-
-    auto sequenceBarrier = m_disruptor->after(delayedEventHandler1)->asSequenceBarrier();
-    auto processor = std::make_shared< BatchEventProcessor< TestEvent > >(ringBuffer, sequenceBarrier, delayedEventHandler2);
-
-    m_disruptor->after(delayedEventHandler1)->And(processor)->handleEventsWith(handlerWithBarrier);
-
-    ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, { delayedEventHandler1, delayedEventHandler2 });
-}
-
-BOOST_AUTO_TEST_CASE(ShouldProvideEventsToWorkHandlers)
-{
-    auto workHandler1 = createTestWorkHandler();
-    auto workHandler2 = createTestWorkHandler();
-    m_disruptor->handleEventsWithWorkerPool({ workHandler1, workHandler2 });
-
-    publishEvent();
-    publishEvent();
-
-    workHandler1->processEvent();
-    workHandler2->processEvent();
-}
-
-BOOST_AUTO_TEST_CASE(ShouldSupportUsingWorkerPoolAsDependency)
-{
-    auto workHandler1 = createTestWorkHandler();
-    auto workHandler2 = createTestWorkHandler();
-    auto delayedEventHandler = createDelayedEventHandler();
-    m_disruptor->handleEventsWithWorkerPool({ workHandler1, workHandler2 })->then(delayedEventHandler);
-
-    publishEvent();
-    publishEvent();
-
-    BOOST_CHECK_EQUAL(m_disruptor->getBarrierFor(delayedEventHandler)->cursor(), -1L);
-
-    workHandler2->processEvent();
-    workHandler1->processEvent();
-
-    delayedEventHandler->processEvent();
-}
-
-BOOST_AUTO_TEST_CASE(ShouldSupportUsingWorkerPoolAsDependencyAndProcessFirstEventAsSoonAsItIsAvailable)
-{
-    auto workHandler1 = createTestWorkHandler();
-    auto workHandler2 = createTestWorkHandler();
-    auto delayedEventHandler = createDelayedEventHandler();
-    m_disruptor->handleEventsWithWorkerPool({ workHandler1, workHandler2 })->then(delayedEventHandler);
-
-    publishEvent();
-    publishEvent();
-
-    workHandler1->processEvent();
-    delayedEventHandler->processEvent();
-
-    workHandler2->processEvent();
-    delayedEventHandler->processEvent();
-}
-
-BOOST_AUTO_TEST_CASE(ShouldSupportUsingWorkerPoolWithADependency)
-{
-    auto workHandler1 = createTestWorkHandler();
-    auto workHandler2 = createTestWorkHandler();
-    auto delayedEventHandler = createDelayedEventHandler();
-    m_disruptor->handleEventsWith(delayedEventHandler)->thenHandleEventsWithWorkerPool({ workHandler1, workHandler2 });
-
-    publishEvent();
-    publishEvent();
-
-    delayedEventHandler->processEvent();
-    delayedEventHandler->processEvent();
-
-    workHandler1->processEvent();
-    workHandler2->processEvent();
-}
-
-BOOST_AUTO_TEST_CASE(ShouldSupportCombiningWorkerPoolWithEventHandlerAsDependencyWhenNotPreviouslyRegistered)
-{
-    auto workHandler1 = createTestWorkHandler();
-    auto delayedEventHandler1 = createDelayedEventHandler();
-    auto delayedEventHandler2 = createDelayedEventHandler();
-    m_disruptor->handleEventsWith(delayedEventHandler1)->And(m_disruptor->handleEventsWithWorkerPool(workHandler1))->then(delayedEventHandler2);
-
-    publishEvent();
-    publishEvent();
-
-    delayedEventHandler1->processEvent();
-    delayedEventHandler1->processEvent();
-
-    workHandler1->processEvent();
-    delayedEventHandler2->processEvent();
-
-    workHandler1->processEvent();
-    delayedEventHandler2->processEvent();
-}
-
-BOOST_AUTO_TEST_CASE(ShouldThrowTimeoutExceptionIfShutdownDoesNotCompleteNormally)
-{
-    auto delayedEventHandler = createDelayedEventHandler();
-    m_disruptor->handleEventsWith(delayedEventHandler);
-    publishEvent();
-
-    BOOST_CHECK_THROW(m_disruptor->shutdown(std::chrono::seconds(1)), TimeoutException);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldTrackRemainingCapacity)
-{
-    std::vector< std::shared_ptr< std::int64_t > > remainingCapacity = { std::make_shared< std::int64_t >(-1) };
-    auto eventHandler = std::make_shared< TempEventHandler >(m_disruptor, remainingCapacity);
-
-    m_disruptor->handleEventsWith(eventHandler);
-
-    publishEvent();
-
-    while (*remainingCapacity[0] == -1)
-    {
-        std::this_thread::sleep_for(std::chrono::milliseconds(100));
-    }
-
-    BOOST_CHECK_EQUAL(*remainingCapacity[0], m_ringBuffer->bufferSize() - 1L);
-    BOOST_CHECK_EQUAL(m_disruptor->ringBuffer()->getRemainingCapacity(), m_ringBuffer->bufferSize() - 0L);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldAllowEventHandlerWithSuperType)
-{
-    auto latch = std::make_shared< CountdownEvent >(2);
-    auto objectHandler = std::make_shared< EventHandlerStub< TestEvent > >(latch);
-
-    m_disruptor->handleEventsWith(objectHandler);
-
-    ensureTwoEventsProcessedAccordingToDependencies(latch);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldAllowChainingEventHandlersWithSuperType)
-{
-    auto latch = std::make_shared< CountdownEvent >(2);
-    auto delayedEventHandler = createDelayedEventHandler();
-    auto objectHandler = std::make_shared< EventHandlerStub< TestEvent > >(latch);
-
-    m_disruptor->handleEventsWith(delayedEventHandler)->then(objectHandler);
-
-    ensureTwoEventsProcessedAccordingToDependencies(latch, { delayedEventHandler });
-}
-
-BOOST_AUTO_TEST_CASE(ShouldMakeEntriesAvailableToFirstCustomProcessorsImmediately)
-{
-    auto countDownLatch = std::make_shared< CountdownEvent >(2);
-    auto eventHandler = std::make_shared< EventHandlerStub< TestEvent > >(countDownLatch);
-
-    m_disruptor->handleEventsWith(std::make_shared< EventProcessorFactory >(m_disruptor, eventHandler, 0));
-
-    ensureTwoEventsProcessedAccordingToDependencies(countDownLatch);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldHonourDependenciesForCustomProcessors)
-{
-    auto countDownLatch = std::make_shared< CountdownEvent >(2);
-    auto eventHandler = std::make_shared< EventHandlerStub< TestEvent > >(countDownLatch);
-    auto delayedEventHandler = createDelayedEventHandler();
-
-    m_disruptor->handleEventsWith(delayedEventHandler)->then(std::make_shared< EventProcessorFactory >(m_disruptor, eventHandler, 1));
-
-    ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, { delayedEventHandler });
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/DummySequenceBarrier.cpp ./Disruptor.Tests/DummySequenceBarrier.cpp
--- ../Disruptor-cpp/Disruptor.Tests/DummySequenceBarrier.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/DummySequenceBarrier.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,38 +0,0 @@
-#include "stdafx.h"
-#include "DummySequenceBarrier.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    std::int64_t DummySequenceBarrier::waitFor(std::int64_t)
-    {
-        return 0;
-    }
-
-    std::int64_t DummySequenceBarrier::cursor()
-    {
-        return 0;
-    }
-
-    bool DummySequenceBarrier::isAlerted()
-    {
-        return false;
-    }
-
-    void DummySequenceBarrier::alert()
-    {
-    }
-
-    void DummySequenceBarrier::clearAlert()
-    {
-    }
-
-    void DummySequenceBarrier::checkAlert()
-    {
-    }
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/DummySequenceBarrier.h ./Disruptor.Tests/DummySequenceBarrier.h
--- ../Disruptor-cpp/Disruptor.Tests/DummySequenceBarrier.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/DummySequenceBarrier.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,26 +0,0 @@
-#pragma once
-
-#include "Disruptor/ISequenceBarrier.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    class DummySequenceBarrier : public ISequenceBarrier
-    {
-    public:
-        std::int64_t waitFor(std::int64_t sequence) override;
-
-        std::int64_t cursor() override;
-
-        bool isAlerted() override;
-        void alert() override;
-
-        void clearAlert() override;
-        void checkAlert() override;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/EventHandlerStub.h ./Disruptor.Tests/EventHandlerStub.h
--- ../Disruptor-cpp/Disruptor.Tests/EventHandlerStub.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/EventHandlerStub.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,34 +0,0 @@
-#pragma once
-
-#include <memory>
-
-#include "Disruptor/IEventHandler.h"
-
-#include "Disruptor.TestTools/CountdownEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-    
-    template <class T>
-    class EventHandlerStub : public IEventHandler< T >
-    {
-    public:
-        explicit EventHandlerStub(const std::shared_ptr< CountdownEvent >& countDownLatch)
-            : m_countDownLatch(countDownLatch)
-        {
-        }
-
-        void onEvent(T& /*data*/, std::int64_t /*sequence*/, bool /*endOfBatch*/) override
-        {
-            m_countDownLatch->signal();
-        }
-
-    private:
-        std::shared_ptr< CountdownEvent > m_countDownLatch;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/EventPollerTests.cpp ./Disruptor.Tests/EventPollerTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/EventPollerTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/EventPollerTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,112 +0,0 @@
-#include "stdafx.h"
-
-#include "Disruptor/ArgumentOutOfRangeException.h"
-#include "Disruptor/BusySpinWaitStrategy.h"
-#include "Disruptor/EventPoller.h"
-#include "Disruptor/Sequence.h"
-#include "Disruptor/SleepingWaitStrategy.h"
-#include "Disruptor/RingBuffer.h"
-
-#include "DataProviderMock.h"
-#include "SequencerMock.h"
-
-
-using namespace Disruptor;
-using namespace Disruptor::Tests;
-
-BOOST_AUTO_TEST_SUITE(EventPollerTests)
-
-BOOST_AUTO_TEST_CASE(ShouldPollForEvents)
-{
-    typedef std::int32_t TestDataType;
-
-    auto pollSequence = std::make_shared< Sequence >();
-    auto bufferSequence = std::make_shared< Sequence >();
-    auto gatingSequence = std::make_shared<  Sequence >();
-
-    auto sequencerMock = std::make_shared< testing::NiceMock< SequencerMock< TestDataType > > >();
-
-    auto handled = false;
-    auto handler = [&](TestDataType&, std::int64_t, bool) -> bool
-    {
-        handled = true;
-        return false;
-    };
-
-    auto providerMock = std::make_shared< testing::NiceMock< DataProviderMock< TestDataType > > >();
-    auto poller = EventPoller< TestDataType >::newInstance(providerMock, sequencerMock, pollSequence, bufferSequence, { gatingSequence });
-    auto event = std::int32_t(42);
-   
-    auto states = PollState::Idle;
-
-    EXPECT_CALL(*sequencerMock, cursor()).WillRepeatedly(testing::Invoke([&]()
-    {
-        switch (states)
-        {
-        case PollState::Processing:
-            return 0L;
-        case PollState::Gating:
-            return 0L;
-        case PollState::Idle:
-            return -1L;
-        default:
-            DISRUPTOR_THROW_ARGUMENT_OUT_OF_RANGE_EXCEPTION(states);
-        }
-    }));
-
-    EXPECT_CALL(*sequencerMock, getHighestPublishedSequence(0L, -1L)).WillRepeatedly(testing::Return(-1L));
-    EXPECT_CALL(*sequencerMock, getHighestPublishedSequence(0L, 0L)).WillRepeatedly(testing::Return(0L));
-
-    EXPECT_CALL(*providerMock, indexer(0)).WillRepeatedly(testing::ReturnRef(event));
-
-    // Initial State - nothing published.
-    states = PollState::Idle;
-    BOOST_CHECK_EQUAL(poller->poll(handler), PollState::Idle);
-
-    // Publish Event.
-    states = PollState::Gating;
-    bufferSequence->incrementAndGet();
-    BOOST_CHECK_EQUAL(poller->poll(handler), PollState::Gating);
-
-    states = PollState::Processing;
-    gatingSequence->incrementAndGet();
-    BOOST_CHECK_EQUAL(poller->poll(handler), PollState::Processing);
-
-    BOOST_CHECK_EQUAL(handled, true);
-}
-
-
-BOOST_AUTO_TEST_CASE(ShouldSuccessfullyPollWhenBufferIsFull)
-{
-    typedef std::int32_t DataType;
-
-    auto handled = 0;
-    auto handler = [&](std::vector< DataType >&, std::int64_t, bool) -> bool
-    {
-        handled++;
-        return true;
-    };
-
-    auto factory = [] { return std::vector< DataType >(1); };
-
-    auto ringBuffer = RingBuffer< std::vector< DataType > >::createMultiProducer(factory, 0x4, std::make_shared< SleepingWaitStrategy >());
-
-    auto poller = ringBuffer->newPoller({});
-    ringBuffer->addGatingSequences({ poller->sequence() });
-
-    const auto count = 4;
-
-    for (auto i = 1; i <= count; ++i)
-    {
-        auto next = ringBuffer->next();
-        (*ringBuffer)[next][0] = i; //sucks
-        ringBuffer->publish(next);
-    }
-
-    // think of another thread
-    poller->poll(handler);
-
-    BOOST_CHECK_EQUAL(handled, 4);
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/EventProcessorMock.h ./Disruptor.Tests/EventProcessorMock.h
--- ../Disruptor-cpp/Disruptor.Tests/EventProcessorMock.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/EventProcessorMock.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,25 +0,0 @@
-#pragma once
-
-#include <gmock/gmock.h>
-
-#include "Disruptor/IEventProcessor.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    class EventProcessorMock : public IEventProcessor
-    {
-    public:
-        MOCK_CONST_METHOD0(sequence, std::shared_ptr< ISequence >());
-
-        MOCK_METHOD0(halt, void());
-        MOCK_METHOD0(run, void());
-
-        MOCK_CONST_METHOD0(isRunning, bool());
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/EventPublisherTests.cpp ./Disruptor.Tests/EventPublisherTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/EventPublisherTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/EventPublisherTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,79 +0,0 @@
-#include "stdafx.h"
-
-#include "Disruptor/NoOpEventProcessor.h"
-#include "Disruptor/RingBuffer.h"
-
-#include "LongEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    struct EventPublisherFixture
-    {
-        struct Translator : public IEventTranslator< LongEvent >
-        {
-            explicit Translator(EventPublisherFixture&)
-            {
-            }
-
-            void translateTo(LongEvent& eventData, std::int64_t sequence) override
-            {
-                eventData.value = sequence + 29;
-            }
-
-        };
-
-        EventPublisherFixture()
-        {
-            m_ringBuffer = RingBuffer< LongEvent >::createMultiProducer([]() { return LongEvent(); }, m_bufferSize);
-            m_translator = std::make_shared< Translator >(*this);
-        }
-
-        const std::int32_t m_bufferSize = 32;
-        const std::int64_t m_valueAdd = 29L;
-        std::shared_ptr< RingBuffer< LongEvent > > m_ringBuffer;
-        std::shared_ptr< Translator > m_translator;
-    };
-
-
-} // namespace Tests
-} // namespace Disruptor
-
-using namespace Disruptor;
-using namespace ::Disruptor::Tests;
-
-
-BOOST_FIXTURE_TEST_SUITE(EventPublisherTests, EventPublisherFixture)
-
-BOOST_AUTO_TEST_CASE(ShouldPublishEvent)
-{
-    m_ringBuffer->addGatingSequences({ std::make_shared< NoOpEventProcessor< LongEvent > >(m_ringBuffer)->sequence() });
-
-    m_ringBuffer->publishEvent(m_translator);
-    m_ringBuffer->publishEvent(m_translator);
-
-    BOOST_CHECK_EQUAL(0L + m_valueAdd, (*m_ringBuffer)[0].value);
-    BOOST_CHECK_EQUAL(1L + m_valueAdd, (*m_ringBuffer)[1].value);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldTryPublishEvent)
-{
-    m_ringBuffer->addGatingSequences({ std::make_shared< Sequence >() });
-
-    for (auto i = 0; i < m_bufferSize; ++i)
-    {
-        BOOST_CHECK_EQUAL(m_ringBuffer->tryPublishEvent(m_translator), true);
-    }
-
-    for (auto i = 0; i < m_bufferSize; ++i)
-    {
-        BOOST_CHECK_EQUAL((*m_ringBuffer)[i].value, i + m_valueAdd);
-    }
-
-    BOOST_CHECK_EQUAL(m_ringBuffer->tryPublishEvent(m_translator), false);
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/ExceptionHandlerMock.h ./Disruptor.Tests/ExceptionHandlerMock.h
--- ../Disruptor-cpp/Disruptor.Tests/ExceptionHandlerMock.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/ExceptionHandlerMock.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,27 +0,0 @@
-#pragma once
-
-#include <cstdint>
-#include <memory>
-
-#include <gmock/gmock.h>
-
-#include "Disruptor/IExceptionHandler.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    template <class T>
-    class ExceptionHandlerMock : public IExceptionHandler< T >
-    {
-    public:
-        MOCK_METHOD3_T(handleEventException, void(const std::exception&, std::int64_t, T&));
-        MOCK_METHOD1(handleOnStartException, void(const std::exception&));
-        MOCK_METHOD1(handleOnShutdownException, void(const std::exception&));
-        MOCK_METHOD2_T(handleOnTimeoutException, void (const std::exception&, std::int64_t));
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/ExceptionThrowingEventHandler.cpp ./Disruptor.Tests/ExceptionThrowingEventHandler.cpp
--- ../Disruptor-cpp/Disruptor.Tests/ExceptionThrowingEventHandler.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/ExceptionThrowingEventHandler.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,21 +0,0 @@
-#include "stdafx.h"
-#include "ExceptionThrowingEventHandler.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    ExceptionThrowingEventHandler::ExceptionThrowingEventHandler(const std::exception& applicationException)
-        : m_applicationException(applicationException)
-    {
-    }
-
-    void ExceptionThrowingEventHandler::onEvent(TestEvent& /*data*/, std::int64_t /*sequence*/, bool /*endOfBatch*/)
-    {
-        throw m_applicationException;
-    }
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/ExceptionThrowingEventHandler.h ./Disruptor.Tests/ExceptionThrowingEventHandler.h
--- ../Disruptor-cpp/Disruptor.Tests/ExceptionThrowingEventHandler.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/ExceptionThrowingEventHandler.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,27 +0,0 @@
-#pragma once
-
-#include <exception>
-
-#include "Disruptor/IEventHandler.h"
-
-#include "Disruptor.Tests/TestEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    class ExceptionThrowingEventHandler : public IEventHandler< TestEvent >
-    {
-    public:
-        explicit ExceptionThrowingEventHandler(const std::exception& applicationException);
-
-        void onEvent(TestEvent& data, std::int64_t sequence, bool endOfBatch) override;
-
-    private:
-        std::exception m_applicationException;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/FatalExceptionHandlerTests.cpp ./Disruptor.Tests/FatalExceptionHandlerTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/FatalExceptionHandlerTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/FatalExceptionHandlerTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,30 +0,0 @@
-#include "stdafx.h"
-
-#include "Disruptor/ArgumentException.h"
-#include "Disruptor/FatalExceptionHandler.h"
-#include "StubEvent.h"
-
-
-using namespace Disruptor;
-
-
-BOOST_AUTO_TEST_SUITE(FatalExceptionHandlerTests)
-
-BOOST_AUTO_TEST_CASE(ShouldHandleFatalException)
-{
-    auto causeException = ArgumentException("FatalExceptionHandlerTests.ShouldHandleFatalException");
-    auto evt = Tests::StubEvent(0);
-
-    auto exceptionHandler = std::make_shared< FatalExceptionHandler< Tests::StubEvent> >();
-
-    try
-    {
-        exceptionHandler->handleEventException(causeException, 0L, evt);
-    }
-    catch (FatalException& ex)
-    {
-        BOOST_CHECK_EQUAL(causeException.what(), ex.innerException().what());
-    }
-}
-
-BOOST_AUTO_TEST_SUITE_END()
\ No newline at end of file
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/FixedSequenceGroupTest.cpp ./Disruptor.Tests/FixedSequenceGroupTest.cpp
--- ../Disruptor-cpp/Disruptor.Tests/FixedSequenceGroupTest.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/FixedSequenceGroupTest.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,25 +0,0 @@
-#include "stdafx.h"
-
-#include "Disruptor/FixedSequenceGroup.h"
-#include "Disruptor/Sequence.h"
-
-
-using namespace Disruptor;
-
-
-BOOST_AUTO_TEST_SUITE(FixedSequenceGroupTest)
-
-BOOST_AUTO_TEST_CASE(ShouldReturnMinimumOf2Sequences)
-{
-    auto sequence1 = std::make_shared< Sequence >(34);
-    auto sequence2 = std::make_shared< Sequence >(47);
-    FixedSequenceGroup group({ sequence1, sequence2 });
-
-    BOOST_CHECK_EQUAL(group.value(), 34L);
-    sequence1->setValue(35);
-    BOOST_CHECK_EQUAL(group.value(), 35L);
-    sequence1->setValue(48);
-    BOOST_CHECK_EQUAL(group.value(), 47L);
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/IgnoreExceptionHandlerTests.cpp ./Disruptor.Tests/IgnoreExceptionHandlerTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/IgnoreExceptionHandlerTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/IgnoreExceptionHandlerTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,23 +0,0 @@
-#include "stdafx.h"
-
-#include "Disruptor/ArgumentException.h"
-#include "Disruptor/IgnoreExceptionHandler.h"
-#include "StubEvent.h"
-
-
-using namespace Disruptor;
-
-
-BOOST_AUTO_TEST_SUITE(IgnoreExceptionHandlerTests)
-
-BOOST_AUTO_TEST_CASE(ShouldIgnoreException)
-{
-    auto causeException = ArgumentException("IgnoreExceptionHandler.ShouldIgnoreException");
-    auto evt = Tests::StubEvent(0);
-
-    auto exceptionHandler = std::make_shared< IgnoreExceptionHandler< Tests::StubEvent> >();
-
-    BOOST_CHECK_NO_THROW(exceptionHandler->handleEventException(causeException, 0L, evt));
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/LifecycleAwareEventHandlerMock.h ./Disruptor.Tests/LifecycleAwareEventHandlerMock.h
--- ../Disruptor-cpp/Disruptor.Tests/LifecycleAwareEventHandlerMock.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/LifecycleAwareEventHandlerMock.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,27 +0,0 @@
-#pragma once
-
-#include <cstdint>
-#include <memory>
-
-#include <gmock/gmock.h>
-
-#include "Disruptor/IEventHandler.h"
-#include "Disruptor/ILifecycleAware.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    template <class T>
-    class LifecycleAwareEventHandlerMock : public IEventHandler< T >, public ILifecycleAware
-    {
-    public:
-        MOCK_METHOD3_T(onEvent, void(T& data, std::int64_t sequence, bool endOfBatch));
-        MOCK_METHOD0(onStart, void());
-        MOCK_METHOD0(onShutdown, void());
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/LifecycleAwareTests.cpp ./Disruptor.Tests/LifecycleAwareTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/LifecycleAwareTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/LifecycleAwareTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,80 +0,0 @@
-#include "stdafx.h"
-
-#include "Disruptor/BatchEventProcessor.h"
-#include "Disruptor/IEventHandler.h"
-#include "Disruptor/IgnoreExceptionHandler.h"
-#include "Disruptor/ILifecycleAware.h"
-#include "Disruptor/RingBuffer.h"
-
-#include "Disruptor.TestTools/ManualResetEvent.h"
-
-#include "StubEvent.h"
-#include "StubExecutor.h"
-
-
-using namespace Disruptor;
-using namespace ::Disruptor::Tests;
-
-
-BOOST_AUTO_TEST_SUITE(LifecycleAwareTests)
-
-class LifecycleAwareEventHandler : public IEventHandler< StubEvent >, public ILifecycleAware
-{
-public:
-
-    std::int32_t startCounter() const { return m_startCounter; }
-    std::int32_t shutdownCounter() const { return m_shutdownCounter; }
-
-    LifecycleAwareEventHandler(ManualResetEvent& startSignal, ManualResetEvent& shutdownSignal)
-        : m_startSignal(startSignal)
-        , m_shutdownSignal(shutdownSignal)
-        , m_startCounter(0)
-        , m_shutdownCounter(0)
-    {}
-
-    void onEvent(StubEvent&, std::int64_t, bool) override
-    {}
-
-    void onStart() override
-    {
-        ++m_startCounter;
-        m_startSignal.set();
-    }
-
-    void onShutdown() override
-    {
-        ++m_shutdownCounter;
-        m_shutdownSignal.set();
-    }
-
-private:
-    ManualResetEvent& m_startSignal;
-    ManualResetEvent& m_shutdownSignal;
-    std::int32_t m_startCounter;
-    std::int32_t m_shutdownCounter;
-};
-
-BOOST_AUTO_TEST_CASE(ShouldNotifyOfBatchProcessorLifecycle)
-{
-    ManualResetEvent startSignal(false);
-    ManualResetEvent shutdownSignal(false);
-    auto ringBuffer = std::make_shared< RingBuffer< StubEvent > >([] { return StubEvent(0); }, 16);
-
-    auto sequenceBarrier = ringBuffer->newBarrier();
-    auto eventHandler = std::make_shared< LifecycleAwareEventHandler >(startSignal, shutdownSignal);
-    auto batchEventProcessor = std::make_shared< BatchEventProcessor< StubEvent > >(ringBuffer, sequenceBarrier, eventHandler);
-
-    auto thread = std::thread([&] { batchEventProcessor->run(); });
-
-    startSignal.waitOne();
-    batchEventProcessor->halt();
-
-    shutdownSignal.waitOne();
-
-    thread.join();
-
-    BOOST_CHECK_EQUAL(eventHandler->startCounter(), 1);
-    BOOST_CHECK_EQUAL(eventHandler->shutdownCounter(), 1);
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/LongEvent.h ./Disruptor.Tests/LongEvent.h
--- ../Disruptor-cpp/Disruptor.Tests/LongEvent.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/LongEvent.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,18 +0,0 @@
-#pragma once
-
-#include <cstdint>
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-    
-    class LongEvent
-    {
-    public:
-        std::int64_t value = 0;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/MultiProducerSequencerTests.cpp ./Disruptor.Tests/MultiProducerSequencerTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/MultiProducerSequencerTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/MultiProducerSequencerTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,29 +0,0 @@
-#include "stdafx.h"
-
-#include "Disruptor/BlockingWaitStrategy.h"
-#include "Disruptor/MultiProducerSequencer.h"
-
-
-using namespace Disruptor;
-
-
-BOOST_AUTO_TEST_SUITE(MultiProducerSequencerTests)
-
-BOOST_AUTO_TEST_CASE(ShouldOnlyAllowMessagesToBeAvailableIfSpecificallyPublished)
-{
-    auto waitingStrategy = std::make_shared< BlockingWaitStrategy >();
-    auto publisher = std::make_shared< MultiProducerSequencer< int > >(1024, waitingStrategy);
-
-    publisher->publish(3);
-    publisher->publish(5);
-
-    BOOST_CHECK_EQUAL(publisher->isAvailable(0), false);
-    BOOST_CHECK_EQUAL(publisher->isAvailable(1), false);
-    BOOST_CHECK_EQUAL(publisher->isAvailable(2), false);
-    BOOST_CHECK_EQUAL(publisher->isAvailable(3), true );
-    BOOST_CHECK_EQUAL(publisher->isAvailable(4), false);
-    BOOST_CHECK_EQUAL(publisher->isAvailable(5), true );
-    BOOST_CHECK_EQUAL(publisher->isAvailable(6), false);
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/RingBufferTests.cpp ./Disruptor.Tests/RingBufferTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/RingBufferTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/RingBufferTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,740 +0,0 @@
-#include "stdafx.h"
-
-#include "Disruptor.TestTools/ManualResetEvent.h"
-
-#include "RingBufferTestsFixture.h"
-
-
-using namespace Disruptor;
-using namespace Disruptor::Tests;
-
-
-BOOST_FIXTURE_TEST_SUITE(RingBufferTests, RingBufferTestsFixture)
-
-BOOST_AUTO_TEST_CASE(ShouldClaimAndGet)
-{
-    BOOST_CHECK_EQUAL(Sequence::InitialCursorValue, m_ringBuffer->cursor());
-    
-    auto expectedEvent = StubEvent(2701);
-
-    auto claimSequence = m_ringBuffer->next();
-    auto& oldEvent = (*m_ringBuffer)[claimSequence];
-    oldEvent.copy(expectedEvent);
-    m_ringBuffer->publish(claimSequence);
-
-    auto sequence = m_sequenceBarrier->waitFor(0);
-    BOOST_CHECK_EQUAL(0, sequence);
-
-    auto& evt = (*m_ringBuffer)[sequence];
-    BOOST_CHECK_EQUAL(expectedEvent, evt);
-    
-    BOOST_CHECK_EQUAL(0L, m_ringBuffer->cursor());
-}
-
-BOOST_AUTO_TEST_CASE(ShouldClaimAndGetInSeparateThread)
-{
-    auto events = getEvents(0, 0);
-
-    auto expectedEvent = StubEvent(2701);
-
-    auto sequence = m_ringBuffer->next();
-    auto& oldEvent = (*m_ringBuffer)[sequence];
-    oldEvent.copy(expectedEvent);
-    m_ringBuffer->publishEvent(StubEvent::translator(), expectedEvent.value(), expectedEvent.testString());
-
-    BOOST_CHECK_EQUAL(expectedEvent, events.get()[0]);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldClaimAndGetMultipleMessages)
-{
-    auto numEvents = m_ringBuffer->bufferSize();
-    for (auto i = 0; i < numEvents; ++i)
-    {
-        m_ringBuffer->publishEvent(StubEvent::translator(), i, std::string());
-    }
-
-    auto expectedSequence = numEvents - 1;
-    auto available = m_sequenceBarrier->waitFor(expectedSequence);
-    BOOST_CHECK_EQUAL(expectedSequence, available);
-
-    for (auto i = 0; i < numEvents; ++i)
-    {
-        BOOST_CHECK_EQUAL(i, (*m_ringBuffer)[i].value());
-    }
-}
-
-BOOST_AUTO_TEST_CASE(ShouldWrap)
-{
-    auto numEvents = m_ringBuffer->bufferSize();
-    auto offset = 1000;
-    for (auto i = 0; i < numEvents + offset; ++i)
-    {
-        m_ringBuffer->publishEvent(StubEvent::translator(), i, std::string());
-    }
-
-    auto expectedSequence = numEvents + offset - 1;
-    auto available = m_sequenceBarrier->waitFor(expectedSequence);
-    BOOST_CHECK_EQUAL(expectedSequence, available);
-
-    for (auto i = offset; i < numEvents + offset; ++i)
-    {
-        BOOST_CHECK_EQUAL(i, (*m_ringBuffer)[i].value());
-    }
-}
-
-BOOST_AUTO_TEST_CASE(ShouldPreventWrapping)
-{
-    auto sequence = std::make_shared< Sequence >(Sequence::InitialCursorValue);
-    auto ringBuffer = RingBuffer< StubEvent >::createMultiProducer([] { return StubEvent(-1); }, 4);
-    ringBuffer->addGatingSequences({ sequence });
-
-    ringBuffer->publishEvent(StubEvent::translator(), 0, std::string("0"));
-    ringBuffer->publishEvent(StubEvent::translator(), 1, std::string("1"));
-    ringBuffer->publishEvent(StubEvent::translator(), 2, std::string("2"));
-    ringBuffer->publishEvent(StubEvent::translator(), 3, std::string("3"));
-
-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvent(StubEvent::translator(), 3, std::string("3")), false);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldThrowExceptionIfBufferIsFull)
-{
-    m_ringBuffer->addGatingSequences({ std::make_shared< Sequence >(m_ringBuffer->bufferSize()) });
-
-    try
-    {
-        for (auto i = 0; i < m_ringBuffer->bufferSize(); ++i)
-        {
-            m_ringBuffer->publish(m_ringBuffer->tryNext());
-        }
-    }
-    catch (std::exception&)
-    {
-        throw std::logic_error("Should not have thrown exception");
-    }
-
-    try
-    {
-        m_ringBuffer->tryNext();
-        throw std::logic_error("Exception should have been thrown");
-    }
-    catch (InsufficientCapacityException&)
-    {
-    }
-}
-
-BOOST_AUTO_TEST_CASE(ShouldPreventProducersOvertakingEventProcessorsWrapPoint)
-{
-    auto ringBufferSize = 4;
-    ManualResetEvent mre(false);
-    auto producerComplete = false;
-    auto ringBuffer = std::make_shared< RingBuffer< StubEvent > >([] { return StubEvent(-1); }, ringBufferSize);
-    auto processor = std::make_shared< TestEventProcessor >(ringBuffer->newBarrier());
-    ringBuffer->addGatingSequences({ processor->sequence() });
-
-    std::thread thread([&]
-    {
-        for (auto i = 0; i <= ringBufferSize; i++) // produce 5 events
-        {
-            auto sequence = ringBuffer->next();
-            auto& evt = (*ringBuffer)[sequence];
-            evt.value(i);
-            ringBuffer->publish(sequence);
-        
-            if (i == 3) // unblock main thread after 4th eventData published
-            {
-                mre.set();
-            }
-        }
-        
-        producerComplete = true;
-    });
-
-    mre.waitOne();
-
-    BOOST_CHECK_EQUAL(ringBuffer->cursor(), ringBufferSize - 1);
-    BOOST_CHECK_EQUAL(producerComplete, false);
-
-    processor->run();
-
-    if (thread.joinable())
-        thread.join();
-
-    BOOST_CHECK_EQUAL(producerComplete, true);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldPublishEvent)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< NoArgEventTranslator >();
-
-    ringBuffer->publishEvent(translator);
-    ringBuffer->tryPublishEvent(translator);
-
-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents(0, 1), *ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldPublishEventOneArg)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< OneArgEventTranslator >();
-    
-    ringBuffer->publishEvent(translator, std::string("Foo"));
-    ringBuffer->tryPublishEvent(translator, std::string("Foo"));
-
-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents(std::string("Foo-0"), std::string("Foo-1")), *ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldPublishEventTwoArg)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< TwoArgEventTranslator >();
-
-    ringBuffer->publishEvent(translator, std::string("Foo"), std::string("Bar"));
-    ringBuffer->tryPublishEvent(translator, std::string("Foo"), std::string("Bar"));
-
-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents(std::string("FooBar-0"), std::string("FooBar-1")), *ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldPublishEventThreeArg)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< ThreeArgEventTranslator >();
-
-    ringBuffer->publishEvent(translator, std::string("Foo"), std::string("Bar"), std::string("Baz"));
-    ringBuffer->tryPublishEvent(translator, std::string("Foo"), std::string("Bar"), std::string("Baz"));
-
-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents(std::string("FooBarBaz-0"), std::string("FooBarBaz-1")), *ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldPublishEvents)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto eventTranslator = std::make_shared< NoArgEventTranslator >();
-    auto translators = { eventTranslator, eventTranslator };
-
-    ringBuffer->publishEvents(translators);
-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translators), true);
-
-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(0, 1, 2, 3), *ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsIfBatchIsLargerThanRingBuffer)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto eventTranslator = std::make_shared< NoArgEventTranslator >();
-    auto translators = { eventTranslator, eventTranslator, eventTranslator, eventTranslator, eventTranslator };
-
-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translators), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldPublishEventsWithBatchSizeOfOne)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto eventTranslator = std::make_shared< NoArgEventTranslator >();
-    auto translators = { eventTranslator, eventTranslator, eventTranslator };
-
-    ringBuffer->publishEvents(translators, 0, 1);
-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translators, 0, 1), true);
-
-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(0, 1, boost::any(), boost::any()), *ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldPublishEventsWithinBatch)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto eventTranslator = std::make_shared< NoArgEventTranslator >();
-    auto translators = { eventTranslator, eventTranslator, eventTranslator };
-
-    ringBuffer->publishEvents(translators, 1, 2);
-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translators, 1, 2), true);
-
-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(0, 1, 2, 3), *ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldPublishEventsOneArg)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< OneArgEventTranslator >();
-
-    ringBuffer->publishEvents(translator, { std::string("Foo"), std::string("Foo") });
-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translator, { std::string("Foo"), std::string("Foo") }), true);
-
-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(std::string("Foo-0"), std::string("Foo-1"), std::string("Foo-2"), std::string("Foo-3")), *ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsOneArgIfBatchIsLargerThanRingBuffer)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< OneArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, { std::string("Foo"), std::string("Foo"), std::string("Foo"), std::string("Foo"), std::string("Foo") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldPublishEventsOneArgBatchSizeOfOne)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< OneArgEventTranslator >();
-
-    ringBuffer->publishEvents(translator, 0, 1, { std::string("Foo"), std::string("Foo") });
-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translator, 0, 1, { std::string("Foo"), std::string("Foo") }), true);
-
-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(std::string("Foo-0"), std::string("Foo-1"), boost::any(), boost::any()), *ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldPublishEventsOneArgWithinBatch)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< OneArgEventTranslator >();
-
-    ringBuffer->publishEvents(translator, 1, 2, { std::string("Foo"), std::string("Foo"), std::string("Foo") });
-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translator, 1, 2, { std::string("Foo"), std::string("Foo"), std::string("Foo") }), true);
-
-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(std::string("Foo-0"), std::string("Foo-1"), std::string("Foo-2"), std::string("Foo-3")), *ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldPublishEventsTwoArg)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< TwoArgEventTranslator >();
-
-    ringBuffer->publishEvents(translator, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") });
-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translator, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }), true);
-
-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(std::string("FooBar-0"), std::string("FooBar-1"), std::string("FooBar-2"), std::string("FooBar-3")), *ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsITwoArgIfBatchSizeIsBiggerThanRingBuffer)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< TwoArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents
-    (
-        translator,
-        { std::string("Foo"), std::string("Foo"), std::string("Foo"), std::string("Foo"), std::string("Foo") },
-        { std::string("Bar"), std::string("Bar"), std::string("Bar"), std::string("Bar"), std::string("Bar") }
-    ), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldPublishEventsTwoArgWithBatchSizeOfOne)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< TwoArgEventTranslator >();
-
-    ringBuffer->publishEvents(translator, 0, 1, { std::string("Foo0"), std::string("Foo1") }, { std::string("Bar0"), std::string("Bar1") });
-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translator, 0, 1, { std::string("Foo2"), std::string("Foo3") }, { std::string("Bar2"), std::string("Bar3") }), true);
-
-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(std::string("Foo0Bar0-0"), std::string("Foo2Bar2-1"), boost::any(), boost::any()), *ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldPublishEventsTwoArgWithinBatch)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< TwoArgEventTranslator >();
-
-    ringBuffer->publishEvents(translator, 1, 2, { std::string("Foo0"), std::string("Foo1"), std::string("Foo2") }, { std::string("Bar0"), std::string("Bar1"), std::string("Bar2") });
-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translator, 1, 2, { std::string("Foo3"), std::string("Foo4"), std::string("Foo5") }, { std::string("Bar3"), std::string("Bar4"), std::string("Bar5") }), true);
-
-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(std::string("Foo1Bar1-0"), std::string("Foo2Bar2-1"), std::string("Foo4Bar4-2"), std::string("Foo5Bar5-3")), *ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldPublishEventsThreeArg)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< ThreeArgEventTranslator >();
-
-    ringBuffer->publishEvents(translator, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }, { std::string("Baz"), std::string("Baz") });
-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translator, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }, { std::string("Baz"), std::string("Baz") }), true);
-
-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(std::string("FooBarBaz-0"), std::string("FooBarBaz-1"), std::string("FooBarBaz-2"), std::string("FooBarBaz-3")), *ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsThreeArgIfBatchIsLargerThanRingBuffer)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< ThreeArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents
-    (
-        translator,
-        { std::string("Foo"), std::string("Foo"), std::string("Foo"), std::string("Foo"), std::string("Foo") },
-        { std::string("Bar"), std::string("Bar"), std::string("Bar"), std::string("Bar"), std::string("Bar") },
-        { std::string("Baz"), std::string("Baz"), std::string("Baz"), std::string("Baz"), std::string("Baz") }
-    ), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldPublishEventsThreeArgBatchSizeOfOne)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< ThreeArgEventTranslator >();
-
-    ringBuffer->publishEvents(translator, 0, 1, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }, { std::string("Baz"), std::string("Baz") });
-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translator, 0, 1, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }, { std::string("Baz"), std::string("Baz") }), true);
-
-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(std::string("FooBarBaz-0"), std::string("FooBarBaz-1"), boost::any(), boost::any()), *ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldPublishEventsThreeArgWithinBatch)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< ThreeArgEventTranslator >();
-
-    ringBuffer->publishEvents(translator, 1, 2, { std::string("Foo0"), std::string("Foo1"), std::string("Foo2") },
-                                                { std::string("Bar0"), std::string("Bar1"), std::string("Bar2") },
-                                                { std::string("Baz0"), std::string("Baz1"), std::string("Baz2") });
-    
-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translator, 1, 2, { std::string("Foo3"), std::string("Foo4"), std::string("Foo5") },
-                                                                     { std::string("Bar3"), std::string("Bar4"), std::string("Bar5") },
-                                                                     { std::string("Baz3"), std::string("Baz4"), std::string("Baz5") }), true);
-
-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(std::string("Foo1Bar1Baz1-0"), std::string("Foo2Bar2Baz2-1"), std::string("Foo4Bar4Baz4-2"), std::string("Foo5Bar5Baz5-3")), *ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsWhenBatchSizeIs0)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< NoArgEventTranslator >();
-    auto translators = { translator, translator, translator, translator };
-
-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translators, 1, 0), ArgumentException);
-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translators, 1, 0), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsWhenBatchExtendsPastEndOfArray)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< NoArgEventTranslator >();
-    auto translators = { translator, translator, translator };
-
-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translators, 1, 3), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsWhenBatchExtendsPastEndOfArray)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< NoArgEventTranslator >();
-    auto translators = { translator, translator, translator };
-
-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translators, 1, 3), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsWhenBatchSizeIsNegative)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< NoArgEventTranslator >();
-    auto translators = { translator, translator, translator, translator };
-
-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translators, 1, -1), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsWhenBatchSizeIsNegative)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< NoArgEventTranslator >();
-    auto translators = { translator, translator, translator, translator };
-
-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translators, 1, -1), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsWhenBatchStartsAtIsNegative)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< NoArgEventTranslator >();
-    auto translators = { translator, translator, translator, translator };
-
-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translators, -1, 2), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsWhenBatchStartsAtIsNegative)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< NoArgEventTranslator >();
-    auto translators = { translator, translator, translator, translator };
-
-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translators, -1, 2), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsOneArgWhenBatchSizeIs0)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< OneArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, 1, 0, { std::string("Foo"), std::string("Foo") }), ArgumentException);
-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, 1, 0, { std::string("Foo"), std::string("Foo") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsOneArgWhenBatchExtendsPastEndOfArray)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< OneArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, 1, 3, { std::string("Foo"), std::string("Foo") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsOneArgWhenBatchSizeIsNegative)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< OneArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, 1, -1, { std::string("Foo"), std::string("Foo") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsOneArgWhenBatchStartsAtIsNegative)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< OneArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, -1, 2, { std::string("Foo"), std::string("Foo") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsOneArgWhenBatchExtendsPastEndOfArray)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< OneArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, 1, 3, { std::string("Foo"), std::string("Foo") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsOneArgWhenBatchSizeIsNegative)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< OneArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, 1, -1, { std::string("Foo"), std::string("Foo") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsOneArgWhenBatchStartsAtIsNegative)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< OneArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, -1, 2, { std::string("Foo"), std::string("Foo") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsTwoArgWhenBatchSizeIs0)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< TwoArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, 1, 0, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }), ArgumentException);
-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, 1, 0, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsTwoArgWhenBatchExtendsPastEndOfArray)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< TwoArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, 1, 3, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsTwoArgWhenBatchSizeIsNegative)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< TwoArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, 1, -1, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsTwoArgWhenBatchStartsAtIsNegative)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< TwoArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, -1, 2, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsTwoArgWhenBatchExtendsPastEndOfArray)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< TwoArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, 1, 3, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsTwoArgWhenBatchSizeIsNegative)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< TwoArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, 1, -1, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsTwoArgWhenBatchStartsAtIsNegative)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< TwoArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, -1, 2, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsThreeArgWhenBatchSizeIs0)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< ThreeArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, 1, 0, { std::string("Foo"), std::string("Foo") },
-                                                                  { std::string("Bar"), std::string("Bar") },
-                                                                  { std::string("Baz"), std::string("Baz") }), ArgumentException);
-
-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, 1, 0, { std::string("Foo"), std::string("Foo") },
-                                                                     { std::string("Bar"), std::string("Bar") },
-                                                                     { std::string("Baz"), std::string("Baz") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsThreeArgWhenBatchExtendsPastEndOfArray)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< ThreeArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, 1, 3, { std::string("Foo"), std::string("Foo") },
-                                                                  { std::string("Bar"), std::string("Bar") },
-                                                                  { std::string("Baz"), std::string("Baz") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsThreeArgWhenBatchSizeIsNegative)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< ThreeArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, 1, -1, { std::string("Foo"), std::string("Foo") },
-                                                                   { std::string("Bar"), std::string("Bar") },
-                                                                   { std::string("Baz"), std::string("Baz") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsThreeArgWhenBatchStartsAtIsNegative)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< ThreeArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, -1, 2, { std::string("Foo"), std::string("Foo") },
-                                                                   { std::string("Bar"), std::string("Bar") },
-                                                                   { std::string("Baz"), std::string("Baz") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsThreeArgWhenBatchExtendsPastEndOfArray)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< ThreeArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, 1, 3, { std::string("Foo"), std::string("Foo") },
-                                                                     { std::string("Bar"), std::string("Bar") },
-                                                                     { std::string("Baz"), std::string("Baz") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsThreeArgWhenBatchSizeIsNegative)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< ThreeArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, 1, -1, { std::string("Foo"), std::string("Foo") },
-                                                                      { std::string("Bar"), std::string("Bar") },
-                                                                      { std::string("Baz"), std::string("Baz") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsThreeArgWhenBatchStartsAtIsNegative)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
-    auto translator = std::make_shared< ThreeArgEventTranslator >();
-
-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, -1, 2, { std::string("Foo"), std::string("Foo") },
-                                                                      { std::string("Bar"), std::string("Bar") },
-                                                                      { std::string("Baz"), std::string("Baz") }), ArgumentException);
-
-    assertEmptyRingBuffer(*ringBuffer);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldAddAndRemoveSequences)
-{
-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 16);
-    auto sequenceThree = std::make_shared< Sequence >(-1);
-    auto sequenceSeven = std::make_shared< Sequence >(-1);
-
-    ringBuffer->addGatingSequences({ sequenceThree, sequenceSeven });
-
-    for (auto i = 0; i < 10; i++)
-    {
-        ringBuffer->publish(ringBuffer->next());
-    }
-    
-    sequenceThree->setValue(3);
-    sequenceSeven->setValue(7);
-    
-    BOOST_CHECK_EQUAL(ringBuffer->getMinimumGatingSequence(), 3L);
-    BOOST_CHECK_EQUAL(ringBuffer->removeGatingSequence(sequenceThree), true);
-    BOOST_CHECK_EQUAL(ringBuffer->getMinimumGatingSequence(), 7L);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldHandleResetToAndNotWrapUnecessarilySingleProducer)
-{
-    assertHandleResetAndNotWrap(RingBuffer< StubEvent >::createSingleProducer(StubEvent::eventFactory(), 4));
-}
-
-BOOST_AUTO_TEST_CASE(ShouldHandleResetToAndNotWrapUnecessarilyMultiProducer)
-{
-    assertHandleResetAndNotWrap(RingBuffer< StubEvent >::createMultiProducer(StubEvent::eventFactory(), 4));
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/RingBufferTestsFixture.cpp ./Disruptor.Tests/RingBufferTestsFixture.cpp
--- ../Disruptor-cpp/Disruptor.Tests/RingBufferTestsFixture.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/RingBufferTestsFixture.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,189 +0,0 @@
-#include "stdafx.h"
-#include "RingBufferTestsFixture.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    RingBufferTestsFixture::RingBufferTestsFixture()
-    {
-        m_ringBuffer = RingBuffer< StubEvent >::createMultiProducer([] { return StubEvent(-1); }, 32);
-        m_sequenceBarrier = m_ringBuffer->newBarrier();
-
-        auto processor = std::make_shared< NoOpEventProcessor< StubEvent > >(m_ringBuffer);
-        m_ringBuffer->addGatingSequences({processor->sequence()});
-    }
-
-    std::future< std::vector< StubEvent > > RingBufferTestsFixture::getEvents(std::int64_t initial, std::int64_t toWaitFor)
-    {
-        auto barrier = std::make_shared< boost::barrier >(2);
-        auto dependencyBarrier = m_ringBuffer->newBarrier();
-
-        auto testWaiter = std::make_shared< TestWaiter >(barrier, dependencyBarrier, m_ringBuffer, initial, toWaitFor);
-        auto task = std::async(std::launch::async, [=] { return testWaiter->call(); });
-
-        barrier->wait();
-
-        return task;
-    }
-
-    void RingBufferTestsFixture::assertHandleResetAndNotWrap(const std::shared_ptr< RingBuffer< StubEvent > >& rb)
-    {
-        auto sequence = std::make_shared< Sequence >();
-        rb->addGatingSequences({sequence});
-
-        for (auto i = 0; i < 128; ++i)
-        {
-            rb->publish(rb->next());
-            sequence->incrementAndGet();
-        }
-
-        BOOST_CHECK_EQUAL(rb->cursor(), 127L);
-
-        rb->resetTo(31);
-        sequence->setValue(31);
-
-        for (auto i = 0; i < 4; ++i)
-        {
-            rb->publish(rb->next());
-        }
-
-        BOOST_CHECK_EQUAL(rb->hasAvailableCapacity(1), false);
-    }
-
-    void RingBufferTestsFixture::assertEmptyRingBuffer(const RingBuffer< boost::any >& ringBuffer)
-    {
-        BOOST_CHECK_EQUAL(ringBuffer[0].empty(), true);
-        BOOST_CHECK_EQUAL(ringBuffer[1].empty(), true);
-        BOOST_CHECK_EQUAL(ringBuffer[2].empty(), true);
-        BOOST_CHECK_EQUAL(ringBuffer[3].empty(), true);
-    }
-
-    void RingBufferTestsFixture::NoArgEventTranslator::translateTo(boost::any& eventData, std::int64_t sequence)
-    {
-        eventData = static_cast< int >(sequence);
-    }
-
-    void RingBufferTestsFixture::ThreeArgEventTranslator::translateTo(boost::any& eventData, std::int64_t sequence, const std::string& arg0, const std::string& arg1, const std::string& arg2)
-    {
-        eventData = arg0 + arg1 + arg2 + "-" + std::to_string(sequence);
-    }
-
-    void RingBufferTestsFixture::TwoArgEventTranslator::translateTo(boost::any& eventData, std::int64_t sequence, const std::string& arg0, const std::string& arg1)
-    {
-        eventData = arg0 + arg1 + "-" + std::to_string(sequence);
-    }
-
-    void RingBufferTestsFixture::OneArgEventTranslator::translateTo(boost::any& eventData, std::int64_t sequence, const std::string& arg0)
-    {
-        eventData = arg0 + "-" + std::to_string(sequence);
-    }
-
-    RingBufferTestsFixture::TestEventProcessor::TestEventProcessor(const std::shared_ptr< ISequenceBarrier >& sequenceBarrier)
-        : m_sequenceBarrier(sequenceBarrier)
-        , m_sequence(std::make_shared< Sequence >())
-    {
-    }
-
-    std::shared_ptr< ISequence > RingBufferTestsFixture::TestEventProcessor::sequence() const
-    {
-        return m_sequence;
-    }
-
-    void RingBufferTestsFixture::TestEventProcessor::halt()
-    {
-        m_isRunning = false;
-    }
-
-    void RingBufferTestsFixture::TestEventProcessor::run()
-    {
-        m_isRunning = true;
-        m_sequenceBarrier->waitFor(0L);
-        m_sequence->setValue(m_sequence->value() + 1);
-    }
-
-    bool RingBufferTestsFixture::TestEventProcessor::isRunning() const
-    {
-        return m_isRunning;
-    }
-
-    RingBufferTestsFixture::RingBufferEquals::RingBufferEquals(const std::initializer_list< boost::any >& values)
-        : m_values(values)
-    {
-    }
-
-    bool RingBufferTestsFixture::RingBufferEquals::operator==(const RingBuffer< boost::any >& ringBuffer) const
-    {
-        auto valid = true;
-        for (auto i = 0u; i < m_values.size(); ++i)
-        {
-            auto value = m_values[i];
-            valid &= value.empty() || anyEqual(ringBuffer[i], value);
-        }
-        return valid;
-    }
-
-    void RingBufferTestsFixture::RingBufferEquals::writeDescriptionTo(std::ostream& stream) const
-    {
-        auto firstItem = true;
-        for (auto&& value : m_values)
-        {
-            if (firstItem)
-                firstItem = false;
-            else
-                stream << ", ";
-
-            stream << anyToString(value);
-        }
-    }
-
-    bool RingBufferTestsFixture::RingBufferEquals::anyEqual(const boost::any& lhs, const boost::any& rhs)
-    {
-        if (lhs.empty() && rhs.empty())
-            return true;
-
-        if (lhs.empty() || rhs.empty())
-            return false;
-
-        if (lhs.type() != rhs.type())
-            return false;
-
-        if (lhs.type() == typeid(std::string))
-            return boost::any_cast< std::string >(lhs) == boost::any_cast< std::string >(rhs);
-
-        if (lhs.type() == typeid(int))
-            return boost::any_cast< int >(lhs) == boost::any_cast< int >(rhs);
-
-        throw std::runtime_error("comparison of any unimplemented for type");
-    }
-
-    std::string RingBufferTestsFixture::RingBufferEquals::anyToString(const boost::any& value)
-    {
-        if (value.empty())
-            return "";
-
-        if (value.type() == typeid(std::string))
-            return boost::any_cast< std::string >(value);
-
-        if (value.type() == typeid(int))
-            return std::to_string(boost::any_cast< int >(value));
-
-        throw std::runtime_error("cannot get string representation of unimplemented any type");
-    }
-
-} // namespace Tests
-} // namespace Disruptor
-
-
-namespace std
-{
-
-    ostream& operator<<(ostream& stream, const Disruptor::Tests::RingBufferTestsFixture::RingBufferEquals& equals)
-    {
-        equals.writeDescriptionTo(stream);
-        return stream;
-    }
-
-} // namespace std
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/RingBufferTestsFixture.h ./Disruptor.Tests/RingBufferTestsFixture.h
--- ../Disruptor-cpp/Disruptor.Tests/RingBufferTestsFixture.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/RingBufferTestsFixture.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,128 +0,0 @@
-#pragma once
-
-#include <cstdint>
-#include <future>
-#include <memory>
-#include <ostream>
-#include <vector>
-
-#include <boost/any.hpp>
-#include <boost/test/unit_test.hpp>
-
-#include "Disruptor/IEventTranslator.h"
-#include "Disruptor/IEventTranslatorVararg.h"
-#include "Disruptor/NoOpEventProcessor.h"
-#include "Disruptor/RingBuffer.h"
-
-#include "Disruptor.Tests/StubEvent.h"
-#include "Disruptor.Tests/TestWaiter.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    struct RingBufferTestsFixture
-    {
-        class NoArgEventTranslator;
-        class OneArgEventTranslator;
-        class TestEventProcessor;
-        class ThreeArgEventTranslator;
-        class TwoArgEventTranslator;
-
-        RingBufferTestsFixture();
-
-        std::future< std::vector< StubEvent > > getEvents(std::int64_t initial, std::int64_t toWaitFor);
-
-        void assertHandleResetAndNotWrap(const std::shared_ptr< RingBuffer< StubEvent > >& rb);
-
-        static void assertEmptyRingBuffer(const RingBuffer< boost::any >& ringBuffer);
-
-
-        class RingBufferEquals
-        {
-        public:
-            RingBufferEquals(const std::initializer_list< boost::any >& values);
-
-            bool operator==(const RingBuffer< boost::any >& ringBuffer) const;
-
-            void writeDescriptionTo(std::ostream& stream) const;
-
-        private:
-            // http://stackoverflow.com/questions/6029092/compare-boostany-contents
-            static bool anyEqual(const boost::any& lhs, const boost::any& rhs);
-
-            static std::string anyToString(const boost::any& value);
-
-            std::vector< boost::any > m_values;
-        };
-
-
-        std::shared_ptr< RingBuffer< StubEvent > > m_ringBuffer;
-        std::shared_ptr< ISequenceBarrier > m_sequenceBarrier;
-
-        std::function< RingBufferEquals(const boost::any&, const boost::any&) > m_ringBufferWithEvents =
-            [](const boost::any& l1, const boost::any& l2) { return RingBufferEquals({ l1, l2 }); };
-
-        std::function< RingBufferEquals(const boost::any&, const boost::any&, const boost::any&, const boost::any&) > m_ringBufferWithEvents4 =
-            [](const boost::any& l1, const boost::any& l2, const boost::any& l3, const boost::any& l4) { return RingBufferEquals({ l1, l2, l3, l4 }); };
-    };
-
-
-    class RingBufferTestsFixture::NoArgEventTranslator : public IEventTranslator< boost::any >
-    {
-    public:
-        void translateTo(boost::any& eventData, std::int64_t sequence) override;
-    };
-
-
-    class RingBufferTestsFixture::ThreeArgEventTranslator : public IEventTranslatorVararg< boost::any, std::string, std::string, std::string >
-    {
-    public:
-        void translateTo(boost::any& eventData, std::int64_t sequence, const std::string& arg0, const std::string& arg1, const std::string& arg2) override;
-    };
-    
-    
-    class RingBufferTestsFixture::TwoArgEventTranslator : public IEventTranslatorVararg< boost::any, std::string, std::string >
-    {
-    public:
-        void translateTo(boost::any& eventData, std::int64_t sequence, const std::string& arg0, const std::string& arg1) override;
-    };
-    
-    
-    class RingBufferTestsFixture::OneArgEventTranslator : public IEventTranslatorVararg< boost::any, std::string >
-    {
-    public:
-        void translateTo(boost::any& eventData, std::int64_t sequence, const std::string& arg0) override;
-    };
-    
-    
-    class RingBufferTestsFixture::TestEventProcessor : public IEventProcessor
-    {
-    public:
-        explicit TestEventProcessor(const std::shared_ptr< ISequenceBarrier >& sequenceBarrier);
-
-        std::shared_ptr< ISequence > sequence() const override;
-
-        void halt() override;
-
-        void run() override;
-
-        bool isRunning() const override;
-
-    private:
-        std::shared_ptr< ISequenceBarrier > m_sequenceBarrier;
-        std::shared_ptr< ISequence > m_sequence;
-        bool m_isRunning = false;
-    };
-        
-} // namespace Tests
-} // namespace Disruptor
-
-
-namespace std
-{
-    ostream& operator<<(ostream& stream, const Disruptor::Tests::RingBufferTestsFixture::RingBufferEquals& equals);
-
-} // namespace std
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/RingBufferWithMocksTest.cpp ./Disruptor.Tests/RingBufferWithMocksTest.cpp
--- ../Disruptor-cpp/Disruptor.Tests/RingBufferWithMocksTest.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/RingBufferWithMocksTest.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,73 +0,0 @@
-#include "stdafx.h"
-
-#include "Disruptor/RingBuffer.h"
-#include "SequencerMock.h"
-#include "StubEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    struct RingBufferWithMocksFixture
-    {
-        RingBufferWithMocksFixture()
-        {
-            m_sequencerMock = std::make_shared< testing::NiceMock< SequencerMock< StubEvent > > >();
-            m_sequencer = m_sequencerMock;
-
-            ON_CALL(*m_sequencerMock, bufferSize()).WillByDefault(testing::Return(16));
-            m_ringBuffer = std::make_shared< RingBuffer< StubEvent > >(StubEvent::eventFactory(), m_sequencer);
-        }
-        
-        std::shared_ptr< RingBuffer< StubEvent > > m_ringBuffer;
-        std::shared_ptr< ISequencer< StubEvent > > m_sequencer;
-        std::shared_ptr< SequencerMock< StubEvent > > m_sequencerMock;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
-
-
-using namespace Disruptor;
-using namespace Disruptor::Tests;
-
-
-BOOST_FIXTURE_TEST_SUITE(RingBufferWithMocksTest, RingBufferWithMocksFixture)
-
-BOOST_AUTO_TEST_CASE(ShouldDelgateNextAndPublish)
-{
-    EXPECT_CALL(*m_sequencerMock, next()).WillOnce(testing::Return(34L));
-    EXPECT_CALL(*m_sequencerMock, publish(34L)).Times(1);
-
-    m_ringBuffer->publish(m_ringBuffer->next());
-}
-
-BOOST_AUTO_TEST_CASE(ShouldDelgateTryNextAndPublish)
-{
-    EXPECT_CALL(*m_sequencerMock, tryNext()).WillOnce(testing::Return(34L));
-    EXPECT_CALL(*m_sequencerMock, publish(34L)).Times(1);
-
-    m_ringBuffer->publish(m_ringBuffer->tryNext());
-}
-
-BOOST_AUTO_TEST_CASE(ShouldDelgateNextNAndPublish)
-{
-    EXPECT_CALL(*m_sequencerMock, next(10)).WillOnce(testing::Return(34L));
-    EXPECT_CALL(*m_sequencerMock, publish(25L, 34L)).Times(1);
-
-    auto hi = m_ringBuffer->next(10);
-    m_ringBuffer->publish(hi - 9, hi);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldDelgateTryNextNAndPublish)
-{
-    EXPECT_CALL(*m_sequencerMock, tryNext(10)).WillOnce(testing::Return(34L));
-    EXPECT_CALL(*m_sequencerMock, publish(25L, 34L)).Times(1);
-
-    auto hi = m_ringBuffer->tryNext(10);
-    m_ringBuffer->publish(hi - 9, hi);
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/SequenceBarrierMock.h ./Disruptor.Tests/SequenceBarrierMock.h
--- ../Disruptor-cpp/Disruptor.Tests/SequenceBarrierMock.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/SequenceBarrierMock.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,28 +0,0 @@
-#pragma once
-
-#include <gmock/gmock.h>
-
-#include "Disruptor/ISequenceBarrier.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    class SequenceBarrierMock : public ISequenceBarrier
-    {
-    public:
-        MOCK_METHOD1(waitFor, std::int64_t(std::int64_t sequence));
-        
-        MOCK_METHOD0(cursor, std::int64_t());
-
-        MOCK_METHOD0(isAlerted, bool());
-        MOCK_METHOD0(alert, void());
-
-        MOCK_METHOD0(clearAlert, void());
-        MOCK_METHOD0(checkAlert, void());
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/SequenceBarrierTests.cpp ./Disruptor.Tests/SequenceBarrierTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/SequenceBarrierTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/SequenceBarrierTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,143 +0,0 @@
-#include "stdafx.h"
-
-#include "Disruptor/AlertException.h"
-#include "Disruptor/IgnoreExceptionHandler.h"
-#include "Disruptor/Sequence.h"
-
-#include "SequenceBarrierTestsFixture.h"
-
-
-using namespace Disruptor;
-using namespace Disruptor::Tests;
-
-
-BOOST_FIXTURE_TEST_SUITE(SequenceBarrierTests, SequenceBarrierTestsFixture)
-
-BOOST_AUTO_TEST_CASE(ShouldWaitForWorkCompleteWhereCompleteWorkThresholdIsAhead)
-{
-    const std::int32_t expectedNumberMessages = 10;
-    const std::int32_t expectedWorkSequence = 9;
-    fillRingBuffer(expectedNumberMessages);
-
-    auto sequence1 = std::make_shared< Sequence >(expectedNumberMessages);
-    auto sequence2 = std::make_shared< Sequence >(expectedNumberMessages);
-    auto sequence3 = std::make_shared< Sequence >(expectedNumberMessages);
-
-    EXPECT_CALL(*m_eventProcessorMock1, sequence()).WillOnce(testing::Return(sequence1));
-    EXPECT_CALL(*m_eventProcessorMock2, sequence()).WillOnce(testing::Return(sequence2));
-    EXPECT_CALL(*m_eventProcessorMock3, sequence()).WillOnce(testing::Return(sequence3));
-
-    auto dependencyBarrier = m_ringBuffer->newBarrier({ m_eventProcessorMock1->sequence(),
-                                                        m_eventProcessorMock2->sequence(),
-                                                        m_eventProcessorMock3->sequence() });
-
-    auto completedWorkSequence = dependencyBarrier->waitFor(expectedWorkSequence);
-    BOOST_CHECK_GE(completedWorkSequence, expectedWorkSequence);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldWaitForWorkCompleteWhereAllWorkersAreBlockedOnRingBuffer)
-{
-    const std::int32_t expectedNumberMessages = 10;
-    fillRingBuffer(expectedNumberMessages);
-
-    std::vector< std::shared_ptr< IEventProcessor > > workers(3);
-    for (auto i = 0u; i < workers.size(); ++i)
-    {
-        workers[i] = std::make_shared< StubEventProcessor >(expectedNumberMessages - 1);
-    }
-
-    auto dependencyBarrier = m_ringBuffer->newBarrier(Util::getSequencesFor(workers));
-    std::thread([=]
-    {
-        auto sequence = m_ringBuffer->next();
-        (*m_ringBuffer)[sequence].value(static_cast< int >(sequence));
-        m_ringBuffer->publish(sequence);
-
-        for (auto&& stubWorker : workers)
-        {
-            stubWorker->sequence()->setValue(sequence);
-        }
-    }).detach();
-
-    std::int64_t expectedWorkSequence = expectedNumberMessages;
-    auto completedWorkSequence = dependencyBarrier->waitFor(expectedWorkSequence);
-    BOOST_CHECK_GE(completedWorkSequence, expectedWorkSequence);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldInterruptDuringBusySpin)
-{
-    const std::int32_t expectedNumberMessages = 10;
-    fillRingBuffer(expectedNumberMessages);
-
-    auto signal = std::make_shared< CountdownEvent >(3);
-    auto sequence1 = std::make_shared< CountDownEventSequence >(8L, signal);
-    auto sequence2 = std::make_shared< CountDownEventSequence >(8L, signal);
-    auto sequence3 = std::make_shared< CountDownEventSequence >(8L, signal);
-
-    EXPECT_CALL(*m_eventProcessorMock1, sequence()).WillOnce(testing::Return(sequence1));
-    EXPECT_CALL(*m_eventProcessorMock2, sequence()).WillOnce(testing::Return(sequence2));
-    EXPECT_CALL(*m_eventProcessorMock3, sequence()).WillOnce(testing::Return(sequence3));
-
-    auto sequenceBarrier = m_ringBuffer->newBarrier(Util::getSequencesFor({ m_eventProcessorMock1,
-                                                                            m_eventProcessorMock2,
-                                                                            m_eventProcessorMock3 }));
-
-    auto alerted = false;
-    auto future = std::async(std::launch::async, [=, &alerted]()
-    {
-        try
-        {
-            sequenceBarrier->waitFor(expectedNumberMessages - 1);
-        }
-        catch (AlertException&)
-        {
-            alerted = true;
-        }
-    });
-
-    signal->wait(std::chrono::seconds(3));
-    sequenceBarrier->alert();
-    future.wait();
-
-    BOOST_CHECK_MESSAGE(alerted == true, "Thread was not interrupted");
-}
-
-BOOST_AUTO_TEST_CASE(ShouldWaitForWorkCompleteWhereCompleteWorkThresholdIsBehind)
-{
-    const std::int32_t expectedNumberMessages = 10;
-    fillRingBuffer(expectedNumberMessages);
-
-    std::vector< std::shared_ptr< IEventProcessor > > eventProcessors(3);
-    for (auto i = 0u; i < eventProcessors.size(); ++i)
-    {
-        eventProcessors[i] = std::make_shared< StubEventProcessor >(expectedNumberMessages - 2);
-    }
-
-    auto eventProcessorBarrier = m_ringBuffer->newBarrier(Util::getSequencesFor(eventProcessors));
-
-    std::async(std::launch::async, [=]
-    {
-        for (auto&& stubWorker : eventProcessors)
-        {
-            stubWorker->sequence()->setValue(stubWorker->sequence()->value() + 1);
-        }
-    }).wait();
-
-    std::int64_t expectedWorkSequence = expectedNumberMessages - 1;
-    auto completedWorkSequence = eventProcessorBarrier->waitFor(expectedWorkSequence);
-    BOOST_CHECK_GE(completedWorkSequence, expectedWorkSequence);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldSetAndClearAlertStatus)
-{
-    auto sequenceBarrier = m_ringBuffer->newBarrier();
-    BOOST_CHECK_EQUAL(sequenceBarrier->isAlerted(), false);
-
-    sequenceBarrier->alert();
-    BOOST_CHECK_EQUAL(sequenceBarrier->isAlerted(), true);
-
-    sequenceBarrier->clearAlert();
-    BOOST_CHECK_EQUAL(sequenceBarrier->isAlerted(), false);
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/SequenceBarrierTestsFixture.cpp ./Disruptor.Tests/SequenceBarrierTestsFixture.cpp
--- ../Disruptor-cpp/Disruptor.Tests/SequenceBarrierTestsFixture.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/SequenceBarrierTestsFixture.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,97 +0,0 @@
-#include "stdafx.h"
-#include "SequenceBarrierTestsFixture.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    SequenceBarrierTestsFixture::SequenceBarrierTestsFixture()
-    {
-        m_ringBuffer = RingBuffer< StubEvent >::createMultiProducer([] { return StubEvent(-1); }, 64);
-
-        m_eventProcessorMock1 = std::make_shared< testing::NiceMock< EventProcessorMock > >();
-        m_eventProcessorMock2 = std::make_shared< testing::NiceMock< EventProcessorMock > >();
-        m_eventProcessorMock3 = std::make_shared< testing::NiceMock< EventProcessorMock > >();
-
-        m_ringBuffer->addGatingSequences({std::make_shared< NoOpEventProcessor< StubEvent > >(m_ringBuffer)->sequence()});
-    }
-
-    void SequenceBarrierTestsFixture::fillRingBuffer(std::int64_t expectedNumberEvents)
-    {
-        for (auto i = 0; i < expectedNumberEvents; i++)
-        {
-            auto sequence = m_ringBuffer->next();
-            auto& event = (*m_ringBuffer)[sequence];
-            event.value(i);
-            m_ringBuffer->publish(sequence);
-        }
-    }
-
-    SequenceBarrierTestsFixture::StubEventProcessor::StubEventProcessor(std::int64_t sequence)
-    {
-        m_sequence->setValue(sequence);
-    }
-
-    void SequenceBarrierTestsFixture::StubEventProcessor::run()
-    {
-        if (std::atomic_exchange(&m_running, 1) != 0)
-            DISRUPTOR_THROW_INVALID_OPERATION_EXCEPTION("Already running");
-    }
-
-    std::shared_ptr< ISequence > SequenceBarrierTestsFixture::StubEventProcessor::sequence() const
-    {
-        return m_sequence;
-    }
-
-    void SequenceBarrierTestsFixture::StubEventProcessor::halt()
-    {
-        m_running = 0;
-    }
-
-    bool SequenceBarrierTestsFixture::StubEventProcessor::isRunning() const
-    {
-        return m_running == 1;
-    }
-
-    SequenceBarrierTestsFixture::CountDownEventSequence::CountDownEventSequence(std::int64_t initialValue, const std::shared_ptr< CountdownEvent >& signal)
-        : m_signal(signal)
-        , m_sequenceImplementation(std::make_shared< Sequence >(initialValue))
-    {
-    }
-
-    std::int64_t SequenceBarrierTestsFixture::CountDownEventSequence::value() const
-    {
-        if (m_signal->currentCount() > 0)
-            m_signal->signal();
-
-        return m_sequenceImplementation->value();
-    }
-
-    void SequenceBarrierTestsFixture::CountDownEventSequence::setValue(std::int64_t value)
-    {
-        m_sequenceImplementation->setValue(value);
-    }
-
-    bool SequenceBarrierTestsFixture::CountDownEventSequence::compareAndSet(std::int64_t expectedSequence, std::int64_t nextSequence)
-    {
-        return m_sequenceImplementation->compareAndSet(expectedSequence, nextSequence);
-    }
-
-    std::int64_t SequenceBarrierTestsFixture::CountDownEventSequence::incrementAndGet()
-    {
-        return m_sequenceImplementation->incrementAndGet();
-    }
-
-    std::int64_t SequenceBarrierTestsFixture::CountDownEventSequence::addAndGet(std::int64_t value)
-    {
-        return m_sequenceImplementation->addAndGet(value);
-    }
-
-    void SequenceBarrierTestsFixture::CountDownEventSequence::writeDescriptionTo(std::ostream& /*stream*/) const
-    {
-    }
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/SequenceBarrierTestsFixture.h ./Disruptor.Tests/SequenceBarrierTestsFixture.h
--- ../Disruptor-cpp/Disruptor.Tests/SequenceBarrierTestsFixture.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/SequenceBarrierTestsFixture.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,78 +0,0 @@
-#pragma once
-
-#include <memory>
-
-#include "Disruptor/NoOpEventProcessor.h"
-#include "Disruptor/RingBuffer.h"
-
-#include "Disruptor.TestTools/CountdownEvent.h"
-
-#include "Disruptor.Tests/EventProcessorMock.h"
-#include "Disruptor.Tests/StubEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    struct SequenceBarrierTestsFixture
-    {
-        class CountDownEventSequence;
-        class StubEventProcessor;
-
-        SequenceBarrierTestsFixture();
-
-        void fillRingBuffer(std::int64_t expectedNumberEvents);
-
-
-        std::shared_ptr< RingBuffer< StubEvent > > m_ringBuffer;
-        std::shared_ptr< EventProcessorMock > m_eventProcessorMock1;
-        std::shared_ptr< EventProcessorMock > m_eventProcessorMock2;
-        std::shared_ptr< EventProcessorMock > m_eventProcessorMock3;
-    };
-
-
-    class SequenceBarrierTestsFixture::StubEventProcessor : public IEventProcessor
-    {
-    public:
-        explicit StubEventProcessor(std::int64_t sequence);
-
-        void run() override;
-
-        std::shared_ptr< ISequence > sequence() const override;
-
-        void halt() override;
-
-        bool isRunning() const override;
-
-    private:
-        std::atomic< std::int32_t > m_running;
-        std::shared_ptr< Sequence > m_sequence = std::make_shared< Sequence >();
-    };
-
-
-    class SequenceBarrierTestsFixture::CountDownEventSequence : public ISequence
-    {
-    public:
-        CountDownEventSequence(std::int64_t initialValue, const std::shared_ptr< CountdownEvent >& signal);
-
-        std::int64_t value() const override;
-
-        void setValue(std::int64_t value) override;
-
-        bool compareAndSet(std::int64_t expectedSequence, std::int64_t nextSequence) override;
-
-        std::int64_t incrementAndGet() override;
-
-        std::int64_t addAndGet(std::int64_t value) override;
-
-        void writeDescriptionTo(std::ostream& stream) const override;
-
-    private:
-        std::shared_ptr< CountdownEvent > m_signal;
-        std::shared_ptr< ISequence > m_sequenceImplementation;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/SequenceReportingCallbackTests.cpp ./Disruptor.Tests/SequenceReportingCallbackTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/SequenceReportingCallbackTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/SequenceReportingCallbackTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,90 +0,0 @@
-#include "stdafx.h"
-
-#include "Disruptor/BatchEventProcessor.h"
-#include "Disruptor/ISequenceReportingEventHandler.h"
-#include "Disruptor/RingBuffer.h"
-
-#include "Disruptor.TestTools/ManualResetEvent.h"
-
-#include "StubEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    struct SequenceReportingCallbackTestsFixture
-    {
-        std::shared_ptr< ManualResetEvent > m_callbackSignal = std::make_shared< ManualResetEvent >(false);
-        std::shared_ptr< ManualResetEvent > m_onEndOfBatchSignal = std::make_shared< ManualResetEvent >(false);
-    };
-    
-    class TestSequenceReportingEventHandler : public ISequenceReportingEventHandler< StubEvent >
-    {
-    public:
-        TestSequenceReportingEventHandler(const std::shared_ptr< ManualResetEvent >& callbackSignal,
-                                          const std::shared_ptr< ManualResetEvent >& onEndOfBatchSignal)
-            : m_callbackSignal(callbackSignal)
-            , m_onEndOfBatchSignal(onEndOfBatchSignal)
-        {
-        }
-
-        void setSequenceCallback(const std::shared_ptr< ISequence >& sequenceTrackerCallback) override
-        {
-            m_sequenceCallback = sequenceTrackerCallback;
-        }
-
-        void onEvent(StubEvent& /*evt*/, std::int64_t sequence, bool endOfBatch) override
-        {
-            m_sequenceCallback->setValue(sequence);
-            m_callbackSignal->set();
-
-            if (endOfBatch)
-            {
-                m_onEndOfBatchSignal->waitOne();
-            }
-        }
-
-    private:
-        std::shared_ptr< ISequence > m_sequenceCallback;
-        std::shared_ptr< ManualResetEvent > m_callbackSignal;
-        std::shared_ptr< ManualResetEvent > m_onEndOfBatchSignal;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
-
-
-using namespace Disruptor;
-using namespace Disruptor::Tests;
-
-
-BOOST_FIXTURE_TEST_SUITE(SequenceReportingCallbackTests, SequenceReportingCallbackTestsFixture)
-
-BOOST_AUTO_TEST_CASE(ShouldReportProgressByUpdatingSequenceViaCallback)
-{
-    auto ringBuffer = RingBuffer< StubEvent >::createMultiProducer([] { return StubEvent(-1); }, 16);
-    auto sequenceBarrier = ringBuffer->newBarrier();
-    auto handler = std::make_shared< TestSequenceReportingEventHandler >(m_callbackSignal, m_onEndOfBatchSignal);
-    auto batchEventProcessor = std::make_shared< BatchEventProcessor< StubEvent > >(ringBuffer, sequenceBarrier, handler);
-    ringBuffer->addGatingSequences({ batchEventProcessor->sequence() });
-
-    std::thread thread([&] { batchEventProcessor->run(); });
-
-    BOOST_CHECK_EQUAL(-1L, batchEventProcessor->sequence()->value());
-    ringBuffer->publish(ringBuffer->next());
-
-    m_callbackSignal->waitOne();
-    BOOST_CHECK_EQUAL(0L, batchEventProcessor->sequence()->value());
-
-    m_onEndOfBatchSignal->set();
-    BOOST_CHECK_EQUAL(0L, batchEventProcessor->sequence()->value());
-
-    batchEventProcessor->halt();
-
-    if (thread.joinable())
-        thread.join();
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/SequenceUpdater.cpp ./Disruptor.Tests/SequenceUpdater.cpp
--- ../Disruptor-cpp/Disruptor.Tests/SequenceUpdater.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/SequenceUpdater.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,43 +0,0 @@
-#include "stdafx.h"
-#include "SequenceUpdater.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    SequenceUpdater::SequenceUpdater(std::int64_t sleepTime, const std::shared_ptr< IWaitStrategy >& waitStrategy)
-        : m_barrier(2)
-        , m_sleepTime(static_cast< std::int32_t >(sleepTime))
-        , m_waitStrategy(waitStrategy)
-    {
-    }
-
-    void SequenceUpdater::run()
-    {
-        try
-        {
-            m_barrier.signal();
-            m_barrier.wait();
-            if (0 != m_sleepTime)
-            {
-                std::this_thread::sleep_for(std::chrono::milliseconds(m_sleepTime));
-            }
-            sequence->incrementAndGet();
-            m_waitStrategy->signalAllWhenBlocking();
-        }
-        catch (std::exception& ex)
-        {
-            std::cout << ex.what() << std::endl;
-        }
-    }
-
-    void SequenceUpdater::waitForStartup()
-    {
-        m_barrier.signal();
-        m_barrier.wait();
-    }
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/SequenceUpdater.h ./Disruptor.Tests/SequenceUpdater.h
--- ../Disruptor-cpp/Disruptor.Tests/SequenceUpdater.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/SequenceUpdater.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,34 +0,0 @@
-#pragma once
-
-#include <cstdint>
-
-#include "Disruptor/IWaitStrategy.h"
-#include "Disruptor/Sequence.h"
-
-#include "Disruptor.TestTools/CountdownEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    class SequenceUpdater
-    {
-    public:
-        SequenceUpdater(std::int64_t sleepTime, const std::shared_ptr< IWaitStrategy >& waitStrategy);
-
-        void run();
-
-        void waitForStartup();
-
-        std::shared_ptr< Sequence > sequence = std::make_shared< Sequence >();
-
-    private:
-        CountdownEvent m_barrier;
-        std::int32_t m_sleepTime = 0;
-        std::shared_ptr< IWaitStrategy > m_waitStrategy;
-    };
-    
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/SequencerFixture.h ./Disruptor.Tests/SequencerFixture.h
--- ../Disruptor-cpp/Disruptor.Tests/SequencerFixture.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/SequencerFixture.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,30 +0,0 @@
-#pragma once
-
-#include "Disruptor/BlockingWaitStrategy.h"
-#include "Disruptor/MultiProducerSequencer.h"
-#include "Disruptor/Sequence.h"
-#include "Disruptor/SingleProducerSequencer.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    template <class T>
-    struct SequencerTestFixture
-    {
-        SequencerTestFixture()
-            : m_waitStrategy(std::make_shared< BlockingWaitStrategy >())
-            , m_sequencer(std::make_shared< T >(m_bufferSize, m_waitStrategy))
-            , m_gatingSequence(std::make_shared< Sequence >())
-        {}
-    
-        const std::int32_t m_bufferSize = 16;
-        std::shared_ptr< IWaitStrategy > m_waitStrategy;
-        std::shared_ptr< T > m_sequencer;
-        std::shared_ptr< Sequence > m_gatingSequence;
-    };
-    
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/SequencerMock.h ./Disruptor.Tests/SequencerMock.h
--- ../Disruptor-cpp/Disruptor.Tests/SequencerMock.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/SequencerMock.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,53 +0,0 @@
-#pragma once
-
-#include <gmock/gmock.h>
-
-#include "Disruptor/ISequencer.h"
-#include "Disruptor.Tests/StubEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    template <class T>
-    class SequencerMock : public ISequencer< T >
-    {
-    public:
-        MOCK_METHOD1(claim, void(std::int64_t sequence));
-
-        MOCK_METHOD1(isAvailable, bool(std::int64_t sequence));
-        
-        MOCK_METHOD1(addGatingSequences, void(const std::vector< std::shared_ptr< ISequence > >& gatingSequences));
-        MOCK_METHOD1(removeGatingSequence, bool(const std::shared_ptr< ISequence >& sequence));
-
-        MOCK_METHOD1(newBarrier, std::shared_ptr< ISequenceBarrier >(const std::vector< std::shared_ptr< ISequence > >& sequencesToTrack));
-        MOCK_METHOD0(getMinimumSequence, std::int64_t());
-
-        MOCK_METHOD2_T(newPoller, std::shared_ptr< EventPoller< T > >(const std::shared_ptr< IDataProvider< T > >& provider, const std::vector< std::shared_ptr< ISequence > >& gatingSequences));
-        
-        MOCK_CONST_METHOD1(writeDescriptionTo, void(std::ostream& stream));
-
-        MOCK_METHOD0(bufferSize, std::int32_t());
-
-        MOCK_METHOD1(hasAvailableCapacity, bool(std::int32_t requiredCapacity));
-
-        MOCK_METHOD0(getRemainingCapacity, std::int64_t());
-
-        MOCK_METHOD0(next, std::int64_t());
-        MOCK_METHOD1(next, std::int64_t(std::int32_t n));
-
-        MOCK_METHOD0(tryNext, std::int64_t());
-        MOCK_METHOD1(tryNext, std::int64_t(std::int32_t n));
-
-        MOCK_METHOD1(publish, void(std::int64_t sequence));
-        MOCK_METHOD2(publish, void(std::int64_t lo, std::int64_t hi));
-
-        MOCK_CONST_METHOD0(cursor, std::int64_t());
-
-        MOCK_METHOD2(getHighestPublishedSequence, std::int64_t(std::int64_t nextSequence, std::int64_t availableSequence));
-    };
-
-} // namespace Tests
-} // namespace Disruptor
\ No newline at end of file
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/SequencerTests.cpp ./Disruptor.Tests/SequencerTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/SequencerTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/SequencerTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,215 +0,0 @@
-#include "stdafx.h"
-
-#include <boost/mpl/vector.hpp>
-
-#include "Disruptor.TestTools/ManualResetEvent.h"
-
-#include "SequencerFixture.h"
-#include "WaitStrategyMock.h"
-
-
-using namespace Disruptor;
-using namespace Disruptor::Tests;
-
-
-typedef boost::mpl::vector< MultiProducerSequencer< int >, SingleProducerSequencer< int > > Sequencers;
-
-BOOST_AUTO_TEST_SUITE(SequencerTests)
-
-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldStartWithInitialValue, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
-{
-    BOOST_CHECK_EQUAL(this->m_sequencer->next(), 0);
-}
-
-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldBatchClaim, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
-{
-    BOOST_CHECK_EQUAL(this->m_sequencer->next(4), 3);
-}
-
-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldIndicateHasAvailableCapacity, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
-{
-    this->m_sequencer->addGatingSequences({ this->m_gatingSequence });
-
-    BOOST_CHECK_EQUAL(this->m_sequencer->hasAvailableCapacity(1), true);
-    BOOST_CHECK_EQUAL(this->m_sequencer->hasAvailableCapacity(this->m_bufferSize), true);
-    BOOST_CHECK_EQUAL(this->m_sequencer->hasAvailableCapacity(this->m_bufferSize + 1), false);
-
-    this->m_sequencer->publish(this->m_sequencer->next());
-
-    BOOST_CHECK_EQUAL(this->m_sequencer->hasAvailableCapacity(this->m_bufferSize - 1), true);
-    BOOST_CHECK_EQUAL(this->m_sequencer->hasAvailableCapacity(this->m_bufferSize), false);
-}
-
-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldIndicateNoAvailableCapacity, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
-{
-    this->m_sequencer->addGatingSequences({ this->m_gatingSequence });
-
-    auto sequence = this->m_sequencer->next(this->m_bufferSize);
-    this->m_sequencer->publish(sequence - (this->m_bufferSize - 1), sequence);
-
-    BOOST_CHECK_EQUAL(this->m_sequencer->hasAvailableCapacity(1), false);
-}
-
-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldHoldUpPublisherWhenBufferIsFull, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
-{
-    this->m_sequencer->addGatingSequences({ this->m_gatingSequence });
-
-    auto sequence = this->m_sequencer->next(this->m_bufferSize);
-    this->m_sequencer->publish(sequence - (this->m_bufferSize - 1), sequence);
-
-    auto waitingSignal = std::make_shared< ManualResetEvent >(false);
-    auto doneSignal = std::make_shared< ManualResetEvent >(false);
-
-    auto expectedFullSequence = Sequence::InitialCursorValue + this->m_sequencer->bufferSize();
-    BOOST_CHECK_EQUAL(this->m_sequencer->cursor(), expectedFullSequence);
-
-    std::thread([=]
-    {
-        waitingSignal->set();
-
-        auto next = this->m_sequencer->next();
-        this->m_sequencer->publish(next);
-
-        doneSignal->set();
-    }).detach();
-
-    waitingSignal->wait(std::chrono::milliseconds(500));
-    BOOST_CHECK_EQUAL(this->m_sequencer->cursor(), expectedFullSequence);
-
-    this->m_gatingSequence->setValue(Sequence::InitialCursorValue + 1L);
-
-    doneSignal->wait(std::chrono::milliseconds(500));
-    BOOST_CHECK_EQUAL(this->m_sequencer->cursor(), expectedFullSequence + 1L);
-}
-
-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldThrowInsufficientCapacityExceptionWhenSequencerIsFull, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
-{
-    this->m_sequencer->addGatingSequences({ this->m_gatingSequence });
-
-    for (auto i = 0; i < this->m_bufferSize; ++i)
-    {
-        this->m_sequencer->next();
-    }
-
-    BOOST_CHECK_THROW(this->m_sequencer->tryNext(), InsufficientCapacityException);
-}
-
-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldCalculateRemainingCapacity, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
-{
-    this->m_sequencer->addGatingSequences({ this->m_gatingSequence });
-
-    BOOST_CHECK_EQUAL(this->m_sequencer->getRemainingCapacity(), this->m_bufferSize);
-    
-    for (auto i = 1; i < this->m_bufferSize; ++i)
-    {
-        this->m_sequencer->next();
-        BOOST_CHECK_EQUAL(this->m_sequencer->getRemainingCapacity(), this->m_bufferSize - i);
-    }
-}
-
-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShoundNotBeAvailableUntilPublished, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
-{
-    auto next = this->m_sequencer->next(6);
-
-    for (auto i = 0; i <= 5; i++)
-    {
-        BOOST_CHECK_EQUAL(this->m_sequencer->isAvailable(i), false);
-    }
-
-    this->m_sequencer->publish(next - (6 - 1), next);
-    
-    for (auto i = 0; i <= 5; i++)
-    {
-        BOOST_CHECK_EQUAL(this->m_sequencer->isAvailable(i), true);
-    }
-
-    BOOST_CHECK_EQUAL(this->m_sequencer->isAvailable(6), false);
-}
-
-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldNotifyWaitStrategyOnPublish, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
-{
-    auto waitStrategyMock = std::make_shared< testing::NiceMock< WaitStrategyMock > >();
-    auto sequencer = std::make_shared< TSequencer >(this->m_bufferSize, waitStrategyMock);
-
-    EXPECT_CALL(*waitStrategyMock, signalAllWhenBlocking()).Times(1);
-
-    sequencer->publish(sequencer->next());
-}
-
-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldNotifyWaitStrategyOnPublishBatch, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
-{
-    auto waitStrategyMock = std::make_shared< testing::NiceMock< WaitStrategyMock > >();
-    auto sequencer = std::make_shared< TSequencer >(this->m_bufferSize, waitStrategyMock);
-
-    EXPECT_CALL(*waitStrategyMock, signalAllWhenBlocking()).Times(1);
-
-    auto next = sequencer->next(4);
-    sequencer->publish(next - (4 - 1), next);
-}
-
-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldWaitOnPublication, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
-{
-    auto barrier = this->m_sequencer->newBarrier({});
-
-    auto next = this->m_sequencer->next(10);
-    auto lo = next - (10 - 1);
-    auto mid = next - 5;
-
-    for (auto l = lo; l < mid; ++l)
-    {
-       this->m_sequencer->publish(l);
-    }
-
-    BOOST_CHECK_EQUAL(barrier->waitFor(-1), mid - 1);
-
-    for (auto l = mid; l <= next; ++l)
-    {
-        this->m_sequencer->publish(l);
-    }
-
-    BOOST_CHECK_EQUAL(barrier->waitFor(-1), next);
-}
-
-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldTryNext, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
-{
-    this->m_sequencer->addGatingSequences({ this->m_gatingSequence });
-
-    for (auto i = 0; i < this->m_bufferSize; i++)
-    {
-        BOOST_CHECK_NO_THROW(this->m_sequencer->publish(this->m_sequencer->tryNext()));
-    }
- 
-    BOOST_CHECK_THROW(this->m_sequencer->tryNext(), InsufficientCapacityException);
-}
-
-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldClaimSpecificSequence, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
-{
-    std::int64_t sequence = 14;
-
-    this->m_sequencer->claim(sequence);
-    this->m_sequencer->publish(sequence);
-
-    BOOST_CHECK_EQUAL(this->m_sequencer->next(), sequence + 1);
-}
-
-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldNotAllowBulkNextLessThanZero, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
-{
-    BOOST_CHECK_THROW(this->m_sequencer->next(-1), ArgumentException);
-}
-
-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldNotAllowBulkNextOfZero, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
-{
-    BOOST_CHECK_THROW(this->m_sequencer->next(0), ArgumentException);
-}
-
-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldNotAllowBulkTryNextLessThanZero, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
-{
-    BOOST_CHECK_THROW(this->m_sequencer->tryNext(-1), ArgumentException);
-}
-
-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldNotAllowBulkTryNextOfZero, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
-{
-    BOOST_CHECK_THROW(this->m_sequencer->tryNext(0), ArgumentException);
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/SleepingEventHandler.cpp ./Disruptor.Tests/SleepingEventHandler.cpp
--- ../Disruptor-cpp/Disruptor.Tests/SleepingEventHandler.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/SleepingEventHandler.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,16 +0,0 @@
-#include "stdafx.h"
-#include "SleepingEventHandler.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    void SleepingEventHandler::onEvent(TestEvent& /*data*/, std::int64_t /*sequence*/, bool /*endOfBatch*/)
-    {
-        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
-    }
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/SleepingEventHandler.h ./Disruptor.Tests/SleepingEventHandler.h
--- ../Disruptor-cpp/Disruptor.Tests/SleepingEventHandler.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/SleepingEventHandler.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,20 +0,0 @@
-#pragma once
-
-#include "Disruptor/IEventHandler.h"
-
-#include "Disruptor.Tests/TestEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-    
-    class SleepingEventHandler : public IEventHandler< TestEvent >
-    {
-    public:
-        void onEvent(TestEvent& data, std::int64_t sequence, bool endOfBatch) override;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/SleepingWaitStrategyTests.cpp ./Disruptor.Tests/SleepingWaitStrategyTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/SleepingWaitStrategyTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/SleepingWaitStrategyTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,18 +0,0 @@
-#include "stdafx.h"
-
-#include "Disruptor/SleepingWaitStrategy.h"
-#include "WaitStrategyTestUtil.h"
-
-
-using namespace Disruptor;
-using namespace Disruptor::Tests;
-
-
-BOOST_AUTO_TEST_SUITE(SleepingWaitStrategyTests)
-
-BOOST_AUTO_TEST_CASE(ShouldWaitForValue)
-{
-    assertWaitForWithDelayOf(50, std::make_shared< SleepingWaitStrategy >());
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/SpinWaitWaitStrategyTests.cpp ./Disruptor.Tests/SpinWaitWaitStrategyTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/SpinWaitWaitStrategyTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/SpinWaitWaitStrategyTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,18 +0,0 @@
-#include "stdafx.h"
-
-#include "Disruptor/SpinWaitWaitStrategy.h"
-#include "WaitStrategyTestUtil.h"
-
-
-using namespace Disruptor;
-using namespace Disruptor::Tests;
-
-
-BOOST_AUTO_TEST_SUITE(SpinWaitWaitStrategyTests)
-
-BOOST_AUTO_TEST_CASE(ShouldWaitForValue)
-{
-    assertWaitForWithDelayOf(50, std::make_shared< SpinWaitWaitStrategy >());
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/StubEvent.cpp ./Disruptor.Tests/StubEvent.cpp
--- ../Disruptor-cpp/Disruptor.Tests/StubEvent.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/StubEvent.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,75 +0,0 @@
-#include "stdafx.h"
-#include "StubEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    void StubEvent::TwoTranslator::translateTo(StubEvent& event, std::int64_t /*sequence*/, const std::int32_t& arg0, const std::string& arg1)
-    {
-        event.value(arg0);
-        event.testString(arg1);
-    }
-
-    StubEvent::StubEvent(int i)
-        : m_value(i)
-    {
-    }
-
-    int StubEvent::value() const
-    {
-        return m_value;
-    }
-
-    void StubEvent::value(int i)
-    {
-        m_value = i;
-    }
-
-    std::string StubEvent::testString() const
-    {
-        return m_testString;
-    }
-
-    void StubEvent::testString(std::string x)
-    {
-        m_testString = x;
-    }
-
-    void StubEvent::copy(const StubEvent& evt)
-    {
-        m_value = evt.m_value;
-    }
-
-    bool StubEvent::operator==(const StubEvent& rhs) const
-    {
-        return m_value == rhs.m_value;
-    }
-
-    const std::shared_ptr< StubEvent::TwoTranslator >& StubEvent::translator()
-    {
-        static auto result(std::make_shared< TwoTranslator >());
-        return result;
-    }
-
-    const std::function< StubEvent() >& StubEvent::eventFactory()
-    {
-        static std::function< StubEvent() > result([] { return StubEvent(-1); });
-        return result;
-    }
-
-} // namespace Tests
-} // namespace Disruptor
-
-
-namespace std
-{
-
-    ostream& operator<<(ostream& stream, const Disruptor::Tests::StubEvent& event)
-    {
-        return stream << "Value: " << event.value() << ", TestString: " << event.testString();
-    }
-
-} // namespace std
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/StubEvent.h ./Disruptor.Tests/StubEvent.h
--- ../Disruptor-cpp/Disruptor.Tests/StubEvent.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/StubEvent.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,69 +0,0 @@
-#pragma once
-
-#include <cstdint>
-#include <string>
-
-#include "Disruptor/IEventTranslatorVararg.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    class StubEvent
-    {
-        typedef IEventTranslatorVararg< StubEvent, std::int32_t, std::string > EventTranslatorType;
-
-        class TwoTranslator : public EventTranslatorType
-        {
-        public:
-            void translateTo(StubEvent& event, std::int64_t sequence, const std::int32_t& arg0, const std::string& arg1) override;
-        };
-
-    public:
-        StubEvent()
-            : m_value(0)
-            , m_testString()
-        {}
-
-        explicit StubEvent(int i);
-
-        void operator=(const StubEvent& other)
-        {
-            m_value = other.m_value;
-            m_testString = other.m_testString;
-        }
-
-        int value() const;
-        void value(int i);
-
-        std::string testString() const;
-        void testString(std::string x);
-
-        void copy(const StubEvent& evt);
-
-        bool operator==(const StubEvent& rhs) const;
-
-        static const std::shared_ptr< TwoTranslator >& translator();
-
-        static const std::function< StubEvent() >& eventFactory();
-
-    private:
-        int m_value;
-        std::string m_testString;
-    };
-    
-} // namespace Tests
-} // namespace Disruptor
-
-
-#include <ostream>
-
-
-namespace std
-{
-
-    ostream& operator<<(ostream& stream, const Disruptor::Tests::StubEvent& event);
-
-} // namespace std
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/StubExceptionHandler.h ./Disruptor.Tests/StubExceptionHandler.h
--- ../Disruptor-cpp/Disruptor.Tests/StubExceptionHandler.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/StubExceptionHandler.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,47 +0,0 @@
-#pragma once
-
-#include "Disruptor/IExceptionHandler.h"
-
-#include "Disruptor.Tests/AtomicReference.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    template <class T>
-    class StubExceptionHandler : public IExceptionHandler< T >
-    {
-    public:
-        explicit StubExceptionHandler(const std::shared_ptr< AtomicReference< std::exception > >& exceptionHandled)
-            : m_exceptionHandled(exceptionHandled)
-        {
-        }
-
-        void handleEventException(const std::exception& ex, std::int64_t /*sequence*/, T& /*evt*/) override
-        {
-            m_exceptionHandled->write(ex);
-        }
-
-        void handleOnStartException(const std::exception& ex) override
-        {
-            m_exceptionHandled->write(ex);
-        }
-
-        void handleOnShutdownException(const std::exception& ex) override
-        {
-            m_exceptionHandled->write(ex);
-        }
-
-        void handleOnTimeoutException(const std::exception& ex, std::int64_t /*sequence*/) override
-        {
-            m_exceptionHandled->write(ex);
-        }
-
-    private:
-        std::shared_ptr< AtomicReference< std::exception > > m_exceptionHandled;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/StubExecutor.cpp ./Disruptor.Tests/StubExecutor.cpp
--- ../Disruptor-cpp/Disruptor.Tests/StubExecutor.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/StubExecutor.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,65 +0,0 @@
-#include "stdafx.h"
-#include "StubExecutor.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    std::future< void > StubExecutor::execute(const std::function< void() >& command)
-    {
-        ++m_executionCount;
-
-        std::future< void > result;
-
-        if (!m_ignoreExecutions)
-        {
-            std::packaged_task< void() > task(command);
-            result = task.get_future();
-
-            std::lock_guard< decltype(m_mutex) > lock(m_mutex);
-            m_threads.push_back(boost::thread(std::move(task)));
-        }
-
-        return result;
-    }
-
-    void StubExecutor::joinAllThreads()
-    {
-        std::lock_guard< decltype(m_mutex) > lock(m_mutex);
-
-        while (!m_threads.empty())
-        {
-            boost::thread thread(std::move(m_threads.front()));
-            m_threads.pop_front();
-
-            if (thread.joinable())
-            {
-                try
-                {
-                    thread.interrupt();
-                    thread.timed_join(boost::posix_time::milliseconds(5000));
-                }
-                catch (std::exception& ex)
-                {
-                    std::cout << ex.what() << std::endl;
-                }
-            }
-
-            BOOST_CHECK_MESSAGE(thread.joinable() == false, "Failed to stop thread: " << thread.get_id());
-        }
-    }
-
-    void StubExecutor::ignoreExecutions()
-    {
-        m_ignoreExecutions = true;
-    }
-
-    std::int32_t StubExecutor::getExecutionCount() const
-    {
-        return m_executionCount;
-    }
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/StubExecutor.h ./Disruptor.Tests/StubExecutor.h
--- ../Disruptor-cpp/Disruptor.Tests/StubExecutor.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/StubExecutor.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,42 +0,0 @@
-#pragma once
-
-#include <atomic>
-#include <cstdint>
-#include <deque>
-
-#include <boost/thread.hpp>
-
-#include "Disruptor/IExecutor.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    class StubExecutor : public IExecutor
-    {
-    public:
-        StubExecutor() 
-           : m_ignoreExecutions(false)
-           , m_executionCount(0)
-        {}
-
-        std::future< void > execute(const std::function< void() >& command) override;
-
-        void joinAllThreads();
-
-        void ignoreExecutions();
-
-        std::int32_t getExecutionCount() const;
-
-    private:
-        std::recursive_mutex m_mutex;
-        std::deque< boost::thread > m_threads;
-        std::atomic< bool > m_ignoreExecutions;
-        std::atomic< std::int32_t > m_executionCount;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
-
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/StubPublisher.cpp ./Disruptor.Tests/StubPublisher.cpp
--- ../Disruptor-cpp/Disruptor.Tests/StubPublisher.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/StubPublisher.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,40 +0,0 @@
-
-#include "stdafx.h"
-#include "StubPublisher.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    StubPublisher::StubPublisher(const std::shared_ptr< RingBuffer< TestEvent > >& ringBuffer)
-        : m_running(true)
-        , m_publicationCount(0)
-    {
-        m_ringBuffer = ringBuffer;
-    }
-
-    void StubPublisher::run()
-    {
-        while (m_running)
-        {
-            auto sequence = m_ringBuffer->next();
-            m_ringBuffer->publish(sequence);
-            ++m_publicationCount;
-        }
-    }
-
-    std::int32_t StubPublisher::getPublicationCount() const
-    {
-        return m_publicationCount;
-    }
-
-    void StubPublisher::halt()
-    {
-        m_running = false;
-    }
-
-} // namespace Tests
-} // namespace Disruptor
-
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/StubPublisher.h ./Disruptor.Tests/StubPublisher.h
--- ../Disruptor-cpp/Disruptor.Tests/StubPublisher.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/StubPublisher.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,36 +0,0 @@
-#pragma once
-
-#include <atomic>
-#include <cstdint>
-#include <memory>
-
-#include "Disruptor/RingBuffer.h"
-
-#include "Disruptor.Tests/TestEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    class StubPublisher
-    {
-    public:
-        explicit StubPublisher(const std::shared_ptr< RingBuffer< TestEvent > >& ringBuffer);
-
-        void run();
-
-        std::int32_t getPublicationCount() const;
-
-        void halt();
-
-    private:
-        std::atomic< bool > m_running;
-        std::atomic< std::int32_t > m_publicationCount;
-
-        std::shared_ptr< RingBuffer< TestEvent > > m_ringBuffer;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/TestEvent.h ./Disruptor.Tests/TestEvent.h
--- ../Disruptor-cpp/Disruptor.Tests/TestEvent.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/TestEvent.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,14 +0,0 @@
-#pragma once
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    class TestEvent
-    {
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/TestWaiter.cpp ./Disruptor.Tests/TestWaiter.cpp
--- ../Disruptor-cpp/Disruptor.Tests/TestWaiter.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/TestWaiter.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,38 +0,0 @@
-#include "stdafx.h"
-#include "TestWaiter.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    TestWaiter::TestWaiter(const std::shared_ptr< boost::barrier >& barrier,
-                           const std::shared_ptr< ISequenceBarrier >& sequenceBarrier,
-                           const std::shared_ptr< RingBuffer< StubEvent > >& ringBuffer,
-                           std::int64_t initialSequence,
-                           std::int64_t toWaitForSequence)
-        : m_barrier(barrier)
-        , m_sequenceBarrier(sequenceBarrier)
-        , m_ringBuffer(ringBuffer)
-        , m_initialSequence(initialSequence)
-        , m_toWaitForSequence(toWaitForSequence)
-    {
-    }
-
-    std::vector< StubEvent > TestWaiter::call() const
-    {
-        m_barrier->wait();
-        m_sequenceBarrier->waitFor(m_toWaitForSequence);
-
-        std::vector< StubEvent > events;
-        for (auto l = m_initialSequence; l <= m_toWaitForSequence; ++l)
-        {
-            events.push_back((*m_ringBuffer)[l]);
-        }
-
-        return events;
-    }
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/TestWaiter.h ./Disruptor.Tests/TestWaiter.h
--- ../Disruptor-cpp/Disruptor.Tests/TestWaiter.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/TestWaiter.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,37 +0,0 @@
-#pragma once
-
-#include <memory>
-#include <boost/thread/barrier.hpp>
-
-#include "Disruptor/ISequenceBarrier.h"
-#include "Disruptor/RingBuffer.h"
-
-#include "Disruptor.Tests/StubEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    class TestWaiter
-    {
-    public:
-        TestWaiter(const std::shared_ptr< boost::barrier >& barrier,
-                   const std::shared_ptr< ISequenceBarrier >& sequenceBarrier,
-                   const std::shared_ptr< RingBuffer< StubEvent > >& ringBuffer,
-                   std::int64_t initialSequence,
-                   std::int64_t toWaitForSequence);
-
-        std::vector< StubEvent > call() const;
-
-    private:
-        std::shared_ptr< boost::barrier > m_barrier;
-        std::shared_ptr< ISequenceBarrier > m_sequenceBarrier;
-        std::shared_ptr< RingBuffer< StubEvent > > m_ringBuffer;
-        std::int64_t m_initialSequence;
-        std::int64_t m_toWaitForSequence;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/TestWorkHandler.cpp ./Disruptor.Tests/TestWorkHandler.cpp
--- ../Disruptor-cpp/Disruptor.Tests/TestWorkHandler.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/TestWorkHandler.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,34 +0,0 @@
-#include "stdafx.h"
-#include "TestWorkHandler.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    void TestWorkHandler::onEvent(TestEvent& /*evt*/)
-    {
-        waitForAndSetFlag(0);
-    }
-
-    void TestWorkHandler::processEvent()
-    {
-        waitForAndSetFlag(1);
-    }
-
-    void TestWorkHandler::stopWaiting()
-    {
-        m_stopped = true;
-    }
-
-    void TestWorkHandler::waitForAndSetFlag(std::int32_t newValue)
-    {
-        while (!m_stopped && std::atomic_exchange(&m_readyToProcessEvent, newValue) == newValue)
-        {
-            std::this_thread::yield();
-        }
-    }
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/TestWorkHandler.h ./Disruptor.Tests/TestWorkHandler.h
--- ../Disruptor-cpp/Disruptor.Tests/TestWorkHandler.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/TestWorkHandler.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,38 +0,0 @@
-#pragma once
-
-#include <atomic>
-#include <cstdint>
-
-#include "Disruptor/IWorkHandler.h"
-
-#include "Disruptor.Tests/TestEvent.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    class TestWorkHandler : public IWorkHandler< TestEvent >
-    {
-    public:
-        TestWorkHandler() 
-            : m_readyToProcessEvent(0)
-            , m_stopped(false)
-        {}
-
-        void onEvent(TestEvent& evt) override;
-
-        void processEvent();
-
-        void stopWaiting();
-
-    private:
-        void waitForAndSetFlag(std::int32_t newValue);
-
-        std::atomic< std::int32_t > m_readyToProcessEvent;
-        std::atomic< bool > m_stopped;
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/TimeoutBlockingWaitStrategyTests.cpp ./Disruptor.Tests/TimeoutBlockingWaitStrategyTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/TimeoutBlockingWaitStrategyTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/TimeoutBlockingWaitStrategyTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,44 +0,0 @@
-#include "stdafx.h"
-
-#include "Disruptor/Sequence.h"
-#include "Disruptor/TimeoutBlockingWaitStrategy.h"
-#include "Disruptor/TimeoutException.h"
-
-#include "SequenceBarrierMock.h"
-
-
-using namespace Disruptor;
-
-
-BOOST_AUTO_TEST_SUITE(TimeoutBlockingWaitStrategyTest)
-
-BOOST_AUTO_TEST_CASE(ShouldTimeoutWaitFor)
-{
-    auto sequenceBarrierMock = std::make_shared< testing::NiceMock< Tests::SequenceBarrierMock > >();
-
-    auto theTimeout = std::chrono::milliseconds(500);
-    auto waitStrategy = std::make_shared< TimeoutBlockingWaitStrategy >(theTimeout);
-    auto cursor = std::make_shared< Sequence >(5);
-    const auto& dependent = cursor;
-
-    EXPECT_CALL(*sequenceBarrierMock, checkAlert()).Times(testing::AtLeast(1));
-
-    auto t0 = ClockConfig::Clock::now();
-
-    try
-    {
-        waitStrategy->waitFor(6, *cursor, *dependent, *sequenceBarrierMock);
-        throw std::runtime_error("TimeoutException should have been thrown");
-    }
-    catch (TimeoutException&)
-    {
-    }
-
-    auto t1 = ClockConfig::Clock::now();
-
-    auto timeWaiting = t1 - t0;
-
-    BOOST_CHECK(timeWaiting >= theTimeout);
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/UtilTests.cpp ./Disruptor.Tests/UtilTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/UtilTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/UtilTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,36 +0,0 @@
-#include "stdafx.h"
-
-#include "Disruptor/Sequence.h"
-#include "Disruptor/Util.h"
-
-
-using namespace Disruptor;
-
-
-BOOST_AUTO_TEST_SUITE(UtilTests)
-
-BOOST_AUTO_TEST_CASE(ShouldReturnNextPowerOfTwo)
-{
-    auto powerOfTwo = Util::ceilingNextPowerOfTwo(1000);
-
-    BOOST_CHECK_EQUAL(1024, powerOfTwo);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldReturnExactPowerOfTwo)
-{
-    auto powerOfTwo = Util::ceilingNextPowerOfTwo(1024);
-
-    BOOST_CHECK_EQUAL(1024, powerOfTwo);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldReturnMinimumSequence)
-{
-    BOOST_CHECK_EQUAL(4L, Util::getMinimumSequence({ std::make_shared< Sequence >(11), std::make_shared< Sequence >(4), std::make_shared< Sequence >(13) }));
-}
-
-BOOST_AUTO_TEST_CASE(ShouldReturnLongMaxWhenNoEventProcessors)
-{
-    BOOST_CHECK_EQUAL(std::numeric_limits< std::int64_t >::max(), Util::getMinimumSequence({ }));
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/WaitStrategyMock.h ./Disruptor.Tests/WaitStrategyMock.h
--- ../Disruptor-cpp/Disruptor.Tests/WaitStrategyMock.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/WaitStrategyMock.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,27 +0,0 @@
-#pragma once
-
-#include <cstdint>
-#include <memory>
-
-#include <gmock/gmock.h>
-
-#include "Disruptor/IWaitStrategy.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    class WaitStrategyMock : public IWaitStrategy
-    {
-    public:
-        MOCK_METHOD4(waitFor, std::int64_t(std::int64_t sequence, Sequence& cursor, ISequence& dependentSequence, ISequenceBarrier& barrier));
-
-        MOCK_METHOD0(signalAllWhenBlocking, void());
-        
-        MOCK_CONST_METHOD1(writeDescriptionTo, void(std::ostream& stream));
-    };
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/WaitStrategyTestUtil.cpp ./Disruptor.Tests/WaitStrategyTestUtil.cpp
--- ../Disruptor-cpp/Disruptor.Tests/WaitStrategyTestUtil.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/WaitStrategyTestUtil.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,29 +0,0 @@
-#include "stdafx.h"
-#include "WaitStrategyTestUtil.h"
-
-#include "Disruptor/IWaitStrategy.h"
-#include "Disruptor/Sequence.h"
-
-#include "DummySequenceBarrier.h"
-#include "SequenceUpdater.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-
-    void assertWaitForWithDelayOf(std::int64_t sleepTimeMillis, const std::shared_ptr< IWaitStrategy >& waitStrategy)
-    {
-        auto sequencerUpdater = std::make_shared< SequenceUpdater >(sleepTimeMillis, waitStrategy);
-        std::thread([=] { sequencerUpdater->run(); }).detach();
-        sequencerUpdater->waitForStartup();
-        auto cursor = std::make_shared< Sequence >(0);
-        auto barrier = std::make_shared< DummySequenceBarrier >();
-        auto sequence = waitStrategy->waitFor(0, *cursor, *sequencerUpdater->sequence, *barrier);
-
-        BOOST_CHECK_EQUAL(sequence, 0L);
-    }
-    
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/WaitStrategyTestUtil.h ./Disruptor.Tests/WaitStrategyTestUtil.h
--- ../Disruptor-cpp/Disruptor.Tests/WaitStrategyTestUtil.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/WaitStrategyTestUtil.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,19 +0,0 @@
-#pragma once
-
-#include <cstdint>
-#include <memory>
-
-
-namespace Disruptor
-{
-
-    class IWaitStrategy;
-
-
-namespace Tests
-{
-
-    void assertWaitForWithDelayOf(std::int64_t sleepTimeMillis, const std::shared_ptr< IWaitStrategy >& waitStrategy);
-
-} // namespace Tests
-} // namespace Disruptor
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/WorkerPoolTests.cpp ./Disruptor.Tests/WorkerPoolTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/WorkerPoolTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/WorkerPoolTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,110 +0,0 @@
-#include "stdafx.h"
-
-#include "Disruptor/BasicExecutor.h"
-#include "Disruptor/FatalExceptionHandler.h"
-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
-#include "Disruptor/WorkerPool.h"
-
-
-namespace Disruptor
-{
-namespace Tests
-{
-    
-    class AtomicLong
-    {
-    public:
-        AtomicLong() : m_value(0)
-        {}
-
-        AtomicLong(const AtomicLong& other)
-            : m_value(other.value())
-        {}
-
-        void operator=(const AtomicLong& other)
-        {
-            m_value = other.value();
-        }
-
-        std::int64_t value() const
-        {
-            return m_value;
-        }
-
-        void increment()
-        {
-            ++m_value;
-        }
-
-    private:
-        std::atomic< std::int64_t > m_value;
-    };
-
-    class AtomicLongWorkHandler : public IWorkHandler< AtomicLong >
-    {
-    public:
-        void onEvent(AtomicLong& evt) override
-        {
-            evt.increment();
-        }
-    };
-
-} // namespace Tests
-} // namespace Disruptor
-
-
-using namespace Disruptor;
-using namespace Disruptor::Tests;
-
-
-BOOST_AUTO_TEST_SUITE(WorkerPoolTests)
-
-BOOST_AUTO_TEST_CASE(ShouldProcessEachMessageByOnlyOneWorker)
-{
-    auto taskScheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
-    taskScheduler->start(2);
-
-    WorkerPool< AtomicLong > pool
-    (
-        [] { return AtomicLong(); },
-        std::make_shared< FatalExceptionHandler< AtomicLong > >(),
-        { std::make_shared< AtomicLongWorkHandler >(), std::make_shared< AtomicLongWorkHandler >() }
-    );
-
-    auto ringBuffer = pool.start(std::make_shared< BasicExecutor >(taskScheduler));
-
-    ringBuffer->next();
-    ringBuffer->next();
-    ringBuffer->publish(0);
-    ringBuffer->publish(1);
-
-    std::this_thread::sleep_for(std::chrono::milliseconds(500));
-
-    BOOST_CHECK_EQUAL((*ringBuffer)[0].value(), 1L);
-    BOOST_CHECK_EQUAL((*ringBuffer)[1].value(), 1L);
-}
-
-BOOST_AUTO_TEST_CASE(ShouldProcessOnlyOnceItHasBeenPublished)
-{
-    auto taskScheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
-    taskScheduler->start(2);
-
-    WorkerPool< AtomicLong > pool
-    (
-        [] { return AtomicLong(); },
-        std::make_shared< FatalExceptionHandler< AtomicLong > >(),
-        { std::make_shared< AtomicLongWorkHandler >(), std::make_shared< AtomicLongWorkHandler >() }
-    );
-
-    auto ringBuffer = pool.start(std::make_shared< BasicExecutor >(taskScheduler));
-
-    ringBuffer->next();
-    ringBuffer->next();
-
-    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
-
-    BOOST_CHECK_EQUAL((*ringBuffer)[0].value(), 0L);
-    BOOST_CHECK_EQUAL((*ringBuffer)[1].value(), 0L);
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/YieldingWaitStrategyTests.cpp ./Disruptor.Tests/YieldingWaitStrategyTests.cpp
--- ../Disruptor-cpp/Disruptor.Tests/YieldingWaitStrategyTests.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/YieldingWaitStrategyTests.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,18 +0,0 @@
-#include "stdafx.h"
-
-#include "Disruptor/YieldingWaitStrategy.h"
-#include "WaitStrategyTestUtil.h"
-
-
-using namespace Disruptor;
-using namespace Disruptor::Tests;
-
-
-BOOST_AUTO_TEST_SUITE(YieldingWaitStrategyTests)
-
-BOOST_AUTO_TEST_CASE(ShouldWaitForValue)
-{
-    assertWaitForWithDelayOf(50, std::make_shared< YieldingWaitStrategy >());
-}
-
-BOOST_AUTO_TEST_SUITE_END()
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/main.cpp ./Disruptor.Tests/main.cpp
--- ../Disruptor-cpp/Disruptor.Tests/main.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/main.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,32 +0,0 @@
-#define BOOST_TEST_MODULE Disruptor.Tests
-
-
-#include <boost/test/unit_test.hpp>
-#include <boost/test/results_reporter.hpp>
-
-#include <gmock/gmock.h>
-
-#if _MSC_VER
-# pragma warning (disable: 4231) // nonstandard extension used : 'extern' before template explicit instantiation
-#endif
-
-struct GlobalFixture
-{
-    GlobalFixture()
-    {
-        // all passed test names are printed to the output
-        boost::unit_test::unit_test_log.set_threshold_level(boost::unit_test::log_test_units);
-        // a very small report is printed to the output (passed tests count / total tests count)
-        boost::unit_test::results_reporter::set_level(boost::unit_test::SHORT_REPORT);
-
-        testing::GTEST_FLAG(throw_on_failure) = true;
-        testing::InitGoogleMock(&boost::unit_test::framework::master_test_suite().argc, boost::unit_test::framework::master_test_suite().argv);
-    }
-
-    ~GlobalFixture()
-    {
-    }
-};
-
-BOOST_GLOBAL_FIXTURE(GlobalFixture);
-
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/postbuild.bat ./Disruptor.Tests/postbuild.bat
--- ../Disruptor-cpp/Disruptor.Tests/postbuild.bat	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/postbuild.bat	1969-12-31 19:00:00.000000000 -0500
@@ -1,14 +0,0 @@
-@setlocal
-@echo off
-
-rem VS post build step command line sample:
-rem call postbuild.bat $(OutDir) $(Configuration) $(Platform) $(PlatformToolsetVersion)
-
-set outdir=%1
-
-if not "%TEAMCITY_PROJECT_NAME%" == "" (
-    echo Running unit tests...
-    call "%outdir%\disruptor.Tests.exe" --detect_memory_leaks=0 --result_code=no
-)
-
-@endlocal
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/stdafx.cpp ./Disruptor.Tests/stdafx.cpp
--- ../Disruptor-cpp/Disruptor.Tests/stdafx.cpp	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/stdafx.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,8 +0,0 @@
-// stdafx.cpp : source file that includes just the standard includes
-// disruptorLibTests.pch will be the pre-compiled header
-// stdafx.obj will contain the pre-compiled type information
-
-#include "stdafx.h"
-
-// TODO: reference any additional headers you need in STDAFX.H
-// and not in this file
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/stdafx.h ./Disruptor.Tests/stdafx.h
--- ../Disruptor-cpp/Disruptor.Tests/stdafx.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/stdafx.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,38 +0,0 @@
-// stdafx.h : include file for standard system include files,
-// or project specific include files that are used frequently, but
-// are changed infrequently
-//
-
-#pragma once
-
-#include <boost/config.hpp>
-
-// STL
-#include <algorithm>
-#include <chrono>
-#include <cstdint>
-#include <functional>
-#include <future>
-#include <memory>
-#include <stdexcept>
-#include <string>
-#include <thread>
-#include <typeinfo>
-#include <unordered_map>
-#include <vector>
-
-// Boost.Test
-
-#include "Disruptor/Pragmas.h"
-
-DISRUPTOR_PRAGMA_PUSH
-DISRUPTOR_PRAGMA_IGNORE_ALL
-DISRUPTOR_PRAGMA_IGNORE_UNUSED_VARIABLES
-
-#include <boost/test/results_reporter.hpp>
-#include <boost/test/unit_test.hpp>
-
-DISRUPTOR_PRAGMA_POP
-
-// Google Mock
-#include <gmock/gmock.h>
diff -Naru -x .git ../Disruptor-cpp/Disruptor.Tests/targetver.h ./Disruptor.Tests/targetver.h
--- ../Disruptor-cpp/Disruptor.Tests/targetver.h	2021-01-27 10:59:26.000000000 -0500
+++ ./Disruptor.Tests/targetver.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,8 +0,0 @@
-#pragma once
-
-// Including SDKDDKVer.h defines the highest available Windows platform.
-
-// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
-// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.
-
-#include <SDKDDKVer.h>
diff -Naru -x .git ../Disruptor-cpp/disruptorCppGitPatch ./disruptorCppGitPatch
--- ../Disruptor-cpp/disruptorCppGitPatch	1969-12-31 19:00:00.000000000 -0500
+++ ./disruptorCppGitPatch	2021-01-22 12:33:36.000000000 -0500
@@ -0,0 +1,12388 @@
+diff --git a/Disruptor.PerfTests/CMakeLists.txt b/Disruptor.PerfTests/CMakeLists.txt
+deleted file mode 100644
+index 45586eb..0000000
+--- a/Disruptor.PerfTests/CMakeLists.txt
++++ /dev/null
+@@ -1,60 +0,0 @@
+-project(Disruptor.PerfTests)
+-cmake_minimum_required(VERSION 2.6)
+-
+-
+-find_package(Boost COMPONENTS system thread date_time)
+-if(Boost_FOUND)
+-    include_directories(${Boost_INCLUDE_DIRS})
+-    link_directories(${Boost_LIBRARY_DIRS})
+-endif()
+-
+-include_directories("..")
+-
+-
+-set(DisruptorPerfTests_sources
+-
+-    main.cpp
+-
+-    EventCountingQueueProcessor.cpp
+-    EventCountingWorkHandler.cpp
+-    FizzBuzzEvent.cpp
+-    FizzBuzzEventHandler.cpp
+-    FunctionEvent.cpp
+-    FunctionEventHandler.cpp
+-    LatencyTestSession.cpp
+-    LatencyTestSessionResult.cpp
+-    LongArrayEventHandler.cpp
+-    MutableLong.cpp
+-    OneToOneRawBatchThroughputTest.cpp
+-    OneToOneRawThroughputTest.cpp
+-    OneToOneSequencedBatchThroughputTest.cpp
+-    OneToOneSequencedLongArrayThroughputTest.cpp
+-    OneToOneSequencedPollerThroughputTest.cpp
+-    OneToOneSequencedThroughputTest.cpp
+-    OneToOneTranslatorThroughputTest.cpp
+-    OneToThreeDiamondSequencedThroughputTest.cpp
+-    OneToThreePipelineSequencedThroughputTest.cpp
+-    OneToThreeReleasingWorkerPoolThroughputTest.cpp
+-    OneToThreeSequencedThroughputTest.cpp
+-    OneToThreeWorkerPoolThroughputTest.cpp
+-    Operation.cpp
+-    PerfTestUtil.cpp
+-    PingPongSequencedLatencyTest.cpp
+-    TestRepository.cpp
+-    ThreeToOneSequencedBatchThroughputTest.cpp
+-    ThreeToOneSequencedThroughputTest.cpp
+-    ThreeToThreeSequencedThroughputTest.cpp
+-    ThroughputTestSession.cpp
+-    ThroughputTestSessionResult.cpp
+-    TwoToTwoWorkProcessorThroughputTest.cpp
+-    ValueAdditionEventHandler.cpp
+-    ValueEvent.cpp
+-    ValueMutationEventHandler.cpp
+-)
+-
+-add_definitions(-DBOOST_TEST_DYN_LINK)
+-
+-add_executable(Disruptor.PerfTests ${DisruptorPerfTests_sources})
+-target_link_libraries(Disruptor.PerfTests DisruptorStatic Disruptor.TestTools ${Boost_LIBRARIES} pthread)
+-
+-add_custom_target(performance_test ${CMAKE_CURRENT_BINARY_DIR}/Disruptor.PerfTests)
+diff --git a/Disruptor.PerfTests/EventCountingQueueProcessor.cpp b/Disruptor.PerfTests/EventCountingQueueProcessor.cpp
+deleted file mode 100644
+index 4067cd2..0000000
+--- a/Disruptor.PerfTests/EventCountingQueueProcessor.cpp
++++ /dev/null
+@@ -1,39 +0,0 @@
+-#include "stdafx.h"
+-#include "EventCountingQueueProcessor.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    EventCountingQueueProcessor::EventCountingQueueProcessor(const std::shared_ptr< BlockingQueue< std::int64_t > >& blockingQueue,
+-                                                             const std::vector< std::shared_ptr< PaddedLong > >& counters,
+-                                                             std::int32_t index)
+-        : m_running(false)
+-        , m_blockingQueue(blockingQueue)
+-        , m_counters(counters)
+-        , m_index(index)
+-    {
+-    }
+-
+-    void EventCountingQueueProcessor::halt()
+-    {
+-        m_running = false;
+-    }
+-
+-    void EventCountingQueueProcessor::run()
+-    {
+-        m_running = true;
+-        while (m_running)
+-        {
+-            std::int64_t item;
+-            if (!m_blockingQueue->timedWaitAndPop(item, std::chrono::microseconds(100)))
+-                continue;
+-
+-            m_counters[m_index]->value = m_counters[m_index]->value + 1L;
+-        }
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/EventCountingQueueProcessor.h b/Disruptor.PerfTests/EventCountingQueueProcessor.h
+deleted file mode 100644
+index 6019c77..0000000
+--- a/Disruptor.PerfTests/EventCountingQueueProcessor.h
++++ /dev/null
+@@ -1,37 +0,0 @@
+-#pragma once
+-
+-#include <atomic>
+-#include <cstdint>
+-#include <memory>
+-#include <vector>
+-
+-#include "Disruptor/BlockingQueue.h"
+-
+-#include "Disruptor.PerfTests/PaddedLong.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class EventCountingQueueProcessor
+-    {
+-    public:
+-        EventCountingQueueProcessor(const std::shared_ptr< BlockingQueue< std::int64_t > >& blockingQueue,
+-                                    const std::vector< std::shared_ptr< PaddedLong > >& counters,
+-                                    std::int32_t index);
+-
+-        void halt();
+-
+-        void run();
+-
+-    private:
+-        std::atomic< bool > m_running;
+-        std::shared_ptr< BlockingQueue< std::int64_t > > m_blockingQueue;
+-        std::vector< std::shared_ptr< PaddedLong > > m_counters;
+-        std::int32_t m_index;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/EventCountingWorkHandler.cpp b/Disruptor.PerfTests/EventCountingWorkHandler.cpp
+deleted file mode 100644
+index ab239aa..0000000
+--- a/Disruptor.PerfTests/EventCountingWorkHandler.cpp
++++ /dev/null
+@@ -1,22 +0,0 @@
+-#include "stdafx.h"
+-#include "EventCountingWorkHandler.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    EventCountingWorkHandler::EventCountingWorkHandler(const std::vector< std::shared_ptr< PaddedLong > >& counters, std::int32_t index)
+-        : m_counters(counters)
+-        , m_index(index)
+-    {
+-    }
+-
+-    void EventCountingWorkHandler::onEvent(ValueEvent& /*evt*/)
+-    {
+-        m_counters[m_index]->value = m_counters[m_index]->value + 1L;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/EventCountingWorkHandler.h b/Disruptor.PerfTests/EventCountingWorkHandler.h
+deleted file mode 100644
+index 3a1221e..0000000
+--- a/Disruptor.PerfTests/EventCountingWorkHandler.h
++++ /dev/null
+@@ -1,31 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-#include <memory>
+-#include <vector>
+-
+-#include "Disruptor/IWorkHandler.h"
+-
+-#include "Disruptor.PerfTests/PaddedLong.h"
+-#include "Disruptor.PerfTests/ValueEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class EventCountingWorkHandler : public IWorkHandler< ValueEvent >
+-    {
+-    public:
+-        EventCountingWorkHandler(const std::vector< std::shared_ptr< PaddedLong > >& counters, std::int32_t index);
+-
+-        void onEvent(ValueEvent& evt) override;
+-
+-    private:
+-        std::vector< std::shared_ptr< PaddedLong > > m_counters;
+-        std::int32_t m_index;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/ExecutorService.h b/Disruptor.PerfTests/ExecutorService.h
+deleted file mode 100644
+index c61ca0f..0000000
+--- a/Disruptor.PerfTests/ExecutorService.h
++++ /dev/null
+@@ -1,25 +0,0 @@
+-#pragma once
+-
+-#include <future>
+-#include <memory>
+-
+-#include "Disruptor/BatchEventProcessor.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    template <class T>
+-    class ExecutorService
+-    {
+-    public:
+-        std::future< void > submit(const std::shared_ptr< BatchEventProcessor< T > >& eventProcessor)
+-        {
+-            return std::async(std::launch::async, [eventProcessor] { eventProcessor->run(); });
+-        }
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/FizzBuzzEvent.cpp b/Disruptor.PerfTests/FizzBuzzEvent.cpp
+deleted file mode 100644
+index 6e87691..0000000
+--- a/Disruptor.PerfTests/FizzBuzzEvent.cpp
++++ /dev/null
+@@ -1,24 +0,0 @@
+-#include "stdafx.h"
+-#include "FizzBuzzEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    void FizzBuzzEvent::reset()
+-    {
+-        value = 0;
+-        fizz = false;
+-        buzz = false;
+-    }
+-
+-    const std::function< FizzBuzzEvent() >& FizzBuzzEvent::eventFactory()
+-    {
+-        static std::function< FizzBuzzEvent() > result([] { return FizzBuzzEvent(); });
+-        return result;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/FizzBuzzEvent.h b/Disruptor.PerfTests/FizzBuzzEvent.h
+deleted file mode 100644
+index f306426..0000000
+--- a/Disruptor.PerfTests/FizzBuzzEvent.h
++++ /dev/null
+@@ -1,26 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-#include <functional>
+-#include <memory>
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class FizzBuzzEvent
+-    {
+-    public:
+-        void reset();
+-
+-        static const std::function< FizzBuzzEvent() >& eventFactory();
+-
+-        std::int64_t value = 0;
+-        bool fizz = false;
+-        bool buzz = false;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/FizzBuzzEventHandler.cpp b/Disruptor.PerfTests/FizzBuzzEventHandler.cpp
+deleted file mode 100644
+index 449c3df..0000000
+--- a/Disruptor.PerfTests/FizzBuzzEventHandler.cpp
++++ /dev/null
+@@ -1,54 +0,0 @@
+-#include "stdafx.h"
+-#include "FizzBuzzEventHandler.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    FizzBuzzEventHandler::FizzBuzzEventHandler(FizzBuzzStep fizzBuzzStep)
+-        : m_fizzBuzzStep(fizzBuzzStep)
+-    {
+-    }
+-
+-    std::int64_t FizzBuzzEventHandler::fizzBuzzCounter() const
+-    {
+-        return m_fizzBuzzCounter.value;
+-    }
+-
+-    void FizzBuzzEventHandler::reset(const std::shared_ptr< Tests::ManualResetEvent >& latch, std::int64_t iterations)
+-    {
+-        m_fizzBuzzCounter.value = 0;
+-        m_iterations = iterations;
+-        m_latch = latch;
+-    }
+-
+-    void FizzBuzzEventHandler::onEvent(FizzBuzzEvent& data, std::int64_t sequence, bool)
+-    {
+-        switch (m_fizzBuzzStep)
+-        {
+-        case FizzBuzzStep::Fizz:
+-            data.fizz = data.value % 3 == 0;
+-            break;
+-
+-        case FizzBuzzStep::Buzz:
+-            data.buzz = data.value % 5 == 0;
+-            break;
+-
+-        case FizzBuzzStep::FizzBuzz:
+-            if (data.fizz && data.buzz)
+-            {
+-                m_fizzBuzzCounter.value = m_fizzBuzzCounter.value + 1;
+-            }
+-            break;
+-        }
+-
+-        if (sequence == m_iterations - 1)
+-        {
+-            m_latch->set();
+-        }
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/FizzBuzzEventHandler.h b/Disruptor.PerfTests/FizzBuzzEventHandler.h
+deleted file mode 100644
+index 50ae2af..0000000
+--- a/Disruptor.PerfTests/FizzBuzzEventHandler.h
++++ /dev/null
+@@ -1,36 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/IEventHandler.h"
+-
+-#include "Disruptor.TestTools/ManualResetEvent.h"
+-
+-#include "Disruptor.PerfTests/FizzBuzzEvent.h"
+-#include "Disruptor.PerfTests/FizzBuzzStep.h"
+-#include "Disruptor.PerfTests/PaddedLong.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class FizzBuzzEventHandler : public IEventHandler< FizzBuzzEvent >
+-    {
+-    public:
+-        explicit FizzBuzzEventHandler(FizzBuzzStep fizzBuzzStep);
+-
+-        std::int64_t fizzBuzzCounter() const;
+-
+-        void reset(const std::shared_ptr< Tests::ManualResetEvent >& latch, std::int64_t iterations);
+-
+-        void onEvent(FizzBuzzEvent& data, std::int64_t sequence, bool /*endOfBatch*/) override;
+-
+-    private:
+-        FizzBuzzStep m_fizzBuzzStep;
+-        std::int64_t m_iterations = 0;
+-        std::shared_ptr< Tests::ManualResetEvent > m_latch;
+-        PaddedLong m_fizzBuzzCounter;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/FizzBuzzStep.h b/Disruptor.PerfTests/FizzBuzzStep.h
+deleted file mode 100644
+index 1be0249..0000000
+--- a/Disruptor.PerfTests/FizzBuzzStep.h
++++ /dev/null
+@@ -1,17 +0,0 @@
+-#pragma once
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    enum class FizzBuzzStep
+-    {
+-        Fizz,
+-        Buzz,
+-        FizzBuzz,
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/FunctionEvent.cpp b/Disruptor.PerfTests/FunctionEvent.cpp
+deleted file mode 100644
+index e1644fa..0000000
+--- a/Disruptor.PerfTests/FunctionEvent.cpp
++++ /dev/null
+@@ -1,17 +0,0 @@
+-#include "stdafx.h"
+-#include "FunctionEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    const std::function< FunctionEvent() >& FunctionEvent::eventFactory()
+-    {
+-        static std::function< FunctionEvent() > result([] { return FunctionEvent(); });
+-        return result;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/FunctionEvent.h b/Disruptor.PerfTests/FunctionEvent.h
+deleted file mode 100644
+index 547b92a..0000000
+--- a/Disruptor.PerfTests/FunctionEvent.h
++++ /dev/null
+@@ -1,24 +0,0 @@
+-#pragma once
+-
+-#include <functional>
+-#include <memory>
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class FunctionEvent
+-    {
+-    public:
+-        static const std::function< FunctionEvent() >& eventFactory();
+-
+-        std::int64_t operandOne = 0;
+-        std::int64_t operandTwo = 0;
+-        std::int64_t stepOneResult = 0;
+-        std::int64_t stepTwoResult = 0;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/FunctionEventHandler.cpp b/Disruptor.PerfTests/FunctionEventHandler.cpp
+deleted file mode 100644
+index 89168a3..0000000
+--- a/Disruptor.PerfTests/FunctionEventHandler.cpp
++++ /dev/null
+@@ -1,54 +0,0 @@
+-#include "stdafx.h"
+-#include "FunctionEventHandler.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    FunctionEventHandler::FunctionEventHandler(FunctionStep functionStep)
+-        : m_functionStep(functionStep)
+-    {
+-    }
+-
+-    std::int64_t FunctionEventHandler::stepThreeCounter() const
+-    {
+-        return m_counter.value;
+-    }
+-
+-    void FunctionEventHandler::reset(const std::shared_ptr< Tests::ManualResetEvent >& latch, std::int64_t iterations)
+-    {
+-        m_counter.value = 0;
+-        m_iterations = iterations;
+-        m_latch = latch;
+-    }
+-
+-    void FunctionEventHandler::onEvent(FunctionEvent& data, std::int64_t sequence, bool /*endOfBatch*/)
+-    {
+-        switch (m_functionStep)
+-        {
+-        case FunctionStep::One:
+-            data.stepOneResult = data.operandOne + data.operandTwo;
+-            break;
+-
+-        case FunctionStep::Two:
+-            data.stepTwoResult = data.stepOneResult + 3L;
+-            break;
+-
+-        case FunctionStep::Three:
+-            if ((data.stepTwoResult & 4L) == 4L)
+-            {
+-                m_counter.value = m_counter.value + 1;
+-            }
+-            break;
+-        }
+-
+-        if (sequence == m_iterations - 1)
+-        {
+-            m_latch->set();
+-        }
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/FunctionEventHandler.h b/Disruptor.PerfTests/FunctionEventHandler.h
+deleted file mode 100644
+index a0bb0ad..0000000
+--- a/Disruptor.PerfTests/FunctionEventHandler.h
++++ /dev/null
+@@ -1,38 +0,0 @@
+-#pragma once
+-
+-#include <memory>
+-
+-#include "Disruptor/IEventHandler.h"
+-
+-#include "Disruptor.TestTools/ManualResetEvent.h"
+-
+-#include "Disruptor.PerfTests/FunctionEvent.h"
+-#include "Disruptor.PerfTests/FunctionStep.h"
+-#include "Disruptor.PerfTests/PaddedLong.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class FunctionEventHandler : public IEventHandler< FunctionEvent >
+-    {
+-    public:
+-        explicit FunctionEventHandler(FunctionStep functionStep);
+-
+-        std::int64_t stepThreeCounter() const;
+-
+-        void reset(const std::shared_ptr< Tests::ManualResetEvent >& latch, std::int64_t iterations);
+-
+-        void onEvent(FunctionEvent& data, std::int64_t sequence, bool endOfBatch);
+-
+-    private:
+-        FunctionStep m_functionStep;
+-        PaddedLong m_counter;
+-        std::int64_t m_iterations{0};
+-        std::shared_ptr< Tests::ManualResetEvent > m_latch;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/FunctionStep.h b/Disruptor.PerfTests/FunctionStep.h
+deleted file mode 100644
+index 22622dd..0000000
+--- a/Disruptor.PerfTests/FunctionStep.h
++++ /dev/null
+@@ -1,17 +0,0 @@
+-#pragma once
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    enum class FunctionStep
+-    {
+-        One,
+-        Two,
+-        Three,
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/ILatencyTest.h b/Disruptor.PerfTests/ILatencyTest.h
+deleted file mode 100644
+index 9ebfe69..0000000
+--- a/Disruptor.PerfTests/ILatencyTest.h
++++ /dev/null
+@@ -1,25 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-
+-#include "Disruptor.TestTools/LatencyRecorder.h"
+-#include "Disruptor.TestTools/Stopwatch.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class ILatencyTest
+-    {
+-    public:
+-        virtual ~ILatencyTest() = default;
+-
+-        virtual void run(Stopwatch& stopwatch, const std::shared_ptr< Tests::LatencyRecorder >& latencyRecorder) = 0;
+-
+-        virtual std::int32_t requiredProcessorCount() const = 0;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/IThroughputTest.h b/Disruptor.PerfTests/IThroughputTest.h
+deleted file mode 100644
+index 773ee3e..0000000
+--- a/Disruptor.PerfTests/IThroughputTest.h
++++ /dev/null
+@@ -1,24 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-
+-#include "Disruptor.TestTools/Stopwatch.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class IThroughputTest
+-    {
+-    public:
+-        virtual ~IThroughputTest() = default;
+-
+-        virtual std::int64_t run(Stopwatch& stopwatch) = 0;
+-
+-        virtual std::int32_t requiredProcessorCount() const = 0;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/LatencyTestSession.cpp b/Disruptor.PerfTests/LatencyTestSession.cpp
+deleted file mode 100644
+index 85106f0..0000000
+--- a/Disruptor.PerfTests/LatencyTestSession.cpp
++++ /dev/null
+@@ -1,75 +0,0 @@
+-#include "stdafx.h"
+-#include "LatencyTestSession.h"
+-
+-#include "Disruptor.TestTools/LatencyRecorder.h"
+-#include "Disruptor.TestTools/Stopwatch.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    LatencyTestSession::LatencyTestSession(const LatencyTestInfo& testInfo)
+-    {
+-        m_testInfo = testInfo;
+-    }
+-
+-    void LatencyTestSession::run()
+-    {
+-        auto testInstance = m_testInfo.factory();
+-
+-        checkProcessorsRequirements(testInstance);
+-
+-        std::cout << "Latency Test to run => " << m_testInfo.name << ", Runs => " << m_runs << std::endl;
+-        std::cout << "Starting latency tests" << std::endl;;
+-
+-        Stopwatch stopwatch;
+-        for (auto i = 0; i < m_runs; ++i)
+-        {
+-            stopwatch.reset();
+-            auto histogram = std::make_shared< Tests::LatencyRecorder >(100000000L);
+-
+-            try
+-            {
+-                testInstance->run(stopwatch, histogram);
+-            }
+-            catch (std::exception& ex)
+-            {
+-                LatencyTestSessionResult result(ex);
+-                std::cout << result.toString() << std::endl;
+-                m_results.push_back(result);
+-                continue;
+-            }
+-
+-            LatencyTestSessionResult result(histogram, stopwatch.elapsed());
+-            std::cout << result.toString() << std::endl;
+-            m_results.push_back(result);
+-        }
+-    }
+-
+-    void LatencyTestSession::checkProcessorsRequirements(const std::shared_ptr< ILatencyTest >& test)
+-    {
+-        auto availableProcessors = static_cast< std::int32_t >(std::thread::hardware_concurrency());
+-        if (test->requiredProcessorCount() <= availableProcessors)
+-            return;
+-
+-        std::cout << "*** Warning ***: your system has insufficient processors to execute the test efficiently. " << std::endl;
+-        std::cout << "Processors required = " << test->requiredProcessorCount() << ", available = " << availableProcessors << std::endl;
+-    }
+-
+-    std::int64_t LatencyTestSession::convertStopwatchTicksToNano(double durationInTicks)
+-    {
+-        auto clockFrequency = static_cast< double >(ClockConfig::Duration::period::den) / static_cast< double >(ClockConfig::Duration::period::num);
+-        auto durationInNano = (durationInTicks / clockFrequency) * std::pow(10, 9);
+-        return static_cast< std::int64_t >(durationInNano);
+-    }
+-
+-    double LatencyTestSession::convertNanoToStopwatchTicks(std::int64_t pauseDurationInNanos)
+-    {
+-        auto clockFrequency = static_cast< double >(ClockConfig::Duration::period::den) / static_cast< double >(ClockConfig::Duration::period::num);
+-        return pauseDurationInNanos * std::pow(10, -9) * clockFrequency;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/LatencyTestSession.h b/Disruptor.PerfTests/LatencyTestSession.h
+deleted file mode 100644
+index 8d7d8b2..0000000
+--- a/Disruptor.PerfTests/LatencyTestSession.h
++++ /dev/null
+@@ -1,38 +0,0 @@
+-#pragma once
+-
+-#include <memory>
+-#include <string>
+-
+-#include "Disruptor.PerfTests/TestFactory.h"
+-#include "LatencyTestSessionResult.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class ILatencyTest;
+-
+-
+-    class LatencyTestSession
+-    {
+-    public:
+-        explicit LatencyTestSession(const LatencyTestInfo& testInfo);
+-
+-        void run();
+-
+-        static std::int64_t convertStopwatchTicksToNano(double durationInTicks);
+-        static double convertNanoToStopwatchTicks(std::int64_t pauseDurationInNanos);
+-
+-    private:
+-        static void checkProcessorsRequirements(const std::shared_ptr< ILatencyTest >& test);
+-
+-        const std::int32_t m_runs = 3;
+-
+-        LatencyTestInfo m_testInfo;
+-        std::vector< LatencyTestSessionResult > m_results;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/LatencyTestSessionResult.cpp b/Disruptor.PerfTests/LatencyTestSessionResult.cpp
+deleted file mode 100644
+index b8fb9b0..0000000
+--- a/Disruptor.PerfTests/LatencyTestSessionResult.cpp
++++ /dev/null
+@@ -1,53 +0,0 @@
+-#include "stdafx.h"
+-#include "LatencyTestSessionResult.h"
+-
+-#include <iomanip>
+-#include <sstream>
+-
+-#include "Disruptor.TestTools/DurationHumanizer.h"
+-#include "Disruptor.TestTools/HumanNumberFacet.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    LatencyTestSessionResult::LatencyTestSessionResult(const std::shared_ptr< Tests::LatencyRecorder >& latencyRecorder, const ClockConfig::Duration& duration)
+-        : m_latencyRecorder(latencyRecorder)
+-        , m_duration(duration)
+-    {
+-    }
+-
+-    LatencyTestSessionResult::LatencyTestSessionResult(const std::exception& exception)
+-        : m_exception(exception)
+-    {
+-    }
+-
+-    std::string LatencyTestSessionResult::toString()
+-    {
+-        std::ostringstream result;
+-        result.imbue(std::locale(result.getloc(), new Tests::HumanNumberFacet()));
+-
+-        if (m_exception)
+-            result << "Run: FAILED: " << m_exception.get().what();
+-        else
+-        {
+-            auto humanDuration = Tests::DurationHumanizer::deduceHumanDuration(duration());
+-
+-            result << "Run: "
+-                << "Duration (" << humanDuration.shortUnitName << "): " << std::setprecision(3) << humanDuration.value
+-                << ", Latency: ";
+-            m_latencyRecorder->writeReport(result);
+-        }
+-
+-        return result.str();
+-    }
+-
+-    ClockConfig::Duration LatencyTestSessionResult::duration() const
+-    {
+-        return m_duration;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/LatencyTestSessionResult.h b/Disruptor.PerfTests/LatencyTestSessionResult.h
+deleted file mode 100644
+index ad6a3e5..0000000
+--- a/Disruptor.PerfTests/LatencyTestSessionResult.h
++++ /dev/null
+@@ -1,36 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-#include <exception>
+-#include <iosfwd>
+-
+-#include <boost/optional.hpp>
+-
+-#include "Disruptor/ClockConfig.h"
+-#include "Disruptor.TestTools/LatencyRecorder.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class LatencyTestSessionResult
+-    {
+-    public:
+-        LatencyTestSessionResult(const std::shared_ptr< Tests::LatencyRecorder >& latencyRecorder, const ClockConfig::Duration& duration);
+-        
+-        explicit LatencyTestSessionResult(const std::exception& exception);
+-
+-        std::string toString();
+-
+-        ClockConfig::Duration duration() const;
+-
+-    private:
+-        std::shared_ptr< Tests::LatencyRecorder > m_latencyRecorder;
+-        ClockConfig::Duration m_duration;
+-        boost::optional< std::exception > m_exception;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/LongArrayEventHandler.cpp b/Disruptor.PerfTests/LongArrayEventHandler.cpp
+deleted file mode 100644
+index bbfca15..0000000
+--- a/Disruptor.PerfTests/LongArrayEventHandler.cpp
++++ /dev/null
+@@ -1,47 +0,0 @@
+-#include "stdafx.h"
+-#include "LongArrayEventHandler.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    std::int64_t LongArrayEventHandler::count() const
+-    {
+-        return m_count;
+-    }
+-
+-    const std::shared_ptr< Tests::ManualResetEvent >& LongArrayEventHandler::signal() const
+-    {
+-        return m_signal;
+-    }
+-
+-    std::int64_t LongArrayEventHandler::value() const
+-    {
+-        return m_value->value;
+-    }
+-
+-    void LongArrayEventHandler::reset(const std::shared_ptr< Tests::ManualResetEvent >& signal, std::int64_t expectedCount)
+-    {
+-        m_value->value = 0L;
+-        m_signal = signal;
+-        m_count = expectedCount;
+-    }
+-
+-    void LongArrayEventHandler::onEvent(std::vector< std::int64_t >& data, std::int64_t /*sequence*/, bool /*endOfBatch*/)
+-    {
+-        for (auto i = 0u; i < data.size(); ++i)
+-        {
+-            m_value->value = m_value->value + data[i];
+-        }
+-
+-        if (--m_count == 0)
+-        {
+-            if (m_signal != nullptr)
+-                m_signal->set();
+-        }
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/LongArrayEventHandler.h b/Disruptor.PerfTests/LongArrayEventHandler.h
+deleted file mode 100644
+index 930dba0..0000000
+--- a/Disruptor.PerfTests/LongArrayEventHandler.h
++++ /dev/null
+@@ -1,38 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-#include <vector>
+-
+-#include "Disruptor/IEventHandler.h"
+-
+-#include "Disruptor.TestTools/ManualResetEvent.h"
+-
+-#include "Disruptor.PerfTests/PaddedLong.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class LongArrayEventHandler : public IEventHandler< std::vector< std::int64_t > >
+-    {
+-    public:
+-        std::int64_t count() const;
+-
+-        const std::shared_ptr< Tests::ManualResetEvent >& signal() const;
+-
+-        std::int64_t value() const;
+-
+-        void reset(const std::shared_ptr< Tests::ManualResetEvent >& signal, std::int64_t expectedCount);
+-
+-        void onEvent(std::vector< std::int64_t >& data, std::int64_t sequence, bool endOfBatch) override;
+-
+-    private:
+-        std::shared_ptr< PaddedLong > m_value = std::make_shared< PaddedLong >();
+-        std::int64_t m_count = 0;
+-        std::shared_ptr< Tests::ManualResetEvent > m_signal;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/MultiBufferBatchEventProcessor.h b/Disruptor.PerfTests/MultiBufferBatchEventProcessor.h
+deleted file mode 100644
+index c531ed3..0000000
+--- a/Disruptor.PerfTests/MultiBufferBatchEventProcessor.h
++++ /dev/null
+@@ -1,135 +0,0 @@
+-#pragma once
+-
+-#include <atomic>
+-#include <iostream>
+-#include <memory>
+-#include <thread>
+-#include <vector>
+-
+-#include "Disruptor/AlertException.h"
+-#include "Disruptor/ArgumentException.h"
+-#include "Disruptor/IDataProvider.h"
+-#include "Disruptor/IEventHandler.h"
+-#include "Disruptor/IEventProcessor.h"
+-#include "Disruptor/ISequenceBarrier.h"
+-#include "Disruptor/NotSupportedException.h"
+-#include "Disruptor/Sequence.h"
+-#include "Disruptor/TimeoutException.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    template <class T>
+-    class MultiBufferBatchEventProcessor : public IEventProcessor
+-    {
+-    public:
+-        MultiBufferBatchEventProcessor(const std::vector< std::shared_ptr< IDataProvider< T > > >& providers,
+-                                       const std::vector< std::shared_ptr< ISequenceBarrier > >& barriers,
+-                                       const std::shared_ptr< IEventHandler< T > >& handler)
+-        {
+-            if (providers.size() != barriers.size())
+-                DISRUPTOR_THROW_ARGUMENT_EXCEPTION("Should have as many providers as barriers (" << providers.size() << " != " << barriers.size() << ")");
+-
+-            m_providers = providers;
+-            m_barriers = barriers;
+-            m_handler = handler;
+-
+-            m_sequences.resize(m_providers.size());
+-            for (auto i = 0u; i < m_sequences.size(); ++i)
+-            {
+-                m_sequences[i] = std::make_shared< Sequence >();
+-            }
+-        }
+-
+-        void run() override
+-        {
+-            if (std::atomic_exchange(&m_isRunning, 1) != 0)
+-                throw std::runtime_error("Already running");
+-
+-            for (auto&& barrier : m_barriers)
+-            {
+-                barrier->clearAlert();
+-            }
+-
+-            auto barrierLength = m_barriers.size();
+-
+-            while (true)
+-            {
+-                try
+-                {
+-                    for (auto i = 0u; i < barrierLength; ++i)
+-                    {
+-                        auto available = m_barriers[i]->waitFor(-1);
+-                        auto sequence = m_sequences[i];
+-
+-                        auto nextSequence = sequence->value() + 1;
+-
+-                        for (auto l = nextSequence; l <= available; ++l)
+-                        {
+-                            m_handler->onEvent((*m_providers[i])[l], l, nextSequence == available);
+-                        }
+-
+-                        sequence->setValue(available);
+-
+-                        m_count += available - nextSequence + 1;
+-                    }
+-
+-                    std::this_thread::yield();
+-                }
+-                catch (AlertException&)
+-                {
+-                    if (m_isRunning == 0)
+-                        break;
+-                }
+-                catch (TimeoutException& ex)
+-                {
+-                    std::cout << ex.what() << std::endl;
+-                }
+-                catch (std::exception& ex)
+-                {
+-                    std::cout << ex.what() << std::endl;
+-                    break;
+-                }
+-            }
+-        }
+-
+-        std::shared_ptr< ISequence > sequence() const override
+-        {
+-            DISRUPTOR_THROW_NOT_SUPPORTED_EXCEPTION();
+-        }
+-
+-        std::int64_t count() const
+-        {
+-            return m_count;
+-        }
+-
+-        const std::vector< std::shared_ptr< ISequence > >& getSequences() const
+-        {
+-            return m_sequences;
+-        }
+-
+-        void halt() override
+-        {
+-            m_isRunning = 0;
+-            m_barriers[0]->alert();
+-        }
+-
+-        bool isRunning() const override
+-        {
+-            return m_isRunning == 1;
+-        }
+-        
+-    private:
+-        std::atomic< std::int32_t > m_isRunning{0};
+-        std::vector< std::shared_ptr< IDataProvider< T > > > m_providers;
+-        std::vector< std::shared_ptr< ISequenceBarrier > > m_barriers;
+-        std::shared_ptr< IEventHandler< T > > m_handler;
+-        std::vector< std::shared_ptr< ISequence > > m_sequences;
+-        std::int64_t m_count = 0;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/MutableLong.cpp b/Disruptor.PerfTests/MutableLong.cpp
+deleted file mode 100644
+index 3467207..0000000
+--- a/Disruptor.PerfTests/MutableLong.cpp
++++ /dev/null
+@@ -1,16 +0,0 @@
+-#include "stdafx.h"
+-#include "MutableLong.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    MutableLong::MutableLong(std::int64_t value)
+-        : value(value)
+-    {
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/MutableLong.h b/Disruptor.PerfTests/MutableLong.h
+deleted file mode 100644
+index fbdee0b..0000000
+--- a/Disruptor.PerfTests/MutableLong.h
++++ /dev/null
+@@ -1,20 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class MutableLong
+-    {
+-    public:
+-        explicit MutableLong(std::int64_t value);
+-
+-        std::int64_t value;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToOneRawBatchThroughputTest.cpp b/Disruptor.PerfTests/OneToOneRawBatchThroughputTest.cpp
+deleted file mode 100644
+index 509952d..0000000
+--- a/Disruptor.PerfTests/OneToOneRawBatchThroughputTest.cpp
++++ /dev/null
+@@ -1,88 +0,0 @@
+-#include "stdafx.h"
+-#include "OneToOneRawBatchThroughputTest.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    OneToOneRawBatchThroughputTest::OneToOneRawBatchThroughputTest()
+-    {
+-        m_myRunnable = std::make_shared< MyRunnable >(m_sequencer);
+-        m_sequencer->addGatingSequences({ m_myRunnable->sequence });
+-    }
+-
+-    std::int64_t OneToOneRawBatchThroughputTest::run(Stopwatch& stopwatch)
+-    {
+-        std::int32_t batchSize = 10;
+-        auto latch = std::make_shared< Tests::ManualResetEvent >(false);
+-        auto expectedCount = m_myRunnable->sequence->value() + m_iterations * batchSize;
+-        m_myRunnable->reset(latch, expectedCount);
+-        std::thread([this] { m_myRunnable->run(); }).detach();
+-        stopwatch.start();
+-
+-        auto sequencer = m_sequencer;
+-
+-        for (std::int64_t i = 0; i < m_iterations; i++)
+-        {
+-            auto next = sequencer->next(batchSize);
+-            sequencer->publish(next - (batchSize - 1), next);
+-        }
+-
+-        latch->waitOne();
+-        stopwatch.stop();
+-        waitForEventProcessorSequence(expectedCount);
+-
+-        return m_iterations * batchSize;
+-    }
+-
+-    std::int32_t OneToOneRawBatchThroughputTest::requiredProcessorCount() const
+-    {
+-        return 2;
+-    }
+-
+-    void OneToOneRawBatchThroughputTest::waitForEventProcessorSequence(std::int64_t expectedCount)
+-    {
+-        while (m_myRunnable->sequence->value() != expectedCount)
+-        {
+-            std::this_thread::sleep_for(std::chrono::milliseconds(1));
+-        }
+-    }
+-
+-    OneToOneRawBatchThroughputTest::MyRunnable::MyRunnable(const std::shared_ptr< ISequencer< boost::any > >& sequencer)
+-    {
+-        m_barrier = sequencer->newBarrier({});
+-    }
+-
+-    void OneToOneRawBatchThroughputTest::MyRunnable::reset(const std::shared_ptr< Tests::ManualResetEvent >& latch, std::int64_t expectedCount)
+-    {
+-        m_latch = latch;
+-        m_expectedCount = expectedCount;
+-    }
+-
+-    void OneToOneRawBatchThroughputTest::MyRunnable::run()
+-    {
+-        auto expected = m_expectedCount;
+-
+-        try
+-        {
+-            std::int64_t processed;
+-            do
+-            {
+-                processed = m_barrier->waitFor(sequence->value() + 1);
+-                sequence->setValue(processed);
+-            }
+-            while (processed < expected);
+-
+-            m_latch->set();
+-            sequence->setValue(processed);
+-        }
+-        catch (std::exception& ex)
+-        {
+-            std::cout << ex.what() << std::endl;
+-        }
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToOneRawBatchThroughputTest.h b/Disruptor.PerfTests/OneToOneRawBatchThroughputTest.h
+deleted file mode 100644
+index 150549a..0000000
+--- a/Disruptor.PerfTests/OneToOneRawBatchThroughputTest.h
++++ /dev/null
+@@ -1,102 +0,0 @@
+-#pragma once
+-
+-#include <boost/any.hpp>
+-
+-#include "Disruptor/ISequencer.h"
+-#include "Disruptor/Sequence.h"
+-#include "Disruptor/SingleProducerSequencer.h"
+-#include "Disruptor/YieldingWaitStrategy.h"
+-
+-#include "Disruptor.TestTools/ManualResetEvent.h"
+-#include "Disruptor.TestTools/Stopwatch.h"
+-
+-#include "Disruptor.PerfTests/IThroughputTest.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    /**
+-     * UniCast a series of items between 1 publisher and 1 event processor.
+-     * +----+    +-----+
+-     * | P1 |--->| EP1 |
+-     * +----+    +-----+
+-     * 
+-     * Queue Based:
+-     * ============
+-     * 
+-     *        put take
+-     * +----+    +====+    +-----+
+-     * | P1 |---\| Q1 |/---| EP1 |
+-     * +----+    +====+    +-----+
+-     * 
+-     * P1  - Publisher 1
+-     * Q1  - Queue 1
+-     * EP1 - EventProcessor 1
+-     * 
+-     * Disruptor:
+-     * ==========
+-     *              track to prevent wrap
+-     *              +------------------+
+-     *              |                  |
+-     *              |                  v
+-     * +----+    +====+    +====+   +-----+
+-     * | P1 |--->| RB |/---| SB |   | EP1 |
+-     * +----+    +====+    +====+   +-----+
+-     *      claim get    ^        |
+-     *                        |        |
+-     *                        +--------+
+-     *                          waitFor
+-     * P1  - Publisher 1
+-     * RB  - RingBuffer
+-     * SB  - SequenceBarrier
+-     * EP1 - EventProcessor 1
+-     *
+-     */
+-    class OneToOneRawBatchThroughputTest : public IThroughputTest
+-    {
+-        class MyRunnable;
+-
+-    public:
+-        OneToOneRawBatchThroughputTest();
+-
+-        std::int64_t run(Stopwatch& stopwatch) override;
+-        std::int32_t requiredProcessorCount() const override;
+-
+-    private:
+-        void waitForEventProcessorSequence(std::int64_t expectedCount);
+-
+-        const std::int32_t m_bufferSize = 1024 * 64;
+-
+-#ifdef _DEBUG
+-        const std::int64_t m_iterations = 100L * 100L * 20L;
+-#else
+-        const std::int64_t m_iterations = 1000L * 1000L * 200L;
+-#endif
+-
+-        std::shared_ptr< ISequencer< boost::any > > m_sequencer = std::make_shared< SingleProducerSequencer< boost::any > >(m_bufferSize, std::make_shared< YieldingWaitStrategy >());
+-        std::shared_ptr< MyRunnable > m_myRunnable;
+-    };
+-
+-
+-    class OneToOneRawBatchThroughputTest::MyRunnable
+-    {
+-    public:
+-        explicit MyRunnable(const std::shared_ptr< ISequencer< boost::any > >& sequencer);
+-
+-        void reset(const std::shared_ptr< Tests::ManualResetEvent >& latch, std::int64_t expectedCount);
+-
+-        void run();
+-
+-        std::shared_ptr< Sequence > sequence = std::make_shared< Sequence >(-1);
+-
+-    private:
+-        std::shared_ptr< Tests::ManualResetEvent > m_latch;
+-        std::int64_t m_expectedCount;
+-        std::shared_ptr< ISequenceBarrier > m_barrier;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToOneRawThroughputTest.cpp b/Disruptor.PerfTests/OneToOneRawThroughputTest.cpp
+deleted file mode 100644
+index 5fa4514..0000000
+--- a/Disruptor.PerfTests/OneToOneRawThroughputTest.cpp
++++ /dev/null
+@@ -1,106 +0,0 @@
+-#include "stdafx.h"
+-#include "OneToOneRawThroughputTest.h"
+-
+-#include "Disruptor.TestTools/ScopeExitFunctor.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    OneToOneRawThroughputTest::OneToOneRawThroughputTest()
+-    {
+-        m_myRunnable = std::make_shared< MyRunnable >(m_sequencer);
+-        m_sequencer->addGatingSequences({ m_myRunnable->sequence });
+-        m_taskScheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
+-    }
+-
+-    std::int64_t OneToOneRawThroughputTest::run(Stopwatch& stopwatch)
+-    {
+-        m_taskScheduler->start(requiredProcessorCount());
+-        TestTools::ScopeExitFunctor atScopeExit([this] { m_taskScheduler->stop(); });
+-
+-        auto latch = std::make_shared< Tests::ManualResetEvent >(false);
+-        const auto expectedCount = m_myRunnable->sequence->value() + m_iterations;
+-        m_myRunnable->reset(latch, expectedCount);
+-
+-        auto consumerTask = m_taskScheduler->scheduleAndStart(std::packaged_task< void() >([this] { m_myRunnable->run(); }));
+-        stopwatch.start();
+-
+-        auto sequencer = m_sequencer;
+-
+-        auto producerTask = m_taskScheduler->scheduleAndStart(std::packaged_task< void() >([this, sequencer, latch]
+-        {
+-            auto& s = *sequencer;
+-            for (std::int64_t i = 0; i < m_iterations; ++i)
+-            {
+-                auto next = s.next();
+-                s.publish(next);
+-            }
+-
+-            latch->waitOne();
+-        }));
+-
+-        producerTask.wait();
+-        stopwatch.stop();
+-        waitForEventProcessorSequence(expectedCount);
+-
+-        consumerTask.wait();
+-
+-        return m_iterations;
+-    }
+-
+-    std::int32_t OneToOneRawThroughputTest::requiredProcessorCount() const
+-    {
+-        return 2;
+-    }
+-
+-    void OneToOneRawThroughputTest::waitForEventProcessorSequence(std::int64_t expectedCount) const
+-    {
+-        while (m_myRunnable->sequence->value() != expectedCount)
+-        {
+-            std::this_thread::sleep_for(std::chrono::milliseconds(1));
+-        }
+-    }
+-
+-    OneToOneRawThroughputTest::MyRunnable::MyRunnable(const std::shared_ptr< ISequencer< boost::any > >& sequencer)
+-    {
+-        m_barrier = sequencer->newBarrier({});
+-    }
+-
+-    void OneToOneRawThroughputTest::MyRunnable::reset(const std::shared_ptr< Tests::ManualResetEvent >& latch, std::int64_t expectedCount)
+-    {
+-        m_latch = latch;
+-        m_expectedCount = expectedCount;
+-    }
+-
+-    void OneToOneRawThroughputTest::MyRunnable::run() const
+-    {
+-        auto expected = m_expectedCount;
+-
+-        auto& b = *m_barrier;
+-        auto& s = *sequence;
+-
+-        try
+-        {
+-            std::int64_t processed;
+-
+-            do
+-            {
+-                processed = b.waitFor(s.value() + 1);
+-                s.setValue(processed);
+-            }
+-            while (processed < expected);
+-
+-            m_latch->set();
+-            s.setValue(processed);
+-        }
+-        catch (std::exception& ex)
+-        {
+-            std::cout << ex.what() << std::endl;
+-        }
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToOneRawThroughputTest.h b/Disruptor.PerfTests/OneToOneRawThroughputTest.h
+deleted file mode 100644
+index d9312f4..0000000
+--- a/Disruptor.PerfTests/OneToOneRawThroughputTest.h
++++ /dev/null
+@@ -1,105 +0,0 @@
+-#pragma once
+-
+-#include <boost/any.hpp>
+-
+-#include "Disruptor/ISequencer.h"
+-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
+-#include "Disruptor/Sequence.h"
+-#include "Disruptor/SingleProducerSequencer.h"
+-#include "Disruptor/YieldingWaitStrategy.h"
+-
+-#include "Disruptor.TestTools/ManualResetEvent.h"
+-#include "Disruptor.TestTools/Stopwatch.h"
+-
+-#include "Disruptor.PerfTests/IThroughputTest.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    /**
+-     *  UniCast a series of items between 1 publisher and 1 event processor.
+-     *  +----+    +-----+
+-     *  | P1 |--->| EP1 |
+-     *  +----+    +-----+
+-     *  
+-     *  Queue Based:
+-     *  ============
+-     *  
+-     *         put take
+-     *  +----+    +====+    +-----+
+-     *  | P1 |---\| Q1 |/---| EP1 |
+-     *  +----+    +====+    +-----+
+-     *  
+-     *  P1  - Publisher 1
+-     *  Q1  - Queue 1
+-     *  EP1 - EventProcessor 1
+-     *  
+-     *  Disruptor:
+-     *  ==========
+-     *               track to prevent wrap
+-     *               +------------------+
+-     *               |                  |
+-     *               |                  v
+-     *  +----+    +====+    +====+   +-----+
+-     *  | P1 |--->| RB |/---| SB |   | EP1 |
+-     *  +----+    +====+    +====+   +-----+
+-     *       claim get    ^        |
+-     *                         |        |
+-     *                         +--------+
+-     *                           waitFor
+-     *  P1  - Publisher 1
+-     *  RB  - RingBuffer
+-     *  SB  - SequenceBarrier
+-     *  EP1 - EventProcessor 1
+-     * 
+-     */
+-    class OneToOneRawThroughputTest : public IThroughputTest
+-    {
+-        //C# Run: Ops:  140 078 898 - Duration: 1428 (ms)
+-        class MyRunnable;
+-
+-    public:
+-        OneToOneRawThroughputTest();
+-
+-        std::int64_t run(Stopwatch& stopwatch) override;
+-        std::int32_t requiredProcessorCount() const override;
+-
+-    private:
+-        void waitForEventProcessorSequence(std::int64_t expectedCount) const;
+-
+-        const std::int32_t m_bufferSize = 1024 * 64;
+-
+-//#ifdef _DEBUG
+-//        const std::int64_t m_iterations = 100L * 100L * 20L;
+-//#else
+-        const std::int64_t m_iterations = 1000L * 1000L * 200L;
+-//#endif
+-
+-        std::shared_ptr< ISequencer< boost::any > > m_sequencer = std::make_shared< SingleProducerSequencer< boost::any > >(m_bufferSize, std::make_shared< YieldingWaitStrategy >());
+-        std::shared_ptr< MyRunnable > m_myRunnable;
+-        std::shared_ptr< RoundRobinThreadAffinedTaskScheduler > m_taskScheduler;
+-    };
+-
+-
+-    class OneToOneRawThroughputTest::MyRunnable
+-    {
+-    public:
+-        explicit MyRunnable(const std::shared_ptr< ISequencer< boost::any > >& sequencer);
+-
+-        void reset(const std::shared_ptr< Tests::ManualResetEvent >& latch, std::int64_t expectedCount);
+-
+-        void run() const;
+-
+-        std::shared_ptr< Sequence > sequence = std::make_shared< Sequence >(-1);
+-
+-    private:
+-        std::shared_ptr< Tests::ManualResetEvent > m_latch;
+-        std::int64_t m_expectedCount = 0;
+-        std::shared_ptr< ISequenceBarrier > m_barrier;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToOneSequencedBatchThroughputTest.cpp b/Disruptor.PerfTests/OneToOneSequencedBatchThroughputTest.cpp
+deleted file mode 100644
+index 9b4f243..0000000
+--- a/Disruptor.PerfTests/OneToOneSequencedBatchThroughputTest.cpp
++++ /dev/null
+@@ -1,70 +0,0 @@
+-#include "stdafx.h"
+-#include "OneToOneSequencedBatchThroughputTest.h"
+-
+-#include "Disruptor/BasicExecutor.h"
+-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
+-#include "Disruptor/YieldingWaitStrategy.h"
+-
+-#include "Disruptor.TestTools/ScopeExitFunctor.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    OneToOneSequencedBatchThroughputTest::OneToOneSequencedBatchThroughputTest()
+-    {
+-        m_taskScheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
+-        m_executor = std::make_shared< BasicExecutor >(m_taskScheduler);
+-
+-        m_ringBuffer = RingBuffer< ValueEvent >::createSingleProducer(ValueEvent::eventFactory(), m_bufferSize, std::make_shared< YieldingWaitStrategy >());
+-        auto sequenceBarrier = m_ringBuffer->newBarrier();
+-        m_handler = std::make_shared< ValueAdditionEventHandler >();
+-        m_batchEventProcessor = std::make_shared< BatchEventProcessor< ValueEvent > >(m_ringBuffer, sequenceBarrier, m_handler);
+-        m_ringBuffer->addGatingSequences({ m_batchEventProcessor->sequence() });
+-    }
+-
+-    std::int64_t OneToOneSequencedBatchThroughputTest::run(Stopwatch& stopwatch)
+-    {
+-        m_taskScheduler->start(requiredProcessorCount());
+-        TestTools::ScopeExitFunctor atScopeExit([this] { m_taskScheduler->stop(); });
+-
+-        auto signal = std::make_shared< Tests::ManualResetEvent >(false);
+-        auto expectedCount = m_batchEventProcessor->sequence()->value() + m_iterations * m_batchSize;
+-        m_handler->reset(signal, expectedCount);
+-        auto processorTask = m_executor->execute([this] { m_batchEventProcessor->run(); });
+-        stopwatch.start();
+-
+-        auto&& rb = *m_ringBuffer;
+-
+-        for (auto i = 0; i < m_iterations; ++i)
+-        {
+-            auto hi = rb.next(m_batchSize);
+-            auto lo = hi - (m_batchSize - 1);
+-            for (auto l = lo; l <= hi; ++l)
+-            {
+-                rb[l].value = (i);
+-            }
+-            rb.publish(lo, hi);
+-        }
+-
+-        signal->waitOne();
+-        stopwatch.stop();
+-        PerfTestUtil::waitForEventProcessorSequence(expectedCount, m_batchEventProcessor);
+-        m_batchEventProcessor->halt();
+-        processorTask.wait_for(std::chrono::milliseconds(2000));
+-
+-        PerfTestUtil::failIfNot(m_expectedResult, m_handler->value(),
+-                                "Handler should have processed " + std::to_string(m_expectedResult) + " events, but was: " + std::to_string(m_handler->value()));
+-
+-        return m_batchSize * m_iterations;
+-    }
+-
+-    std::int32_t OneToOneSequencedBatchThroughputTest::requiredProcessorCount() const
+-    {
+-        return 2;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToOneSequencedBatchThroughputTest.h b/Disruptor.PerfTests/OneToOneSequencedBatchThroughputTest.h
+deleted file mode 100644
+index d3d9ac6..0000000
+--- a/Disruptor.PerfTests/OneToOneSequencedBatchThroughputTest.h
++++ /dev/null
+@@ -1,75 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/BatchEventProcessor.h"
+-#include "Disruptor/IExecutor.h"
+-#include "Disruptor/ITaskScheduler.h"
+-#include "Disruptor/RingBuffer.h"
+-
+-#include "Disruptor.PerfTests/IThroughputTest.h"
+-#include "Disruptor.PerfTests/PerfTestUtil.h"
+-#include "Disruptor.PerfTests/ValueAdditionEventHandler.h"
+-#include "Disruptor.PerfTests/ValueEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    /**
+-     * UniCast a series of items between 1 publisher and 1 event processor
+-     * 
+-     * +----+    +-----+
+-     * | P1 |--->| EP1 |
+-     * +----+    +-----+
+-     * 
+-     * Disruptor:
+-     * ==========
+-     *              track to prevent wrap
+-     *              +------------------+
+-     *              |                  |
+-     *              |                  v
+-     * +----+    +====+    +====+   +-----+
+-     * | P1 |---| RB |---| SB |   | EP1 |
+-     * +----+    +====+    +====+   +-----+
+-     *      claim      get    ^        |
+-     *                        |        |
+-     *                        +--------+
+-     *                          waitFor
+-     * 
+-     * P1  - Publisher 1
+-     * RB  - RingBuffer
+-     * SB  - SequenceBarrier
+-     * EP1 - EventProcessor 1
+-     * 
+-     **/
+-    class OneToOneSequencedBatchThroughputTest : public IThroughputTest
+-    {
+-    public:
+-        OneToOneSequencedBatchThroughputTest();
+-
+-        std::int64_t run(Stopwatch& stopwatch) override;
+-
+-        std::int32_t requiredProcessorCount() const override;
+-
+-    private:
+-        const std::int32_t m_batchSize = 10;
+-        const std::int32_t m_bufferSize = 1024 * 64;
+-
+-#ifdef _DEBUG
+-        const std::int64_t m_iterations = 100L * 100L * 10L;
+-#else
+-        const std::int64_t m_iterations = 1000L * 1000L * 100L;
+-#endif
+-
+-        std::shared_ptr< IExecutor > m_executor;
+-        const std::int64_t m_expectedResult = PerfTestUtil::accumulatedAddition(m_iterations) * m_batchSize;
+-
+-        std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer;
+-        std::shared_ptr< ValueAdditionEventHandler > m_handler;
+-        std::shared_ptr< BatchEventProcessor< ValueEvent > > m_batchEventProcessor;
+-        std::shared_ptr< ITaskScheduler > m_taskScheduler;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToOneSequencedLongArrayThroughputTest.cpp b/Disruptor.PerfTests/OneToOneSequencedLongArrayThroughputTest.cpp
+deleted file mode 100644
+index 0aa9ff1..0000000
+--- a/Disruptor.PerfTests/OneToOneSequencedLongArrayThroughputTest.cpp
++++ /dev/null
+@@ -1,82 +0,0 @@
+-#include "stdafx.h"
+-#include "OneToOneSequencedLongArrayThroughputTest.h"
+-
+-#include "Disruptor/BasicExecutor.h"
+-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
+-#include "Disruptor/YieldingWaitStrategy.h"
+-
+-#include "Disruptor.TestTools/ScopeExitFunctor.h"
+-
+-#include "PerfTestUtil.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    OneToOneSequencedLongArrayThroughputTest::OneToOneSequencedLongArrayThroughputTest()
+-    {
+-        m_taskScheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
+-        m_executor = std::make_shared< BasicExecutor >(m_taskScheduler);
+-
+-        m_ringBuffer = RingBuffer< std::vector< std::int64_t > >::createSingleProducer([&] { return std::vector< std::int64_t >(m_arraySize); },
+-                                                                                       m_bufferSize,
+-                                                                                       std::make_shared< YieldingWaitStrategy >());
+-        auto sequenceBarrier = m_ringBuffer->newBarrier();
+-        m_handler = std::make_shared< LongArrayEventHandler >();
+-        m_batchEventProcessor = std::make_shared< BatchEventProcessor< std::vector< std::int64_t > > >(m_ringBuffer, sequenceBarrier, m_handler);
+-        m_ringBuffer->addGatingSequences({ m_batchEventProcessor->sequence() });
+-    }
+-
+-    std::int64_t OneToOneSequencedLongArrayThroughputTest::run(Stopwatch& stopwatch)
+-    {
+-        m_taskScheduler->start(requiredProcessorCount());
+-        TestTools::ScopeExitFunctor atScopeExit([this] { m_taskScheduler->stop(); });
+-
+-        auto signal = std::make_shared< Tests::ManualResetEvent >(false);
+-        auto expectedCount = m_batchEventProcessor->sequence()->value() + m_iterations;
+-        m_handler->reset(signal, m_iterations);
+-        auto processorTask = m_executor->execute([this] { m_batchEventProcessor->run(); });
+-
+-        auto& rb = *m_ringBuffer;
+-
+-        stopwatch.start();
+-
+-        for (auto i = 0; i < m_iterations; ++i)
+-        {
+-            auto next = rb.next();
+-            auto& event = rb[next];
+-            for (auto j = 0u; j < event.size(); ++j)
+-            {
+-                event[j] = i;
+-            }
+-            rb.publish(next);
+-        }
+-
+-        signal->waitOne();
+-        stopwatch.stop();
+-        waitForEventProcessorSequence(expectedCount);
+-        m_batchEventProcessor->halt();
+-        processorTask.wait_for(std::chrono::seconds(10));
+-
+-        PerfTestUtil::failIf(0, m_handler->value(), "Handler has not processed any event");
+-
+-        return m_iterations * m_arraySize;
+-    }
+-
+-    std::int32_t OneToOneSequencedLongArrayThroughputTest::requiredProcessorCount() const
+-    {
+-        return 2;
+-    }
+-
+-    void OneToOneSequencedLongArrayThroughputTest::waitForEventProcessorSequence(std::int64_t expectedCount)
+-    {
+-        while (m_batchEventProcessor->sequence()->value() != expectedCount)
+-        {
+-            std::this_thread::sleep_for(std::chrono::milliseconds(1));
+-        }
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToOneSequencedLongArrayThroughputTest.h b/Disruptor.PerfTests/OneToOneSequencedLongArrayThroughputTest.h
+deleted file mode 100644
+index 6360fd2..0000000
+--- a/Disruptor.PerfTests/OneToOneSequencedLongArrayThroughputTest.h
++++ /dev/null
+@@ -1,72 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/BatchEventProcessor.h"
+-#include "Disruptor/IExecutor.h"
+-#include "Disruptor/ITaskScheduler.h"
+-#include "Disruptor/RingBuffer.h"
+-
+-#include "Disruptor.PerfTests/IThroughputTest.h"
+-#include "Disruptor.PerfTests/LongArrayEventHandler.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    /**
+-     * UniCast a series of items between 1 publisher and 1 event processor.
+-     *
+-     * +----+    +-----+
+-     * | P1 |--->| EP1 |
+-     * +----+    +-----+
+-     * Disruptor:
+-     * ==========
+-     *              track to prevent wrap
+-     *              +------------------+
+-     *              |                  |
+-     *              |                  v
+-     * +----+    +====+    +====+   +-----+
+-     * | P1 |---| RB |---| SB |   | EP1 |
+-     * +----+    +====+    +====+   +-----+
+-     *      claim      get    ^        |
+-     *                        |        |
+-     *                        +--------+
+-     *                          waitFor
+-     * P1  - Publisher 1
+-     * RB  - RingBuffer
+-     * SB  - SequenceBarrier
+-     * EP1 - EventProcessor 1
+-     *
+-     */
+-    class OneToOneSequencedLongArrayThroughputTest : public IThroughputTest
+-    {
+-    public:
+-        OneToOneSequencedLongArrayThroughputTest();
+-
+-        std::int64_t run(Stopwatch& stopwatch) override;
+-
+-        std::int32_t requiredProcessorCount() const override;
+-
+-    private:
+-        void waitForEventProcessorSequence(std::int64_t expectedCount);
+-
+-        const std::int32_t m_bufferSize = 1024 * 1;
+-
+-#ifdef _DEBUG
+-        const std::int64_t m_iterations = 100L * 100L * 1L;
+-#else
+-        const std::int64_t m_iterations = 1000L * 1000L * 1L;
+-#endif
+-
+-        const std::int32_t m_arraySize = 2 * 1024;
+-
+-        std::shared_ptr< ITaskScheduler > m_taskScheduler;
+-        std::shared_ptr< IExecutor > m_executor;
+-        std::shared_ptr< RingBuffer< std::vector< std::int64_t > > > m_ringBuffer;
+-        std::shared_ptr< LongArrayEventHandler > m_handler;
+-        std::shared_ptr< BatchEventProcessor< std::vector< std::int64_t > > > m_batchEventProcessor;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToOneSequencedPollerThroughputTest.cpp b/Disruptor.PerfTests/OneToOneSequencedPollerThroughputTest.cpp
+deleted file mode 100644
+index ee0fd2f..0000000
+--- a/Disruptor.PerfTests/OneToOneSequencedPollerThroughputTest.cpp
++++ /dev/null
+@@ -1,130 +0,0 @@
+-#include "stdafx.h"
+-#include "OneToOneSequencedPollerThroughputTest.h"
+-
+-#include "Disruptor/BasicExecutor.h"
+-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
+-#include "Disruptor/YieldingWaitStrategy.h"
+-
+-#include "Disruptor.TestTools/ScopeExitFunctor.h"
+-#include "Disruptor.TestTools/ManualResetEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    OneToOneSequencedPollerThroughputTest::OneToOneSequencedPollerThroughputTest()
+-    {
+-        m_scheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
+-        m_executor = std::make_shared< BasicExecutor >(m_scheduler);
+-
+-        m_ringBuffer = RingBuffer< ValueEvent >::createSingleProducer(ValueEvent::eventFactory(), m_bufferSize, std::make_shared< YieldingWaitStrategy >());
+-        m_poller = m_ringBuffer->newPoller();
+-        m_ringBuffer->addGatingSequences({ m_poller->sequence() });
+-        m_pollRunnable = std::make_shared< PollRunnable >(m_poller);
+-    }
+-
+-    std::int64_t OneToOneSequencedPollerThroughputTest::run(Stopwatch& stopwatch)
+-    {
+-        m_scheduler->start(requiredProcessorCount());
+-        TestTools::ScopeExitFunctor atScopeExit([this] { m_scheduler->stop(); });
+-
+-        auto latch = std::make_shared< Tests::ManualResetEvent >(false);
+-        auto expectedCount = m_poller->sequence()->value() + m_iterations;
+-        m_pollRunnable->reset(latch, expectedCount);
+-        auto processorTask = m_executor->execute([this] { m_pollRunnable->run(); });
+-        stopwatch.start();
+-
+-        auto& rb = *m_ringBuffer;
+-        for (auto i = 0; i < m_iterations; ++i)
+-        {
+-            auto next = rb.next();
+-            rb[next].value = i;
+-            rb.publish(next);
+-        }
+-
+-        latch->waitOne();
+-        stopwatch.stop();
+-        waitForEventProcessorSequence(expectedCount);
+-        m_pollRunnable->halt();
+-        processorTask.wait_for(std::chrono::milliseconds(2000));
+-
+-        PerfTestUtil::failIfNot(m_expectedResult, m_pollRunnable->value(),
+-                                "Poll runnable should have processed " + std::to_string(m_expectedResult) + ", but was: " + std::to_string(m_pollRunnable->value()));
+-
+-        return m_iterations;
+-    }
+-
+-    std::int32_t OneToOneSequencedPollerThroughputTest::requiredProcessorCount() const
+-    {
+-        return 2;
+-    }
+-
+-    void OneToOneSequencedPollerThroughputTest::waitForEventProcessorSequence(std::int64_t expectedCount)
+-    {
+-        while (m_poller->sequence()->value() != expectedCount)
+-        {
+-            std::this_thread::sleep_for(std::chrono::milliseconds(1));
+-        }
+-    }
+-
+-    OneToOneSequencedPollerThroughputTest::PollRunnable::PollRunnable(const std::shared_ptr< EventPoller< ValueEvent > >& poller)
+-        : m_poller(poller)
+-    {
+-        m_eventHandler = [this](ValueEvent& event, std::int64_t sequence, bool endOfBatch)
+-        {
+-            return this->onEvent(event, sequence, endOfBatch);
+-        };
+-    }
+-
+-    std::int64_t OneToOneSequencedPollerThroughputTest::PollRunnable::value() const
+-    {
+-        return m_value->value;
+-    }
+-
+-    void OneToOneSequencedPollerThroughputTest::PollRunnable::run()
+-    {
+-        try
+-        {
+-            while (m_running == 1)
+-            {
+-                if (PollState::Processing != m_poller->poll(m_eventHandler))
+-                {
+-                    std::this_thread::sleep_for(std::chrono::milliseconds(0));
+-                }
+-            }
+-        }
+-        catch (std::exception& ex)
+-        {
+-            std::cout << ex.what() << std::endl;
+-        }
+-    }
+-
+-    void OneToOneSequencedPollerThroughputTest::PollRunnable::halt()
+-    {
+-        std::atomic_exchange(&m_running, 0);
+-    }
+-
+-    void OneToOneSequencedPollerThroughputTest::PollRunnable::reset(const std::shared_ptr< Tests::ManualResetEvent >& signal, std::int64_t expectedCount)
+-    {
+-        m_value->value = 0L;
+-        m_signal = signal;
+-        m_count = expectedCount;
+-        m_running = 1;
+-    }
+-
+-    bool OneToOneSequencedPollerThroughputTest::PollRunnable::onEvent(ValueEvent& event, std::int64_t sequence, bool /*endOfBatch*/)
+-    {
+-        m_value->value = m_value->value + event.value;
+-
+-        if (m_count == sequence)
+-        {
+-            m_signal->set();
+-        }
+-
+-        return true;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToOneSequencedPollerThroughputTest.h b/Disruptor.PerfTests/OneToOneSequencedPollerThroughputTest.h
+deleted file mode 100644
+index 37def48..0000000
+--- a/Disruptor.PerfTests/OneToOneSequencedPollerThroughputTest.h
++++ /dev/null
+@@ -1,75 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/IExecutor.h"
+-#include "Disruptor/ITaskScheduler.h"
+-#include "Disruptor/RingBuffer.h"
+-
+-#include "Disruptor.TestTools/ManualResetEvent.h"
+-
+-#include "Disruptor.PerfTests/IThroughputTest.h"
+-#include "Disruptor.PerfTests/PaddedLong.h"
+-#include "Disruptor.PerfTests/PerfTestUtil.h"
+-#include "Disruptor.PerfTests/ValueEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class OneToOneSequencedPollerThroughputTest : public IThroughputTest
+-    {
+-        class PollRunnable;
+-
+-    public:
+-        OneToOneSequencedPollerThroughputTest();
+-
+-        std::int64_t run(Stopwatch& stopwatch) override;
+-
+-        std::int32_t requiredProcessorCount() const override;
+-
+-    private:
+-        void waitForEventProcessorSequence(std::int64_t expectedCount);
+-
+-        const std::int32_t m_bufferSize = 1024 * 64;
+-
+-#ifdef _DEBUG
+-        const std::int64_t m_iterations = 100L * 100L * 10L;
+-#else
+-        const std::int64_t m_iterations = 1000L * 1000L * 100L;
+-#endif
+-
+-        std::shared_ptr< IExecutor > m_executor;
+-        std::shared_ptr< ITaskScheduler > m_scheduler;
+-
+-        std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer;
+-        std::shared_ptr< EventPoller< ValueEvent > > m_poller;
+-        std::shared_ptr< PollRunnable > m_pollRunnable;
+-        const std::int64_t m_expectedResult = PerfTestUtil::accumulatedAddition(m_iterations);
+-    };
+-
+-
+-    class OneToOneSequencedPollerThroughputTest::PollRunnable
+-    {
+-    public:
+-        explicit PollRunnable(const std::shared_ptr< EventPoller< ValueEvent > >& poller);
+-
+-        std::int64_t value() const;
+-
+-        void run();
+-        void halt();
+-        void reset(const std::shared_ptr< Tests::ManualResetEvent >& signal, std::int64_t expectedCount);
+-
+-    private:
+-        bool onEvent(ValueEvent& event, std::int64_t sequence, bool endOfBatch);
+-
+-        std::shared_ptr< EventPoller< ValueEvent > > m_poller;
+-        std::function< bool(ValueEvent&, std::int64_t, bool) > m_eventHandler;
+-        std::atomic< std::int32_t > m_running {1};
+-        std::shared_ptr< PaddedLong > m_value = std::make_shared< PaddedLong >();
+-        std::shared_ptr< Tests::ManualResetEvent > m_signal;
+-        std::int64_t m_count;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToOneSequencedThroughputTest.cpp b/Disruptor.PerfTests/OneToOneSequencedThroughputTest.cpp
+deleted file mode 100644
+index 1f130be..0000000
+--- a/Disruptor.PerfTests/OneToOneSequencedThroughputTest.cpp
++++ /dev/null
+@@ -1,69 +0,0 @@
+-#include "stdafx.h"
+-#include "OneToOneSequencedThroughputTest.h"
+-
+-#include "Disruptor/BasicExecutor.h"
+-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
+-#include "Disruptor/YieldingWaitStrategy.h"
+-
+-#include "Disruptor.TestTools/ScopeExitFunctor.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    OneToOneSequencedThroughputTest::OneToOneSequencedThroughputTest()
+-    {
+-        m_taskScheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
+-        m_executor = std::make_shared< BasicExecutor >(m_taskScheduler);
+-
+-        m_latch = std::make_shared< Tests::ManualResetEvent >(false);
+-        m_eventHandler = std::make_shared< ValueAdditionEventHandler >();
+-        m_ringBuffer = RingBuffer< ValueEvent >::createSingleProducer(ValueEvent::eventFactory(), m_bufferSize, std::make_shared< YieldingWaitStrategy >());
+-        auto sequenceBarrier = m_ringBuffer->newBarrier();
+-        m_batchEventProcessor = std::make_shared< BatchEventProcessor< ValueEvent > >(m_ringBuffer, sequenceBarrier, m_eventHandler);
+-        m_ringBuffer->addGatingSequences({ m_batchEventProcessor->sequence() });
+-    }
+-
+-    std::int64_t OneToOneSequencedThroughputTest::run(Stopwatch& stopwatch)
+-    {
+-        m_taskScheduler->start(requiredProcessorCount());
+-        TestTools::ScopeExitFunctor atScopeExit([this] { m_taskScheduler->stop(); });
+-
+-        auto expectedCount = m_batchEventProcessor->sequence()->value() + m_iterations;
+-
+-        m_latch->reset();
+-        m_eventHandler->reset(m_latch, expectedCount);
+-
+-        auto processorTask = m_executor->execute([this] { m_batchEventProcessor->run(); });
+-        stopwatch.start();
+-
+-        auto&& rb = *m_ringBuffer;
+-
+-        for (auto i = 0; i < m_iterations; ++i)
+-        {
+-            auto sequence = rb.next();
+-            rb[sequence].value = i;
+-            rb.publish(sequence);
+-        }
+-
+-        m_latch->waitOne();
+-        stopwatch.stop();
+-        PerfTestUtil::waitForEventProcessorSequence(expectedCount, m_batchEventProcessor);
+-        m_batchEventProcessor->halt();
+-        processorTask.wait_for(std::chrono::seconds(10));
+-
+-        PerfTestUtil::failIfNot(m_expectedResult, m_eventHandler->value(),
+-                                "Handler should have processed " + std::to_string(m_expectedResult) + " events, but was: " + std::to_string(m_eventHandler->value()));
+-
+-        return m_iterations;
+-    }
+-
+-    std::int32_t OneToOneSequencedThroughputTest::requiredProcessorCount() const
+-    {
+-        return 2;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToOneSequencedThroughputTest.h b/Disruptor.PerfTests/OneToOneSequencedThroughputTest.h
+deleted file mode 100644
+index dc0e9ec..0000000
+--- a/Disruptor.PerfTests/OneToOneSequencedThroughputTest.h
++++ /dev/null
+@@ -1,76 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/BatchEventProcessor.h"
+-#include "Disruptor/IExecutor.h"
+-#include "Disruptor/ITaskScheduler.h"
+-#include "Disruptor/RingBuffer.h"
+-
+-#include "Disruptor.TestTools/ManualResetEvent.h"
+-
+-#include "Disruptor.PerfTests/IThroughputTest.h"
+-#include "Disruptor.PerfTests/PerfTestUtil.h"
+-#include "Disruptor.PerfTests/ValueAdditionEventHandler.h"
+-#include "Disruptor.PerfTests/ValueEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    /**
+-     * UniCast a series of items between 1 publisher and 1 event processor.
+-     *
+-     * +----+    +-----+
+-     * | P1 |--->| EP1 |
+-     * +----+    +-----+
+-     *
+-     * Disruptor:
+-     * ==========
+-     *              track to prevent wrap
+-     *              +------------------+
+-     *              |                  |
+-     *              |                  v
+-     * +----+    +====+    +====+   +-----+
+-     * | P1 |---\| RB |/---| SB |   | EP1 |
+-     * +----+    +====+    +====+   +-----+
+-     *      claim       get   ^        |
+-     *                        |        |
+-     *                        +--------+
+-     *                          waitFor
+-     *
+-     * P1  - Publisher 1
+-     * RB  - RingBuffer
+-     * SB  - SequenceBarrier
+-     * EP1 - EventProcessor 1
+-     *
+-     */
+-    class OneToOneSequencedThroughputTest : public IThroughputTest
+-    {
+-    public:
+-        OneToOneSequencedThroughputTest();
+-
+-        std::int64_t run(Stopwatch& stopwatch) override;
+-
+-        std::int32_t requiredProcessorCount() const override;
+-
+-    private:
+-        const std::int32_t m_bufferSize = 1024 * 64;
+-
+-#ifdef _DEBUG
+-        const std::int64_t m_iterations = 100L * 100L * 10L;
+-#else
+-        const std::int64_t m_iterations = 1000L * 1000L * 100L;
+-#endif
+-
+-        std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer;
+-        std::shared_ptr< ValueAdditionEventHandler > m_eventHandler;
+-        std::shared_ptr< Tests::ManualResetEvent > m_latch;
+-        const std::int64_t m_expectedResult = PerfTestUtil::accumulatedAddition(m_iterations);
+-        std::shared_ptr< BatchEventProcessor< ValueEvent > > m_batchEventProcessor;
+-        std::shared_ptr< IExecutor > m_executor;
+-        std::shared_ptr< ITaskScheduler > m_taskScheduler;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToOneTranslatorThroughputTest.cpp b/Disruptor.PerfTests/OneToOneTranslatorThroughputTest.cpp
+deleted file mode 100644
+index e42ef6e..0000000
+--- a/Disruptor.PerfTests/OneToOneTranslatorThroughputTest.cpp
++++ /dev/null
+@@ -1,82 +0,0 @@
+-#include "stdafx.h"
+-#include "OneToOneTranslatorThroughputTest.h"
+-
+-#include "Disruptor/Disruptor.h"
+-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
+-#include "Disruptor/YieldingWaitStrategy.h"
+-
+-#include "Disruptor.TestTools/ScopeExitFunctor.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    std::int64_t OneToOneTranslatorThroughputTest::run(Stopwatch& stopwatch)
+-    {
+-        m_taskScheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
+-        m_taskScheduler->start(requiredProcessorCount());
+-        TestTools::ScopeExitFunctor stopTaskSchedulerAtScopeExit([this] { m_taskScheduler->stop(); });
+-
+-        m_disruptor = std::make_shared< ::Disruptor::disruptor< ValueEvent > >(ValueEvent::eventFactory(),
+-                                                                                  m_bufferSize,
+-                                                                                  m_taskScheduler,
+-                                                                                  ProducerType::Single,
+-                                                                                  std::make_shared< YieldingWaitStrategy >());
+-        TestTools::ScopeExitFunctor stopDisruptorAtScopeExit([this] { m_disruptor->shutdown(std::chrono::seconds(10)); });
+-
+-        m_disruptor->handleEventsWith(m_handler);
+-        m_ringBuffer = m_disruptor->start();
+-
+-        auto& value = m_value;
+-
+-        auto latch = std::make_shared< Tests::ManualResetEvent >(false);
+-        auto expectedCount = m_ringBuffer->getMinimumGatingSequence() + m_iterations;
+-
+-        m_handler->reset(latch, expectedCount);
+-        stopwatch.start();
+-
+-        auto& rb = *m_ringBuffer;
+-
+-        for (std::int64_t l = 0; l < m_iterations; ++l)
+-        {
+-            value.value = l;
+-            rb.publishEvent(Translator::instance(), value);
+-        }
+-
+-        latch->waitOne();
+-        stopwatch.stop();
+-        waitForEventProcessorSequence(expectedCount);
+-
+-        PerfTestUtil::failIfNot(m_expectedResult, m_handler->value());
+-
+-        return m_iterations;
+-    }
+-
+-    std::int32_t OneToOneTranslatorThroughputTest::requiredProcessorCount() const
+-    {
+-        return 2;
+-    }
+-
+-    void OneToOneTranslatorThroughputTest::waitForEventProcessorSequence(std::int64_t expectedCount)
+-    {
+-        while (m_ringBuffer->getMinimumGatingSequence() != expectedCount)
+-        {
+-            std::this_thread::sleep_for(std::chrono::milliseconds(1));
+-        }
+-    }
+-
+-    const std::shared_ptr< OneToOneTranslatorThroughputTest::Translator >& OneToOneTranslatorThroughputTest::Translator::instance()
+-    {
+-        static std::shared_ptr< Translator > result(std::make_shared< Translator >());
+-        return result;
+-    }
+-
+-    void OneToOneTranslatorThroughputTest::Translator::translateTo(ValueEvent& event, std::int64_t /*sequence*/, const MutableLong& arg0)
+-    {
+-        event.value = arg0.value;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToOneTranslatorThroughputTest.h b/Disruptor.PerfTests/OneToOneTranslatorThroughputTest.h
+deleted file mode 100644
+index 4c3fe07..0000000
+--- a/Disruptor.PerfTests/OneToOneTranslatorThroughputTest.h
++++ /dev/null
+@@ -1,85 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/Disruptor.h"
+-#include "Disruptor/ITaskScheduler.h"
+-#include "Disruptor/RingBuffer.h"
+-
+-#include "Disruptor.PerfTests/IThroughputTest.h"
+-#include "Disruptor.PerfTests/MutableLong.h"
+-#include "Disruptor.PerfTests/PerfTestUtil.h"
+-#include "Disruptor.PerfTests/ValueAdditionEventHandler.h"
+-#include "Disruptor.PerfTests/ValueEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    /**
+-     *
+-     *     UniCast a series of items between 1 publisher and 1 event processor using the EventTranslator API
+-     *
+-     *     +----+    +-----+
+-     *     | P1 |--->| EP1 |
+-     *     +----+    +-----+
+-     *
+-     *     Disruptor:
+-     *     ==========
+-     *     track to prevent wrap
+-     *     +------------------+
+-     *     |                  |
+-     *     |                  v
+-     *     +----+    +====+    +====+   +-----+
+-     *     | P1 |--->| RB |/---| SB |   | EP1 |
+-     *     +----+    +====+    +====+   +-----+
+-     *     claim      get    ^        |
+-     *     |        |
+-     *     +--------+
+-     *     waitFor
+-     *
+-     *     P1  - Publisher 1
+-     *     RB  - RingBuffer
+-     *     SB  - SequenceBarrier
+-     *     EP1 - EventProcessor 1
+-     *
+-     */
+-    class OneToOneTranslatorThroughputTest : public IThroughputTest
+-    {
+-        class Translator;
+-
+-    public:
+-        std::int64_t run(Stopwatch& stopwatch) override;
+-
+-        std::int32_t requiredProcessorCount() const override;
+-
+-    private:
+-        void waitForEventProcessorSequence(std::int64_t expectedCount);
+-
+-        const std::int32_t m_bufferSize = 1024 * 64;
+-
+-#ifdef _DEBUG
+-        const std::int64_t m_iterations = 100L * 100L * 10L;
+-#else
+-        const std::int64_t m_iterations = 1000L * 1000L * 100L;
+-#endif
+-
+-        const std::int64_t m_expectedResult = PerfTestUtil::accumulatedAddition(m_iterations);
+-        std::shared_ptr< ValueAdditionEventHandler > m_handler = std::make_shared< ValueAdditionEventHandler >();
+-        std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer;
+-        MutableLong m_value = MutableLong(0);
+-        std::shared_ptr< ITaskScheduler > m_taskScheduler;
+-        std::shared_ptr< disruptor< ValueEvent > > m_disruptor;
+-    };
+-
+-
+-    class OneToOneTranslatorThroughputTest::Translator : public IEventTranslatorVararg< ValueEvent, MutableLong >
+-    {
+-    public:
+-        static const std::shared_ptr< Translator >& instance();
+-
+-        void translateTo(ValueEvent& event, std::int64_t sequence, const MutableLong& arg0) override;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToThreeDiamondSequencedThroughputTest.cpp b/Disruptor.PerfTests/OneToThreeDiamondSequencedThroughputTest.cpp
+deleted file mode 100644
+index f3d5325..0000000
+--- a/Disruptor.PerfTests/OneToThreeDiamondSequencedThroughputTest.cpp
++++ /dev/null
+@@ -1,84 +0,0 @@
+-#include "stdafx.h"
+-#include "OneToThreeDiamondSequencedThroughputTest.h"
+-
+-#include "PerfTestUtil.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    OneToThreeDiamondSequencedThroughputTest::OneToThreeDiamondSequencedThroughputTest()
+-    {
+-        auto sequenceBarrier = m_ringBuffer->newBarrier();
+-
+-        auto fizzHandler = std::make_shared< FizzBuzzEventHandler >(FizzBuzzStep::Fizz);
+-        m_batchProcessorFizz = std::make_shared< BatchEventProcessor< FizzBuzzEvent > >(m_ringBuffer, sequenceBarrier, fizzHandler);
+-
+-        auto buzzHandler = std::make_shared< FizzBuzzEventHandler >(FizzBuzzStep::Buzz);
+-        m_batchProcessorBuzz = std::make_shared< BatchEventProcessor< FizzBuzzEvent > >(m_ringBuffer, sequenceBarrier, buzzHandler);
+-
+-        auto sequenceBarrierFizzBuzz = m_ringBuffer->newBarrier({ m_batchProcessorFizz->sequence(), m_batchProcessorBuzz->sequence() });
+-
+-        m_fizzBuzzHandler = std::make_shared< FizzBuzzEventHandler >(FizzBuzzStep::FizzBuzz);
+-        m_batchProcessorFizzBuzz = std::make_shared< BatchEventProcessor< FizzBuzzEvent > >(m_ringBuffer, sequenceBarrierFizzBuzz, m_fizzBuzzHandler);
+-
+-        std::int64_t temp = 0;
+-        for (std::int64_t i = 0; i < m_iterations; ++i)
+-        {
+-            auto fizz = 0 == (i % 3L);
+-            auto buzz = 0 == (i % 5L);
+-
+-            if (fizz && buzz)
+-            {
+-                ++temp;
+-            }
+-        }
+-        m_expectedResult = temp;
+-
+-        m_ringBuffer->addGatingSequences({ m_batchProcessorFizzBuzz->sequence() });
+-    }
+-
+-    std::int64_t OneToThreeDiamondSequencedThroughputTest::run(Stopwatch& stopwatch)
+-    {
+-        auto latch = std::make_shared< Tests::ManualResetEvent >(false);
+-        m_fizzBuzzHandler->reset(latch, m_batchProcessorFizzBuzz->sequence()->value() + m_iterations);
+-
+-        auto processorTask1 = std::async(std::launch::async, [this] { m_batchProcessorFizz->run(); });
+-        auto processorTask2 = std::async(std::launch::async, [this] { m_batchProcessorBuzz->run(); });
+-        auto processorTask3 = std::async(std::launch::async, [this] { m_batchProcessorFizzBuzz->run(); });
+-
+-        stopwatch.start();
+-
+-        auto& rb = *m_ringBuffer;
+-        for (std::int64_t i = 0; i < m_iterations; ++i)
+-        {
+-            auto sequence = rb.next();
+-            rb[sequence].value = i;
+-            rb.publish(sequence);
+-        }
+-
+-        latch->waitOne();
+-        stopwatch.stop();
+-
+-        m_batchProcessorFizz->halt();
+-        m_batchProcessorBuzz->halt();
+-        m_batchProcessorFizzBuzz->halt();
+-        
+-        processorTask1.wait();
+-        processorTask2.wait();
+-        processorTask3.wait();
+-
+-        PerfTestUtil::failIfNot(m_expectedResult, m_fizzBuzzHandler->fizzBuzzCounter());
+-
+-        return m_iterations;
+-    }
+-
+-    std::int32_t OneToThreeDiamondSequencedThroughputTest::requiredProcessorCount() const
+-    {
+-        return 4;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToThreeDiamondSequencedThroughputTest.h b/Disruptor.PerfTests/OneToThreeDiamondSequencedThroughputTest.h
+deleted file mode 100644
+index b149c36..0000000
+--- a/Disruptor.PerfTests/OneToThreeDiamondSequencedThroughputTest.h
++++ /dev/null
+@@ -1,86 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/BatchEventProcessor.h"
+-#include "Disruptor/RingBuffer.h"
+-#include "Disruptor/YieldingWaitStrategy.h"
+-
+-#include "Disruptor.PerfTests/FizzBuzzEvent.h"
+-#include "Disruptor.PerfTests/FizzBuzzEventHandler.h"
+-#include "Disruptor.PerfTests/IThroughputTest.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    /**
+-     * Produce an event replicated to two event proces
+-     *           +-----+
+-     *    +----->| EP1 |------+
+-     *    |      +-----+      |
+-     *    |                   v
+-     * +----+              +-----+
+-     * | P1 |              | EP3 |
+-     * +----+              +-----+
+-     *    |                   ^
+-     *    |      +-----+      |
+-     *    +----->| EP2 |------+
+-     *           +-----+
+-     * Disruptor:
+-     * ==========
+-     *                    track to prevent wrap
+-     *              +-------------------------------+
+-     *              |                               |
+-     *              |                               v
+-     * +----+    +====+               +=====+    +----
+-     * | P1 |---\| RB |/--------------| SB2 |/---| EP3
+-     * +----+    +====+               +=====+    +----
+-     *      claim   ^  get               |   waitFor
+-     *              |                    |
+-     *           +=====+    +-----+      |
+-     *           | SB1 |/---| EP1 |/-----+
+-     *           +=====+    +-----+      |
+-     *              ^                    |
+-     *              |       +-----+      |
+-     *              +-------| EP2 |/-----+
+-     *             waitFor  +-----+
+-     *
+-     * P1  - Publisher 1
+-     * RB  - RingBuffer
+-     * SB1 - SequenceBarrier 1
+-     * EP1 - EventProcessor 1
+-     * EP2 - EventProcessor 2
+-     * SB2 - SequenceBarrier 2
+-     * EP3 - EventProcessor 3
+-     *
+-     */
+-    class OneToThreeDiamondSequencedThroughputTest : public IThroughputTest
+-    {
+-    public:
+-        OneToThreeDiamondSequencedThroughputTest();
+-
+-        std::int64_t run(Stopwatch& stopwatch) override;
+-
+-        std::int32_t requiredProcessorCount() const override;
+-
+-    private:
+-        const std::int32_t m_bufferSize = 1024 * 8;
+-
+-#ifdef _DEBUG
+-        const std::int64_t m_iterations = 100L * 100L * 10L;
+-#else
+-        const std::int64_t m_iterations = 1000L * 1000L * 100L;
+-#endif
+-
+-        std::int64_t m_expectedResult;
+-
+-        std::shared_ptr< RingBuffer< FizzBuzzEvent > > m_ringBuffer = RingBuffer< FizzBuzzEvent >::createSingleProducer(FizzBuzzEvent::eventFactory(), m_bufferSize, std::make_shared< YieldingWaitStrategy >());
+-        std::shared_ptr< BatchEventProcessor< FizzBuzzEvent > > m_batchProcessorFizz;
+-        std::shared_ptr< BatchEventProcessor< FizzBuzzEvent > > m_batchProcessorBuzz;
+-        std::shared_ptr< BatchEventProcessor< FizzBuzzEvent > > m_batchProcessorFizzBuzz;
+-        std::shared_ptr< FizzBuzzEventHandler > m_fizzBuzzHandler;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToThreePipelineSequencedThroughputTest.cpp b/Disruptor.PerfTests/OneToThreePipelineSequencedThroughputTest.cpp
+deleted file mode 100644
+index 1f8604a..0000000
+--- a/Disruptor.PerfTests/OneToThreePipelineSequencedThroughputTest.cpp
++++ /dev/null
+@@ -1,90 +0,0 @@
+-#include "stdafx.h"
+-#include "OneToThreePipelineSequencedThroughputTest.h"
+-
+-#include "PerfTestUtil.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    OneToThreePipelineSequencedThroughputTest::OneToThreePipelineSequencedThroughputTest()
+-    {
+-        auto stepOneFunctionHandler = std::make_shared< FunctionEventHandler >(FunctionStep::One);
+-        auto stepTwoFunctionHandler = std::make_shared< FunctionEventHandler >(FunctionStep::Two);
+-        m_stepThreeFunctionHandler = std::make_shared< FunctionEventHandler >(FunctionStep::Three);
+-
+-        auto stepOneSequenceBarrier = m_ringBuffer->newBarrier();
+-        m_stepOneBatchProcessor = std::make_shared< BatchEventProcessor< FunctionEvent > >(m_ringBuffer, stepOneSequenceBarrier, stepOneFunctionHandler);
+-
+-        auto stepTwoSequenceBarrier = m_ringBuffer->newBarrier({ m_stepOneBatchProcessor->sequence() });
+-        m_stepTwoBatchProcessor = std::make_shared< BatchEventProcessor< FunctionEvent > >(m_ringBuffer, stepTwoSequenceBarrier, stepTwoFunctionHandler);
+-
+-        auto stepThreeSequenceBarrier = m_ringBuffer->newBarrier({ m_stepTwoBatchProcessor->sequence() });
+-        m_stepThreeBatchProcessor = std::make_shared< BatchEventProcessor< FunctionEvent > >(m_ringBuffer, stepThreeSequenceBarrier, m_stepThreeFunctionHandler);
+-
+-        std::int64_t temp = 0;
+-        auto operandTwo = m_operandTwoInitialValue;
+-
+-        for (std::int64_t i = 0; i < m_iterations; ++i)
+-        {
+-            auto stepOneResult = i + operandTwo--;
+-            auto stepTwoResult = stepOneResult + 3;
+-
+-            if ((stepTwoResult & 4L) == 4L)
+-            {
+-                ++temp;
+-            }
+-        }
+-        m_expectedResult = temp;
+-
+-        m_ringBuffer->addGatingSequences({ m_stepThreeBatchProcessor->sequence() });
+-    }
+-
+-    std::int64_t OneToThreePipelineSequencedThroughputTest::run(Stopwatch& stopwatch)
+-    {
+-        auto latch = std::make_shared< Tests::ManualResetEvent >(false);
+-        m_stepThreeFunctionHandler->reset(latch, m_stepThreeBatchProcessor->sequence()->value() + m_iterations);
+-
+-        auto processorTask1 = m_executor->submit(m_stepOneBatchProcessor);
+-        auto processorTask2 = m_executor->submit(m_stepTwoBatchProcessor);
+-        auto processorTask3 = m_executor->submit(m_stepThreeBatchProcessor);
+-
+-        auto& rb = *m_ringBuffer;
+-
+-        stopwatch.start();
+-
+-        auto operandTwo = m_operandTwoInitialValue;
+-        for (std::int64_t i = 0; i < m_iterations; ++i)
+-        {
+-            auto sequence = rb.next();
+-            auto& event = rb[sequence];
+-            event.operandOne = i;
+-            event.operandTwo = operandTwo--;
+-            rb.publish(sequence);
+-        }
+-
+-        latch->waitOne();
+-        stopwatch.stop();
+-
+-        m_stepOneBatchProcessor->halt();
+-        m_stepTwoBatchProcessor->halt();
+-        m_stepThreeBatchProcessor->halt();
+-
+-        processorTask1.wait();
+-        processorTask2.wait();
+-        processorTask3.wait();
+-
+-        PerfTestUtil::failIfNot(m_expectedResult, m_stepThreeFunctionHandler->stepThreeCounter());
+-
+-        return m_iterations;
+-    }
+-
+-    std::int32_t OneToThreePipelineSequencedThroughputTest::requiredProcessorCount() const
+-    {
+-        return 4;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToThreePipelineSequencedThroughputTest.h b/Disruptor.PerfTests/OneToThreePipelineSequencedThroughputTest.h
+deleted file mode 100644
+index 855f369..0000000
+--- a/Disruptor.PerfTests/OneToThreePipelineSequencedThroughputTest.h
++++ /dev/null
+@@ -1,80 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/RingBuffer.h"
+-#include "Disruptor/YieldingWaitStrategy.h"
+-
+-#include "Disruptor.PerfTests/ExecutorService.h"
+-#include "Disruptor.PerfTests/FunctionEvent.h"
+-#include "Disruptor.PerfTests/FunctionEventHandler.h"
+-#include "Disruptor.PerfTests/IThroughputTest.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    /**
+-     * Pipeline a series of stages from a publisher to ultimate event processor.
+-     * Each event processor depends on the output of the event processor.
+-     * 
+-     * +----+    +-----+    +-----+    +-----+
+-     * | P1 |--->| EP1 |--->| EP2 |--->| EP3 |
+-     * +----+    +-----+    +-----+    +-----+
+-     * 
+-     * Disruptor:
+-     * ==========
+-     *                           track to prevent wrap
+-     *              +----------------------------------------------------------------+
+-     *              |                                                                |
+-     *              |                                                                v
+-     * +----+    +====+    +=====+    +-----+    +=====+    +-----+    +=====+    +-----+
+-     * | P1 |--->| RB |    | SB1 |/---| EP1 |/---| SB2 |/---| EP2 |/---| SB3 |/---| EP3 |
+-     * +----+    +====+    +=====+    +-----+    +=====+    +-----+    +=====+    +-----+
+-     *      claim   ^  get    |   waitFor           |   waitFor           |  waitFor
+-     *              |         |                     |                     |
+-     *              +---------+---------------------+---------------------+
+-     *        
+-     * P1  - Publisher 1
+-     * RB  - RingBuffer
+-     * SB1 - SequenceBarrier 1
+-     * EP1 - EventProcessor 1
+-     * SB2 - SequenceBarrier 2
+-     * EP2 - EventProcessor 2
+-     * SB3 - SequenceBarrier 3
+-     * EP3 - EventProcessor 3
+-     * 
+-     */
+-    class OneToThreePipelineSequencedThroughputTest : public IThroughputTest
+-    {
+-    public:
+-        OneToThreePipelineSequencedThroughputTest();
+-
+-        std::int64_t run(Stopwatch& stopwatch) override;
+-
+-        std::int32_t requiredProcessorCount() const override;
+-
+-    private:
+-        const std::int32_t m_bufferSize = 1024 * 8;
+-
+-#ifdef _DEBUG
+-        const std::int64_t m_iterations = 100L * 100L * 10L;
+-#else
+-        const std::int64_t m_iterations = 1000L * 1000L * 100L;
+-#endif
+-
+-        std::shared_ptr< ExecutorService< FunctionEvent > > m_executor = std::make_shared< ExecutorService< FunctionEvent > >();
+-
+-        const std::int64_t m_operandTwoInitialValue = 777L;
+-        std::int64_t m_expectedResult;
+-
+-        std::shared_ptr< RingBuffer< FunctionEvent > > m_ringBuffer = RingBuffer< FunctionEvent >::createSingleProducer(FunctionEvent::eventFactory(), m_bufferSize, std::make_shared< YieldingWaitStrategy >());
+-
+-        std::shared_ptr< BatchEventProcessor< FunctionEvent > > m_stepOneBatchProcessor;
+-        std::shared_ptr< BatchEventProcessor< FunctionEvent > > m_stepTwoBatchProcessor;
+-        std::shared_ptr< BatchEventProcessor< FunctionEvent > > m_stepThreeBatchProcessor;
+-        std::shared_ptr< FunctionEventHandler > m_stepThreeFunctionHandler;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToThreeReleasingWorkerPoolThroughputTest.cpp b/Disruptor.PerfTests/OneToThreeReleasingWorkerPoolThroughputTest.cpp
+deleted file mode 100644
+index 7adff91..0000000
+--- a/Disruptor.PerfTests/OneToThreeReleasingWorkerPoolThroughputTest.cpp
++++ /dev/null
+@@ -1,105 +0,0 @@
+-#include "stdafx.h"
+-#include "OneToThreeReleasingWorkerPoolThroughputTest.h"
+-
+-#include "Disruptor/BasicExecutor.h"
+-#include "Disruptor/FatalExceptionHandler.h"
+-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
+-
+-#include "Disruptor.TestTools/ScopeExitFunctor.h"
+-
+-#include "PerfTestUtil.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    OneToThreeReleasingWorkerPoolThroughputTest::OneToThreeReleasingWorkerPoolThroughputTest()
+-    {
+-        for (auto i = 0; i < m_numWorkers; ++i)
+-        {
+-            m_counters[i] = std::make_shared< PaddedLong >();
+-        }
+-
+-        for (auto i = 0; i < m_numWorkers; ++i)
+-        {
+-            m_handlers[i] = std::make_shared< EventCountingAndReleasingWorkHandler >(m_counters, i);
+-        }
+-
+-        m_workerPool = std::make_shared< WorkerPool< ValueEvent > >(m_ringBuffer, m_ringBuffer->newBarrier(), std::make_shared< FatalExceptionHandler< ValueEvent > >(), m_handlers);
+-
+-        m_ringBuffer->addGatingSequences({ m_workerPool->getWorkerSequences() });
+-    }
+-
+-    std::int64_t OneToThreeReleasingWorkerPoolThroughputTest::run(Stopwatch& stopwatch)
+-    {
+-        auto scheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
+-        scheduler->start(requiredProcessorCount());
+-        TestTools::ScopeExitFunctor atScopeExit([scheduler] { scheduler->stop(); });
+-
+-        resetCounters();
+-        auto& ringBuffer = *m_workerPool->start(std::make_shared< BasicExecutor >(scheduler));
+-        stopwatch.start();
+-
+-        for (std::int64_t i = 0; i < m_iterations; ++i)
+-        {
+-            std::int64_t sequence = ringBuffer.next();
+-            ringBuffer[sequence].value = i;
+-            ringBuffer.publish(sequence);
+-        }
+-
+-        m_workerPool->drainAndHalt();
+-
+-        // Workaround to ensure that the last worker(s) have completed after releasing their events
+-        std::this_thread::sleep_for(std::chrono::milliseconds(1));
+-        stopwatch.stop();
+-
+-        PerfTestUtil::failIfNot(m_iterations, sumCounters());
+-
+-        return m_iterations;
+-    }
+-
+-    std::int32_t OneToThreeReleasingWorkerPoolThroughputTest::requiredProcessorCount() const
+-    {
+-        return 4;
+-    }
+-
+-    void OneToThreeReleasingWorkerPoolThroughputTest::resetCounters()
+-    {
+-        for (auto i = 0; i < m_numWorkers; ++i)
+-        {
+-            m_counters[i]->value = 0L;
+-        }
+-    }
+-
+-    std::int64_t OneToThreeReleasingWorkerPoolThroughputTest::sumCounters()
+-    {
+-        std::int64_t sumJobs = 0L;
+-        for (auto i = 0; i < m_numWorkers; ++i)
+-        {
+-            sumJobs += m_counters[i]->value;
+-        }
+-
+-        return sumJobs;
+-    }
+-
+-    OneToThreeReleasingWorkerPoolThroughputTest::EventCountingAndReleasingWorkHandler::EventCountingAndReleasingWorkHandler(const std::vector< std::shared_ptr< PaddedLong > >& counters, std::int32_t index)
+-        : m_counters(counters)
+-        , m_index(index)
+-    {
+-    }
+-
+-    void OneToThreeReleasingWorkerPoolThroughputTest::EventCountingAndReleasingWorkHandler::onEvent(ValueEvent& /*evt*/)
+-    {
+-        m_eventReleaser->release();
+-        m_counters[m_index]->value = m_counters[m_index]->value + 1L;
+-    }
+-
+-    void OneToThreeReleasingWorkerPoolThroughputTest::EventCountingAndReleasingWorkHandler::setEventReleaser(const std::shared_ptr< IEventReleaser >& eventReleaser)
+-    {
+-        m_eventReleaser = eventReleaser;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToThreeReleasingWorkerPoolThroughputTest.h b/Disruptor.PerfTests/OneToThreeReleasingWorkerPoolThroughputTest.h
+deleted file mode 100644
+index a5735a2..0000000
+--- a/Disruptor.PerfTests/OneToThreeReleasingWorkerPoolThroughputTest.h
++++ /dev/null
+@@ -1,68 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/IWorkHandler.h"
+-#include "Disruptor/RingBuffer.h"
+-#include "Disruptor/WorkerPool.h"
+-#include "Disruptor/YieldingWaitStrategy.h"
+-
+-#include "Disruptor.PerfTests/EventCountingQueueProcessor.h"
+-#include "Disruptor.PerfTests/EventCountingWorkHandler.h"
+-#include "Disruptor.PerfTests/IThroughputTest.h"
+-#include "Disruptor.PerfTests/PaddedLong.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class OneToThreeReleasingWorkerPoolThroughputTest : public IThroughputTest
+-    {
+-        class EventCountingAndReleasingWorkHandler;
+-
+-    public:
+-        OneToThreeReleasingWorkerPoolThroughputTest();
+-
+-        std::int64_t run(Stopwatch& stopwatch) override;
+-
+-        std::int32_t requiredProcessorCount() const override;
+-
+-    private:
+-        void resetCounters();
+-        std::int64_t sumCounters();
+-
+-        const std::int32_t m_numWorkers = 3;
+-        const std::int32_t m_bufferSize = 1024 * 8;
+-
+-#ifdef _DEBUG
+-        const std::int64_t m_iterations = 100L * 100L * 1L;
+-#else
+-        const std::int64_t m_iterations = 1000L * 1000L * 10L;
+-#endif
+-
+-        std::vector< std::shared_ptr< PaddedLong > > m_counters = std::vector< std::shared_ptr< PaddedLong > >(m_numWorkers);
+-        std::vector< std::shared_ptr< IWorkHandler< ValueEvent > > > m_handlers = std::vector< std::shared_ptr< IWorkHandler< ValueEvent > > >(m_numWorkers);
+-        std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer = RingBuffer< ValueEvent >::createSingleProducer(ValueEvent::eventFactory(),
+-                                                                                                                  m_bufferSize,
+-                                                                                                                  std::make_shared< YieldingWaitStrategy >());
+-        std::shared_ptr< WorkerPool< ValueEvent > > m_workerPool;
+-    };
+-
+-
+-    class OneToThreeReleasingWorkerPoolThroughputTest::EventCountingAndReleasingWorkHandler : public IWorkHandler< ValueEvent >, public IEventReleaseAware
+-    {
+-    public:
+-        EventCountingAndReleasingWorkHandler(const std::vector< std::shared_ptr< PaddedLong > >& counters, std::int32_t index);
+-
+-        void onEvent(ValueEvent& evt) override;
+-
+-        void setEventReleaser(const std::shared_ptr< IEventReleaser >& eventReleaser) override;
+-
+-    private:
+-        std::vector< std::shared_ptr< PaddedLong > > m_counters;
+-        std::int32_t m_index;
+-        std::shared_ptr< IEventReleaser > m_eventReleaser;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToThreeSequencedThroughputTest.cpp b/Disruptor.PerfTests/OneToThreeSequencedThroughputTest.cpp
+deleted file mode 100644
+index ca03fdb..0000000
+--- a/Disruptor.PerfTests/OneToThreeSequencedThroughputTest.cpp
++++ /dev/null
+@@ -1,97 +0,0 @@
+-#include "stdafx.h"
+-#include "OneToThreeSequencedThroughputTest.h"
+-
+-#include "Disruptor/BasicExecutor.h"
+-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
+-#include "Disruptor/YieldingWaitStrategy.h"
+-
+-#include "Disruptor.TestTools/ScopeExitFunctor.h"
+-#include "Disruptor/BatchEventProcessor.h"
+-#include "PerfTestUtil.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    OneToThreeSequencedThroughputTest::OneToThreeSequencedThroughputTest()
+-    {
+-        m_taskScheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
+-        m_executor = std::make_shared< BasicExecutor >(m_taskScheduler);
+-
+-        for (std::int64_t i = 0; i < m_iterations; ++i)
+-        {
+-            m_results[0] = OperationExtensions::Op(Operation::Addition, m_results[0], i);
+-            m_results[1] = OperationExtensions::Op(Operation::Subtraction, m_results[1], i);
+-            m_results[2] = OperationExtensions::Op(Operation::And, m_results[2], i);
+-        }
+-
+-        m_ringBuffer = RingBuffer< ValueEvent >::createSingleProducer(ValueEvent::eventFactory(), m_bufferSize, std::make_shared< YieldingWaitStrategy >());
+-        auto sequenceBarrier = m_ringBuffer->newBarrier();
+-
+-        m_handlers[0] = std::make_shared< ValueMutationEventHandler >(Operation::Addition);
+-        m_handlers[1] = std::make_shared< ValueMutationEventHandler >(Operation::Subtraction);
+-        m_handlers[2] = std::make_shared< ValueMutationEventHandler >(Operation::And);
+-
+-        for (auto i = 0; i < m_numEventProcessors; ++i)
+-        {
+-            m_batchEventProcessors[i] = std::make_shared< BatchEventProcessor< ValueEvent > >(m_ringBuffer, sequenceBarrier, m_handlers[i]);
+-        }
+-
+-        std::vector< std::shared_ptr< ISequence > > sequences;
+-        for (auto&& processor : m_batchEventProcessors)
+-        {
+-            sequences.push_back(processor->sequence());
+-        }
+-        m_ringBuffer->addGatingSequences(sequences);
+-    }
+-
+-    std::int64_t OneToThreeSequencedThroughputTest::run(Stopwatch& stopwatch)
+-    {
+-        m_taskScheduler->start(requiredProcessorCount());
+-        TestTools::ScopeExitFunctor atScopeExit([this] { m_taskScheduler->stop(); });
+-
+-        auto latch = std::make_shared< boost::barrier >(m_numEventProcessors + 1);
+-
+-        std::vector< std::future< void > > processorTasks;
+-        for (auto i = 0; i < m_numEventProcessors; ++i)
+-        {
+-            m_handlers[i]->reset(latch, m_batchEventProcessors[i]->sequence()->value() + m_iterations);
+-            processorTasks.push_back(m_executor->execute([this, i] { m_batchEventProcessors[i]->run(); }));
+-        }
+-
+-        auto& rb = *m_ringBuffer;
+-
+-        stopwatch.start();
+-
+-        for (std::int64_t i = 0; i < m_iterations; ++i)
+-        {
+-            auto sequence = rb.next();
+-            rb[sequence].value = i;
+-            rb.publish(sequence);
+-        }
+-
+-        latch->wait();
+-        stopwatch.stop();
+-
+-        for (auto i = 0; i < m_numEventProcessors; ++i)
+-        {
+-            m_batchEventProcessors[i]->halt();
+-            PerfTestUtil::failIfNot(m_results[i], m_handlers[i]->value(),
+-                                    "Result " + std::to_string(m_results[i]) + " != " + std::to_string(m_handlers[i]->value()));
+-        }
+-
+-        for (auto&& task : processorTasks)
+-            task.wait();
+-
+-        return m_numEventProcessors * m_iterations;
+-    }
+-
+-    std::int32_t OneToThreeSequencedThroughputTest::requiredProcessorCount() const
+-    {
+-        return 4;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToThreeSequencedThroughputTest.h b/Disruptor.PerfTests/OneToThreeSequencedThroughputTest.h
+deleted file mode 100644
+index 7c48dc7..0000000
+--- a/Disruptor.PerfTests/OneToThreeSequencedThroughputTest.h
++++ /dev/null
+@@ -1,81 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/BatchEventProcessor.h"
+-#include "Disruptor/IExecutor.h"
+-#include "Disruptor/ITaskScheduler.h"
+-#include "Disruptor/RingBuffer.h"
+-
+-#include "Disruptor.PerfTests/IThroughputTest.h"
+-#include "Disruptor.PerfTests/ValueEvent.h"
+-#include "Disruptor.PerfTests/ValueMutationEventHandler.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    /**
+-     * MultiCast a series of items between 1 publisher and 3 event processors.
+-     *           +-----+
+-     *    +----->| EP1 |
+-     *    |      +-----+
+-     *    |
+-     * +----+    +-----+
+-     * | P1 |--->| EP2 |
+-     * +----+    +-----+
+-     *    |
+-     *    |      +-----+
+-     *    +----->| EP3 |
+-     *           +-----+
+-     * Disruptor:
+-     * ==========
+-     *                             track to prevent wrap
+-     *             +--------------------+----------+----------+
+-     *             |                    |          |          |
+-     *             |                    v          v          v
+-     * +----+    +====+    +====+    +-----+    +-----+    +-----+
+-     * | P1 |---\| RB |/---| SB |    | EP1 |    | EP2 |    | EP3 |
+-     * +----+    +====+    +====+    +-----+    +-----+    +-----+
+-     *      claim      get    ^         |          |          |
+-     *                        |         |          |          |
+-     *                        +---------+----------+----------+
+-     *                                      waitFor
+-     * P1  - Publisher 1
+-     * RB  - RingBuffer
+-     * SB  - SequenceBarrier
+-     * EP1 - EventProcessor 1
+-     * EP2 - EventProcessor 2
+-     * EP3 - EventProcessor 3
+-     *
+-     */
+-    class OneToThreeSequencedThroughputTest : public IThroughputTest
+-    {
+-    public:
+-        OneToThreeSequencedThroughputTest();
+-
+-        std::int64_t run(Stopwatch& stopwatch) override;
+-
+-        std::int32_t requiredProcessorCount() const override;
+-
+-    private:
+-        const std::int32_t m_numEventProcessors = 3;
+-        const std::int32_t m_bufferSize = 1024 * 8;
+-
+-#ifdef _DEBUG
+-        const std::int64_t m_iterations = 100L * 100L * 10L;
+-#else
+-        const std::int64_t m_iterations = 1000L * 1000L * 100L;
+-#endif
+-
+-        std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer;
+-        std::vector< std::shared_ptr< BatchEventProcessor< ValueEvent > > > m_batchEventProcessors = std::vector< std::shared_ptr< BatchEventProcessor< ValueEvent > > >(m_numEventProcessors);
+-        std::vector< std::int64_t > m_results = std::vector< std::int64_t >(m_numEventProcessors);
+-        std::vector< std::shared_ptr< ValueMutationEventHandler > > m_handlers = std::vector< std::shared_ptr< ValueMutationEventHandler > >(m_numEventProcessors);
+-        
+-        std::shared_ptr< IExecutor > m_executor;
+-        std::shared_ptr< ITaskScheduler > m_taskScheduler;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToThreeWorkerPoolThroughputTest.cpp b/Disruptor.PerfTests/OneToThreeWorkerPoolThroughputTest.cpp
+deleted file mode 100644
+index 73cd3b2..0000000
+--- a/Disruptor.PerfTests/OneToThreeWorkerPoolThroughputTest.cpp
++++ /dev/null
+@@ -1,93 +0,0 @@
+-#include "stdafx.h"
+-#include "OneToThreeWorkerPoolThroughputTest.h"
+-
+-#include "Disruptor/BasicExecutor.h"
+-#include "Disruptor/FatalExceptionHandler.h"
+-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
+-
+-#include "Disruptor.TestTools/ScopeExitFunctor.h"
+-
+-#include "PerfTestUtil.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    OneToThreeWorkerPoolThroughputTest::OneToThreeWorkerPoolThroughputTest()
+-    {
+-        for (auto i = 0; i < m_numWorkers; ++i)
+-        {
+-            m_counters[i] = std::make_shared< PaddedLong >();
+-        }
+-
+-        for (auto i = 0; i < m_numWorkers; ++i)
+-        {
+-            m_queueWorkers[i] = std::make_shared< EventCountingQueueProcessor >(m_blockingQueue, m_counters, i);
+-        }
+-
+-        for (auto i = 0; i < m_numWorkers; ++i)
+-        {
+-            m_handlers[i] = std::make_shared< EventCountingWorkHandler >(m_counters, i);
+-        }
+-
+-        m_workerPool = std::make_shared< WorkerPool< ValueEvent > >(m_ringBuffer, m_ringBuffer->newBarrier(), std::make_shared< FatalExceptionHandler< ValueEvent > >(), m_handlers);
+-
+-        m_ringBuffer->addGatingSequences({ m_workerPool->getWorkerSequences() });
+-    }
+-
+-    std::int64_t OneToThreeWorkerPoolThroughputTest::run(Stopwatch& stopwatch)
+-    {
+-        auto scheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
+-        scheduler->start(requiredProcessorCount());
+-        TestTools::ScopeExitFunctor atScopeExit([scheduler] { scheduler->stop(); });
+-
+-        resetCounters();
+-        auto& ringBuffer = *m_workerPool->start(std::make_shared< BasicExecutor >(scheduler));
+-        stopwatch.start();
+-
+-        for (std::int64_t i = 0; i < m_iterations; ++i)
+-        {
+-            std::int64_t sequence = ringBuffer.next();
+-            ringBuffer[sequence].value = i;
+-            ringBuffer.publish(sequence);
+-        }
+-
+-        m_workerPool->drainAndHalt();
+-
+-        // Workaround to ensure that the last worker(s) have completed after releasing their events
+-        std::this_thread::sleep_for(std::chrono::milliseconds(1));
+-        stopwatch.stop();
+-
+-        PerfTestUtil::failIfNot(m_iterations, sumCounters());
+-
+-        return m_iterations;
+-    }
+-
+-    std::int32_t OneToThreeWorkerPoolThroughputTest::requiredProcessorCount() const
+-    {
+-        return 4;
+-    }
+-
+-    void OneToThreeWorkerPoolThroughputTest::resetCounters()
+-    {
+-        for (auto i = 0; i < m_numWorkers; ++i)
+-        {
+-            m_counters[i]->value = 0L;
+-        }
+-    }
+-
+-    std::int64_t OneToThreeWorkerPoolThroughputTest::sumCounters()
+-    {
+-        std::int64_t sumJobs = 0L;
+-        for (auto i = 0; i < m_numWorkers; ++i)
+-        {
+-            sumJobs += m_counters[i]->value;
+-        }
+-
+-        return sumJobs;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/OneToThreeWorkerPoolThroughputTest.h b/Disruptor.PerfTests/OneToThreeWorkerPoolThroughputTest.h
+deleted file mode 100644
+index 12869bd..0000000
+--- a/Disruptor.PerfTests/OneToThreeWorkerPoolThroughputTest.h
++++ /dev/null
+@@ -1,56 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/BlockingQueue.h"
+-#include "Disruptor/IWorkHandler.h"
+-#include "Disruptor/RingBuffer.h"
+-#include "Disruptor/WorkerPool.h"
+-#include "Disruptor/YieldingWaitStrategy.h"
+-
+-#include "Disruptor.PerfTests/EventCountingQueueProcessor.h"
+-#include "Disruptor.PerfTests/EventCountingWorkHandler.h"
+-#include "Disruptor.PerfTests/IThroughputTest.h"
+-#include "Disruptor.PerfTests/PaddedLong.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class OneToThreeWorkerPoolThroughputTest : public IThroughputTest
+-    {
+-    public:
+-        OneToThreeWorkerPoolThroughputTest();
+-
+-        std::int64_t run(Stopwatch& stopwatch) override;
+-
+-        std::int32_t requiredProcessorCount() const override;
+-
+-    private:
+-        void resetCounters();
+-        std::int64_t sumCounters();
+-
+-        const std::int32_t m_numWorkers = 3;
+-        const std::int32_t m_bufferSize = 1024 * 8;
+-
+-#ifdef _DEBUG
+-        const std::int64_t m_iterations = 100L * 100L * 10L;
+-#else
+-        const std::int64_t m_iterations = 1000L * 1000L * 100L;
+-#endif
+-
+-        std::vector< std::shared_ptr< PaddedLong > > m_counters = std::vector< std::shared_ptr< PaddedLong > >(m_numWorkers);
+-
+-        std::shared_ptr< BlockingQueue< std::int64_t > > m_blockingQueue = std::make_shared< BlockingQueue< std::int64_t > >();
+-        std::vector< std::shared_ptr< EventCountingQueueProcessor > > m_queueWorkers = std::vector< std::shared_ptr< EventCountingQueueProcessor > >(m_numWorkers);
+-        std::vector< std::shared_ptr< IWorkHandler< ValueEvent > > > m_handlers = std::vector< std::shared_ptr< IWorkHandler< ValueEvent > > >(m_numWorkers);
+-
+-        std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer = RingBuffer< ValueEvent >::createSingleProducer(ValueEvent::eventFactory(),
+-                                                                                                                  m_bufferSize,
+-                                                                                                                  std::make_shared< YieldingWaitStrategy >());
+-
+-        std::shared_ptr< WorkerPool< ValueEvent > > m_workerPool;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/Operation.cpp b/Disruptor.PerfTests/Operation.cpp
+deleted file mode 100644
+index 939cc2b..0000000
+--- a/Disruptor.PerfTests/Operation.cpp
++++ /dev/null
+@@ -1,31 +0,0 @@
+-#include "stdafx.h"
+-#include "Operation.h"
+-
+-#include "Disruptor/ArgumentOutOfRangeException.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-namespace OperationExtensions
+-{
+-
+-    std::int64_t Op(Operation operation, std::int64_t lhs, std::int64_t rhs)
+-    {
+-        switch (operation)
+-        {
+-        case Operation::Addition:
+-            return lhs + rhs;
+-        case Operation::Subtraction:
+-            return lhs - rhs;
+-        case Operation::And:
+-            return lhs & rhs;
+-        default:
+-            DISRUPTOR_THROW_ARGUMENT_OUT_OF_RANGE_EXCEPTION("The variable 'operation' (" << static_cast< int >(operation) << ") is out of range");
+-        }
+-    }
+-
+-} // namespace OperationExtensions
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/Operation.h b/Disruptor.PerfTests/Operation.h
+deleted file mode 100644
+index db0fa21..0000000
+--- a/Disruptor.PerfTests/Operation.h
++++ /dev/null
+@@ -1,25 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    enum class Operation
+-    {
+-        Addition,
+-        Subtraction,
+-        And
+-    };
+-
+-namespace OperationExtensions
+-{
+-
+-    std::int64_t Op(Operation operation, std::int64_t lhs, std::int64_t rhs);
+-
+-} // namespace OperationExtensions
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/PaddedLong.h b/Disruptor.PerfTests/PaddedLong.h
+deleted file mode 100644
+index 27c0314..0000000
+--- a/Disruptor.PerfTests/PaddedLong.h
++++ /dev/null
+@@ -1,18 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    struct PaddedLong
+-    {
+-        std::int64_t value = 0;
+-        char _padding[54];
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/PerfTestUtil.cpp b/Disruptor.PerfTests/PerfTestUtil.cpp
+deleted file mode 100644
+index 8e1d44c..0000000
+--- a/Disruptor.PerfTests/PerfTestUtil.cpp
++++ /dev/null
+@@ -1,60 +0,0 @@
+-#include "stdafx.h"
+-#include "PerfTestUtil.h"
+-
+-#include <boost/date_time.hpp>
+-
+-#include "Disruptor/IEventProcessor.h"
+-#include "Disruptor/ISequence.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-namespace PerfTestUtil
+-{
+-
+-    std::int64_t accumulatedAddition(std::int64_t iterations)
+-    {
+-        std::int64_t temp = 0L;
+-        for (std::int64_t i = 0L; i < iterations; i++)
+-        {
+-            temp += i;
+-        }
+-
+-        return temp;
+-    }
+-
+-    void failIf(std::int64_t a, std::int64_t b, const std::string& message)
+-    {
+-        if (a == b)
+-        {
+-            throw std::runtime_error(message.empty() ? "Test failed " + std::to_string(a) + " == " + std::to_string(b) : message);
+-        }
+-    }
+-
+-    void failIfNot(std::int64_t a, std::int64_t b, const std::string& message)
+-    {
+-        if (a != b)
+-        {
+-            throw std::runtime_error(message.empty() ? "Test failed " + std::to_string(a) + " != " + std::to_string(b) : message);
+-        }
+-    }
+-
+-    void waitForEventProcessorSequence(std::int64_t expectedCount, const std::shared_ptr< IEventProcessor >& batchEventProcessor)
+-    {
+-        while (batchEventProcessor->sequence()->value() != expectedCount)
+-        {
+-            std::this_thread::sleep_for(std::chrono::milliseconds(1));
+-        }
+-    }
+-
+-    std::string utcDateToString()
+-    {
+-        auto t(boost::posix_time::second_clock::universal_time());
+-        return to_simple_string(t);
+-    }
+-
+-} // namespace PerfTestUtil
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/PerfTestUtil.h b/Disruptor.PerfTests/PerfTestUtil.h
+deleted file mode 100644
+index 54419bc..0000000
+--- a/Disruptor.PerfTests/PerfTestUtil.h
++++ /dev/null
+@@ -1,29 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-#include <string>
+-
+-
+-namespace Disruptor
+-{
+-
+-    class IEventProcessor;
+-
+-namespace PerfTests
+-{
+-namespace PerfTestUtil
+-{
+-
+-    std::int64_t accumulatedAddition(std::int64_t iterations);
+-
+-    void failIf(std::int64_t a, std::int64_t b, const std::string& message = std::string());
+-
+-    void failIfNot(std::int64_t a, std::int64_t b, const std::string& message = std::string());
+-
+-    void waitForEventProcessorSequence(std::int64_t expectedCount, const std::shared_ptr< IEventProcessor >& batchEventProcessor);
+-
+-    std::string utcDateToString();
+-    
+-} // namespace PerfTestUtil
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/PingPongSequencedLatencyTest.cpp b/Disruptor.PerfTests/PingPongSequencedLatencyTest.cpp
+deleted file mode 100644
+index 8ccfa88..0000000
+--- a/Disruptor.PerfTests/PingPongSequencedLatencyTest.cpp
++++ /dev/null
+@@ -1,161 +0,0 @@
+-#include "stdafx.h"
+-#include "PingPongSequencedLatencyTest.h"
+-
+-#include "Disruptor/BasicExecutor.h"
+-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
+-
+-#include "Disruptor.TestTools/ScopeExitFunctor.h"
+-#include "LatencyTestSession.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    PingPongSequencedLatencyTest::PingPongSequencedLatencyTest()
+-    {
+-        m_taskScheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
+-        m_executor = std::make_shared< BasicExecutor >(m_taskScheduler);
+-
+-        m_pingBuffer = RingBuffer< ValueEvent >::createSingleProducer(ValueEvent::eventFactory(), m_bufferSize, std::make_shared< BlockingWaitStrategy >());
+-        m_pongBuffer = RingBuffer< ValueEvent >::createSingleProducer(ValueEvent::eventFactory(), m_bufferSize, std::make_shared< BlockingWaitStrategy >());
+-
+-        m_pingBarrier = m_pingBuffer->newBarrier();
+-        m_pongBarrier = m_pongBuffer->newBarrier();
+-
+-        m_pinger = std::make_shared< Pinger >(m_pingBuffer, m_iterations, m_pauseDurationInNanos);
+-        m_ponger = std::make_shared< Ponger >(m_pongBuffer);
+-
+-        m_pingProcessor = std::make_shared< BatchEventProcessor< ValueEvent > >(m_pongBuffer, m_pongBarrier, m_pinger);
+-        m_pongProcessor = std::make_shared< BatchEventProcessor< ValueEvent > >(m_pingBuffer, m_pingBarrier, m_ponger);
+-
+-        m_pingBuffer->addGatingSequences({ m_pongProcessor->sequence() });
+-        m_pongBuffer->addGatingSequences({ m_pingProcessor->sequence() });
+-    }
+-
+-    std::int32_t PingPongSequencedLatencyTest::requiredProcessorCount() const
+-    {
+-        return 2;
+-    }
+-
+-    void PingPongSequencedLatencyTest::run(Stopwatch& stopwatch, const std::shared_ptr< Tests::LatencyRecorder >& latencyRecorder)
+-    {
+-        m_taskScheduler->start(requiredProcessorCount());
+-        TestTools::ScopeExitFunctor atScopeExit([this] { m_taskScheduler->stop(); });
+-
+-        auto globalSignal = std::make_shared< Tests::CountdownEvent >(3);
+-        auto signal = std::make_shared< Tests::ManualResetEvent >(false);
+-        m_pinger->reset(globalSignal, signal, latencyRecorder);
+-        m_ponger->reset(globalSignal);
+-
+-        auto processorTask1 = m_executor->execute([this] { m_pongProcessor->run(); });
+-        auto processorTask2 = m_executor->execute([this] { m_pingProcessor->run(); });
+-
+-        globalSignal->signal();
+-        globalSignal->wait();
+-        stopwatch.start();
+-        // running here
+-        signal->waitOne();
+-        stopwatch.stop();
+-
+-        m_pingProcessor->halt();
+-        m_pongProcessor->halt();
+-
+-        processorTask1.wait();
+-        processorTask2.wait();
+-    }
+-
+-
+-    PingPongSequencedLatencyTest::Pinger::Pinger(const std::shared_ptr< RingBuffer< ValueEvent > >& buffer, std::int64_t maxEvents, std::int32_t pauseDurationInNanos)
+-        : m_buffer(buffer)
+-        , m_maxEvents(maxEvents)
+-        , m_pauseDurationInNanos(pauseDurationInNanos)
+-    {
+-        m_pauseDurationInStopwatchTicks = (std::int64_t)LatencyTestSession::convertNanoToStopwatchTicks(pauseDurationInNanos);
+-    }
+-
+-    void PingPongSequencedLatencyTest::Pinger::onEvent(ValueEvent& data, std::int64_t /*sequence*/, bool /*endOfBatch*/)
+-    {
+-        auto t1 = Stopwatch::getTimestamp();
+-
+-        m_latencyRecorder->record(LatencyTestSession::convertStopwatchTicksToNano((double)(t1 - m_t0)));
+-
+-        if (data.value < m_maxEvents)
+-        {
+-            while (m_pauseDurationInNanos > (Stopwatch::getTimestamp() - t1))
+-            {
+-                std::this_thread::sleep_for(std::chrono::milliseconds(0));
+-            }
+-
+-            send();
+-        }
+-        else
+-        {
+-            m_signal->set();
+-        }
+-    }
+-
+-    void PingPongSequencedLatencyTest::Pinger::onStart()
+-    {
+-        m_globalSignal->signal();
+-        m_globalSignal->wait();
+-
+-        send();
+-    }
+-
+-    void PingPongSequencedLatencyTest::Pinger::onShutdown()
+-    {
+-    }
+-
+-    void PingPongSequencedLatencyTest::Pinger::reset(const std::shared_ptr< Tests::CountdownEvent >& globalSignal,
+-                                                     const std::shared_ptr< Tests::ManualResetEvent >& signal,
+-                                                     const std::shared_ptr< Tests::LatencyRecorder >& latencyRecorder)
+-    {
+-        m_latencyRecorder = latencyRecorder;
+-        m_globalSignal = globalSignal;
+-        m_signal = signal;
+-
+-        m_counter = 0;
+-    }
+-
+-    void PingPongSequencedLatencyTest::Pinger::send()
+-    {
+-        m_t0 = Stopwatch::getTimestamp();
+-        auto next = m_buffer->next();
+-        (*m_buffer)[next].value = m_counter;
+-        m_buffer->publish(next);
+-
+-        ++m_counter;
+-    }
+-
+-
+-    PingPongSequencedLatencyTest::Ponger::Ponger(const std::shared_ptr< RingBuffer< ValueEvent > >& buffer)
+-        : m_buffer(buffer)
+-    {
+-    }
+-
+-    void PingPongSequencedLatencyTest::Ponger::onEvent(ValueEvent& data, std::int64_t /*sequence*/, bool /*endOfBatch*/)
+-    {
+-        auto next = m_buffer->next();
+-        (*m_buffer)[next].value = data.value;
+-        m_buffer->publish(next);
+-    }
+-
+-    void PingPongSequencedLatencyTest::Ponger::onStart()
+-    {
+-        m_globalSignal->signal();
+-        m_globalSignal->wait();
+-    }
+-
+-    void PingPongSequencedLatencyTest::Ponger::onShutdown()
+-    {
+-    }
+-
+-    void PingPongSequencedLatencyTest::Ponger::reset(const std::shared_ptr< Tests::CountdownEvent >& globalSignal)
+-    {
+-        m_globalSignal = globalSignal;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/PingPongSequencedLatencyTest.h b/Disruptor.PerfTests/PingPongSequencedLatencyTest.h
+deleted file mode 100644
+index 9eadb7c..0000000
+--- a/Disruptor.PerfTests/PingPongSequencedLatencyTest.h
++++ /dev/null
+@@ -1,109 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/BatchEventProcessor.h"
+-#include "Disruptor/IEventHandler.h"
+-#include "Disruptor/IExecutor.h"
+-#include "Disruptor/RingBuffer.h"
+-#include "Disruptor/ILifecycleAware.h"
+-#include "Disruptor/ITaskScheduler.h"
+-
+-#include "Disruptor.TestTools/CountdownEvent.h"
+-#include "Disruptor.TestTools/ManualResetEvent.h"
+-#include "Disruptor.TestTools/Stopwatch.h"
+-
+-#include "Disruptor.PerfTests/ILatencyTest.h"
+-#include "Disruptor.PerfTests/ValueEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class PingPongSequencedLatencyTest : public ILatencyTest
+-    {
+-        class Pinger;
+-        class Ponger;
+-
+-    public:
+-        PingPongSequencedLatencyTest();
+-
+-        std::int32_t requiredProcessorCount() const override;
+-
+-        void run(Stopwatch& stopwatch, const std::shared_ptr< Tests::LatencyRecorder >& latencyRecorder) override;
+-
+-    private:
+-        const std::int32_t m_bufferSize = 1024;
+-
+-#ifdef _DEBUG
+-        const std::int64_t m_iterations = 10L * 100L * 3L;
+-#else
+-        const std::int64_t m_iterations = 100L * 1000L * 30L;
+-#endif
+-
+-        const std::int32_t m_pauseDurationInNanos = 1000;
+-
+-        std::shared_ptr< RingBuffer< ValueEvent > > m_pingBuffer;
+-        std::shared_ptr< RingBuffer< ValueEvent > > m_pongBuffer;
+-
+-        std::shared_ptr< ISequenceBarrier > m_pongBarrier;
+-        std::shared_ptr< Pinger > m_pinger;
+-        std::shared_ptr< BatchEventProcessor< ValueEvent > > m_pingProcessor;
+-
+-        std::shared_ptr< ISequenceBarrier > m_pingBarrier;
+-        std::shared_ptr< Ponger > m_ponger;
+-        std::shared_ptr< BatchEventProcessor< ValueEvent > > m_pongProcessor;
+-
+-        std::shared_ptr< IExecutor > m_executor;
+-        std::shared_ptr< ITaskScheduler > m_taskScheduler;
+-    };
+-
+-
+-    class PingPongSequencedLatencyTest::Pinger : public IEventHandler< ValueEvent >, public ILifecycleAware
+-    {
+-    public:
+-        Pinger(const std::shared_ptr< RingBuffer< ValueEvent > >& buffer, std::int64_t maxEvents, std::int32_t pauseDurationInNanos);
+-
+-        void onEvent(ValueEvent& data, std::int64_t sequence, bool endOfBatch) override;
+-
+-        void onStart() override;
+-        void onShutdown() override;
+-
+-        void reset(const std::shared_ptr< Tests::CountdownEvent >& globalSignal,
+-                   const std::shared_ptr< Tests::ManualResetEvent >& signal,
+-                   const std::shared_ptr< Tests::LatencyRecorder >& latencyRecorder);
+-
+-    private:
+-        void send();
+-
+-        std::shared_ptr< RingBuffer< ValueEvent > > m_buffer;
+-        std::int64_t m_maxEvents;
+-        std::int32_t m_pauseDurationInNanos;
+-        std::int64_t m_pauseDurationInStopwatchTicks;
+-        std::shared_ptr< Tests::LatencyRecorder > m_latencyRecorder;
+-        std::int64_t m_t0;
+-        std::int64_t m_counter;
+-        std::shared_ptr< Tests::CountdownEvent > m_globalSignal;
+-        std::shared_ptr< Tests::ManualResetEvent > m_signal;
+-    };
+-
+-
+-    class PingPongSequencedLatencyTest::Ponger : public IEventHandler< ValueEvent >, public ILifecycleAware
+-    {
+-    public:
+-        explicit Ponger(const std::shared_ptr< RingBuffer< ValueEvent > >& buffer);
+-
+-        void onEvent(ValueEvent& data, std::int64_t sequence, bool endOfBatch) override;
+-
+-        void onStart() override;
+-        void onShutdown() override;
+-
+-        void reset(const std::shared_ptr< Tests::CountdownEvent >& globalSignal);
+-
+-    private:
+-        std::shared_ptr< RingBuffer< ValueEvent > > m_buffer;
+-        std::shared_ptr< Tests::CountdownEvent > m_globalSignal;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/TestFactory.h b/Disruptor.PerfTests/TestFactory.h
+deleted file mode 100644
+index 6f93fed..0000000
+--- a/Disruptor.PerfTests/TestFactory.h
++++ /dev/null
+@@ -1,26 +0,0 @@
+-#pragma once
+-
+-#include <string>
+-
+-#include "Disruptor.PerfTests/ILatencyTest.h"
+-#include "Disruptor.PerfTests/IThroughputTest.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    template <class TTest>
+-    struct TestFactory
+-    {
+-        std::string name;
+-        std::function<std::shared_ptr< TTest >()> factory;
+-    };
+-
+-
+-    using ThroughputTestInfo = TestFactory< IThroughputTest >;
+-    using LatencyTestInfo = TestFactory< ILatencyTest >;
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/TestRepository.cpp b/Disruptor.PerfTests/TestRepository.cpp
+deleted file mode 100644
+index 133aaa3..0000000
+--- a/Disruptor.PerfTests/TestRepository.cpp
++++ /dev/null
+@@ -1,140 +0,0 @@
+-#include "stdafx.h"
+-#include "TestRepository.h"
+-
+-#include <boost/algorithm/string.hpp>
+-
+-// Raw
+-#include "OneToOneRawBatchThroughputTest.h"
+-#include "OneToOneRawThroughputTest.h"
+-
+-// Sequenced
+-#include "OneToOneSequencedBatchThroughputTest.h"
+-#include "OneToOneSequencedLongArrayThroughputTest.h"
+-#include "OneToOneSequencedPollerThroughputTest.h"
+-#include "OneToOneSequencedThroughputTest.h"
+-#include "OneToThreeDiamondSequencedThroughputTest.h"
+-#include "OneToThreePipelineSequencedThroughputTest.h"
+-#include "OneToThreeSequencedThroughputTest.h"
+-#include "PingPongSequencedLatencyTest.h"
+-#include "ThreeToOneSequencedBatchThroughputTest.h"
+-#include "ThreeToOneSequencedThroughputTest.h"
+-#include "ThreeToThreeSequencedThroughputTest.h"
+-
+-// Translator
+-#include "OneToOneTranslatorThroughputTest.h"
+-
+-// WorkHandler
+-#include "OneToThreeReleasingWorkerPoolThroughputTest.h"
+-#include "OneToThreeWorkerPoolThroughputTest.h"
+-#include "TwoToTwoWorkProcessorThroughputTest.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    TestRepository::TestRepository()
+-    {
+-        // Raw
+-        registerTest< OneToOneRawBatchThroughputTest >();
+-        registerTest< OneToOneRawThroughputTest >();
+-
+-        // Sequenced
+-        registerTest< OneToOneSequencedBatchThroughputTest >();
+-        registerTest< OneToOneSequencedLongArrayThroughputTest >();
+-        registerTest< OneToOneSequencedPollerThroughputTest >();
+-        registerTest< OneToOneSequencedThroughputTest >();
+-        registerTest< OneToThreeDiamondSequencedThroughputTest >();
+-        registerTest< OneToThreePipelineSequencedThroughputTest >();
+-        registerTest< OneToThreeSequencedThroughputTest >();
+-        registerTest< PingPongSequencedLatencyTest >();
+-        registerTest< ThreeToOneSequencedBatchThroughputTest >();
+-        registerTest< ThreeToOneSequencedThroughputTest >();
+-        registerTest< ThreeToThreeSequencedThroughputTest >();
+-
+-        // Translator
+-        registerTest< OneToOneTranslatorThroughputTest >();
+-
+-        // WorkHandler
+-        registerTest< OneToThreeReleasingWorkerPoolThroughputTest >();
+-        registerTest< OneToThreeWorkerPoolThroughputTest >();
+-        registerTest< TwoToTwoWorkProcessorThroughputTest >();
+-    }
+-
+-    void TestRepository::registerTest(const TypeInfo& typeInfo, const std::function<std::shared_ptr< IThroughputTest >()>& testFactory)
+-    {
+-        ThroughputTestInfo info{ typeInfo.name(), testFactory };
+-
+-        m_throughputTestInfosByName.insert(std::make_pair(boost::algorithm::to_lower_copy(typeInfo.fullyQualifiedName()), info));
+-        m_throughputTestInfosByName.insert(std::make_pair(boost::algorithm::to_lower_copy(typeInfo.name()), info));
+-    }
+-
+-    void TestRepository::registerTest(const TypeInfo& typeInfo, const std::function<std::shared_ptr< ILatencyTest >()>& testFactory)
+-    {
+-        LatencyTestInfo info{ typeInfo.name(), testFactory };
+-
+-        m_latencyTestInfosByName.insert(std::make_pair(boost::algorithm::to_lower_copy(typeInfo.fullyQualifiedName()), info));
+-        m_latencyTestInfosByName.insert(std::make_pair(boost::algorithm::to_lower_copy(typeInfo.name()), info));
+-    }
+-
+-    const TestRepository& TestRepository::instance()
+-    {
+-        static TestRepository instance;
+-        return instance;
+-    }
+-
+-    std::vector< ThroughputTestInfo > TestRepository::allThrougputTests() const
+-    {
+-        std::vector< ThroughputTestInfo > result;
+-        std::set< std::string > testNames;
+-
+-        for (auto&& x : m_throughputTestInfosByName)
+-        {
+-            if (testNames.count(x.second.name) > 0)
+-                continue;
+-
+-            testNames.insert(x.second.name);
+-            result.push_back(x.second);
+-        }
+-        return result;
+-    }
+-
+-    bool TestRepository::tryGetThroughputTest(const std::string& testName, ThroughputTestInfo& testInfo) const
+-    {
+-        auto it = m_throughputTestInfosByName.find(boost::algorithm::to_lower_copy(testName));
+-        if (it == m_throughputTestInfosByName.end())
+-            return false;
+-
+-        testInfo = it->second;
+-        return true;
+-    }
+-
+-    std::vector< LatencyTestInfo > TestRepository::allLatencyTests() const
+-    {
+-        std::vector< LatencyTestInfo > result;
+-        std::set< std::string > testNames;
+-
+-        for (auto&& x : m_latencyTestInfosByName)
+-        {
+-            if (testNames.count(x.second.name) > 0)
+-                continue;
+-
+-            testNames.insert(x.second.name);
+-            result.push_back(x.second);
+-        }
+-        return result;
+-    }
+-
+-    bool TestRepository::tryGetLatencyTest(const std::string& testName, LatencyTestInfo& testInfo) const
+-    {
+-        auto it = m_latencyTestInfosByName.find(boost::algorithm::to_lower_copy(testName));
+-        if (it == m_latencyTestInfosByName.end())
+-            return false;
+-
+-        testInfo = it->second;
+-        return true;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/TestRepository.h b/Disruptor.PerfTests/TestRepository.h
+deleted file mode 100644
+index cb7794a..0000000
+--- a/Disruptor.PerfTests/TestRepository.h
++++ /dev/null
+@@ -1,53 +0,0 @@
+-#pragma once
+-
+-#include <map>
+-#include <memory>
+-#include <string>
+-
+-#include "Disruptor/TypeInfo.h"
+-
+-#include "Disruptor.PerfTests/TestFactory.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class TestRepository
+-    {
+-    public:
+-        static const TestRepository& instance();
+-
+-        std::vector< ThroughputTestInfo > allThrougputTests() const;
+-        bool tryGetThroughputTest(const std::string& testName, ThroughputTestInfo& testInfo) const;
+-
+-        std::vector< LatencyTestInfo > allLatencyTests() const;
+-        bool tryGetLatencyTest(const std::string& testName, LatencyTestInfo& testInfo) const;
+-
+-    private:
+-        TestRepository();
+-
+-        template <class TTest>
+-        void registerTest()
+-        {
+-            static_assert(std::is_base_of< IThroughputTest, TTest >::value || std::is_base_of< ILatencyTest, TTest >::value,
+-                          "TTest should implement IThroughputTest or ILatencyTest");
+-
+-            std::function<std::shared_ptr<TTest>()>&& factory = []() -> std::shared_ptr<TTest>
+-            {
+-                return std::make_shared<TTest>();
+-            };
+-
+-            registerTest(Utils::getMetaTypeInfo< TTest >(), factory);
+-        }
+-
+-        void registerTest(const TypeInfo& typeInfo, const std::function<std::shared_ptr< IThroughputTest >()>& testFactory);
+-        void registerTest(const TypeInfo& typeInfo, const std::function<std::shared_ptr< ILatencyTest >()>& testFactory);
+-
+-        std::map< std::string, ThroughputTestInfo > m_throughputTestInfosByName;
+-        std::map< std::string, LatencyTestInfo > m_latencyTestInfosByName;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/ThreeToOneSequencedBatchThroughputTest.cpp b/Disruptor.PerfTests/ThreeToOneSequencedBatchThroughputTest.cpp
+deleted file mode 100644
+index 79824de..0000000
+--- a/Disruptor.PerfTests/ThreeToOneSequencedBatchThroughputTest.cpp
++++ /dev/null
+@@ -1,92 +0,0 @@
+-#include "stdafx.h"
+-#include "ThreeToOneSequencedBatchThroughputTest.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    ThreeToOneSequencedBatchThroughputTest::ThreeToOneSequencedBatchThroughputTest()
+-    {
+-        auto sequenceBarrier = m_ringBuffer->newBarrier();
+-        for (auto i = 0; i < m_numPublishers; ++i)
+-        {
+-            m_valuePublishers[i] = std::make_shared< ValueBatchPublisher >(m_cyclicBarrier, m_ringBuffer, m_iterations / m_numPublishers, 10);
+-        }
+-
+-        m_batchEventProcessor = std::make_shared< BatchEventProcessor< ValueEvent > >(m_ringBuffer, sequenceBarrier, m_handler);
+-        m_ringBuffer->addGatingSequences({ m_batchEventProcessor->sequence() });
+-    }
+-
+-    std::int64_t ThreeToOneSequencedBatchThroughputTest::run(Stopwatch& stopwatch)
+-    {
+-        m_cyclicBarrier->reset();
+-
+-        auto latch = std::make_shared< Tests::ManualResetEvent >(false);
+-        m_handler->reset(latch, m_batchEventProcessor->sequence()->value() + ((m_iterations / m_numPublishers) * m_numPublishers));
+-
+-        std::vector< std::future< void > > futures(m_numPublishers);
+-        for (auto i = 0; i < m_numPublishers; ++i)
+-        {
+-            auto index = i;
+-            futures[i] = std::async(std::launch::async, [this, index] { m_valuePublishers[index]->run(); });
+-        }
+-        auto processorTask = std::async(std::launch::async, [this] { m_batchEventProcessor->run(); });
+-
+-        stopwatch.start();
+-        m_cyclicBarrier->signal();
+-        m_cyclicBarrier->wait();
+-
+-        for (auto i = 0; i < m_numPublishers; ++i)
+-        {
+-            futures[i].wait();
+-        }
+-
+-        latch->waitOne();
+-
+-        stopwatch.stop();
+-        m_batchEventProcessor->halt();
+-        processorTask.wait_for(std::chrono::milliseconds(2000));
+-
+-        return m_iterations;
+-    }
+-
+-    std::int32_t ThreeToOneSequencedBatchThroughputTest::requiredProcessorCount() const
+-    {
+-        return 4;
+-    }
+-
+-    ThreeToOneSequencedBatchThroughputTest::ValueBatchPublisher::ValueBatchPublisher(const std::shared_ptr< Tests::CountdownEvent >& cyclicBarrier,
+-                                                                                     const std::shared_ptr< RingBuffer< ValueEvent > >& ringBuffer,
+-                                                                                     std::int64_t iterations,
+-                                                                                     std::int32_t batchSize)
+-        : m_cyclicBarrier(cyclicBarrier)
+-        , m_ringBuffer(ringBuffer)
+-        , m_iterations(iterations)
+-        , m_batchSize(batchSize)
+-    {
+-    }
+-
+-    void ThreeToOneSequencedBatchThroughputTest::ValueBatchPublisher::run()
+-    {
+-        auto& rb = *m_ringBuffer;
+-
+-        m_cyclicBarrier->signal();
+-        m_cyclicBarrier->wait();
+-
+-        for (std::int64_t i = 0; i < m_iterations; i += m_batchSize)
+-        {
+-            auto hi = m_ringBuffer->next(m_batchSize);
+-            auto lo = hi - (m_batchSize - 1);
+-            for (auto l = lo; l <= hi; ++l)
+-            {
+-                auto& event = rb[l];
+-                event.value = l;
+-            }
+-            m_ringBuffer->publish(lo, hi);
+-        }
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/ThreeToOneSequencedBatchThroughputTest.h b/Disruptor.PerfTests/ThreeToOneSequencedBatchThroughputTest.h
+deleted file mode 100644
+index 71aad14..0000000
+--- a/Disruptor.PerfTests/ThreeToOneSequencedBatchThroughputTest.h
++++ /dev/null
+@@ -1,101 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/BatchEventProcessor.h"
+-#include "Disruptor/BusySpinWaitStrategy.h"
+-#include "Disruptor/RingBuffer.h"
+-
+-#include "Disruptor.TestTools/CountdownEvent.h"
+-
+-#include "Disruptor.PerfTests/IThroughputTest.h"
+-#include "Disruptor.PerfTests/ValueAdditionEventHandler.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    /**
+-     * Sequence a series of events from multiple publishers going to one event processor.
+-     * +----+
+-     * | P1 |------+
+-     * +----+      |
+-     *             v
+-     * +----+    +-----+
+-     * | P1 |--->| EP1 |
+-     * +----+    +-----+
+-     *             ^
+-     * +----+      |
+-     * | P3 |------+
+-     * +----+
+-     * Disruptor:
+-     * ==========
+-     *             track to prevent wrap
+-     *             +--------------------+
+-     *             |                    |
+-     *             |                    v
+-     * +----+    +====+    +====+    +-----+
+-     * | P1 |--->| RB |/---| SB |    | EP1 |
+-     * +----+    +====+    +====+    +-----+
+-     *             ^   get    ^         |
+-     * +----+      |          |         |
+-     * | P2 |------+          +---------+
+-     * +----+      |            waitFor
+-     *             |
+-     * +----+      |
+-     * | P3 |------+
+-     * +----+
+-     * P1  - Publisher 1
+-     * P2  - Publisher 2
+-     * P3  - Publisher 3
+-     * RB  - RingBuffer
+-     * SB  - SequenceBarrier
+-     * EP1 - EventProcessor 1
+-     * 
+-     */
+-    class ThreeToOneSequencedBatchThroughputTest : public IThroughputTest
+-    {
+-        class ValueBatchPublisher
+-        {
+-        public:
+-            ValueBatchPublisher(const std::shared_ptr< Tests::CountdownEvent >& cyclicBarrier,
+-                                const std::shared_ptr< RingBuffer< ValueEvent > >& ringBuffer,
+-                                std::int64_t iterations,
+-                                std::int32_t batchSize);
+-
+-            void run();
+-
+-        private:
+-            std::shared_ptr< Tests::CountdownEvent > m_cyclicBarrier;
+-            std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer;
+-            std::int64_t m_iterations;
+-            std::int32_t m_batchSize;
+-        };
+-
+-    public:
+-        ThreeToOneSequencedBatchThroughputTest();
+-
+-        std::int64_t run(Stopwatch& stopwatch) override;
+-
+-        std::int32_t requiredProcessorCount() const override;
+-
+-    private:
+-        const std::int32_t m_numPublishers = 3;
+-        const std::int32_t m_bufferSize = 1024 * 64;
+-
+-#ifdef _DEBUG
+-        const std::int64_t m_iterations = 100L * 100L * 10L;
+-#else
+-        const std::int64_t m_iterations = 1000L * 1000L * 100L;
+-#endif
+-
+-        std::shared_ptr< Tests::CountdownEvent > m_cyclicBarrier = std::make_shared< Tests::CountdownEvent >(m_numPublishers + 1);
+-
+-        std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer = RingBuffer< ValueEvent >::createMultiProducer(ValueEvent::eventFactory(), m_bufferSize, std::make_shared< BusySpinWaitStrategy >());
+-        std::shared_ptr< ValueAdditionEventHandler > m_handler = std::make_shared< ValueAdditionEventHandler >();
+-        std::shared_ptr< BatchEventProcessor< ValueEvent > > m_batchEventProcessor;
+-        std::vector< std::shared_ptr< ValueBatchPublisher > > m_valuePublishers = std::vector< std::shared_ptr< ValueBatchPublisher > >(m_numPublishers);
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/ThreeToOneSequencedThroughputTest.cpp b/Disruptor.PerfTests/ThreeToOneSequencedThroughputTest.cpp
+deleted file mode 100644
+index 39b4e42..0000000
+--- a/Disruptor.PerfTests/ThreeToOneSequencedThroughputTest.cpp
++++ /dev/null
+@@ -1,87 +0,0 @@
+-#include "stdafx.h"
+-#include "ThreeToOneSequencedThroughputTest.h"
+-
+-#include "Disruptor.TestTools/ScopeExitFunctor.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    ThreeToOneSequencedThroughputTest::ThreeToOneSequencedThroughputTest()
+-    {
+-        m_sequenceBarrier = m_ringBuffer->newBarrier();
+-        m_batchEventProcessor = std::make_shared< BatchEventProcessor< ValueEvent > >(m_ringBuffer, m_sequenceBarrier, m_handler);
+-        for (auto i = 0; i < m_numPublishers; ++i)
+-        {
+-            m_valuePublishers[i] = [this](const std::shared_ptr< Tests::CountdownEvent >& countdownEvent,
+-                                          const std::shared_ptr< RingBuffer< ValueEvent > >& ringBuffer,
+-                                          std::int64_t iterations)
+-            {
+-                this->valuePublisher(countdownEvent, ringBuffer, iterations);
+-            };
+-        }
+-        m_ringBuffer->addGatingSequences({ m_batchEventProcessor->sequence() });
+-    }
+-
+-    std::int64_t ThreeToOneSequencedThroughputTest::run(Stopwatch& stopwatch)
+-    {
+-        m_scheduler->start(5);
+-        TestTools::ScopeExitFunctor atScopeExit([this] { m_scheduler->stop(); });
+-
+-        m_cyclicBarrier->reset();
+-        auto latch = std::make_shared< Tests::ManualResetEvent >(false);
+-        m_handler->reset(latch, m_batchEventProcessor->sequence()->value() + ((m_iterations / m_numPublishers) * m_numPublishers));
+-
+-        std::vector< std::future< void > > futures(m_numPublishers);
+-        for (auto i = 0; i < m_numPublishers; ++i)
+-        {
+-            auto index = i;
+-            futures[i] = m_scheduler->scheduleAndStart(std::packaged_task< void() >([this, index] { m_valuePublishers[index](m_cyclicBarrier, m_ringBuffer, m_iterations); }));
+-        }
+-        auto processorTask = m_scheduler->scheduleAndStart(std::packaged_task< void() >([this] { m_batchEventProcessor->run(); }));
+-
+-        stopwatch.start();
+-        m_cyclicBarrier->signal();
+-        m_cyclicBarrier->wait();
+-
+-        for (auto i = 0; i < m_numPublishers; ++i)
+-        {
+-            futures[i].wait();
+-        }
+-
+-        latch->waitOne();
+-
+-        stopwatch.stop();
+-        m_batchEventProcessor->halt();
+-        processorTask.wait_for(std::chrono::milliseconds(2000));
+-
+-        return m_iterations;
+-    }
+-
+-    std::int32_t ThreeToOneSequencedThroughputTest::requiredProcessorCount() const
+-    {
+-        return 4;
+-    }
+-
+-    void ThreeToOneSequencedThroughputTest::valuePublisher(const std::shared_ptr< Tests::CountdownEvent >& countdownEvent,
+-                                                           const std::shared_ptr< RingBuffer< ValueEvent > >& ringBuffer,
+-                                                           std::int64_t iterations)
+-    {
+-        auto& rb = *ringBuffer;
+-
+-        countdownEvent->signal();
+-        countdownEvent->wait();
+-
+-        for (std::int64_t i = 0; i < iterations; ++i)
+-        {
+-            auto sequence = rb.next();
+-            auto& eventData = rb[sequence];
+-            eventData.value = i;
+-            rb.publish(sequence);
+-        }
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/ThreeToOneSequencedThroughputTest.h b/Disruptor.PerfTests/ThreeToOneSequencedThroughputTest.h
+deleted file mode 100644
+index 27dd1e0..0000000
+--- a/Disruptor.PerfTests/ThreeToOneSequencedThroughputTest.h
++++ /dev/null
+@@ -1,97 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/BatchEventProcessor.h"
+-#include "Disruptor/BusySpinWaitStrategy.h"
+-#include "Disruptor/ITaskScheduler.h"
+-#include "Disruptor/RingBuffer.h"
+-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
+-
+-#include "Disruptor.TestTools/CountdownEvent.h"
+-
+-#include "Disruptor.PerfTests/IThroughputTest.h"
+-#include "Disruptor.PerfTests/ValueEvent.h"
+-#include "Disruptor.PerfTests/ValueAdditionEventHandler.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    /**
+-     * Sequence a series of events from multiple publishers going to one event processor.
+-     * 
+-     * +----+
+-     * | P1 |------+
+-     * +----+      |
+-     *             v
+-     * +----+    +-----+
+-     * | P1 |--->| EP1 |
+-     * +----+    +-----+
+-     *             ^
+-     * +----+      |
+-     * | P3 |------+
+-     * +----+
+-     * Disruptor:
+-     * ==========
+-     *             track to prevent wrap
+-     *             +--------------------+
+-     *             |                    |
+-     *             |                    v
+-     * +----+    +====+    +====+    +-----+
+-     * | P1 |--->| RB |/---| SB |    | EP1 |
+-     * +----+    +====+    +====+    +-----+
+-     *             ^   get    ^         |
+-     * +----+      |          |         |
+-     * | P2 |------+          +---------+
+-     * +----+      |            waitFor
+-     *             |
+-     * +----+      |
+-     * | P3 |------+
+-     * +----+
+-     * 
+-     * P1  - Publisher 1
+-     * P2  - Publisher 2
+-     * P3  - Publisher 3
+-     * RB  - RingBuffer
+-     * SB  - SequenceBarrier
+-     * EP1 - EventProcessor 1
+-     * 
+-     */
+-    class ThreeToOneSequencedThroughputTest : public IThroughputTest
+-    {
+-        using ValuePublisher = std::function< void(const std::shared_ptr< Tests::CountdownEvent >&, const std::shared_ptr< RingBuffer< ValueEvent > >&, std::int64_t) >;
+-
+-    public:
+-        ThreeToOneSequencedThroughputTest();
+-
+-        std::int64_t run(Stopwatch& stopwatch) override;
+-
+-        std::int32_t requiredProcessorCount() const override;
+-
+-    private:
+-        static void valuePublisher(const std::shared_ptr< Tests::CountdownEvent >& countdownEvent,
+-                                   const std::shared_ptr< RingBuffer< ValueEvent > >& ringBuffer,
+-                                   std::int64_t iterations);
+-
+-        const std::int32_t m_numPublishers = 3;
+-        const std::int32_t m_bufferSize = 1024 * 64;
+-
+-#ifdef _DEBUG
+-        const std::int64_t m_iterations = 100L * 100L * 2L;
+-#else
+-        const std::int64_t m_iterations = 1000L * 1000L * 20L;
+-#endif
+-
+-        std::shared_ptr< Tests::CountdownEvent > m_cyclicBarrier = std::make_shared< Tests::CountdownEvent >(m_numPublishers + 1);
+-        std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer = RingBuffer< ValueEvent >::createMultiProducer(ValueEvent::eventFactory(), m_bufferSize, std::make_shared< BusySpinWaitStrategy >());
+-
+-        std::shared_ptr< ITaskScheduler > m_scheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
+-        std::shared_ptr< ISequenceBarrier > m_sequenceBarrier;
+-        std::shared_ptr< ValueAdditionEventHandler > m_handler = std::make_shared< ValueAdditionEventHandler >();
+-        std::shared_ptr< BatchEventProcessor< ValueEvent > > m_batchEventProcessor;
+-        std::vector< ValuePublisher > m_valuePublishers = std::vector< ValuePublisher >(m_numPublishers);
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/ThreeToThreeSequencedThroughputTest.cpp b/Disruptor.PerfTests/ThreeToThreeSequencedThroughputTest.cpp
+deleted file mode 100644
+index d384f67..0000000
+--- a/Disruptor.PerfTests/ThreeToThreeSequencedThroughputTest.cpp
++++ /dev/null
+@@ -1,101 +0,0 @@
+-#include "stdafx.h"
+-#include "ThreeToThreeSequencedThroughputTest.h"
+-
+-#include "Disruptor/YieldingWaitStrategy.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    ThreeToThreeSequencedThroughputTest::ThreeToThreeSequencedThroughputTest()
+-    {
+-        for (auto i = 0; i < m_numPublishers; ++i)
+-        {
+-            m_buffers[i] = RingBuffer< std::vector< std::int64_t > >::createSingleProducer([this] {return std::vector< std::int64_t >(m_arraySize); },
+-                                                                                           m_bufferSize,
+-                                                                                           std::make_shared< YieldingWaitStrategy >());
+-            m_barriers[i] = m_buffers[i]->newBarrier();
+-            m_valuePublishers[i] = [this](const std::shared_ptr< Tests::CountdownEvent >& countdownEvent,
+-                                          const std::shared_ptr< RingBuffer< std::vector< std::int64_t > > >& ringBuffer,
+-                                          std::int64_t iterations,
+-                                          std::int32_t arraySize)
+-            {
+-                this->valuePublisher(countdownEvent, ringBuffer, iterations, arraySize);
+-            };
+-        }
+-
+-        std::vector< std::shared_ptr< IDataProvider< std::vector< std::int64_t > > > > providers;
+-        std::copy(m_buffers.begin(), m_buffers.end(), std::back_inserter(providers));
+-
+-        m_batchEventProcessor = std::make_shared< MultiBufferBatchEventProcessor< std::vector< std::int64_t > > >(providers, m_barriers, m_handler);
+-
+-        for (auto i = 0; i < m_numPublishers; ++i)
+-        {
+-            m_buffers[i]->addGatingSequences({ m_batchEventProcessor->getSequences()[i] });
+-        }
+-    }
+-
+-    std::int64_t ThreeToThreeSequencedThroughputTest::run(Stopwatch& stopwatch)
+-    {
+-        m_cyclicBarrier->reset();
+-
+-        auto latch = std::make_shared< Tests::ManualResetEvent >(false);
+-        m_handler->reset(latch, m_iterations);
+-
+-        std::vector< std::future< void > > futures(m_numPublishers);
+-        for (auto i = 0; i < m_numPublishers; ++i)
+-        {
+-            auto index = i;
+-            futures[i] = std::async(std::launch::async, [this, index] { this->m_valuePublishers[index](m_cyclicBarrier, m_buffers[index], m_iterations / m_numPublishers, m_arraySize); });
+-        }
+-        auto processorTask = std::async(std::launch::async, [this] { this->m_batchEventProcessor->run(); });
+-
+-        stopwatch.start();
+-        m_cyclicBarrier->signal();
+-        m_cyclicBarrier->wait();
+-
+-        for (auto i = 0; i < m_numPublishers; ++i)
+-        {
+-            futures[i].wait();
+-        }
+-
+-        latch->waitOne();
+-
+-        stopwatch.stop();
+-        m_batchEventProcessor->halt();
+-        processorTask.wait_for(std::chrono::milliseconds(2000));
+-
+-        return m_iterations * m_arraySize;
+-    }
+-
+-    std::int32_t ThreeToThreeSequencedThroughputTest::requiredProcessorCount() const
+-    {
+-        return 4;
+-    }
+-
+-    void ThreeToThreeSequencedThroughputTest::valuePublisher(const std::shared_ptr< Tests::CountdownEvent >& countdownEvent,
+-                                                             const std::shared_ptr< RingBuffer< std::vector< std::int64_t > > >& ringBuffer,
+-                                                             std::int64_t iterations,
+-                                                             std::int32_t arraySize)
+-    {
+-        auto& rb = *ringBuffer;
+-
+-        countdownEvent->signal();
+-        countdownEvent->wait();
+-
+-        for (std::int64_t i = 0; i < iterations; ++i)
+-        {
+-            auto sequence = rb.next();
+-            auto& eventData = rb[sequence];
+-            for (auto j = 0; j < arraySize; ++j)
+-            {
+-                eventData[j] = i + j;
+-            }
+-            rb.publish(sequence);
+-        }
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/ThreeToThreeSequencedThroughputTest.h b/Disruptor.PerfTests/ThreeToThreeSequencedThroughputTest.h
+deleted file mode 100644
+index 4124680..0000000
+--- a/Disruptor.PerfTests/ThreeToThreeSequencedThroughputTest.h
++++ /dev/null
+@@ -1,89 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/RingBuffer.h"
+-
+-#include "Disruptor.TestTools/CountdownEvent.h"
+-
+-#include "Disruptor.PerfTests/IThroughputTest.h"
+-#include "Disruptor.PerfTests/LongArrayEventHandler.h"
+-#include "Disruptor.PerfTests/MultiBufferBatchEventProcessor.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    /**
+-     *
+-     * Sequence a series of events from multiple publishers going to one event processor.
+-     * 
+-     * Disruptor:
+-     * ==========
+-     *             track to prevent wrap
+-     *             +--------------------+
+-     *             |                    |
+-     *             |                    |
+-     * +----+    +====+    +====+       |
+-     * | P1 |--->| RB |--->| SB |--+    |
+-     * +----+    +====+    +====+  |    |
+-     *                             |    v
+-     * +----+    +====+    +====+  | +----+
+-     * | P2 |--->| RB |--->| SB |--+>| EP |
+-     * +----+    +====+    +====+  | +----+
+-     *                             |
+-     * +----+    +====+    +====+  |
+-     * | P3 |--->| RB |--->| SB |--+
+-     * +----+    +====+    +====+
+-     *
+-     *
+-     * P1 - Publisher 1
+-     * P2 - Publisher 2
+-     * P3 - Publisher 3
+-     * RB - RingBuffer
+-     * SB - SequenceBarrier
+-     * EP - EventProcessor
+-     *
+-     */
+-    class ThreeToThreeSequencedThroughputTest : public IThroughputTest
+-    {
+-        using LongArrayPublisher = std::function< void(const std::shared_ptr< Tests::CountdownEvent >&,
+-                                                       const std::shared_ptr< RingBuffer< std::vector< std::int64_t > > >&,
+-                                                       std::int64_t,
+-                                                       std::int32_t) >;
+-
+-    public:
+-        ThreeToThreeSequencedThroughputTest();
+-
+-        std::int64_t run(Stopwatch& stopwatch) override;
+-
+-        std::int32_t requiredProcessorCount() const override;
+-
+-    private:
+-        static void valuePublisher(const std::shared_ptr< Tests::CountdownEvent >& countdownEvent,
+-                                   const std::shared_ptr< RingBuffer< std::vector< std::int64_t > > >& ringBuffer,
+-                                   std::int64_t iterations,
+-                                   std::int32_t arraySize);
+-
+-        const std::int32_t m_numPublishers = 3;
+-        const std::int32_t m_arraySize = 3;
+-        const std::int32_t m_bufferSize = 1024 * 64;
+-
+-#ifdef _DEBUG
+-        const std::int64_t m_iterations = 100L * 100L * 18L;
+-#else
+-        const std::int64_t m_iterations = 1000L * 1000L * 180L;
+-#endif
+-
+-        std::shared_ptr< Tests::CountdownEvent > m_cyclicBarrier = std::make_shared< Tests::CountdownEvent >(m_numPublishers + 1);
+-
+-        std::vector< std::shared_ptr< RingBuffer< std::vector< std::int64_t > > > > m_buffers = std::vector< std::shared_ptr< RingBuffer< std::vector< std::int64_t > > > >(m_numPublishers);
+-        std::vector< std::shared_ptr< ISequenceBarrier > > m_barriers = std::vector< std::shared_ptr< ISequenceBarrier > >(m_numPublishers);
+-        std::vector< LongArrayPublisher > m_valuePublishers = std::vector< LongArrayPublisher >(m_numPublishers);
+-        
+-        std::shared_ptr< LongArrayEventHandler > m_handler = std::make_shared< LongArrayEventHandler >();
+-        std::shared_ptr< MultiBufferBatchEventProcessor< std::vector< std::int64_t > > > m_batchEventProcessor;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/ThroughputTestSession.cpp b/Disruptor.PerfTests/ThroughputTestSession.cpp
+deleted file mode 100644
+index 9530ec1..0000000
+--- a/Disruptor.PerfTests/ThroughputTestSession.cpp
++++ /dev/null
+@@ -1,86 +0,0 @@
+-#include "stdafx.h"
+-#include "ThroughputTestSession.h"
+-
+-#include <numeric>
+-#include <sstream>
+-
+-#include <boost/filesystem.hpp>
+-
+-#include "Disruptor.TestTools/Stopwatch.h"
+-
+-#include "Disruptor.PerfTests/PerfTestUtil.h"
+-#include "Disruptor.PerfTests/ThroughputTestSessionResult.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    ThroughputTestSession::ThroughputTestSession(const ThroughputTestInfo& testInfo)
+-    {
+-        m_testInfo = testInfo;
+-    }
+-
+-    void ThroughputTestSession::run()
+-    {
+-        auto testInstance = m_testInfo.factory();
+-
+-        checkProcessorsRequirements(testInstance);
+-
+-        std::cout << "Throughput Test to run => " << m_testInfo.name << ", Runs => " << m_runs << std::endl;
+-        std::cout << "Starting throughput tests" << std::endl;
+-
+-        Stopwatch stopwatch;
+-
+-        for (auto i = 0; i < m_runs; i++)
+-        {
+-            stopwatch.reset();
+-
+-            std::int64_t totalOperationsInRun;
+-
+-            try
+-            {
+-                totalOperationsInRun = testInstance->run(stopwatch);
+-            }
+-            catch (std::exception& ex)
+-            {
+-                ThroughputTestSessionResult result(ex);
+-                std::cout << result.toString() << std::endl;
+-
+-                m_results.push_back(result);
+-                continue;
+-            }
+-
+-            ThroughputTestSessionResult result(totalOperationsInRun, stopwatch.elapsed());
+-            std::cout << result.toString() << std::endl;
+-
+-            m_results.push_back(result);
+-        }
+-    }
+-
+-    std::int64_t ThroughputTestSession::getAverageThroughput()
+-    {
+-        double averageThroughput = 0;
+-        for (auto&& x : m_results)
+-        {
+-            auto totalSeconds = std::chrono::duration_cast< std::chrono::seconds >(x.duration());
+-            averageThroughput += static_cast< double >(x.totalOperationsInRun()) / totalSeconds.count();
+-        }
+-
+-        return static_cast< std::int64_t >(averageThroughput / static_cast< double >(m_results.size()));
+-    }
+-
+-
+-    void ThroughputTestSession::checkProcessorsRequirements(const std::shared_ptr<IThroughputTest>& test)
+-    {
+-        auto availableProcessors = static_cast< std::int32_t >(std::thread::hardware_concurrency());
+-        if (test->requiredProcessorCount() <= availableProcessors)
+-            return;
+-
+-        std::cout << "*** Warning ***: your system has insufficient processors to execute the test efficiently. " << std::endl;
+-        std::cout << "Processors required = " << test->requiredProcessorCount() << ", available = " << availableProcessors << std::endl;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/ThroughputTestSession.h b/Disruptor.PerfTests/ThroughputTestSession.h
+deleted file mode 100644
+index 77e24c5..0000000
+--- a/Disruptor.PerfTests/ThroughputTestSession.h
++++ /dev/null
+@@ -1,37 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor.PerfTests/TestFactory.h"
+-#include "Disruptor.PerfTests/ThroughputTestSessionResult.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class IThroughputTest;
+-
+-
+-    class ThroughputTestSession
+-    {
+-    public:
+-        explicit ThroughputTestSession(const ThroughputTestInfo& testInfo);
+-
+-        void run();
+-
+-    private:
+-        static void checkProcessorsRequirements(const std::shared_ptr<IThroughputTest>& test);
+-        std::int64_t getAverageThroughput();
+-
+-#ifdef _DEBUG
+-        const std::int32_t m_runs = 3;
+-#else
+-        const std::int32_t m_runs = 7;
+-#endif
+-
+-        std::vector< ThroughputTestSessionResult > m_results;
+-        ThroughputTestInfo m_testInfo;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/ThroughputTestSessionResult.cpp b/Disruptor.PerfTests/ThroughputTestSessionResult.cpp
+deleted file mode 100644
+index b5b5c1c..0000000
+--- a/Disruptor.PerfTests/ThroughputTestSessionResult.cpp
++++ /dev/null
+@@ -1,88 +0,0 @@
+-#include "stdafx.h"
+-#include "ThroughputTestSessionResult.h"
+-
+-#include <iomanip>
+-#include <sstream>
+-
+-#include "Disruptor.TestTools/DurationHumanizer.h"
+-#include "Disruptor.TestTools/HumanNumberFacet.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    ThroughputTestSessionResult::ThroughputTestSessionResult(std::int64_t totalOperationsInRun, ClockConfig::Duration duration)
+-        : m_totalOperationsInRun(totalOperationsInRun)
+-        , m_duration(duration)
+-    {}
+-
+-    ThroughputTestSessionResult::ThroughputTestSessionResult(const std::exception& exception)
+-        : m_exception(exception)
+-    {}
+-
+-    void ThroughputTestSessionResult::appendDetailedHtmlReport(std::int32_t runId, std::ostringstream& os)
+-    {
+-        if (m_exception)
+-        {
+-            os
+-                << " <tr>" << std::endl
+-                << "     <td>" << runId << "</td>" << std::endl
+-                << "     <td>FAILED</td>" << std::endl
+-                << "     <td>" << m_exception.get().what() << "</td>" << std::endl
+-                << "</tr>" << std::endl;
+-        }
+-        else
+-        {
+-            os
+-                << "<tr>" << std::endl
+-                << "     <td>" << runId << "</td>" << std::endl
+-                << "     <td>" << ops() << "</td>" << std::endl
+-                << "     <td>" << durationInMilliseconds() << "</td>" << std::endl
+-                << "</tr>" << std::endl;
+-        }
+-    }
+-
+-    std::string ThroughputTestSessionResult::toString()
+-    {
+-        std::ostringstream result;
+-        result.imbue(std::locale(result.getloc(), new Tests::HumanNumberFacet()));
+-
+-        if (m_exception)
+-            result << "Run: FAILED: " << m_exception.get().what();
+-        else
+-        {
+-            auto humanDuration = Tests::DurationHumanizer::deduceHumanDuration(duration());
+-
+-            result << "Run: Ops: " << ops()
+-                   << " - Duration (" << humanDuration.shortUnitName << "): " << std::setprecision(3) << humanDuration.value;
+-        }
+-
+-        return result.str();
+-    }
+-
+-    std::int64_t ThroughputTestSessionResult::totalOperationsInRun() const
+-    {
+-        return m_totalOperationsInRun;
+-    }
+-
+-    ClockConfig::Duration ThroughputTestSessionResult::duration() const
+-    {
+-        return m_duration;
+-    }
+-
+-    std::int64_t ThroughputTestSessionResult::ops() const
+-    {
+-        auto elapsed = std::chrono::duration_cast< std::chrono::microseconds >(m_duration).count();
+-        return static_cast< std::int64_t >(static_cast< double >(1000 * 1000 * m_totalOperationsInRun) / elapsed);
+-    }
+-
+-    std::int64_t ThroughputTestSessionResult::durationInMilliseconds() const
+-    {
+-        auto totalMilliseconds = std::chrono::duration_cast< std::chrono::milliseconds >(m_duration);
+-        return static_cast< std::int64_t >(totalMilliseconds.count());
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/ThroughputTestSessionResult.h b/Disruptor.PerfTests/ThroughputTestSessionResult.h
+deleted file mode 100644
+index 57ac6f5..0000000
+--- a/Disruptor.PerfTests/ThroughputTestSessionResult.h
++++ /dev/null
+@@ -1,40 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-#include <exception>
+-#include <iosfwd>
+-
+-#include <boost/optional.hpp>
+-
+-#include "Disruptor/ClockConfig.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class ThroughputTestSessionResult
+-    {
+-    public:
+-        ThroughputTestSessionResult(std::int64_t totalOperationsInRun, ClockConfig::Duration duration);
+-
+-        explicit ThroughputTestSessionResult(const std::exception& exception);
+-
+-        void appendDetailedHtmlReport(std::int32_t runId, std::ostringstream& stringBuilder);
+-        std::string toString();
+-
+-        std::int64_t totalOperationsInRun() const;
+-        ClockConfig::Duration duration() const;
+-
+-        std::int64_t ops() const;
+-        std::int64_t durationInMilliseconds() const;
+-
+-    private:
+-        std::int64_t m_totalOperationsInRun = 0;
+-        ClockConfig::Duration m_duration;
+-        boost::optional< std::exception > m_exception;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/TwoToTwoWorkProcessorThroughputTest.cpp b/Disruptor.PerfTests/TwoToTwoWorkProcessorThroughputTest.cpp
+deleted file mode 100644
+index 2bf9803..0000000
+--- a/Disruptor.PerfTests/TwoToTwoWorkProcessorThroughputTest.cpp
++++ /dev/null
+@@ -1,113 +0,0 @@
+-#include "stdafx.h"
+-#include "TwoToTwoWorkProcessorThroughputTest.h"
+-
+-#include "Disruptor/IgnoreExceptionHandler.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    TwoToTwoWorkProcessorThroughputTest::TwoToTwoWorkProcessorThroughputTest()
+-    {
+-        auto sequenceBarrier = m_ringBuffer->newBarrier();
+-        m_handlers[0] = std::make_shared< ValueAdditionWorkHandler >();
+-        m_handlers[1] = std::make_shared< ValueAdditionWorkHandler >();
+-
+-        m_workProcessors[0] = WorkProcessor< ValueEvent >::create(m_ringBuffer, sequenceBarrier, m_handlers[0], std::make_shared< IgnoreExceptionHandler< ValueEvent > >(), m_workSequence);
+-        m_workProcessors[1] = WorkProcessor< ValueEvent >::create(m_ringBuffer, sequenceBarrier, m_handlers[1], std::make_shared< IgnoreExceptionHandler< ValueEvent > >(), m_workSequence);
+-
+-        for (auto i = 0; i < m_numPublishers; ++i)
+-        {
+-            m_valuePublishers[i] = std::make_shared< ValuePublisher >(m_cyclicBarrier, m_ringBuffer, m_iterations);
+-        }
+-
+-        m_ringBuffer->addGatingSequences({ m_workProcessors[0]->sequence(), m_workProcessors[1]->sequence() });
+-    }
+-
+-    std::int64_t TwoToTwoWorkProcessorThroughputTest::run(Stopwatch& stopwatch)
+-    {
+-        m_cyclicBarrier->reset();
+-
+-        auto expected = m_ringBuffer->cursor() + (m_numPublishers * m_iterations);
+-        auto futures = std::vector< std::future< void > >(m_numPublishers);
+-        for (auto i = 0; i < m_numPublishers; ++i)
+-        {
+-            auto index = i;
+-            futures[i] = std::async(std::launch::async, [this, index] { m_valuePublishers[index]->run(); });
+-        }
+-
+-        for (auto&& processor : m_workProcessors)
+-        {
+-            std::thread([processor] { processor->run(); }).detach();
+-        }
+-
+-        stopwatch.start();
+-        m_cyclicBarrier->signal();
+-        m_cyclicBarrier->wait();
+-
+-        for (auto i = 0; i < m_numPublishers; ++i)
+-        {
+-            futures[i].wait();
+-        }
+-
+-        while (m_workSequence->value() < expected)
+-        {
+-            std::this_thread::yield();
+-        }
+-
+-        stopwatch.stop();
+-
+-        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
+-
+-        for (auto&& processor : m_workProcessors)
+-        {
+-            processor->halt();
+-        }
+-
+-        return m_iterations;
+-    }
+-
+-    std::int32_t TwoToTwoWorkProcessorThroughputTest::requiredProcessorCount() const
+-    {
+-        return 4;
+-    }
+-
+-
+-    TwoToTwoWorkProcessorThroughputTest::ValuePublisher::ValuePublisher(const std::shared_ptr< Tests::CountdownEvent >& cyclicBarrier,  
+-                                                                        const std::shared_ptr< RingBuffer< ValueEvent > >& ringBuffer,
+-                                                                        std::int64_t iterations)
+-        : m_cyclicBarrier(cyclicBarrier)
+-        , m_ringBuffer(ringBuffer)
+-        , m_iterations(iterations)
+-    {
+-    }
+-
+-    void TwoToTwoWorkProcessorThroughputTest::ValuePublisher::run()
+-    {
+-        m_cyclicBarrier->signal();
+-        m_cyclicBarrier->wait();
+-
+-        for (std::int64_t i = 0; i < m_iterations; ++i)
+-        {
+-            auto sequence = m_ringBuffer->next();
+-            auto& event = (*m_ringBuffer)[sequence];
+-            event.value = i;
+-            m_ringBuffer->publish(sequence);
+-        }
+-    }
+-
+-    void TwoToTwoWorkProcessorThroughputTest::ValueAdditionWorkHandler::onEvent(ValueEvent& evt)
+-    {
+-        auto value = evt.value;
+-        m_total += value;
+-    }
+-
+-    std::int64_t TwoToTwoWorkProcessorThroughputTest::ValueAdditionWorkHandler::total() const
+-    {
+-        return m_total;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/TwoToTwoWorkProcessorThroughputTest.h b/Disruptor.PerfTests/TwoToTwoWorkProcessorThroughputTest.h
+deleted file mode 100644
+index 354e275..0000000
+--- a/Disruptor.PerfTests/TwoToTwoWorkProcessorThroughputTest.h
++++ /dev/null
+@@ -1,98 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/BusySpinWaitStrategy.h"
+-#include "Disruptor/IWorkHandler.h"
+-#include "Disruptor/RingBuffer.h"
+-#include "Disruptor/WorkProcessor.h"
+-
+-#include "Disruptor.TestTools/CountdownEvent.h"
+-
+-#include "Disruptor.PerfTests/IThroughputTest.h"
+-#include "Disruptor.PerfTests/ValueEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    /**
+-     *
+-     * Sequence a series of events from multiple publishers going to multiple work processors.
+-     * 
+-     * +----+                  +-----+
+-     * | P1 |---+          +-->| WP1 |
+-     * +----+   |  +-----+ |   +-----+
+-     *          +->| RB1 |-+
+-     * +----+   |  +-----+ |   +-----+
+-     * | P2 |---+          +-->| WP2 |
+-     * +----+                  +-----+
+-     * 
+-     * P1  - Publisher 1
+-     * P2  - Publisher 2
+-     * RB  - RingBuffer
+-     * WP1 - EventProcessor 1
+-     * WP2 - EventProcessor 2
+-     * 
+-     */
+-    class TwoToTwoWorkProcessorThroughputTest : public IThroughputTest
+-    {
+-        class ValuePublisher;
+-        class ValueAdditionWorkHandler;
+-
+-    public:
+-        TwoToTwoWorkProcessorThroughputTest();
+-
+-        std::int64_t run(Stopwatch& stopwatch) override;
+-
+-        std::int32_t requiredProcessorCount() const override;
+-
+-    private:
+-        const std::int32_t m_numPublishers = 2;
+-        const std::int32_t m_bufferSize = 1024 * 64;
+-
+-#ifdef _DEBUG
+-        const std::int64_t m_iterations = 100L * 100L * 1L;
+-#else
+-        const std::int64_t m_iterations = 1000L * 1000L * 1L;
+-#endif
+-
+-        std::shared_ptr< Tests::CountdownEvent > m_cyclicBarrier = std::make_shared< Tests::CountdownEvent >(m_numPublishers + 1);
+-
+-        std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer = RingBuffer< ValueEvent >::createMultiProducer(ValueEvent::eventFactory(), m_bufferSize, std::make_shared< BusySpinWaitStrategy >());
+-        std::shared_ptr< Sequence > m_workSequence = std::make_shared< Sequence >();
+-        std::vector< std::shared_ptr< ValueAdditionWorkHandler > > m_handlers = std::vector< std::shared_ptr< ValueAdditionWorkHandler > >(2);
+-        std::vector< std::shared_ptr< WorkProcessor< ValueEvent > > > m_workProcessors = std::vector< std::shared_ptr< WorkProcessor< ValueEvent > > >(2);
+-        std::vector< std::shared_ptr< ValuePublisher > > m_valuePublishers = std::vector< std::shared_ptr< ValuePublisher > >(m_numPublishers);
+-    };
+-
+-
+-    class TwoToTwoWorkProcessorThroughputTest::ValuePublisher
+-    {
+-    public:
+-        ValuePublisher(const std::shared_ptr< Tests::CountdownEvent >& cyclicBarrier,
+-                       const std::shared_ptr< RingBuffer< ValueEvent > >& ringBuffer,
+-                       std::int64_t iterations);
+-
+-        void run();
+-
+-    private:
+-        std::shared_ptr< Tests::CountdownEvent > m_cyclicBarrier;
+-        const std::shared_ptr< RingBuffer< ValueEvent > > m_ringBuffer;
+-        const std::int64_t m_iterations;
+-    };
+-
+-
+-    class TwoToTwoWorkProcessorThroughputTest::ValueAdditionWorkHandler : public IWorkHandler< ValueEvent >
+-    {
+-    public:
+-        void onEvent(ValueEvent& evt) override;
+-
+-        std::int64_t total() const;
+-
+-    private:
+-        std::int64_t m_total = 0;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/ValueAdditionEventHandler.cpp b/Disruptor.PerfTests/ValueAdditionEventHandler.cpp
+deleted file mode 100644
+index ac8ee05..0000000
+--- a/Disruptor.PerfTests/ValueAdditionEventHandler.cpp
++++ /dev/null
+@@ -1,39 +0,0 @@
+-#include "stdafx.h"
+-#include "ValueAdditionEventHandler.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    void ValueAdditionEventHandler::reset(const std::shared_ptr< Tests::ManualResetEvent >& latch, std::int64_t expectedCount)
+-    {
+-        m_value.value = 0;
+-        m_latch = latch;
+-        m_count = expectedCount;
+-    }
+-
+-    void ValueAdditionEventHandler::onEvent(ValueEvent& value, std::int64_t sequence, bool)
+-    {
+-        m_value.value = m_value.value + value.value;
+-
+-        if (count() == sequence)
+-        {
+-            if (m_latch != nullptr)
+-                m_latch->set();
+-        }
+-    }
+-
+-    std::int64_t ValueAdditionEventHandler::count() const
+-    {
+-        return m_count;
+-    }
+-
+-    std::int64_t ValueAdditionEventHandler::value() const
+-    {
+-        return m_value.value;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/ValueAdditionEventHandler.h b/Disruptor.PerfTests/ValueAdditionEventHandler.h
+deleted file mode 100644
+index ca71959..0000000
+--- a/Disruptor.PerfTests/ValueAdditionEventHandler.h
++++ /dev/null
+@@ -1,36 +0,0 @@
+-#pragma once
+-
+-#include <memory>
+-
+-#include "Disruptor/IEventHandler.h"
+-
+-#include "Disruptor.TestTools/ManualResetEvent.h"
+-
+-#include "Disruptor.PerfTests/PaddedLong.h"
+-#include "Disruptor.PerfTests/ValueEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class ValueAdditionEventHandler : public IEventHandler< ValueEvent >
+-    {
+-    public:
+-        void reset(const std::shared_ptr< Tests::ManualResetEvent >& latch, std::int64_t expectedCount);
+-
+-        void onEvent(ValueEvent& value, std::int64_t sequence, bool /*endOfBatch*/) override;
+-
+-        std::int64_t count() const;
+-
+-        std::int64_t value() const;
+-
+-    private:
+-        PaddedLong m_value;
+-        std::int64_t m_count = 0;
+-        std::shared_ptr< Tests::ManualResetEvent > m_latch;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/ValueEvent.cpp b/Disruptor.PerfTests/ValueEvent.cpp
+deleted file mode 100644
+index 07ee320..0000000
+--- a/Disruptor.PerfTests/ValueEvent.cpp
++++ /dev/null
+@@ -1,17 +0,0 @@
+-#include "stdafx.h"
+-#include "ValueEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    const std::function< ValueEvent() >& ValueEvent::eventFactory()
+-    {
+-        static std::function< ValueEvent() > result([] { return ValueEvent(); });
+-        return result;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/ValueEvent.h b/Disruptor.PerfTests/ValueEvent.h
+deleted file mode 100644
+index 317d962..0000000
+--- a/Disruptor.PerfTests/ValueEvent.h
++++ /dev/null
+@@ -1,20 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-#include <functional>
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class ValueEvent
+-    {
+-    public:
+-        static const std::function< ValueEvent() >& eventFactory();
+-
+-        std::int64_t value;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/ValueMutationEventHandler.cpp b/Disruptor.PerfTests/ValueMutationEventHandler.cpp
+deleted file mode 100644
+index 7871a6b..0000000
+--- a/Disruptor.PerfTests/ValueMutationEventHandler.cpp
++++ /dev/null
+@@ -1,38 +0,0 @@
+-#include "stdafx.h"
+-#include "ValueMutationEventHandler.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    ValueMutationEventHandler::ValueMutationEventHandler(Operation operation)
+-        : m_operation(operation)
+-    {
+-    }
+-
+-    std::int64_t ValueMutationEventHandler::value() const
+-    {
+-        return m_value.value;
+-    }
+-
+-    void ValueMutationEventHandler::reset(const std::shared_ptr< boost::barrier >& latch, std::int64_t expectedCount)
+-    {
+-        m_value.value = 0L;
+-        m_latch = latch;
+-        m_iterations = expectedCount;
+-    }
+-
+-    void ValueMutationEventHandler::onEvent(ValueEvent& data, std::int64_t sequence, bool /*endOfBatch*/)
+-    {
+-        m_value.value = OperationExtensions::Op(m_operation, m_value.value, data.value);
+-
+-        if (sequence == m_iterations)
+-        {
+-            m_latch->wait();
+-        }
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/ValueMutationEventHandler.h b/Disruptor.PerfTests/ValueMutationEventHandler.h
+deleted file mode 100644
+index 8136a91..0000000
+--- a/Disruptor.PerfTests/ValueMutationEventHandler.h
++++ /dev/null
+@@ -1,36 +0,0 @@
+-#pragma once
+-
+-#include <boost/thread/barrier.hpp>
+-
+-#include "Disruptor/IEventHandler.h"
+-
+-#include "Disruptor.PerfTests/Operation.h"
+-#include "Disruptor.PerfTests/PaddedLong.h"
+-#include "Disruptor.PerfTests/ValueEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class ValueMutationEventHandler : public IEventHandler< ValueEvent >
+-    {
+-    public:
+-        explicit ValueMutationEventHandler(Operation operation);
+-
+-        std::int64_t value() const;
+-
+-        void reset(const std::shared_ptr< boost::barrier >& latch, std::int64_t expectedCount);
+-
+-        void onEvent(ValueEvent& data, std::int64_t sequence, bool endOfBatch);
+-
+-    private:
+-        Operation m_operation;
+-        PaddedLong m_value;
+-        std::int64_t m_iterations = 0;
+-        std::shared_ptr< boost::barrier > m_latch;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.PerfTests/main.cpp b/Disruptor.PerfTests/main.cpp
+deleted file mode 100644
+index 5d6dbe2..0000000
+--- a/Disruptor.PerfTests/main.cpp
++++ /dev/null
+@@ -1,70 +0,0 @@
+-#include "stdafx.h"
+-
+-#include <boost/algorithm/string.hpp>
+-
+-#include "LatencyTestSession.h"
+-#include "TestRepository.h"
+-#include "ThroughputTestSession.h"
+-
+-using namespace Disruptor::PerfTests;
+-
+-void runAllTests(const TestRepository& testRepository);
+-void runOneTest(const TestRepository& testRepository, const std::string& testName);
+-
+-int main(int, char**)
+-{
+-    auto& testRepository = TestRepository::instance();
+-
+-    std::string testName;
+-
+-    std::cout << "Test name (ALL by default):  " << testName << " ?" << std::endl;
+-
+-    std::getline(std::cin, testName);
+-
+-    boost::algorithm::trim(testName);
+-
+-    if (boost::algorithm::iequals(testName, "ALL") || testName.empty())
+-    {
+-        runAllTests(testRepository);
+-    }
+-    else
+-    {
+-        runOneTest(testRepository, testName);
+-    }
+-
+-    return 0;
+-}
+-
+-void runAllTests(const TestRepository& testRepository)
+-{
+-    for (auto&& info : testRepository.allLatencyTests())
+-    {
+-        LatencyTestSession session(info);
+-        session.run();
+-    }
+-
+-    for (auto&& info : testRepository.allThrougputTests())
+-    {
+-        ThroughputTestSession session(info);
+-        session.run();
+-    }
+-}
+-
+-void runOneTest(const TestRepository& testRepository, const std::string& testName)
+-{
+-    LatencyTestInfo latencyTestInfo;
+-    if (testRepository.tryGetLatencyTest(testName, latencyTestInfo))
+-    {
+-        LatencyTestSession session(latencyTestInfo);
+-        session.run();
+-    }
+-    else
+-    {
+-        ThroughputTestInfo throughputTestInfo;
+-        if (testRepository.tryGetThroughputTest(testName, throughputTestInfo))
+-        {
+-            ThroughputTestSession session(throughputTestInfo);
+-            session.run();
+-        }
+-    }
+-}
+diff --git a/Disruptor.PerfTests/stdafx.cpp b/Disruptor.PerfTests/stdafx.cpp
+deleted file mode 100644
+index 1f8dac0..0000000
+--- a/Disruptor.PerfTests/stdafx.cpp
++++ /dev/null
+@@ -1,8 +0,0 @@
+-// stdafx.cpp : source file that includes just the standard includes
+-// disruptorLibTests.pch will be the pre-compiled header
+-// stdafx.obj will contain the pre-compiled type information
+-
+-#include "stdafx.h"
+-
+-// TODO: reference any additional headers you need in STDAFX.H
+-// and not in this file
+diff --git a/Disruptor.PerfTests/stdafx.h b/Disruptor.PerfTests/stdafx.h
+deleted file mode 100644
+index e4f4e6c..0000000
+--- a/Disruptor.PerfTests/stdafx.h
++++ /dev/null
+@@ -1,45 +0,0 @@
+-// stdafx.h : include file for standard system include files,
+-// or project specific include files that are used frequently, but
+-// are changed infrequently
+-//
+-
+-#pragma once
+-
+-#include <boost/config.hpp>
+-
+-#if _MSC_VER // only on Windows
+-
+-# ifndef WIN32_LEAN_AND_MEAN
+-#  define WIN32_LEAN_AND_MEAN    // Exclude rarely-used stuff from Windows headers
+-# endif
+-
+-# pragma warning(disable: 4512) // Assignment operator could not be generated
+-
+-# include "targetver.h"
+-# include <tchar.h>
+-# include <winsock2.h>
+-# include <Windows.h>
+-#endif
+-
+-// STL includes
+-#include <algorithm>
+-#include <chrono>
+-#include <cstdint>
+-#include <deque>
+-#include <exception>
+-#include <functional>
+-#include <future>
+-#include <iostream>
+-#include <limits>
+-#include <list>
+-#include <map>
+-#include <memory>
+-#include <queue>
+-#include <set>
+-#include <stdexcept>
+-#include <string>
+-#include <thread>
+-#include <unordered_set>
+-#include <unordered_map>
+-#include <thread>
+-#include <vector>
+\ No newline at end of file
+diff --git a/Disruptor.PerfTests/targetver.h b/Disruptor.PerfTests/targetver.h
+deleted file mode 100644
+index 87c0086..0000000
+--- a/Disruptor.PerfTests/targetver.h
++++ /dev/null
+@@ -1,8 +0,0 @@
+-#pragma once
+-
+-// Including SDKDDKVer.h defines the highest available Windows platform.
+-
+-// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
+-// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.
+-
+-#include <SDKDDKVer.h>
+diff --git a/Disruptor.TestTools/CMakeLists.txt b/Disruptor.TestTools/CMakeLists.txt
+deleted file mode 100644
+index 6d8105d..0000000
+--- a/Disruptor.TestTools/CMakeLists.txt
++++ /dev/null
+@@ -1,24 +0,0 @@
+-project(Disruptor.TestTools)
+-cmake_minimum_required(VERSION 2.6)
+-
+-
+-find_package(Boost COMPONENTS system)
+-if(Boost_FOUND)
+-    include_directories(${Boost_INCLUDE_DIRS})
+-    link_directories(${Boost_LIBRARY_DIRS})
+-endif()
+-
+-include_directories("..")
+-
+-
+-set(DisruptorTestTools_sources
+-
+-    CountdownEvent.cpp
+-    ManualResetEvent.cpp
+-    ResetEvent.cpp
+-    ScopeExitFunctor.cpp
+-    Stopwatch.cpp
+-    LatencyRecorder.cpp
+-)
+-
+-add_library(Disruptor.TestTools STATIC ${DisruptorTestTools_sources})
+diff --git a/Disruptor.TestTools/CountdownEvent.cpp b/Disruptor.TestTools/CountdownEvent.cpp
+deleted file mode 100644
+index 7185fb0..0000000
+--- a/Disruptor.TestTools/CountdownEvent.cpp
++++ /dev/null
+@@ -1,57 +0,0 @@
+-#include "stdafx.h"
+-#include "CountdownEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    CountdownEvent::CountdownEvent(std::uint32_t initialCount)
+-        : ResetEvent(initialCount == 0)
+-        , m_initialCount(initialCount)
+-        , m_currentCount(initialCount)
+-    {}
+-
+-    std::uint32_t CountdownEvent::initialCount() const
+-    {
+-        return m_initialCount;
+-    }
+-
+-    std::uint32_t CountdownEvent::currentCount() const
+-    {
+-        return m_currentCount;
+-    }
+-
+-    void CountdownEvent::reset()
+-    {
+-        m_currentCount = initialCount();
+-        ResetEvent::reset();
+-    }
+-
+-    void CountdownEvent::reset(std::uint32_t initialCount)
+-    {
+-        m_initialCount = initialCount;
+-        reset();
+-    }
+-
+-    bool CountdownEvent::wait(ClockConfig::Duration timeDuration)
+-    {
+-        while (currentCount() != 0)
+-        {
+-            ResetEvent::reset();
+-            ResetEvent::wait(timeDuration);
+-        }
+-
+-        return true;
+-    }
+-
+-    void CountdownEvent::signal()
+-    {
+-        --m_currentCount;
+-        if (currentCount() == 0)
+-            set();
+-    }
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.TestTools/CountdownEvent.h b/Disruptor.TestTools/CountdownEvent.h
+deleted file mode 100644
+index 9b32f48..0000000
+--- a/Disruptor.TestTools/CountdownEvent.h
++++ /dev/null
+@@ -1,35 +0,0 @@
+-#pragma once
+-
+-#include <atomic>
+-
+-#include "Disruptor/ClockConfig.h"
+-#include "Disruptor.TestTools/ResetEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    class CountdownEvent : public ResetEvent
+-    {
+-    public:
+-        explicit CountdownEvent(std::uint32_t initialCount);
+-
+-        std::uint32_t initialCount() const;
+-        std::uint32_t currentCount() const;
+-
+-        void signal();
+-
+-        void reset() override;
+-        void reset(std::uint32_t initialCount);
+-
+-        bool wait(ClockConfig::Duration timeDuration = ClockConfig::Duration()) override;
+-
+-    private:
+-        mutable std::atomic< std::uint32_t > m_initialCount;
+-        mutable std::atomic< std::uint32_t > m_currentCount;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.TestTools/DurationHumanizer.h b/Disruptor.TestTools/DurationHumanizer.h
+deleted file mode 100644
+index 454e9e5..0000000
+--- a/Disruptor.TestTools/DurationHumanizer.h
++++ /dev/null
+@@ -1,92 +0,0 @@
+-#pragma once
+-
+-#include <string>
+-
+-#include "DurationUnit.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    struct HumanDuration
+-    {
+-        double value;
+-        DurationUnits::DurationUnit unit;
+-        std::string unitName;
+-        std::string shortUnitName;
+-    };
+-
+-
+-    class DurationHumanizer
+-    {
+-    public:
+-        template <class TDuration>
+-        static HumanDuration deduceHumanDuration(const TDuration& duration)
+-        {
+-            if (isReadable< std::chrono::nanoseconds >(duration))
+-                return createHumanDuration< std::chrono::nanoseconds >(duration);
+-
+-            if (isReadable< std::chrono::microseconds >(duration))
+-                return createHumanDuration< std::chrono::microseconds >(duration);
+-
+-            if (isReadable< std::chrono::milliseconds >(duration))
+-                return createHumanDuration< std::chrono::milliseconds >(duration);
+-
+-            if (isReadable< std::chrono::seconds >(duration))
+-                return createHumanDuration< std::chrono::seconds >(duration);
+-
+-            if (isReadable< std::chrono::minutes >(duration))
+-                return createHumanDuration< std::chrono::minutes >(duration);
+-
+-            return createHumanDuration< std::chrono::hours >(duration);
+-        }
+-
+-        template <class TClosestDuration, class TDuration>
+-        static HumanDuration createHumanDuration(const TDuration& duration)
+-        {
+-            using FloatingPointDuration = std::chrono::duration< float, typename TClosestDuration::period >;
+-            auto count = FloatingPointDuration(duration).count();
+-
+-            HumanDuration result;
+-            result.value = static_cast< double >(count);
+-            result.unit = DurationToUnit< TClosestDuration >::value;
+-            result.unitName = DurationUnitInfo< DurationToUnit< TClosestDuration >::value >::name();
+-            result.shortUnitName = DurationUnitInfo< DurationToUnit< TClosestDuration >::value >::shortName();
+-
+-            return result;
+-        }
+-
+-        template <class TDuration>
+-        static HumanDuration createHumanDurationWithUnit(const TDuration& duration, DurationUnits::DurationUnit durationUnit)
+-        {
+-            switch (durationUnit)
+-            {
+-            case DurationUnits::Nanoseconds:
+-                return createHumanDuration< std::chrono::nanoseconds, TDuration >(duration);
+-            case DurationUnits::Microseconds:
+-                return createHumanDuration< std::chrono::microseconds, TDuration >(duration);
+-            case DurationUnits::Milliseconds:
+-                return createHumanDuration< std::chrono::milliseconds, TDuration >(duration);
+-            case DurationUnits::Seconds:
+-                return createHumanDuration< std::chrono::seconds, TDuration >(duration);
+-            case DurationUnits::Minutes:
+-                return createHumanDuration< std::chrono::minutes, TDuration >(duration);
+-            case DurationUnits::Hours:
+-                return createHumanDuration< std::chrono::hours, TDuration >(duration);
+-            default:;
+-                throw std::exception();
+-            }
+-        }
+-
+-    private:
+-        template <class TClosestDuration, class TDuration>
+-        static bool isReadable(const TDuration& duration)
+-        {
+-            return std::chrono::duration_cast< TClosestDuration >(duration).count() < 1000;
+-        }
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.TestTools/DurationUnit.h b/Disruptor.TestTools/DurationUnit.h
+deleted file mode 100644
+index 4686b67..0000000
+--- a/Disruptor.TestTools/DurationUnit.h
++++ /dev/null
+@@ -1,100 +0,0 @@
+-#pragma once
+-
+-#include <chrono>
+-#include <string>
+-#include <type_traits>
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    namespace DurationUnits
+-    {
+-        enum DurationUnit
+-        {
+-            Nanoseconds,
+-            Microseconds,
+-            Milliseconds,
+-            Seconds,
+-            Minutes,
+-            Hours,
+-        };
+-    }
+-
+-    template <DurationUnits::DurationUnit>
+-    struct DurationUnitInfo;
+-
+-    template <>
+-    struct DurationUnitInfo< DurationUnits::Nanoseconds >
+-    {
+-        static std::string name() { return "nanoseconds"; }
+-        static std::string shortName() { return "ns"; }
+-    };
+-
+-    template <>
+-    struct DurationUnitInfo< DurationUnits::Microseconds >
+-    {
+-        static std::string name() { return "microseconds"; }
+-        static std::string shortName() { return "us"; }
+-    };
+-
+-    template <>
+-    struct DurationUnitInfo< DurationUnits::Milliseconds >
+-    {
+-        static std::string name() { return "milliseconds"; }
+-        static std::string shortName() { return "ms"; }
+-    };
+-
+-    template <>
+-    struct DurationUnitInfo< DurationUnits::Seconds >
+-    {
+-        static std::string name() { return "seconds"; }
+-        static std::string shortName() { return "s"; }
+-    };
+-
+-    template <>
+-    struct DurationUnitInfo< DurationUnits::Minutes >
+-    {
+-        static std::string name() { return "minutes"; }
+-        static std::string shortName() { return "m"; }
+-    };
+-
+-    template <>
+-    struct DurationUnitInfo< DurationUnits::Hours >
+-    {
+-        static std::string name() { return "hours"; }
+-        static std::string shortName() { return "h"; }
+-    };
+-
+-
+-    template <class TDuration>
+-    struct DurationToUnit;
+-
+-    template <>
+-    struct DurationToUnit< std::chrono::nanoseconds > : std::integral_constant< DurationUnits::DurationUnit, DurationUnits::Nanoseconds >
+-    {};
+-
+-    template <>
+-    struct DurationToUnit< std::chrono::microseconds > : std::integral_constant< DurationUnits::DurationUnit, DurationUnits::Microseconds >
+-    {};
+-
+-    template <>
+-    struct DurationToUnit< std::chrono::milliseconds > : std::integral_constant< DurationUnits::DurationUnit, DurationUnits::Milliseconds >
+-    {};
+-
+-    template <>
+-    struct DurationToUnit< std::chrono::seconds > : std::integral_constant< DurationUnits::DurationUnit, DurationUnits::Seconds >
+-    {};
+-
+-    template <>
+-    struct DurationToUnit< std::chrono::minutes > : std::integral_constant< DurationUnits::DurationUnit, DurationUnits::Minutes >
+-    {};
+-
+-    template <>
+-    struct DurationToUnit< std::chrono::hours > : std::integral_constant< DurationUnits::DurationUnit, DurationUnits::Hours >
+-    {};
+-    
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.TestTools/HumanNumberFacet.h b/Disruptor.TestTools/HumanNumberFacet.h
+deleted file mode 100644
+index d5bbc0e..0000000
+--- a/Disruptor.TestTools/HumanNumberFacet.h
++++ /dev/null
+@@ -1,25 +0,0 @@
+-#pragma once
+-
+-#include <locale>
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    struct HumanNumberFacet : std::numpunct< char >
+-    {
+-        char do_thousands_sep() const override
+-        {
+-            return ' ';
+-        }
+-
+-        std::string do_grouping() const override
+-        {
+-            return "\3";
+-        }
+-    };
+-    
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.TestTools/LatencyRecorder.cpp b/Disruptor.TestTools/LatencyRecorder.cpp
+deleted file mode 100644
+index 1595795..0000000
+--- a/Disruptor.TestTools/LatencyRecorder.cpp
++++ /dev/null
+@@ -1,58 +0,0 @@
+-#include "stdafx.h"
+-#include "LatencyRecorder.h"
+-
+-#include "Disruptor.TestTools/DurationHumanizer.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    struct DurationPrinter
+-    {
+-        explicit DurationPrinter(std::int64_t nanoseconds)
+-            : value(nanoseconds)
+-        {
+-        }
+-
+-        std::int64_t value;
+-    };
+-
+-    std::ostream& operator<<(std::ostream& stream, const DurationPrinter& printer)
+-    {
+-        auto humanDuration = Tests::DurationHumanizer::deduceHumanDuration(std::chrono::nanoseconds(printer.value));
+-
+-        return stream << humanDuration.value << " " << humanDuration.shortUnitName;
+-    }
+-
+-
+-    LatencyRecorder::LatencyRecorder(std::int64_t sampleSize)
+-        : m_accumulator(boost::accumulators::tag::tail< boost::accumulators::right >::cache_size = sampleSize)
+-    {
+-    }
+-
+-    void LatencyRecorder::record(std::int64_t value)
+-    {
+-        m_accumulator(value);
+-    }
+-
+-    void LatencyRecorder::writeReport(std::ostream& stream) const
+-    {
+-        stream
+-            << "min: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::min(m_accumulator)))
+-            << ", mean: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::mean(m_accumulator)))
+-            << ", max: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::max(m_accumulator)))
+-            << ", Q99.99: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::quantile(m_accumulator, boost::accumulators::quantile_probability = 0.9999)))
+-            << ", Q99.9: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::quantile(m_accumulator, boost::accumulators::quantile_probability = 0.999)))
+-            << ", Q99: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::quantile(m_accumulator, boost::accumulators::quantile_probability = 0.99)))
+-            << ", Q98: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::quantile(m_accumulator, boost::accumulators::quantile_probability = 0.98)))
+-            << ", Q95: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::quantile(m_accumulator, boost::accumulators::quantile_probability = 0.95)))
+-            << ", Q93: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::quantile(m_accumulator, boost::accumulators::quantile_probability = 0.93)))
+-            << ", Q90: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::quantile(m_accumulator, boost::accumulators::quantile_probability = 0.90)))
+-            << ", Q50: " << DurationPrinter(static_cast< std::int64_t >(boost::accumulators::quantile(m_accumulator, boost::accumulators::quantile_probability = 0.50)))
+-            ;
+-    }
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.TestTools/LatencyRecorder.h b/Disruptor.TestTools/LatencyRecorder.h
+deleted file mode 100644
+index fdd36d4..0000000
+--- a/Disruptor.TestTools/LatencyRecorder.h
++++ /dev/null
+@@ -1,48 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-
+-#include "Disruptor/Pragmas.h"
+-
+-DISRUPTOR_PRAGMA_PUSH
+-DISRUPTOR_PRAGMA_IGNORE_ALL
+-DISRUPTOR_PRAGMA_IGNORE_UNREACHABLE_CODE
+-DISRUPTOR_PRAGMA_IGNORE_DEPRECATED_DECLARATIONS
+-#include <boost/accumulators/accumulators.hpp>
+-#include <boost/accumulators/statistics.hpp>
+-DISRUPTOR_PRAGMA_POP
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    class LatencyRecorder
+-    {
+-        using Accumulator = boost::accumulators::accumulator_set
+-        <
+-            double,
+-            boost::accumulators::stats
+-            <
+-                boost::accumulators::tag::mean,
+-                boost::accumulators::tag::max,
+-                boost::accumulators::tag::min,
+-                boost::accumulators::tag::variance,
+-                boost::accumulators::tag::tail_quantile< boost::accumulators::right >
+-            >
+-        >;
+-
+-    public:
+-        explicit LatencyRecorder(std::int64_t sampleSize);
+-        
+-        void record(std::int64_t value);
+-
+-        void writeReport(std::ostream& stream) const;
+-
+-    private:
+-        Accumulator m_accumulator;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.TestTools/ManualResetEvent.cpp b/Disruptor.TestTools/ManualResetEvent.cpp
+deleted file mode 100644
+index 932f1fc..0000000
+--- a/Disruptor.TestTools/ManualResetEvent.cpp
++++ /dev/null
+@@ -1,41 +0,0 @@
+-#include "stdafx.h"
+-#include "ManualResetEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    ManualResetEvent::ManualResetEvent(bool signaled)
+-        : ResetEvent(signaled)
+-    {
+-    }
+-
+-    void ManualResetEvent::set(bool ensureWaitIsTriggered)
+-    {
+-        ResetEvent::set(ensureWaitIsTriggered);
+-    }
+-
+-    void ManualResetEvent::reset()
+-    {
+-        ResetEvent::reset();
+-    }
+-
+-    bool ManualResetEvent::isSet() const
+-    {
+-        return ResetEvent::isSet();
+-    }
+-
+-    bool ManualResetEvent::waitOne()
+-    {
+-        return wait(std::chrono::hours());
+-    }
+-
+-    bool ManualResetEvent::wait(ClockConfig::Duration timeDuration)
+-    {
+-        return ResetEvent::wait(timeDuration);
+-    }
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.TestTools/ManualResetEvent.h b/Disruptor.TestTools/ManualResetEvent.h
+deleted file mode 100644
+index 7f78995..0000000
+--- a/Disruptor.TestTools/ManualResetEvent.h
++++ /dev/null
+@@ -1,28 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/ClockConfig.h"
+-
+-#include "Disruptor.TestTools/ResetEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    class ManualResetEvent : public ResetEvent
+-    {
+-    public:
+-        explicit ManualResetEvent(bool signaled = false);
+-
+-        bool isSet() const override;
+-
+-        void set(bool ensureWaitIsTriggered = false) override;
+-        void reset() override;
+-
+-        bool waitOne();
+-        bool wait(ClockConfig::Duration timeDuration) override;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.TestTools/ResetEvent.cpp b/Disruptor.TestTools/ResetEvent.cpp
+deleted file mode 100644
+index 3016189..0000000
+--- a/Disruptor.TestTools/ResetEvent.cpp
++++ /dev/null
+@@ -1,79 +0,0 @@
+-#include "stdafx.h"
+-#include "ResetEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    ResetEvent::ResetEvent(bool signaled)
+-        : m_signaled(signaled)
+-        , m_mutex()
+-        , m_conditionVariable()
+-        , m_waitCount(0)
+-    {
+-    }
+-
+-    void ResetEvent::set(bool ensureWaitIsTriggered)
+-    {
+-        {
+-            std::unique_lock< decltype(m_mutex) > lock(m_mutex);
+-            m_signaled = true;
+-        }
+-        m_conditionVariable.notify_all();
+-
+-        while (ensureWaitIsTriggered && m_waitCount > 0)
+-            std::this_thread::yield();
+-    }
+-
+-    void ResetEvent::reset()
+-    {
+-        std::unique_lock< decltype(m_mutex) > lock(m_mutex);
+-        m_signaled = false;
+-    }
+-
+-    bool ResetEvent::internalWait(ClockConfig::Duration timeDuration)
+-    {
+-        std::unique_lock< decltype(m_mutex) > lock(m_mutex);
+-
+-        auto hasReceivedSignal = false;
+-
+-        if (!m_signaled)
+-        {
+-            ++m_waitCount;
+-
+-            if (timeDuration == ClockConfig::Duration())
+-            {
+-                do
+-                {
+-                    m_conditionVariable.wait(lock);
+-                }
+-                while (!m_signaled);
+-
+-                hasReceivedSignal = true;
+-            }
+-            else
+-            {
+-                hasReceivedSignal = m_conditionVariable.wait_for(lock, timeDuration, [this] { return this->m_signaled; });
+-            }
+-
+-            --m_waitCount;
+-        }
+-
+-        return hasReceivedSignal || m_signaled;
+-    }
+-
+-    bool ResetEvent::wait(ClockConfig::Duration timeDuration)
+-    {
+-        return internalWait(timeDuration);
+-    }
+-
+-    bool ResetEvent::isSet() const
+-    {
+-        std::lock_guard< decltype(m_mutex) > lock(m_mutex);
+-        return m_signaled;
+-    }
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.TestTools/ResetEvent.h b/Disruptor.TestTools/ResetEvent.h
+deleted file mode 100644
+index c0e8173..0000000
+--- a/Disruptor.TestTools/ResetEvent.h
++++ /dev/null
+@@ -1,40 +0,0 @@
+-#pragma once
+-
+-#include <mutex>
+-#include <condition_variable>
+-
+-#include "Disruptor/ClockConfig.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    class ResetEvent
+-    {
+-    public:
+-        explicit ResetEvent(bool signaled = false);
+-        virtual ~ResetEvent() = default;
+-
+-        ResetEvent(const ResetEvent&) = delete;
+-
+-    protected:
+-        virtual bool isSet() const;
+-
+-        virtual void set(bool ensureWaitIsTriggered = false);
+-        virtual void reset();
+-
+-        virtual bool wait(ClockConfig::Duration timeDuration);
+-
+-    private:
+-        bool internalWait(ClockConfig::Duration timeDuration);
+-
+-        bool m_signaled;
+-        mutable std::mutex m_mutex;
+-        std::condition_variable m_conditionVariable;
+-        int m_waitCount;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.TestTools/ScopeExitFunctor.cpp b/Disruptor.TestTools/ScopeExitFunctor.cpp
+deleted file mode 100644
+index e5fb678..0000000
+--- a/Disruptor.TestTools/ScopeExitFunctor.cpp
++++ /dev/null
+@@ -1,22 +0,0 @@
+-#include "stdafx.h"
+-#include "ScopeExitFunctor.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace TestTools
+-{
+-
+-    ScopeExitFunctor::ScopeExitFunctor(const std::function< void() >& func)
+-        : m_func(func)
+-    {
+-    }
+-
+-    ScopeExitFunctor::~ScopeExitFunctor()
+-    {
+-        if (m_func)
+-            m_func();
+-    }
+-
+-} // namespace TestTools
+-} // namespace Disruptor
+diff --git a/Disruptor.TestTools/ScopeExitFunctor.h b/Disruptor.TestTools/ScopeExitFunctor.h
+deleted file mode 100644
+index 5868774..0000000
+--- a/Disruptor.TestTools/ScopeExitFunctor.h
++++ /dev/null
+@@ -1,23 +0,0 @@
+-#pragma once
+-
+-#include <functional>
+-
+-
+-namespace Disruptor
+-{
+-namespace TestTools
+-{
+-
+-    class ScopeExitFunctor
+-    {
+-    public:
+-        explicit ScopeExitFunctor(const std::function< void() >& func);
+-
+-        ~ScopeExitFunctor();
+-
+-    private:
+-        std::function< void() > m_func;
+-    };
+-    
+-} // namespace TestTools
+-} // namespace Disruptor
+diff --git a/Disruptor.TestTools/Stopwatch.cpp b/Disruptor.TestTools/Stopwatch.cpp
+deleted file mode 100644
+index 1d43d57..0000000
+--- a/Disruptor.TestTools/Stopwatch.cpp
++++ /dev/null
+@@ -1,76 +0,0 @@
+-#include "stdafx.h"
+-#include "Stopwatch.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    Stopwatch::Stopwatch()
+-        : m_isRunning(false)
+-    {
+-        m_begin = m_end = ClockConfig::Clock::now();
+-    }
+-
+-    ClockConfig::Duration Stopwatch::elapsed() const
+-    {
+-        if (isRunning())
+-            m_end = ClockConfig::Clock::now();
+-
+-        return m_end - m_begin;
+-    }
+-
+-    bool Stopwatch::isRunning() const
+-    {
+-        return !!m_isRunning && m_isRunning.get();
+-    }
+-
+-    void Stopwatch::reset()
+-    {
+-        stop();
+-        m_begin = m_end;
+-        m_isRunning.reset();
+-    }
+-
+-    ClockConfig::TimePoint Stopwatch::restart()
+-    {
+-        reset();
+-        start();
+-
+-        return m_begin;
+-    }
+-
+-    void Stopwatch::start()
+-    {
+-        // Should we resume or start the StopWatch?
+-        if (!m_isRunning)
+-        {
+-            m_isRunning = true;
+-            m_begin = ClockConfig::Clock::now();
+-        }
+-        else
+-            m_isRunning = true;
+-    }
+-
+-    Stopwatch Stopwatch::startNew()
+-    {
+-        Stopwatch stopwatch;
+-        stopwatch.start();
+-
+-        return stopwatch;
+-    }
+-
+-    std::int64_t Stopwatch::getTimestamp()
+-    {
+-        return static_cast< std::int64_t >(ClockConfig::Clock::now().time_since_epoch().count());
+-    }
+-
+-    void Stopwatch::stop()
+-    {
+-        m_end = ClockConfig::Clock::now();
+-        m_isRunning = false;
+-    }
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.TestTools/Stopwatch.h b/Disruptor.TestTools/Stopwatch.h
+deleted file mode 100644
+index fcbdcec..0000000
+--- a/Disruptor.TestTools/Stopwatch.h
++++ /dev/null
+@@ -1,41 +0,0 @@
+-#pragma once
+-
+-#include <chrono>
+-#include <boost/optional.hpp>
+-
+-#include "Disruptor/ClockConfig.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace PerfTests
+-{
+-
+-    class Stopwatch
+-    {
+-    public:
+-        Stopwatch();
+-
+-        ClockConfig::Duration elapsed() const;
+-
+-        bool isRunning() const;
+-
+-        static Stopwatch startNew();
+-
+-        static std::int64_t getTimestamp();
+-
+-        void start();
+-        void stop();
+-
+-        void reset();
+-
+-        ClockConfig::TimePoint restart();
+-
+-    private:
+-        boost::optional< bool > m_isRunning;
+-        ClockConfig::TimePoint m_begin;
+-        mutable ClockConfig::TimePoint m_end;
+-    };
+-
+-} // namespace PerfTests
+-} // namespace Disruptor
+diff --git a/Disruptor.TestTools/stdafx.cpp b/Disruptor.TestTools/stdafx.cpp
+deleted file mode 100644
+index 174c7ef..0000000
+--- a/Disruptor.TestTools/stdafx.cpp
++++ /dev/null
+@@ -1,8 +0,0 @@
+-// stdafx.cpp : source file that includes just the standard includes
+-// disruptorLib.pch will be the pre-compiled header
+-// stdafx.obj will contain the pre-compiled type information
+-
+-#include "stdafx.h"
+-
+-// TODO: reference any additional headers you need in STDAFX.H
+-// and not in this file
+diff --git a/Disruptor.TestTools/stdafx.h b/Disruptor.TestTools/stdafx.h
+deleted file mode 100644
+index 08c4386..0000000
+--- a/Disruptor.TestTools/stdafx.h
++++ /dev/null
+@@ -1,44 +0,0 @@
+-// stdafx.h : include file for standard system include files,
+-// or project specific include files that are used frequently, but
+-// are changed infrequently
+-//
+-
+-#pragma once
+-
+-#include <boost/config.hpp>
+-
+-#if _MSC_VER // only on Windows
+-
+-# ifndef WIN32_LEAN_AND_MEAN
+-#  define WIN32_LEAN_AND_MEAN    // Exclude rarely-used stuff from Windows headers
+-# endif
+-
+-# pragma warning(disable: 4512) // Assignment operator could not be generated
+-
+-# include "targetver.h"
+-# include <tchar.h>
+-# include <winsock2.h>
+-# include <Windows.h>
+-#endif
+-
+-// STL includes
+-#include <algorithm>
+-#include <chrono>
+-#include <cstdint>
+-#include <deque>
+-#include <exception>
+-#include <functional>
+-#include <iostream>
+-#include <limits>
+-#include <list>
+-#include <map>
+-#include <memory>
+-#include <queue>
+-#include <set>
+-#include <stdexcept>
+-#include <string>
+-#include <thread>
+-#include <unordered_set>
+-#include <unordered_map>
+-#include <thread>
+-#include <vector>
+\ No newline at end of file
+diff --git a/Disruptor.TestTools/targetver.h b/Disruptor.TestTools/targetver.h
+deleted file mode 100644
+index 87c0086..0000000
+--- a/Disruptor.TestTools/targetver.h
++++ /dev/null
+@@ -1,8 +0,0 @@
+-#pragma once
+-
+-// Including SDKDDKVer.h defines the highest available Windows platform.
+-
+-// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
+-// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.
+-
+-#include <SDKDDKVer.h>
+diff --git a/Disruptor.Tests/AggregateEventHandlerTests.cpp b/Disruptor.Tests/AggregateEventHandlerTests.cpp
+deleted file mode 100644
+index 136b071..0000000
+--- a/Disruptor.Tests/AggregateEventHandlerTests.cpp
++++ /dev/null
+@@ -1,56 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "Disruptor/AggregateEventHandler.h"
+-
+-#include "AggregateEventHandlerTestsFixture.h"
+-#include "SequencerFixture.h"
+-
+-
+-using namespace Disruptor;
+-using namespace Disruptor::Tests;
+-
+-
+-BOOST_AUTO_TEST_SUITE(AggregateEventHandlerTests)
+-
+-BOOST_FIXTURE_TEST_CASE(ShouldCallOnEventInSequence, AggregateEventHandlerTestsFixture)
+-{
+-    auto evt = 7;
+-    const std::int64_t sequence = 3;
+-    const auto endOfBatch = true;
+-
+-    EXPECT_CALL(*m_eventHandlerMock1, onEvent(evt, sequence, endOfBatch)).Times(1);
+-    EXPECT_CALL(*m_eventHandlerMock2, onEvent(evt, sequence, endOfBatch)).Times(1);
+-    EXPECT_CALL(*m_eventHandlerMock3, onEvent(evt, sequence, endOfBatch)).Times(1);
+-
+-    m_aggregateEventHandler->onEvent(evt, sequence, endOfBatch);
+-}
+-
+-BOOST_FIXTURE_TEST_CASE(ShouldCallOnStartInSequence, AggregateEventHandlerTestsFixture)
+-{
+-    EXPECT_CALL(*m_eventHandlerMock1, onStart()).Times(1);
+-    EXPECT_CALL(*m_eventHandlerMock2, onStart()).Times(1);
+-    EXPECT_CALL(*m_eventHandlerMock3, onStart()).Times(1);
+-
+-    m_aggregateEventHandler->onStart();
+-}
+-
+-BOOST_FIXTURE_TEST_CASE(ShouldCallOnShutdownInSequence, AggregateEventHandlerTestsFixture)
+-{
+-    EXPECT_CALL(*m_eventHandlerMock1, onShutdown()).Times(1);
+-    EXPECT_CALL(*m_eventHandlerMock2, onShutdown()).Times(1);
+-    EXPECT_CALL(*m_eventHandlerMock3, onShutdown()).Times(1);
+-
+-    m_aggregateEventHandler->onShutdown();
+-}
+-
+-BOOST_FIXTURE_TEST_CASE(ShouldHandleEmptyListOfEventHandlers, AggregateEventHandlerTestsFixture)
+-{
+-    auto newAggregateEventHandler = std::make_shared< AggregateEventHandler< std::int32_t > >();
+-
+-    auto v = 7;
+-    BOOST_CHECK_NO_THROW(newAggregateEventHandler->onEvent(v, 0, true));
+-    BOOST_CHECK_NO_THROW(newAggregateEventHandler->onStart());
+-    BOOST_CHECK_NO_THROW(newAggregateEventHandler->onShutdown());
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/AggregateEventHandlerTestsFixture.cpp b/Disruptor.Tests/AggregateEventHandlerTestsFixture.cpp
+deleted file mode 100644
+index ed062ee..0000000
+--- a/Disruptor.Tests/AggregateEventHandlerTestsFixture.cpp
++++ /dev/null
+@@ -1,21 +0,0 @@
+-#include "stdafx.h"
+-#include "AggregateEventHandlerTestsFixture.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    AggregateEventHandlerTestsFixture::AggregateEventHandlerTestsFixture()
+-    {
+-        m_eventHandlerMock1 = std::make_shared< testing::NiceMock< LifecycleAwareEventHandlerMock< std::int32_t > > >();
+-        m_eventHandlerMock2 = std::make_shared< testing::NiceMock< LifecycleAwareEventHandlerMock< std::int32_t > > >();
+-        m_eventHandlerMock3 = std::make_shared< testing::NiceMock< LifecycleAwareEventHandlerMock< std::int32_t > > >();
+-
+-        std::vector< std::shared_ptr< IEventHandler< std::int32_t > > > v = {m_eventHandlerMock1, m_eventHandlerMock2, m_eventHandlerMock3};
+-        m_aggregateEventHandler = std::make_shared< AggregateEventHandler< std::int32_t > >(v);
+-    }
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/AggregateEventHandlerTestsFixture.h b/Disruptor.Tests/AggregateEventHandlerTestsFixture.h
+deleted file mode 100644
+index 723ac7d..0000000
+--- a/Disruptor.Tests/AggregateEventHandlerTestsFixture.h
++++ /dev/null
+@@ -1,28 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-#include <memory>
+-
+-#include "Disruptor/AggregateEventHandler.h"
+-
+-#include "Disruptor.Tests/LifecycleAwareEventHandlerMock.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    struct AggregateEventHandlerTestsFixture
+-    {
+-        AggregateEventHandlerTestsFixture();
+-
+-        std::shared_ptr< LifecycleAwareEventHandlerMock< std::int32_t > > m_eventHandlerMock1;
+-        std::shared_ptr< LifecycleAwareEventHandlerMock< std::int32_t > > m_eventHandlerMock2;
+-        std::shared_ptr< LifecycleAwareEventHandlerMock< std::int32_t > > m_eventHandlerMock3;
+-
+-        std::shared_ptr< AggregateEventHandler< std::int32_t > > m_aggregateEventHandler;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/AtomicReference.h b/Disruptor.Tests/AtomicReference.h
+deleted file mode 100644
+index d945247..0000000
+--- a/Disruptor.Tests/AtomicReference.h
++++ /dev/null
+@@ -1,35 +0,0 @@
+-#pragma once
+-
+-#include <boost/optional.hpp>
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    template <class T>
+-    class AtomicReference
+-    {
+-    public:
+-        explicit AtomicReference(const boost::optional< T >& value = boost::none)
+-            : m_value(value)
+-        {
+-        }
+-
+-        boost::optional< T > read()
+-        {
+-            return m_value;
+-        }
+-
+-        void write(const boost::optional< T >& value)
+-        {
+-            m_value = value;
+-        }
+-
+-    private:
+-        boost::optional< T > m_value;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/BatchEventProcessorTests.cpp b/Disruptor.Tests/BatchEventProcessorTests.cpp
+deleted file mode 100644
+index be403dc..0000000
+--- a/Disruptor.Tests/BatchEventProcessorTests.cpp
++++ /dev/null
+@@ -1,78 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "BatchEventProcessorTestsFixture.h"
+-
+-
+-using namespace Disruptor;
+-using namespace Disruptor::Tests;
+-
+-
+-BOOST_AUTO_TEST_SUITE(BatchEventProcessorTests);
+-
+-BOOST_FIXTURE_TEST_CASE(ShouldThrowExceptionOnSettingNullExceptionHandler, BatchEventProcessorTestsFixture)
+-{
+-    BOOST_CHECK_THROW(m_batchEventProcessor->setExceptionHandler(nullptr), ArgumentNullException);
+-}
+-
+-BOOST_FIXTURE_TEST_CASE(ShouldCallMethodsInLifecycleOrder, BatchEventProcessorTestsFixture)
+-{
+-    EXPECT_CALL(*m_batchHandlerMock, onEvent((*m_ringBuffer)[0], 0, true)).WillOnce(testing::Invoke([this](StubEvent&, std::int64_t, bool)
+-    {
+-        m_countDownEvent.signal();
+-    }));
+-
+-    std::thread thread([this] { m_batchEventProcessor->run(); });
+-
+-    BOOST_CHECK_EQUAL(-1, m_batchEventProcessor->sequence()->value());
+-
+-    m_ringBuffer->publish(m_ringBuffer->next());
+-
+-    BOOST_CHECK_EQUAL(m_countDownEvent.wait(std::chrono::milliseconds(50)), true);
+-    m_batchEventProcessor->halt();
+-    thread.join();
+-}
+-
+-BOOST_FIXTURE_TEST_CASE(ShouldCallMethodsInLifecycleOrderForBatch, BatchEventProcessorTestsFixture)
+-{
+-    EXPECT_CALL(*m_batchHandlerMock, onEvent((*m_ringBuffer)[0], 0, false)).Times(1);
+-    EXPECT_CALL(*m_batchHandlerMock, onEvent((*m_ringBuffer)[1], 1, false)).Times(1);
+-    EXPECT_CALL(*m_batchHandlerMock, onEvent((*m_ringBuffer)[2], 2, true)).WillOnce(testing::Invoke([this](StubEvent&, std::int64_t, bool)
+-    {
+-        m_countDownEvent.signal();
+-    }));
+-
+-    m_ringBuffer->publish(m_ringBuffer->next());
+-    m_ringBuffer->publish(m_ringBuffer->next());
+-    m_ringBuffer->publish(m_ringBuffer->next());
+-
+-    std::thread thread([this] { m_batchEventProcessor->run(); });
+-
+-    BOOST_CHECK_EQUAL(m_countDownEvent.wait(std::chrono::milliseconds(50)), true);
+-    m_batchEventProcessor->halt();
+-    thread.join();
+-}
+-
+-BOOST_FIXTURE_TEST_CASE(ShouldCallExceptionHandlerOnUncaughtException, BatchEventProcessorTestsFixture)
+-{
+-    InvalidOperationException ex("BatchEventProcessorTests.ShouldCallExceptionHandlerOnUncaughtException");
+-    m_batchEventProcessor->setExceptionHandler(m_excpetionHandlerMock);
+-    
+-    EXPECT_CALL(*m_batchHandlerMock, onEvent((*m_ringBuffer)[0], 0, true)).WillRepeatedly(testing::Throw(ex));
+-
+-    EXPECT_CALL(*m_excpetionHandlerMock, handleEventException(testing::_, 0, (*m_ringBuffer)[0]))
+-        .WillRepeatedly(testing::Invoke([&](const std::exception& lException, std::int64_t, StubEvent&)
+-        {
+-            BOOST_CHECK_EQUAL(lException.what(), ex.what());
+-            m_countDownEvent.signal();
+-        }));
+-
+-    std::thread thread([this] { m_batchEventProcessor->run(); });
+-
+-    m_ringBuffer->publish(m_ringBuffer->next());
+-
+-    BOOST_CHECK_EQUAL(m_countDownEvent.wait(std::chrono::milliseconds(50)), true);
+-    m_batchEventProcessor->halt();
+-    thread.join();
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/BatchEventProcessorTestsFixture.cpp b/Disruptor.Tests/BatchEventProcessorTestsFixture.cpp
+deleted file mode 100644
+index 41cf0bc..0000000
+--- a/Disruptor.Tests/BatchEventProcessorTestsFixture.cpp
++++ /dev/null
+@@ -1,24 +0,0 @@
+-#include "stdafx.h"
+-#include "BatchEventProcessorTestsFixture.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    BatchEventProcessorTestsFixture::BatchEventProcessorTestsFixture()
+-        : m_countDownEvent(1)
+-    {
+-        auto eventFactory = []() { return StubEvent(-1); };
+-
+-        m_ringBuffer = std::make_shared< RingBuffer< StubEvent > >(eventFactory, 16);
+-        m_sequenceBarrier = m_ringBuffer->newBarrier();
+-
+-        m_batchHandlerMock = std::make_shared< testing::NiceMock< BatchHandlerMock< StubEvent > > >();
+-        m_excpetionHandlerMock = std::make_shared< testing::NiceMock< ExceptionHandlerMock< StubEvent > > >();
+-        m_batchEventProcessor = std::make_shared< BatchEventProcessor< StubEvent > >(m_ringBuffer, m_sequenceBarrier, m_batchHandlerMock);
+-    }
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/BatchEventProcessorTestsFixture.h b/Disruptor.Tests/BatchEventProcessorTestsFixture.h
+deleted file mode 100644
+index 9a45ecc..0000000
+--- a/Disruptor.Tests/BatchEventProcessorTestsFixture.h
++++ /dev/null
+@@ -1,32 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/BatchEventProcessor.h"
+-#include "Disruptor/ISequenceBarrier.h"
+-#include "Disruptor/RingBuffer.h"
+-
+-#include "Disruptor.TestTools/CountdownEvent.h"
+-
+-#include "Disruptor.Tests/BatchHandlerMock.h"
+-#include "Disruptor.Tests/ExceptionHandlerMock.h"
+-#include "Disruptor.Tests/StubEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    struct BatchEventProcessorTestsFixture
+-    {
+-        BatchEventProcessorTestsFixture();
+-
+-        std::shared_ptr< RingBuffer< StubEvent > > m_ringBuffer;
+-        std::shared_ptr< ISequenceBarrier > m_sequenceBarrier;
+-        std::shared_ptr< BatchHandlerMock< StubEvent > > m_batchHandlerMock;
+-        std::shared_ptr< ExceptionHandlerMock< StubEvent > > m_excpetionHandlerMock;
+-        std::shared_ptr< BatchEventProcessor< StubEvent > > m_batchEventProcessor;
+-        CountdownEvent m_countDownEvent;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/BatchHandlerMock.h b/Disruptor.Tests/BatchHandlerMock.h
+deleted file mode 100644
+index 5ff9da7..0000000
+--- a/Disruptor.Tests/BatchHandlerMock.h
++++ /dev/null
+@@ -1,24 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-#include <memory>
+-
+-#include <gmock/gmock.h>
+-
+-#include "Disruptor/IEventHandler.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    template <class T>
+-    class BatchHandlerMock : public IEventHandler< T >
+-    {
+-    public:
+-        MOCK_METHOD3_T(onEvent, void(T& data, std::int64_t sequence, bool endOfBatch));
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/BatchingTests.cpp b/Disruptor.Tests/BatchingTests.cpp
+deleted file mode 100644
+index 10bb441..0000000
+--- a/Disruptor.Tests/BatchingTests.cpp
++++ /dev/null
+@@ -1,123 +0,0 @@
+-#include "stdafx.h"
+-
+-#include <boost/mpl/vector.hpp>
+-
+-#include "Disruptor/Disruptor.h"
+-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
+-#include "Disruptor/SleepingWaitStrategy.h"
+-
+-#include "LongEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    class ParallelEventHandler : public IEventHandler< LongEvent >
+-    {
+-    public:
+-        ParallelEventHandler(std::int64_t mask, std::int64_t ordinal)
+-            : processed(0)
+-        {
+-            m_mask = mask;
+-            m_ordinal = ordinal;
+-        }
+-    
+-        void onEvent(LongEvent& event, std::int64_t sequence, bool endOfBatch) override
+-        {
+-            if ((sequence & m_mask) == m_ordinal)
+-            {
+-                eventCount++;
+-                tempValue = event.value;
+-            }
+-            
+-            if (endOfBatch || ++batchCount >= m_batchSize)
+-            {
+-                publishedValue = tempValue;
+-                batchCount = 0;
+-            }
+-            else
+-            {
+-                std::this_thread::yield();
+-            }
+-
+-            processed = sequence;
+-        }
+-
+-        std::int64_t eventCount = 0;
+-        std::int64_t batchCount = 0;
+-        std::int64_t publishedValue = 0;
+-        std::int64_t tempValue = 0;
+-        std::atomic< std::int64_t > processed;
+-
+-    private:
+-        std::int64_t m_mask = 0;
+-        std::int64_t m_ordinal = 0;
+-        static const std::int32_t m_batchSize = 10;
+-    };
+-    
+-    class EventTranslator : public IEventTranslator< LongEvent >
+-    {
+-    public:
+-        void translateTo(LongEvent& eventData, std::int64_t sequence) override
+-        {
+-            eventData.value = sequence;
+-        }
+-    };
+-    
+-} // namespace Tests
+-} // namespace Disruptor
+-
+-
+-using namespace Disruptor;
+-using namespace ::Disruptor::Tests;
+-
+-
+-BOOST_AUTO_TEST_SUITE(BatchingTests)
+-
+-typedef boost::mpl::vector
+-<
+-    std::integral_constant< ProducerType, ProducerType::Single >,
+-    std::integral_constant< ProducerType, ProducerType::Multi >
+->
+-ProducerTypes;
+-
+-BOOST_AUTO_TEST_CASE_TEMPLATE(ShouldBatch, TProducerType, ProducerTypes)
+-{
+-    auto scheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
+-    scheduler->start(std::thread::hardware_concurrency());
+-
+-    auto d = std::make_shared< disruptor< LongEvent > >([] { return LongEvent(); }, 2048, scheduler, TProducerType::value, std::make_shared< SleepingWaitStrategy >());
+-
+-    auto handler1 = std::make_shared< ParallelEventHandler >(1, 0);
+-    auto handler2 = std::make_shared< ParallelEventHandler >(1, 1);
+-
+-    d->handleEventsWith({ handler1, handler2 });
+-
+-    auto buffer = d->start();
+-
+-    auto translator = std::make_shared< EventTranslator >();
+-
+-    const std::int32_t eventCount = 10000;
+-    for (auto i = 0; i < eventCount; ++i)
+-    {
+-        buffer->publishEvent(translator);
+-    }
+-
+-    while (handler1->processed != eventCount - 1 ||
+-           handler2->processed != eventCount - 1)
+-    {
+-        std::this_thread::sleep_for(std::chrono::milliseconds(1));
+-    }
+-
+-    BOOST_CHECK_EQUAL(handler1->publishedValue, static_cast< std::int64_t >(eventCount) - 2);
+-    BOOST_CHECK_EQUAL(handler1->eventCount, static_cast< std::int64_t >(eventCount) / 2);
+-    BOOST_CHECK_EQUAL(handler2->publishedValue, static_cast< std::int64_t >(eventCount) - 1);
+-    BOOST_CHECK_EQUAL(handler2->eventCount, static_cast< std::int64_t >(eventCount) / 2);
+-
+-    d->shutdown();
+-    scheduler->stop();
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/BusySpinWaitStrategyTests.cpp b/Disruptor.Tests/BusySpinWaitStrategyTests.cpp
+deleted file mode 100644
+index 746073e..0000000
+--- a/Disruptor.Tests/BusySpinWaitStrategyTests.cpp
++++ /dev/null
+@@ -1,18 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "Disruptor/BusySpinWaitStrategy.h"
+-#include "WaitStrategyTestUtil.h"
+-
+-
+-using namespace Disruptor;
+-using namespace Disruptor::Tests;
+-
+-
+-BOOST_AUTO_TEST_SUITE(BusySpinWaitStrategyTests)
+-
+-BOOST_AUTO_TEST_CASE(ShouldWaitForValue)
+-{
+-    assertWaitForWithDelayOf(50, std::make_shared< BusySpinWaitStrategy >());
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/CMakeLists.txt b/Disruptor.Tests/CMakeLists.txt
+deleted file mode 100644
+index 5d3ec82..0000000
+--- a/Disruptor.Tests/CMakeLists.txt
++++ /dev/null
+@@ -1,66 +0,0 @@
+-project(Disruptor.Tests)
+-cmake_minimum_required(VERSION 2.6)
+-
+-find_package(Boost COMPONENTS system chrono thread unit_test_framework)
+-if(Boost_FOUND)
+-    include_directories(${Boost_INCLUDE_DIRS})
+-    link_directories(${Boost_LIBRARY_DIRS})
+-endif()
+-
+-ADD_DEFINITIONS(-DBOOST_TEST_DYN_LINK) 
+-
+-set(DisruptorTests_sources
+-
+-    main.cpp
+-    
+-    AggregateEventHandlerTests.cpp
+-    AggregateEventHandlerTestsFixture.cpp
+-    BatchEventProcessorTests.cpp
+-    BatchEventProcessorTestsFixture.cpp
+-    BatchingTests.cpp
+-    BusySpinWaitStrategyTests.cpp
+-    ConsumerRepositoryTests.cpp
+-    ConsumerRepositoryTestsFixture.cpp
+-    DelayedEventHandler.cpp
+-    DisruptorFixture.cpp
+-    DisruptorStressTest.cpp
+-    DisruptorTests.cpp
+-    DummySequenceBarrier.cpp
+-    EventPollerTests.cpp
+-    EventPublisherTests.cpp
+-    ExceptionThrowingEventHandler.cpp
+-    FatalExceptionHandlerTests.cpp
+-    FixedSequenceGroupTest.cpp
+-    IgnoreExceptionHandlerTests.cpp
+-    LifecycleAwareTests.cpp
+-    MultiProducerSequencerTests.cpp
+-    RingBufferTests.cpp
+-    RingBufferTestsFixture.cpp
+-    RingBufferWithMocksTest.cpp
+-    SequenceBarrierTests.cpp
+-    SequenceBarrierTestsFixture.cpp
+-    SequenceReportingCallbackTests.cpp
+-    SequencerTests.cpp
+-    SequenceUpdater.cpp
+-    SleepingEventHandler.cpp
+-    SleepingWaitStrategyTests.cpp
+-    SpinWaitWaitStrategyTests.cpp
+-    StubEvent.cpp
+-    StubExecutor.cpp
+-    StubPublisher.cpp
+-    TestWaiter.cpp
+-    TestWorkHandler.cpp
+-    TimeoutBlockingWaitStrategyTests.cpp
+-    UtilTests.cpp
+-    WaitStrategyTestUtil.cpp
+-    WorkerPoolTests.cpp
+-    YieldingWaitStrategyTests.cpp
+-)
+-
+-include_directories("..")
+-
+-add_executable(Disruptor.Tests ${DisruptorTests_sources})
+-target_link_libraries(Disruptor.Tests DisruptorStatic Disruptor.TestTools ${Boost_LIBRARIES} gmock)
+-
+-add_test(cmake_Disruptor.Tests ${CMAKE_CURRENT_BINARY_DIR}/Disruptor.Tests --result_code=no --report_level=no)
+-
+diff --git a/Disruptor.Tests/ConsumerRepositoryTests.cpp b/Disruptor.Tests/ConsumerRepositoryTests.cpp
+deleted file mode 100644
+index 0040443..0000000
+--- a/Disruptor.Tests/ConsumerRepositoryTests.cpp
++++ /dev/null
+@@ -1,78 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "ConsumerRepositoryTestsFixture.h"
+-
+-
+-using namespace Disruptor;
+-using namespace Disruptor::Tests;
+-
+-
+-BOOST_AUTO_TEST_SUITE(ConsumerRepositoryTests)
+-
+-BOOST_FIXTURE_TEST_CASE(ShouldGetBarrierByHandler, ConsumerRepositoryTestsFixture)
+-{
+-    m_consumerRepository.add(m_eventProcessor1, m_handler1, m_barrier1);
+-
+-    BOOST_CHECK_EQUAL(m_consumerRepository.getBarrierFor(m_handler1), m_barrier1);
+-}
+-
+-BOOST_FIXTURE_TEST_CASE(ShouldReturnNullForBarrierWhenHandlerIsNotRegistered, ConsumerRepositoryTestsFixture)
+-{
+-    BOOST_CHECK(m_consumerRepository.getBarrierFor(m_handler1) == nullptr);
+-}
+-
+-BOOST_FIXTURE_TEST_CASE(ShouldGetLastEventProcessorsInChain, ConsumerRepositoryTestsFixture)
+-{
+-    m_consumerRepository.add(m_eventProcessor1, m_handler1, m_barrier1);
+-    m_consumerRepository.add(m_eventProcessor2, m_handler2, m_barrier2);
+-
+-    m_consumerRepository.unMarkEventProcessorsAsEndOfChain({ m_eventProcessor2->sequence() });
+-
+-    auto lastEventProcessorsInChain = m_consumerRepository.getLastSequenceInChain(true);
+-
+-    BOOST_CHECK_EQUAL(lastEventProcessorsInChain.size(), 1u);
+-    BOOST_CHECK_EQUAL(lastEventProcessorsInChain[0], m_eventProcessor1->sequence());
+-}
+-
+-BOOST_FIXTURE_TEST_CASE(ShouldRetrieveEventProcessorForHandler, ConsumerRepositoryTestsFixture)
+-{
+-    m_consumerRepository.add(m_eventProcessor1, m_handler1, m_barrier1);
+-
+-    BOOST_CHECK(m_consumerRepository.getEventProcessorFor(m_handler1) == m_eventProcessor1);
+-}
+-
+-BOOST_FIXTURE_TEST_CASE(ShouldThrowExceptionWhenHandlerIsNotRegistered, ConsumerRepositoryTestsFixture)
+-{
+-    BOOST_CHECK_THROW(m_consumerRepository.getEventProcessorFor(std::shared_ptr< SleepingEventHandler >()), Disruptor::ArgumentException);
+-}
+-
+-BOOST_FIXTURE_TEST_CASE(ShouldIterateAllEventProcessors, ConsumerRepositoryTestsFixture)
+-{
+-    m_consumerRepository.add(m_eventProcessor1, m_handler1, m_barrier1);
+-    m_consumerRepository.add(m_eventProcessor2, m_handler2, m_barrier2);
+-
+-    auto seen1 = false;
+-    auto seen2 = false;
+-    
+-    for (auto&& testEntryEventProcessorInfo : m_consumerRepository)
+-    {
+-        auto eventProcessorInfo = std::dynamic_pointer_cast< EventProcessorInfo< TestEvent > >(testEntryEventProcessorInfo);
+-        if (!seen1 && eventProcessorInfo->eventProcessor() == m_eventProcessor1 && eventProcessorInfo->handler() == m_handler1)
+-        {
+-            seen1 = true;
+-        }
+-        else if (!seen2 && eventProcessorInfo->eventProcessor() == m_eventProcessor2 && eventProcessorInfo->handler() == m_handler2)
+-        {
+-            seen2 = true;
+-        }
+-        else
+-        {
+-            BOOST_FAIL("Unexpected eventProcessor info");
+-        }
+-    }
+-
+-    BOOST_CHECK_EQUAL(seen1, true);
+-    BOOST_CHECK_EQUAL(seen2, true);
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/ConsumerRepositoryTestsFixture.cpp b/Disruptor.Tests/ConsumerRepositoryTestsFixture.cpp
+deleted file mode 100644
+index fdc29e1..0000000
+--- a/Disruptor.Tests/ConsumerRepositoryTestsFixture.cpp
++++ /dev/null
+@@ -1,28 +0,0 @@
+-#include "stdafx.h"
+-#include "ConsumerRepositoryTestsFixture.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    ConsumerRepositoryTestsFixture::ConsumerRepositoryTestsFixture()
+-        : m_eventProcessor1(std::make_shared< testing::NiceMock< EventProcessorMock > >())
+-        , m_eventProcessor2(std::make_shared< testing::NiceMock< EventProcessorMock > >())
+-        , m_handler1(std::make_shared< SleepingEventHandler >())
+-        , m_handler2(std::make_shared< SleepingEventHandler >())
+-        , m_barrier1(std::make_shared< testing::NiceMock< SequenceBarrierMock > >())
+-        , m_barrier2(std::make_shared< testing::NiceMock< SequenceBarrierMock > >())
+-    {
+-        auto sequence1 = std::make_shared< Sequence >();
+-        auto sequence2 = std::make_shared< Sequence >();
+-
+-        ON_CALL(*m_eventProcessor1, sequence()).WillByDefault(testing::Return(sequence1));
+-        ON_CALL(*m_eventProcessor1, isRunning()).WillByDefault(testing::Return(true));
+-        ON_CALL(*m_eventProcessor2, sequence()).WillByDefault(testing::Return(sequence1));
+-        ON_CALL(*m_eventProcessor2, isRunning()).WillByDefault(testing::Return(true));
+-    }
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/ConsumerRepositoryTestsFixture.h b/Disruptor.Tests/ConsumerRepositoryTestsFixture.h
+deleted file mode 100644
+index 4d0858e..0000000
+--- a/Disruptor.Tests/ConsumerRepositoryTestsFixture.h
++++ /dev/null
+@@ -1,32 +0,0 @@
+-#pragma once
+-
+-#include <gmock/gmock.h>
+-
+-#include "Disruptor/ConsumerRepository.h"
+-#include "Disruptor/Sequence.h"
+-
+-#include "Disruptor.Tests/EventProcessorMock.h"
+-#include "Disruptor.Tests/SequenceBarrierMock.h"
+-#include "Disruptor.Tests/SleepingEventHandler.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    struct ConsumerRepositoryTestsFixture
+-    {
+-        ConsumerRepositoryTestsFixture();
+-
+-        std::shared_ptr< EventProcessorMock > m_eventProcessor1;
+-        std::shared_ptr< EventProcessorMock > m_eventProcessor2;
+-        std::shared_ptr< SleepingEventHandler > m_handler1;
+-        std::shared_ptr< SleepingEventHandler > m_handler2;
+-        std::shared_ptr< SequenceBarrierMock > m_barrier1;
+-        std::shared_ptr< SequenceBarrierMock > m_barrier2;
+-        ConsumerRepository< TestEvent > m_consumerRepository;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/DataProviderMock.h b/Disruptor.Tests/DataProviderMock.h
+deleted file mode 100644
+index 598f913..0000000
+--- a/Disruptor.Tests/DataProviderMock.h
++++ /dev/null
+@@ -1,29 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-#include <memory>
+-
+-#include <gmock/gmock.h>
+-
+-#include "Disruptor/IDataProvider.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    template <class T>
+-    class DataProviderMock : public IDataProvider< T >
+-    {
+-    public:
+-        MOCK_CONST_METHOD1_T(indexer, T&(std::int64_t sequence));
+-
+-        T& operator[](std::int64_t sequence) const override
+-        {
+-            return this->indexer(sequence);
+-        }
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/DelayedEventHandler.cpp b/Disruptor.Tests/DelayedEventHandler.cpp
+deleted file mode 100644
+index b6a71c9..0000000
+--- a/Disruptor.Tests/DelayedEventHandler.cpp
++++ /dev/null
+@@ -1,68 +0,0 @@
+-#include "stdafx.h"
+-#include "DelayedEventHandler.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    DelayedEventHandler::DelayedEventHandler() 
+-       : DelayedEventHandler(std::make_shared< boost::barrier >(2))
+-    {}
+-
+-    void DelayedEventHandler::onEvent(TestEvent& /*data*/, std::int64_t /*sequence*/, bool /*endOfBatch*/)
+-    {
+-        waitForAndSetFlag(0);
+-    }
+-
+-    void DelayedEventHandler::processEvent()
+-    {
+-        waitForAndSetFlag(1);
+-    }
+-
+-    void DelayedEventHandler::stopWaiting()
+-    {
+-        m_stopped = true;
+-    }
+-
+-    void DelayedEventHandler::onStart()
+-    {
+-        try
+-        {
+-            m_barrier->wait();
+-        }
+-        catch (std::exception& ex)
+-        {
+-            throw std::runtime_error(ex.what());
+-        }
+-    }
+-
+-    void DelayedEventHandler::onShutdown()
+-    {
+-    }
+-
+-    void DelayedEventHandler::awaitStart()
+-    {
+-        m_barrier->wait();
+-    }
+-
+-    DelayedEventHandler::DelayedEventHandler(const std::shared_ptr< boost::barrier >& barrier)
+-        : m_readyToProcessEvent(0)
+-        , m_stopped(false)
+-        , m_barrier(barrier)
+-    {
+-    }
+-
+-    void DelayedEventHandler::waitForAndSetFlag(std::int32_t newValue)
+-    {
+-        //    while (!_stopped && Thread.CurrentThread.IsAlive && Interlocked.Exchange(ref _readyToProcessEvent, newValue) == newValue)
+-        while (!m_stopped && std::atomic_exchange(&m_readyToProcessEvent, newValue) == newValue)
+-        {
+-            std::this_thread::yield();
+-        }
+-    }
+-
+-} // namespace Tests
+-} // namespace Disruptor
+-
+diff --git a/Disruptor.Tests/DelayedEventHandler.h b/Disruptor.Tests/DelayedEventHandler.h
+deleted file mode 100644
+index aaacaf6..0000000
+--- a/Disruptor.Tests/DelayedEventHandler.h
++++ /dev/null
+@@ -1,48 +0,0 @@
+-#pragma once
+-
+-#include <atomic>
+-#include <cstdint>
+-#include <memory>
+-
+-#include <boost/thread/barrier.hpp>
+-
+-#include "Disruptor/IEventHandler.h"
+-#include "Disruptor/ILifecycleAware.h"
+-
+-#include "Disruptor.Tests/TestEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    class DelayedEventHandler : public IEventHandler< TestEvent >, public ILifecycleAware
+-    {
+-    public:
+-        DelayedEventHandler();
+-
+-        void onEvent(TestEvent& data, std::int64_t sequence, bool endOfBatch) override;
+-
+-        void processEvent();
+-
+-        void stopWaiting();
+-
+-        void onStart() override;
+-
+-        void onShutdown() override;
+-
+-        void awaitStart();
+-
+-    private:
+-        explicit DelayedEventHandler(const std::shared_ptr< boost::barrier >& barrier);
+-
+-        void waitForAndSetFlag(std::int32_t newValue);
+-
+-        std::atomic< std::int32_t > m_readyToProcessEvent;
+-        std::atomic< bool > m_stopped;
+-        std::shared_ptr< boost::barrier > m_barrier;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/DisruptorFixture.cpp b/Disruptor.Tests/DisruptorFixture.cpp
+deleted file mode 100644
+index 5335b3d..0000000
+--- a/Disruptor.Tests/DisruptorFixture.cpp
++++ /dev/null
+@@ -1,163 +0,0 @@
+-#include "stdafx.h"
+-#include "DisruptorFixture.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    DisruptorFixture::DisruptorFixture()
+-    {
+-        m_lastPublishedEvent = nullptr;
+-        m_ringBuffer = nullptr;
+-        m_delayedEventHandlers.clear();
+-        m_testWorkHandlers.clear();
+-        m_executor = std::make_shared< StubExecutor >();
+-        m_disruptor = std::make_shared< disruptor< TestEvent > >([] { return TestEvent(); }, 4, m_executor);
+-    }
+-
+-    DisruptorFixture::~DisruptorFixture()
+-    {
+-        for (auto&& delayedEventHandler : m_delayedEventHandlers)
+-        {
+-            delayedEventHandler->stopWaiting();
+-        }
+-
+-        for (auto&& testWorkHandler : m_testWorkHandlers)
+-        {
+-            testWorkHandler->stopWaiting();
+-        }
+-
+-        m_disruptor->halt();
+-        m_executor->joinAllThreads();
+-    }
+-
+-    DisruptorFixture::TempEventHandler::TempEventHandler(const std::shared_ptr< disruptor< TestEvent > >& disruptor,
+-                                                         const std::vector< std::shared_ptr< std::int64_t > >& remainingCapacity)
+-        : m_disruptor(disruptor)
+-        , m_remainingCapacity(remainingCapacity)
+-    {
+-    }
+-
+-    void DisruptorFixture::TempEventHandler::onEvent(TestEvent& /*data*/, std::int64_t /*sequence*/, bool /*endOfBatch*/)
+-    {
+-        *m_remainingCapacity[0] = m_disruptor->ringBuffer()->getRemainingCapacity();
+-    }
+-
+-    DisruptorFixture::EventProcessorFactory::EventProcessorFactory(const std::shared_ptr< disruptor< TestEvent > >& disruptor,
+-                                                                   const std::shared_ptr< IEventHandler< TestEvent > >& eventHandler,
+-                                                                   std::int32_t sequenceLength)
+-        : m_disruptor(disruptor)
+-        , m_eventHandler(eventHandler)
+-        , m_sequenceLength(sequenceLength)
+-    {
+-    }
+-
+-    std::shared_ptr< IEventProcessor > DisruptorFixture::EventProcessorFactory::createEventProcessor(const std::shared_ptr< RingBuffer< TestEvent > >& ringBuffer,
+-                                                                                                     const std::vector< std::shared_ptr< ISequence > >& barrierSequences)
+-    {
+-        BOOST_CHECK_MESSAGE((size_t)m_sequenceLength == barrierSequences.size(), "Should not have had any barrier sequences");
+-        return std::make_shared< BatchEventProcessor< TestEvent > >(m_disruptor->ringBuffer(), ringBuffer->newBarrier(barrierSequences), m_eventHandler);
+-    }
+-
+-    std::shared_ptr< TestWorkHandler > DisruptorFixture::createTestWorkHandler()
+-    {
+-        auto testWorkHandler = std::make_shared< TestWorkHandler >();
+-        m_testWorkHandlers.push_back(testWorkHandler);
+-        return testWorkHandler;
+-    }
+-
+-    void DisruptorFixture::ensureTwoEventsProcessedAccordingToDependencies(const std::shared_ptr< CountdownEvent >& countDownLatch,
+-                                                                           const std::initializer_list< std::shared_ptr< DelayedEventHandler > >& dependencies)
+-    {
+-        publishEvent();
+-        publishEvent();
+-
+-        for (auto&& dependency : dependencies)
+-        {
+-            assertThatCountDownLatchEquals(countDownLatch, 2L);
+-            dependency->processEvent();
+-            dependency->processEvent();
+-        }
+-
+-        assertThatCountDownLatchIsZero(countDownLatch);
+-    }
+-
+-    void DisruptorFixture::assertProducerReaches(const std::shared_ptr< StubPublisher >& stubPublisher, std::int32_t expectedPublicationCount, bool strict)
+-    {
+-        auto loopStart = ClockConfig::Clock::now();
+-        while (stubPublisher->getPublicationCount() < expectedPublicationCount && ClockConfig::Clock::now() - loopStart < std::chrono::milliseconds(5))
+-        {
+-            std::this_thread::yield();
+-        }
+-
+-        if (strict)
+-        {
+-            BOOST_CHECK_EQUAL(stubPublisher->getPublicationCount(), expectedPublicationCount);
+-        }
+-        else
+-        {
+-            auto actualPublicationCount = stubPublisher->getPublicationCount();
+-            BOOST_CHECK_MESSAGE(actualPublicationCount >= expectedPublicationCount,
+-                "Producer reached unexpected count. Expected at least " << expectedPublicationCount << " but only reached " << actualPublicationCount);
+-        }
+-    }
+-
+-    DisruptorFixture::EventTranslator::EventTranslator(DisruptorFixture& disruptorTests)
+-        : m_disruptorTests(disruptorTests)
+-    {
+-    }
+-
+-    void DisruptorFixture::EventTranslator::translateTo(TestEvent& eventData, std::int64_t /*sequence*/)
+-    {
+-        m_disruptorTests.m_lastPublishedEvent = &eventData;
+-    }
+-
+-    TestEvent& DisruptorFixture::publishEvent()
+-    {
+-        if (m_ringBuffer == nullptr)
+-        {
+-            m_ringBuffer = m_disruptor->start();
+-
+-            for (auto&& eventHandler : m_delayedEventHandlers)
+-            {
+-                eventHandler->awaitStart();
+-            }
+-        }
+-
+-        m_disruptor->publishEvent(std::make_shared< EventTranslator >(*this));
+-
+-        return *m_lastPublishedEvent;
+-    }
+-
+-    std::exception DisruptorFixture::waitFor(const std::shared_ptr< AtomicReference< std::exception > >& reference)
+-    {
+-        while (!reference->read())
+-        {
+-            std::this_thread::yield();
+-        }
+-
+-        return reference->read().get();
+-    }
+-
+-    std::shared_ptr< DelayedEventHandler > DisruptorFixture::createDelayedEventHandler()
+-    {
+-        auto delayedEventHandler = std::make_shared< DelayedEventHandler >();
+-        m_delayedEventHandlers.push_back(delayedEventHandler);
+-        return delayedEventHandler;
+-    }
+-
+-    void DisruptorFixture::assertThatCountDownLatchEquals(const std::shared_ptr< CountdownEvent >& countDownLatch, std::int64_t expectedCountDownValue) const
+-    {
+-        BOOST_CHECK_EQUAL(countDownLatch->currentCount(), expectedCountDownValue);
+-    }
+-
+-    void DisruptorFixture::assertThatCountDownLatchIsZero(const std::shared_ptr< CountdownEvent >& countDownLatch) const
+-    {
+-        auto released = countDownLatch->wait(std::chrono::seconds(m_timeoutInSeconds));
+-        BOOST_CHECK_MESSAGE(released == true, "Batch handler did not receive entries: " << countDownLatch->currentCount());
+-    }
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/DisruptorFixture.h b/Disruptor.Tests/DisruptorFixture.h
+deleted file mode 100644
+index 802827d..0000000
+--- a/Disruptor.Tests/DisruptorFixture.h
++++ /dev/null
+@@ -1,102 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-#include <memory>
+-#include <vector>
+-
+-#include "Disruptor/ClockConfig.h"
+-#include "Disruptor/Disruptor.h"
+-
+-#include "Disruptor.TestTools/CountdownEvent.h"
+-
+-#include "Disruptor.Tests/AtomicReference.h"
+-#include "Disruptor.Tests/DelayedEventHandler.h"
+-#include "Disruptor.Tests/StubExecutor.h"
+-#include "Disruptor.Tests/StubPublisher.h"
+-#include "Disruptor.Tests/TestEvent.h"
+-#include "Disruptor.Tests/TestWorkHandler.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    struct DisruptorFixture
+-    {
+-        class EventProcessorFactory;
+-        class EventTranslator;
+-        class TempEventHandler;
+-
+-        DisruptorFixture();
+-        ~DisruptorFixture();
+-
+-        std::shared_ptr< TestWorkHandler > createTestWorkHandler();
+-
+-        void ensureTwoEventsProcessedAccordingToDependencies(const std::shared_ptr< CountdownEvent >& countDownLatch,
+-                                                             const std::initializer_list< std::shared_ptr< DelayedEventHandler > >& dependencies = {});
+-
+-        static void assertProducerReaches(const std::shared_ptr< StubPublisher >& stubPublisher, std::int32_t expectedPublicationCount, bool strict);
+-
+-        TestEvent& publishEvent();
+-
+-        static std::exception waitFor(const std::shared_ptr< AtomicReference< std::exception > >& reference);
+-
+-        std::shared_ptr< DelayedEventHandler > createDelayedEventHandler();
+-
+-        void assertThatCountDownLatchEquals(const std::shared_ptr< CountdownEvent >& countDownLatch, std::int64_t expectedCountDownValue) const;
+-        void assertThatCountDownLatchIsZero(const std::shared_ptr< CountdownEvent >& countDownLatch) const;
+-
+-        std::int32_t m_timeoutInSeconds = 2;
+-        std::shared_ptr< disruptor< TestEvent > > m_disruptor;
+-        std::shared_ptr< StubExecutor > m_executor;
+-        std::vector< std::shared_ptr< DelayedEventHandler > > m_delayedEventHandlers;
+-        std::vector< std::shared_ptr< TestWorkHandler > > m_testWorkHandlers;
+-        std::shared_ptr< RingBuffer< TestEvent > > m_ringBuffer;
+-        TestEvent* m_lastPublishedEvent;
+-    };
+-
+-
+-    class DisruptorFixture::EventProcessorFactory : public IEventProcessorFactory< TestEvent >
+-    {
+-    public:
+-        EventProcessorFactory(const std::shared_ptr< disruptor< TestEvent > >& disruptor,
+-                              const std::shared_ptr< IEventHandler< TestEvent > >& eventHandler,
+-                              std::int32_t sequenceLength);
+-
+-        std::shared_ptr< IEventProcessor > createEventProcessor(const std::shared_ptr< RingBuffer< TestEvent > >& ringBuffer,
+-                                                                const std::vector< std::shared_ptr< ISequence > >& barrierSequences) override;
+-
+-    private:
+-        std::shared_ptr< disruptor< TestEvent > > m_disruptor;
+-        std::shared_ptr< IEventHandler< TestEvent > > m_eventHandler;
+-        std::int32_t m_sequenceLength;
+-    };
+-
+-
+-    class DisruptorFixture::EventTranslator : public IEventTranslator< TestEvent >
+-    {
+-    public:
+-        explicit EventTranslator(DisruptorFixture& disruptorTests);
+-
+-        void translateTo(TestEvent& eventData, std::int64_t sequence) override;
+-
+-    private:
+-        DisruptorFixture& m_disruptorTests;
+-    };
+-
+-
+-    class DisruptorFixture::TempEventHandler : public IEventHandler< TestEvent >
+-    {
+-    public:
+-        TempEventHandler(const std::shared_ptr< disruptor< TestEvent > >& disruptor, const std::vector< std::shared_ptr< std::int64_t > >& remainingCapacity);
+-
+-        void onEvent(TestEvent& data, std::int64_t sequence, bool endOfBatch) override;
+-
+-    private:
+-        std::shared_ptr< disruptor< TestEvent > > m_disruptor;
+-        std::vector< std::shared_ptr< std::int64_t > > m_remainingCapacity;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/DisruptorStressTest.cpp b/Disruptor.Tests/DisruptorStressTest.cpp
+deleted file mode 100644
+index 5b1efae..0000000
+--- a/Disruptor.Tests/DisruptorStressTest.cpp
++++ /dev/null
+@@ -1,178 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "Disruptor/BusySpinWaitStrategy.h"
+-#include "Disruptor/Disruptor.h"
+-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
+-
+-#include "Disruptor.TestTools/CountdownEvent.h"
+-
+-
+-using namespace Disruptor;
+-using namespace ::Disruptor::Tests;
+-
+-
+-BOOST_AUTO_TEST_SUITE(DisruptorStressTest)
+-
+-struct MyTestEvent
+-{
+-    std::int64_t sequence;
+-    std::int64_t a;
+-    std::int64_t b;
+-    std::string s;
+-};
+-
+-class TestEventHandler : public IEventHandler< MyTestEvent >
+-{
+-public:
+-    void onEvent(MyTestEvent& event, std::int64_t sequence, bool) override
+-    {
+-        if (event.sequence != sequence || event.a != sequence + 13 || event.b != sequence - 7)
+-        {
+-            failureCount++;
+-        }
+-
+-        messagesSeen++;
+-    }
+-
+-    std::int32_t failureCount;
+-    std::int32_t messagesSeen;
+-};
+-
+-class Publisher
+-{
+-public:
+-    Publisher(const std::shared_ptr < RingBuffer< MyTestEvent > >& ringBuffer,
+-              std::int32_t iterations,
+-              const std::shared_ptr< CountdownEvent >& start,
+-              const std::shared_ptr< CountdownEvent >& end)
+-        : m_ringBuffer(ringBuffer)
+-        , m_end(end)
+-        , m_start(start)
+-        , m_iterations(iterations)
+-    {}
+-
+-    void run()
+-    {
+-        try
+-        {
+-            m_start->signal();
+-            m_start->wait();
+-
+-            auto i = m_iterations;
+-            while (--i != -1)
+-            {
+-                auto next = m_ringBuffer->next();
+-                auto& testEvent = (*m_ringBuffer)[next];
+-                testEvent.sequence = next;
+-                testEvent.a = next + 13;
+-                testEvent.b = next - 7;
+-
+-                m_ringBuffer->publish(next);
+-            }
+-        }
+-        catch (...)
+-        {
+-            failed = true;
+-        }
+-
+-        m_end->signal();
+-    }
+-
+-    bool failed = false;
+-
+-private:
+-    std::shared_ptr< RingBuffer< MyTestEvent > > m_ringBuffer;
+-    std::shared_ptr< CountdownEvent > m_end;
+-    std::shared_ptr< CountdownEvent > m_start;
+-    std::int32_t m_iterations;
+-};
+-
+-std::vector< std::shared_ptr< Publisher > > initialize(size_t size,
+-                                                       const std::shared_ptr< RingBuffer< MyTestEvent > >& buffer,
+-                                                       int messageCount,
+-                                                       const std::shared_ptr< CountdownEvent >& start,
+-                                                       const std::shared_ptr< CountdownEvent >& end)
+-{
+-    std::vector< std::shared_ptr< Publisher > > result;
+-
+-    for (auto i = 0u; i < size; i++)
+-    {
+-        result.push_back(std::make_shared< Publisher >(buffer, messageCount, start, end));
+-    }
+-
+-    return result;
+-}
+-
+-std::vector< std::shared_ptr< TestEventHandler > > initialize(const std::shared_ptr< disruptor< MyTestEvent > >& disruptor, size_t size)
+-{
+-    std::vector< std::shared_ptr< TestEventHandler > > result;
+-
+-    for (auto i = 0u; i < size; i++)
+-    {
+-        auto handler = std::make_shared< TestEventHandler >();
+-        disruptor->handleEventsWith(handler);
+-        result.push_back(handler);
+-    }
+-
+-    return result;
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldHandleLotsOfThreads)
+-{
+-    auto processorsCount = std::thread::hardware_concurrency();
+-    processorsCount = std::max(processorsCount / 2, 1u);
+-
+-    auto scheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
+-    scheduler->start(processorsCount);
+-
+-    auto waitStrategy = std::make_shared< BusySpinWaitStrategy >();
+-    auto testDisruptor = std::make_shared< disruptor< MyTestEvent > >([] { return MyTestEvent(); }, 1 << 16, scheduler, ProducerType::Multi, waitStrategy);
+-
+-    auto ringBuffer = testDisruptor->ringBuffer();
+-    testDisruptor->setDefaultExceptionHandler(std::make_shared< FatalExceptionHandler< MyTestEvent > >());
+-
+-#ifdef _DEBUG
+-    const auto iterations = 200000;
+-#else
+-    const auto iterations = 20000000;
+-#endif
+-
+-    auto publisherCount = processorsCount;
+-    auto handlerCount = processorsCount;
+-
+-    auto end = std::make_shared< CountdownEvent >(publisherCount);
+-    auto start = std::make_shared< CountdownEvent >(publisherCount);
+-
+-    auto handlers = initialize(testDisruptor, handlerCount);
+-    auto publishers = initialize(publisherCount, ringBuffer, iterations, start, end);
+-
+-    testDisruptor->start();
+-
+-    for (auto&& publisher : publishers)
+-    {
+-        std::thread([publisher] { publisher->run(); }).detach();
+-    }
+-
+-    end->wait();
+-    while (ringBuffer->cursor() < (iterations - 1))
+-    {
+-        std::this_thread::sleep_for(std::chrono::milliseconds(0)); // LockSupport.parkNanos(1);
+-    }
+-
+-    testDisruptor->shutdown();
+-
+-    for (auto&& publisher : publishers)
+-    {
+-        BOOST_CHECK_EQUAL(publisher->failed, false);
+-    }
+-
+-    for (auto&& handler : handlers)
+-    {
+-        BOOST_CHECK_NE(handler->messagesSeen, 0);
+-        BOOST_CHECK_EQUAL(handler->failureCount, 0);
+-    }
+-
+-    scheduler->stop();
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/DisruptorTests.cpp b/Disruptor.Tests/DisruptorTests.cpp
+deleted file mode 100644
+index cb85b3d..0000000
+--- a/Disruptor.Tests/DisruptorTests.cpp
++++ /dev/null
+@@ -1,423 +0,0 @@
+-#include "stdafx.h"
+-
+-#include <boost/any.hpp>
+-
+-#include "Disruptor/Disruptor.h"
+-
+-#include "Disruptor.TestTools/CountdownEvent.h"
+-
+-#include "AtomicReference.h"
+-#include "DisruptorFixture.h"
+-#include "EventHandlerStub.h"
+-#include "ExceptionThrowingEventHandler.h"
+-#include "SleepingEventHandler.h"
+-#include "StubExceptionHandler.h"
+-#include "StubPublisher.h"
+-
+-
+-using namespace Disruptor;
+-using namespace ::Disruptor::Tests;
+-
+-
+-BOOST_FIXTURE_TEST_SUITE(DisruptorTests, DisruptorFixture)
+-
+-BOOST_AUTO_TEST_CASE(ShouldCreateEventProcessorGroupForFirstEventProcessors)
+-{
+-    m_executor->ignoreExecutions();
+-    auto eventHandler1 = std::make_shared< SleepingEventHandler >();
+-    auto eventHandler2 = std::make_shared< SleepingEventHandler >();
+-
+-    auto eventHandlerGroup = m_disruptor->handleEventsWith({ eventHandler1, eventHandler2 });
+-    m_disruptor->start();
+-
+-    BOOST_CHECK(eventHandlerGroup != nullptr);
+-    BOOST_CHECK_EQUAL(m_executor->getExecutionCount(), 2);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldMakeEntriesAvailableToFirstHandlersImmediately)
+-{
+-    auto countDownLatch = std::make_shared< CountdownEvent >(2);
+-    auto eventHandler = std::make_shared< EventHandlerStub< TestEvent > >(countDownLatch);
+-
+-    m_disruptor->handleEventsWith({ createDelayedEventHandler(), eventHandler });
+-
+-    ensureTwoEventsProcessedAccordingToDependencies(countDownLatch);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldWaitUntilAllFirstEventProcessorsProcessEventBeforeMakingItAvailableToDependentEventProcessors)
+-{
+-    auto eventHandler1 = createDelayedEventHandler();
+-
+-    auto countDownLatch = std::make_shared< CountdownEvent >(2);
+-    auto eventHandler2 = std::make_shared< EventHandlerStub< TestEvent > >(countDownLatch);
+-
+-    m_disruptor->handleEventsWith(eventHandler1)->then(eventHandler2);
+-
+-    ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, { eventHandler1 });
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldAllowSpecifyingSpecificEventProcessorsToWaitFor)
+-{
+-    auto handler1 = createDelayedEventHandler();
+-    auto handler2 = createDelayedEventHandler();
+-
+-    auto countDownLatch = std::make_shared< CountdownEvent >(2);
+-    auto handlerWithBarrier = std::make_shared< EventHandlerStub< TestEvent > >(countDownLatch);
+-
+-    m_disruptor->handleEventsWith({ handler1, handler2 });
+-    m_disruptor->after({ handler1, handler2 })->handleEventsWith(handlerWithBarrier);
+-
+-    ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, { handler1, handler2 });
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldWaitOnAllProducersJoinedByAnd)
+-{
+-    auto handler1 = createDelayedEventHandler();
+-    auto handler2 = createDelayedEventHandler();
+-
+-    auto countDownLatch = std::make_shared< CountdownEvent >(2);
+-    auto handlerWithBarrier = std::make_shared< EventHandlerStub< TestEvent > >(countDownLatch);
+-
+-    m_disruptor->handleEventsWith(handler1);
+-    auto handler2Group = m_disruptor->handleEventsWith(handler2);
+-    m_disruptor->after(handler1)->And(handler2Group)->handleEventsWith(handlerWithBarrier);
+-
+-    ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, { handler1, handler2 });
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldThrowExceptionIfHandlerIsNotAlreadyConsuming)
+-{
+-    BOOST_CHECK_THROW(m_disruptor->after(createDelayedEventHandler())->handleEventsWith(createDelayedEventHandler()), ArgumentException);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldSupportSpecifyingAExceptionHandlerForEventProcessors)
+-{
+-    auto eventHandled = std::make_shared< AtomicReference< std::exception > >();
+-    auto exceptionHandler = std::make_shared< StubExceptionHandler< TestEvent > >(eventHandled);
+-    auto testException = std::exception();
+-    auto handler = std::make_shared< ExceptionThrowingEventHandler >(testException);
+-
+-    m_disruptor->handleExceptionsWith(exceptionHandler);
+-    m_disruptor->handleEventsWith(handler);
+-
+-    publishEvent();
+-
+-    auto actualException = waitFor(eventHandled);
+-    BOOST_CHECK(testException.what() == actualException.what());
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldOnlyApplyExceptionsHandlersSpecifiedViaHandleExceptionsWithOnNewEventProcessors)
+-{
+-    auto eventHandled = std::make_shared< AtomicReference< std::exception > >();
+-    auto exceptionHandler = std::make_shared< StubExceptionHandler< TestEvent > >(eventHandled);
+-    auto testException = std::exception();
+-    auto handler = std::make_shared< ExceptionThrowingEventHandler >(testException);
+-
+-    m_disruptor->handleExceptionsWith(exceptionHandler);
+-    m_disruptor->handleEventsWith(handler);
+-    m_disruptor->handleExceptionsWith(std::make_shared< FatalExceptionHandler< TestEvent > >());
+-
+-    publishEvent();
+-
+-    auto actualException = waitFor(eventHandled);
+-    BOOST_CHECK(testException.what() == actualException.what());
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldSupportSpecifyingADefaultExceptionHandlerForEventProcessors)
+-{
+-    auto eventHandled = std::make_shared< AtomicReference< std::exception > >();
+-    auto exceptionHandler = std::make_shared< StubExceptionHandler< TestEvent > >(eventHandled);
+-    auto testException = std::exception();
+-    auto handler = std::make_shared< ExceptionThrowingEventHandler >(testException);
+-
+-    m_disruptor->setDefaultExceptionHandler(exceptionHandler);
+-    m_disruptor->handleEventsWith(handler);
+-
+-    publishEvent();
+-
+-    auto actualException = waitFor(eventHandled);
+-    BOOST_CHECK(testException.what() == actualException.what());
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldApplyDefaultExceptionHandlerToExistingEventProcessors)
+-{
+-    auto eventHandled = std::make_shared< AtomicReference< std::exception > >();
+-    auto exceptionHandler = std::make_shared< StubExceptionHandler< TestEvent > >(eventHandled);
+-    auto testException = std::exception();
+-    auto handler = std::make_shared< ExceptionThrowingEventHandler >(testException);
+-
+-    m_disruptor->handleEventsWith(handler);
+-    m_disruptor->setDefaultExceptionHandler(exceptionHandler);
+-
+-    publishEvent();
+-
+-    auto actualException = waitFor(eventHandled);
+-    BOOST_CHECK(testException.what() == actualException.what());
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldBlockProducerUntilAllEventProcessorsHaveAdvanced)
+-{
+-    auto delayedEventHandler = createDelayedEventHandler();
+-    m_disruptor->handleEventsWith(delayedEventHandler);
+-
+-    auto ringBuffer = m_disruptor->start();
+-    delayedEventHandler->awaitStart();
+-
+-    auto stubPublisher = std::make_shared< StubPublisher >(ringBuffer);
+-    try
+-    {
+-        m_executor->execute([stubPublisher] { stubPublisher->run(); });
+-        
+-        assertProducerReaches(stubPublisher, 4, true);
+-
+-        delayedEventHandler->processEvent();
+-        delayedEventHandler->processEvent();
+-        delayedEventHandler->processEvent();
+-        delayedEventHandler->processEvent();
+-        delayedEventHandler->processEvent();
+-
+-        assertProducerReaches(stubPublisher, 5, false);
+-    }
+-    catch (...)
+-    {
+-    }
+-
+-    stubPublisher->halt();
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldBeAbleToOverrideTheExceptionHandlerForAEventProcessor)
+-{
+-    auto testException = std::exception();
+-    auto eventHandler = std::make_shared< ExceptionThrowingEventHandler >(testException);
+-    m_disruptor->handleEventsWith(eventHandler);
+-
+-    auto reference = std::make_shared< AtomicReference< std::exception > >();
+-    auto exceptionHandler = std::make_shared< StubExceptionHandler< TestEvent > >(reference);
+-
+-    m_disruptor->handleExceptionsFor(eventHandler)->with(exceptionHandler);
+-
+-    publishEvent();
+-
+-    waitFor(reference);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldThrowExceptionWhenAddingEventProcessorsAfterTheProducerBarrierHasBeenCreated)
+-{
+-    m_executor->ignoreExecutions();
+-    m_disruptor->handleEventsWith(std::make_shared< SleepingEventHandler >());
+-    m_disruptor->start();
+-    BOOST_CHECK_THROW(m_disruptor->handleEventsWith(std::make_shared< SleepingEventHandler >()), InvalidOperationException);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldThrowExceptionIfStartIsCalledTwice)
+-{
+-    m_executor->ignoreExecutions();
+-    m_disruptor->handleEventsWith(std::make_shared< SleepingEventHandler >());
+-    m_disruptor->start();
+-    BOOST_CHECK_THROW(m_disruptor->start(), InvalidOperationException);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldSupportCustomProcessorsAsDependencies)
+-{
+-    auto&& ringBuffer = m_disruptor->ringBuffer();
+-
+-    auto delayedEventHandler = createDelayedEventHandler();
+-
+-    auto countDownLatch = std::make_shared< CountdownEvent >(2);
+-    auto handlerWithBarrier = std::make_shared< EventHandlerStub< TestEvent > >(countDownLatch);
+-
+-    auto processor = std::make_shared< BatchEventProcessor< TestEvent > >(ringBuffer, ringBuffer->newBarrier(), delayedEventHandler);
+-    m_disruptor->handleEventsWith(processor)->then(handlerWithBarrier);
+-
+-    ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, { delayedEventHandler });
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldSupportHandlersAsDependenciesToCustomProcessors)
+-{
+-    auto delayedEventHandler = createDelayedEventHandler();
+-    m_disruptor->handleEventsWith(delayedEventHandler);
+-
+-    auto ringBuffer = m_disruptor->ringBuffer();
+-    auto countDownLatch = std::make_shared< CountdownEvent >(2);
+-    auto handlerWithBarrier = std::make_shared< EventHandlerStub< TestEvent > >(countDownLatch);
+-
+-    auto sequenceBarrier = m_disruptor->after(delayedEventHandler)->asSequenceBarrier();
+-    auto processor = std::make_shared< BatchEventProcessor< TestEvent > >(ringBuffer, sequenceBarrier, handlerWithBarrier);
+-    m_disruptor->handleEventsWith(processor);
+-
+-    ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, { delayedEventHandler });
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldSupportCustomProcessorsAndHandlersAsDependencies)
+-{
+-    auto delayedEventHandler1 = createDelayedEventHandler();
+-    auto delayedEventHandler2 = createDelayedEventHandler();
+-    m_disruptor->handleEventsWith(delayedEventHandler1);
+-
+-    auto ringBuffer = m_disruptor->ringBuffer();
+-    auto countDownLatch = std::make_shared< CountdownEvent >(2);
+-    auto handlerWithBarrier = std::make_shared< EventHandlerStub< TestEvent > >(countDownLatch);
+-
+-    auto sequenceBarrier = m_disruptor->after(delayedEventHandler1)->asSequenceBarrier();
+-    auto processor = std::make_shared< BatchEventProcessor< TestEvent > >(ringBuffer, sequenceBarrier, delayedEventHandler2);
+-
+-    m_disruptor->after(delayedEventHandler1)->And(processor)->handleEventsWith(handlerWithBarrier);
+-
+-    ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, { delayedEventHandler1, delayedEventHandler2 });
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldProvideEventsToWorkHandlers)
+-{
+-    auto workHandler1 = createTestWorkHandler();
+-    auto workHandler2 = createTestWorkHandler();
+-    m_disruptor->handleEventsWithWorkerPool({ workHandler1, workHandler2 });
+-
+-    publishEvent();
+-    publishEvent();
+-
+-    workHandler1->processEvent();
+-    workHandler2->processEvent();
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldSupportUsingWorkerPoolAsDependency)
+-{
+-    auto workHandler1 = createTestWorkHandler();
+-    auto workHandler2 = createTestWorkHandler();
+-    auto delayedEventHandler = createDelayedEventHandler();
+-    m_disruptor->handleEventsWithWorkerPool({ workHandler1, workHandler2 })->then(delayedEventHandler);
+-
+-    publishEvent();
+-    publishEvent();
+-
+-    BOOST_CHECK_EQUAL(m_disruptor->getBarrierFor(delayedEventHandler)->cursor(), -1L);
+-
+-    workHandler2->processEvent();
+-    workHandler1->processEvent();
+-
+-    delayedEventHandler->processEvent();
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldSupportUsingWorkerPoolAsDependencyAndProcessFirstEventAsSoonAsItIsAvailable)
+-{
+-    auto workHandler1 = createTestWorkHandler();
+-    auto workHandler2 = createTestWorkHandler();
+-    auto delayedEventHandler = createDelayedEventHandler();
+-    m_disruptor->handleEventsWithWorkerPool({ workHandler1, workHandler2 })->then(delayedEventHandler);
+-
+-    publishEvent();
+-    publishEvent();
+-
+-    workHandler1->processEvent();
+-    delayedEventHandler->processEvent();
+-
+-    workHandler2->processEvent();
+-    delayedEventHandler->processEvent();
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldSupportUsingWorkerPoolWithADependency)
+-{
+-    auto workHandler1 = createTestWorkHandler();
+-    auto workHandler2 = createTestWorkHandler();
+-    auto delayedEventHandler = createDelayedEventHandler();
+-    m_disruptor->handleEventsWith(delayedEventHandler)->thenHandleEventsWithWorkerPool({ workHandler1, workHandler2 });
+-
+-    publishEvent();
+-    publishEvent();
+-
+-    delayedEventHandler->processEvent();
+-    delayedEventHandler->processEvent();
+-
+-    workHandler1->processEvent();
+-    workHandler2->processEvent();
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldSupportCombiningWorkerPoolWithEventHandlerAsDependencyWhenNotPreviouslyRegistered)
+-{
+-    auto workHandler1 = createTestWorkHandler();
+-    auto delayedEventHandler1 = createDelayedEventHandler();
+-    auto delayedEventHandler2 = createDelayedEventHandler();
+-    m_disruptor->handleEventsWith(delayedEventHandler1)->And(m_disruptor->handleEventsWithWorkerPool(workHandler1))->then(delayedEventHandler2);
+-
+-    publishEvent();
+-    publishEvent();
+-
+-    delayedEventHandler1->processEvent();
+-    delayedEventHandler1->processEvent();
+-
+-    workHandler1->processEvent();
+-    delayedEventHandler2->processEvent();
+-
+-    workHandler1->processEvent();
+-    delayedEventHandler2->processEvent();
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldThrowTimeoutExceptionIfShutdownDoesNotCompleteNormally)
+-{
+-    auto delayedEventHandler = createDelayedEventHandler();
+-    m_disruptor->handleEventsWith(delayedEventHandler);
+-    publishEvent();
+-
+-    BOOST_CHECK_THROW(m_disruptor->shutdown(std::chrono::seconds(1)), TimeoutException);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldTrackRemainingCapacity)
+-{
+-    std::vector< std::shared_ptr< std::int64_t > > remainingCapacity = { std::make_shared< std::int64_t >(-1) };
+-    auto eventHandler = std::make_shared< TempEventHandler >(m_disruptor, remainingCapacity);
+-
+-    m_disruptor->handleEventsWith(eventHandler);
+-
+-    publishEvent();
+-
+-    while (*remainingCapacity[0] == -1)
+-    {
+-        std::this_thread::sleep_for(std::chrono::milliseconds(100));
+-    }
+-
+-    BOOST_CHECK_EQUAL(*remainingCapacity[0], m_ringBuffer->bufferSize() - 1L);
+-    BOOST_CHECK_EQUAL(m_disruptor->ringBuffer()->getRemainingCapacity(), m_ringBuffer->bufferSize() - 0L);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldAllowEventHandlerWithSuperType)
+-{
+-    auto latch = std::make_shared< CountdownEvent >(2);
+-    auto objectHandler = std::make_shared< EventHandlerStub< TestEvent > >(latch);
+-
+-    m_disruptor->handleEventsWith(objectHandler);
+-
+-    ensureTwoEventsProcessedAccordingToDependencies(latch);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldAllowChainingEventHandlersWithSuperType)
+-{
+-    auto latch = std::make_shared< CountdownEvent >(2);
+-    auto delayedEventHandler = createDelayedEventHandler();
+-    auto objectHandler = std::make_shared< EventHandlerStub< TestEvent > >(latch);
+-
+-    m_disruptor->handleEventsWith(delayedEventHandler)->then(objectHandler);
+-
+-    ensureTwoEventsProcessedAccordingToDependencies(latch, { delayedEventHandler });
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldMakeEntriesAvailableToFirstCustomProcessorsImmediately)
+-{
+-    auto countDownLatch = std::make_shared< CountdownEvent >(2);
+-    auto eventHandler = std::make_shared< EventHandlerStub< TestEvent > >(countDownLatch);
+-
+-    m_disruptor->handleEventsWith(std::make_shared< EventProcessorFactory >(m_disruptor, eventHandler, 0));
+-
+-    ensureTwoEventsProcessedAccordingToDependencies(countDownLatch);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldHonourDependenciesForCustomProcessors)
+-{
+-    auto countDownLatch = std::make_shared< CountdownEvent >(2);
+-    auto eventHandler = std::make_shared< EventHandlerStub< TestEvent > >(countDownLatch);
+-    auto delayedEventHandler = createDelayedEventHandler();
+-
+-    m_disruptor->handleEventsWith(delayedEventHandler)->then(std::make_shared< EventProcessorFactory >(m_disruptor, eventHandler, 1));
+-
+-    ensureTwoEventsProcessedAccordingToDependencies(countDownLatch, { delayedEventHandler });
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/DummySequenceBarrier.cpp b/Disruptor.Tests/DummySequenceBarrier.cpp
+deleted file mode 100644
+index 30779d2..0000000
+--- a/Disruptor.Tests/DummySequenceBarrier.cpp
++++ /dev/null
+@@ -1,38 +0,0 @@
+-#include "stdafx.h"
+-#include "DummySequenceBarrier.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    std::int64_t DummySequenceBarrier::waitFor(std::int64_t)
+-    {
+-        return 0;
+-    }
+-
+-    std::int64_t DummySequenceBarrier::cursor()
+-    {
+-        return 0;
+-    }
+-
+-    bool DummySequenceBarrier::isAlerted()
+-    {
+-        return false;
+-    }
+-
+-    void DummySequenceBarrier::alert()
+-    {
+-    }
+-
+-    void DummySequenceBarrier::clearAlert()
+-    {
+-    }
+-
+-    void DummySequenceBarrier::checkAlert()
+-    {
+-    }
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/DummySequenceBarrier.h b/Disruptor.Tests/DummySequenceBarrier.h
+deleted file mode 100644
+index b15e376..0000000
+--- a/Disruptor.Tests/DummySequenceBarrier.h
++++ /dev/null
+@@ -1,26 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/ISequenceBarrier.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    class DummySequenceBarrier : public ISequenceBarrier
+-    {
+-    public:
+-        std::int64_t waitFor(std::int64_t sequence) override;
+-
+-        std::int64_t cursor() override;
+-
+-        bool isAlerted() override;
+-        void alert() override;
+-
+-        void clearAlert() override;
+-        void checkAlert() override;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/EventHandlerStub.h b/Disruptor.Tests/EventHandlerStub.h
+deleted file mode 100644
+index 06b88ef..0000000
+--- a/Disruptor.Tests/EventHandlerStub.h
++++ /dev/null
+@@ -1,34 +0,0 @@
+-#pragma once
+-
+-#include <memory>
+-
+-#include "Disruptor/IEventHandler.h"
+-
+-#include "Disruptor.TestTools/CountdownEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-    
+-    template <class T>
+-    class EventHandlerStub : public IEventHandler< T >
+-    {
+-    public:
+-        explicit EventHandlerStub(const std::shared_ptr< CountdownEvent >& countDownLatch)
+-            : m_countDownLatch(countDownLatch)
+-        {
+-        }
+-
+-        void onEvent(T& /*data*/, std::int64_t /*sequence*/, bool /*endOfBatch*/) override
+-        {
+-            m_countDownLatch->signal();
+-        }
+-
+-    private:
+-        std::shared_ptr< CountdownEvent > m_countDownLatch;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/EventPollerTests.cpp b/Disruptor.Tests/EventPollerTests.cpp
+deleted file mode 100644
+index 1ab461f..0000000
+--- a/Disruptor.Tests/EventPollerTests.cpp
++++ /dev/null
+@@ -1,112 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "Disruptor/ArgumentOutOfRangeException.h"
+-#include "Disruptor/BusySpinWaitStrategy.h"
+-#include "Disruptor/EventPoller.h"
+-#include "Disruptor/Sequence.h"
+-#include "Disruptor/SleepingWaitStrategy.h"
+-#include "Disruptor/RingBuffer.h"
+-
+-#include "DataProviderMock.h"
+-#include "SequencerMock.h"
+-
+-
+-using namespace Disruptor;
+-using namespace Disruptor::Tests;
+-
+-BOOST_AUTO_TEST_SUITE(EventPollerTests)
+-
+-BOOST_AUTO_TEST_CASE(ShouldPollForEvents)
+-{
+-    typedef std::int32_t TestDataType;
+-
+-    auto pollSequence = std::make_shared< Sequence >();
+-    auto bufferSequence = std::make_shared< Sequence >();
+-    auto gatingSequence = std::make_shared<  Sequence >();
+-
+-    auto sequencerMock = std::make_shared< testing::NiceMock< SequencerMock< TestDataType > > >();
+-
+-    auto handled = false;
+-    auto handler = [&](TestDataType&, std::int64_t, bool) -> bool
+-    {
+-        handled = true;
+-        return false;
+-    };
+-
+-    auto providerMock = std::make_shared< testing::NiceMock< DataProviderMock< TestDataType > > >();
+-    auto poller = EventPoller< TestDataType >::newInstance(providerMock, sequencerMock, pollSequence, bufferSequence, { gatingSequence });
+-    auto event = std::int32_t(42);
+-   
+-    auto states = PollState::Idle;
+-
+-    EXPECT_CALL(*sequencerMock, cursor()).WillRepeatedly(testing::Invoke([&]()
+-    {
+-        switch (states)
+-        {
+-        case PollState::Processing:
+-            return 0L;
+-        case PollState::Gating:
+-            return 0L;
+-        case PollState::Idle:
+-            return -1L;
+-        default:
+-            DISRUPTOR_THROW_ARGUMENT_OUT_OF_RANGE_EXCEPTION(states);
+-        }
+-    }));
+-
+-    EXPECT_CALL(*sequencerMock, getHighestPublishedSequence(0L, -1L)).WillRepeatedly(testing::Return(-1L));
+-    EXPECT_CALL(*sequencerMock, getHighestPublishedSequence(0L, 0L)).WillRepeatedly(testing::Return(0L));
+-
+-    EXPECT_CALL(*providerMock, indexer(0)).WillRepeatedly(testing::ReturnRef(event));
+-
+-    // Initial State - nothing published.
+-    states = PollState::Idle;
+-    BOOST_CHECK_EQUAL(poller->poll(handler), PollState::Idle);
+-
+-    // Publish Event.
+-    states = PollState::Gating;
+-    bufferSequence->incrementAndGet();
+-    BOOST_CHECK_EQUAL(poller->poll(handler), PollState::Gating);
+-
+-    states = PollState::Processing;
+-    gatingSequence->incrementAndGet();
+-    BOOST_CHECK_EQUAL(poller->poll(handler), PollState::Processing);
+-
+-    BOOST_CHECK_EQUAL(handled, true);
+-}
+-
+-
+-BOOST_AUTO_TEST_CASE(ShouldSuccessfullyPollWhenBufferIsFull)
+-{
+-    typedef std::int32_t DataType;
+-
+-    auto handled = 0;
+-    auto handler = [&](std::vector< DataType >&, std::int64_t, bool) -> bool
+-    {
+-        handled++;
+-        return true;
+-    };
+-
+-    auto factory = [] { return std::vector< DataType >(1); };
+-
+-    auto ringBuffer = RingBuffer< std::vector< DataType > >::createMultiProducer(factory, 0x4, std::make_shared< SleepingWaitStrategy >());
+-
+-    auto poller = ringBuffer->newPoller({});
+-    ringBuffer->addGatingSequences({ poller->sequence() });
+-
+-    const auto count = 4;
+-
+-    for (auto i = 1; i <= count; ++i)
+-    {
+-        auto next = ringBuffer->next();
+-        (*ringBuffer)[next][0] = i; //sucks
+-        ringBuffer->publish(next);
+-    }
+-
+-    // think of another thread
+-    poller->poll(handler);
+-
+-    BOOST_CHECK_EQUAL(handled, 4);
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/EventProcessorMock.h b/Disruptor.Tests/EventProcessorMock.h
+deleted file mode 100644
+index 74648c3..0000000
+--- a/Disruptor.Tests/EventProcessorMock.h
++++ /dev/null
+@@ -1,25 +0,0 @@
+-#pragma once
+-
+-#include <gmock/gmock.h>
+-
+-#include "Disruptor/IEventProcessor.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    class EventProcessorMock : public IEventProcessor
+-    {
+-    public:
+-        MOCK_CONST_METHOD0(sequence, std::shared_ptr< ISequence >());
+-
+-        MOCK_METHOD0(halt, void());
+-        MOCK_METHOD0(run, void());
+-
+-        MOCK_CONST_METHOD0(isRunning, bool());
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/EventPublisherTests.cpp b/Disruptor.Tests/EventPublisherTests.cpp
+deleted file mode 100644
+index ddecf87..0000000
+--- a/Disruptor.Tests/EventPublisherTests.cpp
++++ /dev/null
+@@ -1,79 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "Disruptor/NoOpEventProcessor.h"
+-#include "Disruptor/RingBuffer.h"
+-
+-#include "LongEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    struct EventPublisherFixture
+-    {
+-        struct Translator : public IEventTranslator< LongEvent >
+-        {
+-            explicit Translator(EventPublisherFixture&)
+-            {
+-            }
+-
+-            void translateTo(LongEvent& eventData, std::int64_t sequence) override
+-            {
+-                eventData.value = sequence + 29;
+-            }
+-
+-        };
+-
+-        EventPublisherFixture()
+-        {
+-            m_ringBuffer = RingBuffer< LongEvent >::createMultiProducer([]() { return LongEvent(); }, m_bufferSize);
+-            m_translator = std::make_shared< Translator >(*this);
+-        }
+-
+-        const std::int32_t m_bufferSize = 32;
+-        const std::int64_t m_valueAdd = 29L;
+-        std::shared_ptr< RingBuffer< LongEvent > > m_ringBuffer;
+-        std::shared_ptr< Translator > m_translator;
+-    };
+-
+-
+-} // namespace Tests
+-} // namespace Disruptor
+-
+-using namespace Disruptor;
+-using namespace ::Disruptor::Tests;
+-
+-
+-BOOST_FIXTURE_TEST_SUITE(EventPublisherTests, EventPublisherFixture)
+-
+-BOOST_AUTO_TEST_CASE(ShouldPublishEvent)
+-{
+-    m_ringBuffer->addGatingSequences({ std::make_shared< NoOpEventProcessor< LongEvent > >(m_ringBuffer)->sequence() });
+-
+-    m_ringBuffer->publishEvent(m_translator);
+-    m_ringBuffer->publishEvent(m_translator);
+-
+-    BOOST_CHECK_EQUAL(0L + m_valueAdd, (*m_ringBuffer)[0].value);
+-    BOOST_CHECK_EQUAL(1L + m_valueAdd, (*m_ringBuffer)[1].value);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldTryPublishEvent)
+-{
+-    m_ringBuffer->addGatingSequences({ std::make_shared< Sequence >() });
+-
+-    for (auto i = 0; i < m_bufferSize; ++i)
+-    {
+-        BOOST_CHECK_EQUAL(m_ringBuffer->tryPublishEvent(m_translator), true);
+-    }
+-
+-    for (auto i = 0; i < m_bufferSize; ++i)
+-    {
+-        BOOST_CHECK_EQUAL((*m_ringBuffer)[i].value, i + m_valueAdd);
+-    }
+-
+-    BOOST_CHECK_EQUAL(m_ringBuffer->tryPublishEvent(m_translator), false);
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/ExceptionHandlerMock.h b/Disruptor.Tests/ExceptionHandlerMock.h
+deleted file mode 100644
+index e9eeb35..0000000
+--- a/Disruptor.Tests/ExceptionHandlerMock.h
++++ /dev/null
+@@ -1,27 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-#include <memory>
+-
+-#include <gmock/gmock.h>
+-
+-#include "Disruptor/IExceptionHandler.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    template <class T>
+-    class ExceptionHandlerMock : public IExceptionHandler< T >
+-    {
+-    public:
+-        MOCK_METHOD3_T(handleEventException, void(const std::exception&, std::int64_t, T&));
+-        MOCK_METHOD1(handleOnStartException, void(const std::exception&));
+-        MOCK_METHOD1(handleOnShutdownException, void(const std::exception&));
+-        MOCK_METHOD2_T(handleOnTimeoutException, void (const std::exception&, std::int64_t));
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/ExceptionThrowingEventHandler.cpp b/Disruptor.Tests/ExceptionThrowingEventHandler.cpp
+deleted file mode 100644
+index 048b562..0000000
+--- a/Disruptor.Tests/ExceptionThrowingEventHandler.cpp
++++ /dev/null
+@@ -1,21 +0,0 @@
+-#include "stdafx.h"
+-#include "ExceptionThrowingEventHandler.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    ExceptionThrowingEventHandler::ExceptionThrowingEventHandler(const std::exception& applicationException)
+-        : m_applicationException(applicationException)
+-    {
+-    }
+-
+-    void ExceptionThrowingEventHandler::onEvent(TestEvent& /*data*/, std::int64_t /*sequence*/, bool /*endOfBatch*/)
+-    {
+-        throw m_applicationException;
+-    }
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/ExceptionThrowingEventHandler.h b/Disruptor.Tests/ExceptionThrowingEventHandler.h
+deleted file mode 100644
+index 3538bb7..0000000
+--- a/Disruptor.Tests/ExceptionThrowingEventHandler.h
++++ /dev/null
+@@ -1,27 +0,0 @@
+-#pragma once
+-
+-#include <exception>
+-
+-#include "Disruptor/IEventHandler.h"
+-
+-#include "Disruptor.Tests/TestEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    class ExceptionThrowingEventHandler : public IEventHandler< TestEvent >
+-    {
+-    public:
+-        explicit ExceptionThrowingEventHandler(const std::exception& applicationException);
+-
+-        void onEvent(TestEvent& data, std::int64_t sequence, bool endOfBatch) override;
+-
+-    private:
+-        std::exception m_applicationException;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/FatalExceptionHandlerTests.cpp b/Disruptor.Tests/FatalExceptionHandlerTests.cpp
+deleted file mode 100644
+index 5dfbbcc..0000000
+--- a/Disruptor.Tests/FatalExceptionHandlerTests.cpp
++++ /dev/null
+@@ -1,30 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "Disruptor/ArgumentException.h"
+-#include "Disruptor/FatalExceptionHandler.h"
+-#include "StubEvent.h"
+-
+-
+-using namespace Disruptor;
+-
+-
+-BOOST_AUTO_TEST_SUITE(FatalExceptionHandlerTests)
+-
+-BOOST_AUTO_TEST_CASE(ShouldHandleFatalException)
+-{
+-    auto causeException = ArgumentException("FatalExceptionHandlerTests.ShouldHandleFatalException");
+-    auto evt = Tests::StubEvent(0);
+-
+-    auto exceptionHandler = std::make_shared< FatalExceptionHandler< Tests::StubEvent> >();
+-
+-    try
+-    {
+-        exceptionHandler->handleEventException(causeException, 0L, evt);
+-    }
+-    catch (FatalException& ex)
+-    {
+-        BOOST_CHECK_EQUAL(causeException.what(), ex.innerException().what());
+-    }
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+\ No newline at end of file
+diff --git a/Disruptor.Tests/FixedSequenceGroupTest.cpp b/Disruptor.Tests/FixedSequenceGroupTest.cpp
+deleted file mode 100644
+index b8a9790..0000000
+--- a/Disruptor.Tests/FixedSequenceGroupTest.cpp
++++ /dev/null
+@@ -1,25 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "Disruptor/FixedSequenceGroup.h"
+-#include "Disruptor/Sequence.h"
+-
+-
+-using namespace Disruptor;
+-
+-
+-BOOST_AUTO_TEST_SUITE(FixedSequenceGroupTest)
+-
+-BOOST_AUTO_TEST_CASE(ShouldReturnMinimumOf2Sequences)
+-{
+-    auto sequence1 = std::make_shared< Sequence >(34);
+-    auto sequence2 = std::make_shared< Sequence >(47);
+-    FixedSequenceGroup group({ sequence1, sequence2 });
+-
+-    BOOST_CHECK_EQUAL(group.value(), 34L);
+-    sequence1->setValue(35);
+-    BOOST_CHECK_EQUAL(group.value(), 35L);
+-    sequence1->setValue(48);
+-    BOOST_CHECK_EQUAL(group.value(), 47L);
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/IgnoreExceptionHandlerTests.cpp b/Disruptor.Tests/IgnoreExceptionHandlerTests.cpp
+deleted file mode 100644
+index aafd7d9..0000000
+--- a/Disruptor.Tests/IgnoreExceptionHandlerTests.cpp
++++ /dev/null
+@@ -1,23 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "Disruptor/ArgumentException.h"
+-#include "Disruptor/IgnoreExceptionHandler.h"
+-#include "StubEvent.h"
+-
+-
+-using namespace Disruptor;
+-
+-
+-BOOST_AUTO_TEST_SUITE(IgnoreExceptionHandlerTests)
+-
+-BOOST_AUTO_TEST_CASE(ShouldIgnoreException)
+-{
+-    auto causeException = ArgumentException("IgnoreExceptionHandler.ShouldIgnoreException");
+-    auto evt = Tests::StubEvent(0);
+-
+-    auto exceptionHandler = std::make_shared< IgnoreExceptionHandler< Tests::StubEvent> >();
+-
+-    BOOST_CHECK_NO_THROW(exceptionHandler->handleEventException(causeException, 0L, evt));
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/LifecycleAwareEventHandlerMock.h b/Disruptor.Tests/LifecycleAwareEventHandlerMock.h
+deleted file mode 100644
+index 541381e..0000000
+--- a/Disruptor.Tests/LifecycleAwareEventHandlerMock.h
++++ /dev/null
+@@ -1,27 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-#include <memory>
+-
+-#include <gmock/gmock.h>
+-
+-#include "Disruptor/IEventHandler.h"
+-#include "Disruptor/ILifecycleAware.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    template <class T>
+-    class LifecycleAwareEventHandlerMock : public IEventHandler< T >, public ILifecycleAware
+-    {
+-    public:
+-        MOCK_METHOD3_T(onEvent, void(T& data, std::int64_t sequence, bool endOfBatch));
+-        MOCK_METHOD0(onStart, void());
+-        MOCK_METHOD0(onShutdown, void());
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/LifecycleAwareTests.cpp b/Disruptor.Tests/LifecycleAwareTests.cpp
+deleted file mode 100644
+index e7d9040..0000000
+--- a/Disruptor.Tests/LifecycleAwareTests.cpp
++++ /dev/null
+@@ -1,80 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "Disruptor/BatchEventProcessor.h"
+-#include "Disruptor/IEventHandler.h"
+-#include "Disruptor/IgnoreExceptionHandler.h"
+-#include "Disruptor/ILifecycleAware.h"
+-#include "Disruptor/RingBuffer.h"
+-
+-#include "Disruptor.TestTools/ManualResetEvent.h"
+-
+-#include "StubEvent.h"
+-#include "StubExecutor.h"
+-
+-
+-using namespace Disruptor;
+-using namespace ::Disruptor::Tests;
+-
+-
+-BOOST_AUTO_TEST_SUITE(LifecycleAwareTests)
+-
+-class LifecycleAwareEventHandler : public IEventHandler< StubEvent >, public ILifecycleAware
+-{
+-public:
+-
+-    std::int32_t startCounter() const { return m_startCounter; }
+-    std::int32_t shutdownCounter() const { return m_shutdownCounter; }
+-
+-    LifecycleAwareEventHandler(ManualResetEvent& startSignal, ManualResetEvent& shutdownSignal)
+-        : m_startSignal(startSignal)
+-        , m_shutdownSignal(shutdownSignal)
+-        , m_startCounter(0)
+-        , m_shutdownCounter(0)
+-    {}
+-
+-    void onEvent(StubEvent&, std::int64_t, bool) override
+-    {}
+-
+-    void onStart() override
+-    {
+-        ++m_startCounter;
+-        m_startSignal.set();
+-    }
+-
+-    void onShutdown() override
+-    {
+-        ++m_shutdownCounter;
+-        m_shutdownSignal.set();
+-    }
+-
+-private:
+-    ManualResetEvent& m_startSignal;
+-    ManualResetEvent& m_shutdownSignal;
+-    std::int32_t m_startCounter;
+-    std::int32_t m_shutdownCounter;
+-};
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotifyOfBatchProcessorLifecycle)
+-{
+-    ManualResetEvent startSignal(false);
+-    ManualResetEvent shutdownSignal(false);
+-    auto ringBuffer = std::make_shared< RingBuffer< StubEvent > >([] { return StubEvent(0); }, 16);
+-
+-    auto sequenceBarrier = ringBuffer->newBarrier();
+-    auto eventHandler = std::make_shared< LifecycleAwareEventHandler >(startSignal, shutdownSignal);
+-    auto batchEventProcessor = std::make_shared< BatchEventProcessor< StubEvent > >(ringBuffer, sequenceBarrier, eventHandler);
+-
+-    auto thread = std::thread([&] { batchEventProcessor->run(); });
+-
+-    startSignal.waitOne();
+-    batchEventProcessor->halt();
+-
+-    shutdownSignal.waitOne();
+-
+-    thread.join();
+-
+-    BOOST_CHECK_EQUAL(eventHandler->startCounter(), 1);
+-    BOOST_CHECK_EQUAL(eventHandler->shutdownCounter(), 1);
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/LongEvent.h b/Disruptor.Tests/LongEvent.h
+deleted file mode 100644
+index d787a29..0000000
+--- a/Disruptor.Tests/LongEvent.h
++++ /dev/null
+@@ -1,18 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-    
+-    class LongEvent
+-    {
+-    public:
+-        std::int64_t value = 0;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/MultiProducerSequencerTests.cpp b/Disruptor.Tests/MultiProducerSequencerTests.cpp
+deleted file mode 100644
+index e78c8f0..0000000
+--- a/Disruptor.Tests/MultiProducerSequencerTests.cpp
++++ /dev/null
+@@ -1,29 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "Disruptor/BlockingWaitStrategy.h"
+-#include "Disruptor/MultiProducerSequencer.h"
+-
+-
+-using namespace Disruptor;
+-
+-
+-BOOST_AUTO_TEST_SUITE(MultiProducerSequencerTests)
+-
+-BOOST_AUTO_TEST_CASE(ShouldOnlyAllowMessagesToBeAvailableIfSpecificallyPublished)
+-{
+-    auto waitingStrategy = std::make_shared< BlockingWaitStrategy >();
+-    auto publisher = std::make_shared< MultiProducerSequencer< int > >(1024, waitingStrategy);
+-
+-    publisher->publish(3);
+-    publisher->publish(5);
+-
+-    BOOST_CHECK_EQUAL(publisher->isAvailable(0), false);
+-    BOOST_CHECK_EQUAL(publisher->isAvailable(1), false);
+-    BOOST_CHECK_EQUAL(publisher->isAvailable(2), false);
+-    BOOST_CHECK_EQUAL(publisher->isAvailable(3), true );
+-    BOOST_CHECK_EQUAL(publisher->isAvailable(4), false);
+-    BOOST_CHECK_EQUAL(publisher->isAvailable(5), true );
+-    BOOST_CHECK_EQUAL(publisher->isAvailable(6), false);
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/RingBufferTests.cpp b/Disruptor.Tests/RingBufferTests.cpp
+deleted file mode 100644
+index 380ee09..0000000
+--- a/Disruptor.Tests/RingBufferTests.cpp
++++ /dev/null
+@@ -1,740 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "Disruptor.TestTools/ManualResetEvent.h"
+-
+-#include "RingBufferTestsFixture.h"
+-
+-
+-using namespace Disruptor;
+-using namespace Disruptor::Tests;
+-
+-
+-BOOST_FIXTURE_TEST_SUITE(RingBufferTests, RingBufferTestsFixture)
+-
+-BOOST_AUTO_TEST_CASE(ShouldClaimAndGet)
+-{
+-    BOOST_CHECK_EQUAL(Sequence::InitialCursorValue, m_ringBuffer->cursor());
+-    
+-    auto expectedEvent = StubEvent(2701);
+-
+-    auto claimSequence = m_ringBuffer->next();
+-    auto& oldEvent = (*m_ringBuffer)[claimSequence];
+-    oldEvent.copy(expectedEvent);
+-    m_ringBuffer->publish(claimSequence);
+-
+-    auto sequence = m_sequenceBarrier->waitFor(0);
+-    BOOST_CHECK_EQUAL(0, sequence);
+-
+-    auto& evt = (*m_ringBuffer)[sequence];
+-    BOOST_CHECK_EQUAL(expectedEvent, evt);
+-    
+-    BOOST_CHECK_EQUAL(0L, m_ringBuffer->cursor());
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldClaimAndGetInSeparateThread)
+-{
+-    auto events = getEvents(0, 0);
+-
+-    auto expectedEvent = StubEvent(2701);
+-
+-    auto sequence = m_ringBuffer->next();
+-    auto& oldEvent = (*m_ringBuffer)[sequence];
+-    oldEvent.copy(expectedEvent);
+-    m_ringBuffer->publishEvent(StubEvent::translator(), expectedEvent.value(), expectedEvent.testString());
+-
+-    BOOST_CHECK_EQUAL(expectedEvent, events.get()[0]);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldClaimAndGetMultipleMessages)
+-{
+-    auto numEvents = m_ringBuffer->bufferSize();
+-    for (auto i = 0; i < numEvents; ++i)
+-    {
+-        m_ringBuffer->publishEvent(StubEvent::translator(), i, std::string());
+-    }
+-
+-    auto expectedSequence = numEvents - 1;
+-    auto available = m_sequenceBarrier->waitFor(expectedSequence);
+-    BOOST_CHECK_EQUAL(expectedSequence, available);
+-
+-    for (auto i = 0; i < numEvents; ++i)
+-    {
+-        BOOST_CHECK_EQUAL(i, (*m_ringBuffer)[i].value());
+-    }
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldWrap)
+-{
+-    auto numEvents = m_ringBuffer->bufferSize();
+-    auto offset = 1000;
+-    for (auto i = 0; i < numEvents + offset; ++i)
+-    {
+-        m_ringBuffer->publishEvent(StubEvent::translator(), i, std::string());
+-    }
+-
+-    auto expectedSequence = numEvents + offset - 1;
+-    auto available = m_sequenceBarrier->waitFor(expectedSequence);
+-    BOOST_CHECK_EQUAL(expectedSequence, available);
+-
+-    for (auto i = offset; i < numEvents + offset; ++i)
+-    {
+-        BOOST_CHECK_EQUAL(i, (*m_ringBuffer)[i].value());
+-    }
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldPreventWrapping)
+-{
+-    auto sequence = std::make_shared< Sequence >(Sequence::InitialCursorValue);
+-    auto ringBuffer = RingBuffer< StubEvent >::createMultiProducer([] { return StubEvent(-1); }, 4);
+-    ringBuffer->addGatingSequences({ sequence });
+-
+-    ringBuffer->publishEvent(StubEvent::translator(), 0, std::string("0"));
+-    ringBuffer->publishEvent(StubEvent::translator(), 1, std::string("1"));
+-    ringBuffer->publishEvent(StubEvent::translator(), 2, std::string("2"));
+-    ringBuffer->publishEvent(StubEvent::translator(), 3, std::string("3"));
+-
+-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvent(StubEvent::translator(), 3, std::string("3")), false);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldThrowExceptionIfBufferIsFull)
+-{
+-    m_ringBuffer->addGatingSequences({ std::make_shared< Sequence >(m_ringBuffer->bufferSize()) });
+-
+-    try
+-    {
+-        for (auto i = 0; i < m_ringBuffer->bufferSize(); ++i)
+-        {
+-            m_ringBuffer->publish(m_ringBuffer->tryNext());
+-        }
+-    }
+-    catch (std::exception&)
+-    {
+-        throw std::logic_error("Should not have thrown exception");
+-    }
+-
+-    try
+-    {
+-        m_ringBuffer->tryNext();
+-        throw std::logic_error("Exception should have been thrown");
+-    }
+-    catch (InsufficientCapacityException&)
+-    {
+-    }
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldPreventProducersOvertakingEventProcessorsWrapPoint)
+-{
+-    auto ringBufferSize = 4;
+-    ManualResetEvent mre(false);
+-    auto producerComplete = false;
+-    auto ringBuffer = std::make_shared< RingBuffer< StubEvent > >([] { return StubEvent(-1); }, ringBufferSize);
+-    auto processor = std::make_shared< TestEventProcessor >(ringBuffer->newBarrier());
+-    ringBuffer->addGatingSequences({ processor->sequence() });
+-
+-    std::thread thread([&]
+-    {
+-        for (auto i = 0; i <= ringBufferSize; i++) // produce 5 events
+-        {
+-            auto sequence = ringBuffer->next();
+-            auto& evt = (*ringBuffer)[sequence];
+-            evt.value(i);
+-            ringBuffer->publish(sequence);
+-        
+-            if (i == 3) // unblock main thread after 4th eventData published
+-            {
+-                mre.set();
+-            }
+-        }
+-        
+-        producerComplete = true;
+-    });
+-
+-    mre.waitOne();
+-
+-    BOOST_CHECK_EQUAL(ringBuffer->cursor(), ringBufferSize - 1);
+-    BOOST_CHECK_EQUAL(producerComplete, false);
+-
+-    processor->run();
+-
+-    if (thread.joinable())
+-        thread.join();
+-
+-    BOOST_CHECK_EQUAL(producerComplete, true);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldPublishEvent)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< NoArgEventTranslator >();
+-
+-    ringBuffer->publishEvent(translator);
+-    ringBuffer->tryPublishEvent(translator);
+-
+-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents(0, 1), *ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldPublishEventOneArg)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< OneArgEventTranslator >();
+-    
+-    ringBuffer->publishEvent(translator, std::string("Foo"));
+-    ringBuffer->tryPublishEvent(translator, std::string("Foo"));
+-
+-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents(std::string("Foo-0"), std::string("Foo-1")), *ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldPublishEventTwoArg)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< TwoArgEventTranslator >();
+-
+-    ringBuffer->publishEvent(translator, std::string("Foo"), std::string("Bar"));
+-    ringBuffer->tryPublishEvent(translator, std::string("Foo"), std::string("Bar"));
+-
+-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents(std::string("FooBar-0"), std::string("FooBar-1")), *ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldPublishEventThreeArg)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< ThreeArgEventTranslator >();
+-
+-    ringBuffer->publishEvent(translator, std::string("Foo"), std::string("Bar"), std::string("Baz"));
+-    ringBuffer->tryPublishEvent(translator, std::string("Foo"), std::string("Bar"), std::string("Baz"));
+-
+-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents(std::string("FooBarBaz-0"), std::string("FooBarBaz-1")), *ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldPublishEvents)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto eventTranslator = std::make_shared< NoArgEventTranslator >();
+-    auto translators = { eventTranslator, eventTranslator };
+-
+-    ringBuffer->publishEvents(translators);
+-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translators), true);
+-
+-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(0, 1, 2, 3), *ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsIfBatchIsLargerThanRingBuffer)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto eventTranslator = std::make_shared< NoArgEventTranslator >();
+-    auto translators = { eventTranslator, eventTranslator, eventTranslator, eventTranslator, eventTranslator };
+-
+-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translators), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldPublishEventsWithBatchSizeOfOne)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto eventTranslator = std::make_shared< NoArgEventTranslator >();
+-    auto translators = { eventTranslator, eventTranslator, eventTranslator };
+-
+-    ringBuffer->publishEvents(translators, 0, 1);
+-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translators, 0, 1), true);
+-
+-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(0, 1, boost::any(), boost::any()), *ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldPublishEventsWithinBatch)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto eventTranslator = std::make_shared< NoArgEventTranslator >();
+-    auto translators = { eventTranslator, eventTranslator, eventTranslator };
+-
+-    ringBuffer->publishEvents(translators, 1, 2);
+-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translators, 1, 2), true);
+-
+-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(0, 1, 2, 3), *ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldPublishEventsOneArg)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< OneArgEventTranslator >();
+-
+-    ringBuffer->publishEvents(translator, { std::string("Foo"), std::string("Foo") });
+-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translator, { std::string("Foo"), std::string("Foo") }), true);
+-
+-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(std::string("Foo-0"), std::string("Foo-1"), std::string("Foo-2"), std::string("Foo-3")), *ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsOneArgIfBatchIsLargerThanRingBuffer)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< OneArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, { std::string("Foo"), std::string("Foo"), std::string("Foo"), std::string("Foo"), std::string("Foo") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldPublishEventsOneArgBatchSizeOfOne)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< OneArgEventTranslator >();
+-
+-    ringBuffer->publishEvents(translator, 0, 1, { std::string("Foo"), std::string("Foo") });
+-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translator, 0, 1, { std::string("Foo"), std::string("Foo") }), true);
+-
+-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(std::string("Foo-0"), std::string("Foo-1"), boost::any(), boost::any()), *ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldPublishEventsOneArgWithinBatch)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< OneArgEventTranslator >();
+-
+-    ringBuffer->publishEvents(translator, 1, 2, { std::string("Foo"), std::string("Foo"), std::string("Foo") });
+-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translator, 1, 2, { std::string("Foo"), std::string("Foo"), std::string("Foo") }), true);
+-
+-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(std::string("Foo-0"), std::string("Foo-1"), std::string("Foo-2"), std::string("Foo-3")), *ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldPublishEventsTwoArg)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< TwoArgEventTranslator >();
+-
+-    ringBuffer->publishEvents(translator, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") });
+-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translator, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }), true);
+-
+-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(std::string("FooBar-0"), std::string("FooBar-1"), std::string("FooBar-2"), std::string("FooBar-3")), *ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsITwoArgIfBatchSizeIsBiggerThanRingBuffer)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< TwoArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents
+-    (
+-        translator,
+-        { std::string("Foo"), std::string("Foo"), std::string("Foo"), std::string("Foo"), std::string("Foo") },
+-        { std::string("Bar"), std::string("Bar"), std::string("Bar"), std::string("Bar"), std::string("Bar") }
+-    ), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldPublishEventsTwoArgWithBatchSizeOfOne)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< TwoArgEventTranslator >();
+-
+-    ringBuffer->publishEvents(translator, 0, 1, { std::string("Foo0"), std::string("Foo1") }, { std::string("Bar0"), std::string("Bar1") });
+-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translator, 0, 1, { std::string("Foo2"), std::string("Foo3") }, { std::string("Bar2"), std::string("Bar3") }), true);
+-
+-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(std::string("Foo0Bar0-0"), std::string("Foo2Bar2-1"), boost::any(), boost::any()), *ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldPublishEventsTwoArgWithinBatch)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< TwoArgEventTranslator >();
+-
+-    ringBuffer->publishEvents(translator, 1, 2, { std::string("Foo0"), std::string("Foo1"), std::string("Foo2") }, { std::string("Bar0"), std::string("Bar1"), std::string("Bar2") });
+-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translator, 1, 2, { std::string("Foo3"), std::string("Foo4"), std::string("Foo5") }, { std::string("Bar3"), std::string("Bar4"), std::string("Bar5") }), true);
+-
+-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(std::string("Foo1Bar1-0"), std::string("Foo2Bar2-1"), std::string("Foo4Bar4-2"), std::string("Foo5Bar5-3")), *ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldPublishEventsThreeArg)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< ThreeArgEventTranslator >();
+-
+-    ringBuffer->publishEvents(translator, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }, { std::string("Baz"), std::string("Baz") });
+-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translator, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }, { std::string("Baz"), std::string("Baz") }), true);
+-
+-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(std::string("FooBarBaz-0"), std::string("FooBarBaz-1"), std::string("FooBarBaz-2"), std::string("FooBarBaz-3")), *ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsThreeArgIfBatchIsLargerThanRingBuffer)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< ThreeArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents
+-    (
+-        translator,
+-        { std::string("Foo"), std::string("Foo"), std::string("Foo"), std::string("Foo"), std::string("Foo") },
+-        { std::string("Bar"), std::string("Bar"), std::string("Bar"), std::string("Bar"), std::string("Bar") },
+-        { std::string("Baz"), std::string("Baz"), std::string("Baz"), std::string("Baz"), std::string("Baz") }
+-    ), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldPublishEventsThreeArgBatchSizeOfOne)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< ThreeArgEventTranslator >();
+-
+-    ringBuffer->publishEvents(translator, 0, 1, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }, { std::string("Baz"), std::string("Baz") });
+-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translator, 0, 1, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }, { std::string("Baz"), std::string("Baz") }), true);
+-
+-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(std::string("FooBarBaz-0"), std::string("FooBarBaz-1"), boost::any(), boost::any()), *ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldPublishEventsThreeArgWithinBatch)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< ThreeArgEventTranslator >();
+-
+-    ringBuffer->publishEvents(translator, 1, 2, { std::string("Foo0"), std::string("Foo1"), std::string("Foo2") },
+-                                                { std::string("Bar0"), std::string("Bar1"), std::string("Bar2") },
+-                                                { std::string("Baz0"), std::string("Baz1"), std::string("Baz2") });
+-    
+-    BOOST_CHECK_EQUAL(ringBuffer->tryPublishEvents(translator, 1, 2, { std::string("Foo3"), std::string("Foo4"), std::string("Foo5") },
+-                                                                     { std::string("Bar3"), std::string("Bar4"), std::string("Bar5") },
+-                                                                     { std::string("Baz3"), std::string("Baz4"), std::string("Baz5") }), true);
+-
+-    BOOST_CHECK_EQUAL(m_ringBufferWithEvents4(std::string("Foo1Bar1Baz1-0"), std::string("Foo2Bar2Baz2-1"), std::string("Foo4Bar4Baz4-2"), std::string("Foo5Bar5Baz5-3")), *ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsWhenBatchSizeIs0)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< NoArgEventTranslator >();
+-    auto translators = { translator, translator, translator, translator };
+-
+-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translators, 1, 0), ArgumentException);
+-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translators, 1, 0), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsWhenBatchExtendsPastEndOfArray)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< NoArgEventTranslator >();
+-    auto translators = { translator, translator, translator };
+-
+-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translators, 1, 3), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsWhenBatchExtendsPastEndOfArray)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< NoArgEventTranslator >();
+-    auto translators = { translator, translator, translator };
+-
+-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translators, 1, 3), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsWhenBatchSizeIsNegative)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< NoArgEventTranslator >();
+-    auto translators = { translator, translator, translator, translator };
+-
+-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translators, 1, -1), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsWhenBatchSizeIsNegative)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< NoArgEventTranslator >();
+-    auto translators = { translator, translator, translator, translator };
+-
+-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translators, 1, -1), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsWhenBatchStartsAtIsNegative)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< NoArgEventTranslator >();
+-    auto translators = { translator, translator, translator, translator };
+-
+-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translators, -1, 2), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsWhenBatchStartsAtIsNegative)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< NoArgEventTranslator >();
+-    auto translators = { translator, translator, translator, translator };
+-
+-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translators, -1, 2), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsOneArgWhenBatchSizeIs0)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< OneArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, 1, 0, { std::string("Foo"), std::string("Foo") }), ArgumentException);
+-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, 1, 0, { std::string("Foo"), std::string("Foo") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsOneArgWhenBatchExtendsPastEndOfArray)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< OneArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, 1, 3, { std::string("Foo"), std::string("Foo") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsOneArgWhenBatchSizeIsNegative)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< OneArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, 1, -1, { std::string("Foo"), std::string("Foo") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsOneArgWhenBatchStartsAtIsNegative)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< OneArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, -1, 2, { std::string("Foo"), std::string("Foo") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsOneArgWhenBatchExtendsPastEndOfArray)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< OneArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, 1, 3, { std::string("Foo"), std::string("Foo") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsOneArgWhenBatchSizeIsNegative)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< OneArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, 1, -1, { std::string("Foo"), std::string("Foo") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsOneArgWhenBatchStartsAtIsNegative)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< OneArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, -1, 2, { std::string("Foo"), std::string("Foo") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsTwoArgWhenBatchSizeIs0)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< TwoArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, 1, 0, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }), ArgumentException);
+-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, 1, 0, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsTwoArgWhenBatchExtendsPastEndOfArray)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< TwoArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, 1, 3, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsTwoArgWhenBatchSizeIsNegative)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< TwoArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, 1, -1, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsTwoArgWhenBatchStartsAtIsNegative)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< TwoArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, -1, 2, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsTwoArgWhenBatchExtendsPastEndOfArray)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< TwoArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, 1, 3, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsTwoArgWhenBatchSizeIsNegative)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< TwoArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, 1, -1, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsTwoArgWhenBatchStartsAtIsNegative)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< TwoArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, -1, 2, { std::string("Foo"), std::string("Foo") }, { std::string("Bar"), std::string("Bar") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsThreeArgWhenBatchSizeIs0)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< ThreeArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, 1, 0, { std::string("Foo"), std::string("Foo") },
+-                                                                  { std::string("Bar"), std::string("Bar") },
+-                                                                  { std::string("Baz"), std::string("Baz") }), ArgumentException);
+-
+-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, 1, 0, { std::string("Foo"), std::string("Foo") },
+-                                                                     { std::string("Bar"), std::string("Bar") },
+-                                                                     { std::string("Baz"), std::string("Baz") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsThreeArgWhenBatchExtendsPastEndOfArray)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< ThreeArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, 1, 3, { std::string("Foo"), std::string("Foo") },
+-                                                                  { std::string("Bar"), std::string("Bar") },
+-                                                                  { std::string("Baz"), std::string("Baz") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsThreeArgWhenBatchSizeIsNegative)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< ThreeArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, 1, -1, { std::string("Foo"), std::string("Foo") },
+-                                                                   { std::string("Bar"), std::string("Bar") },
+-                                                                   { std::string("Baz"), std::string("Baz") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotPublishEventsThreeArgWhenBatchStartsAtIsNegative)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< ThreeArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->publishEvents(translator, -1, 2, { std::string("Foo"), std::string("Foo") },
+-                                                                   { std::string("Bar"), std::string("Bar") },
+-                                                                   { std::string("Baz"), std::string("Baz") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsThreeArgWhenBatchExtendsPastEndOfArray)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< ThreeArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, 1, 3, { std::string("Foo"), std::string("Foo") },
+-                                                                     { std::string("Bar"), std::string("Bar") },
+-                                                                     { std::string("Baz"), std::string("Baz") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsThreeArgWhenBatchSizeIsNegative)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< ThreeArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, 1, -1, { std::string("Foo"), std::string("Foo") },
+-                                                                      { std::string("Bar"), std::string("Bar") },
+-                                                                      { std::string("Baz"), std::string("Baz") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldNotTryPublishEventsThreeArgWhenBatchStartsAtIsNegative)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 4);
+-    auto translator = std::make_shared< ThreeArgEventTranslator >();
+-
+-    BOOST_CHECK_THROW(ringBuffer->tryPublishEvents(translator, -1, 2, { std::string("Foo"), std::string("Foo") },
+-                                                                      { std::string("Bar"), std::string("Bar") },
+-                                                                      { std::string("Baz"), std::string("Baz") }), ArgumentException);
+-
+-    assertEmptyRingBuffer(*ringBuffer);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldAddAndRemoveSequences)
+-{
+-    auto ringBuffer = RingBuffer< boost::any >::createSingleProducer([] { return boost::any(); }, 16);
+-    auto sequenceThree = std::make_shared< Sequence >(-1);
+-    auto sequenceSeven = std::make_shared< Sequence >(-1);
+-
+-    ringBuffer->addGatingSequences({ sequenceThree, sequenceSeven });
+-
+-    for (auto i = 0; i < 10; i++)
+-    {
+-        ringBuffer->publish(ringBuffer->next());
+-    }
+-    
+-    sequenceThree->setValue(3);
+-    sequenceSeven->setValue(7);
+-    
+-    BOOST_CHECK_EQUAL(ringBuffer->getMinimumGatingSequence(), 3L);
+-    BOOST_CHECK_EQUAL(ringBuffer->removeGatingSequence(sequenceThree), true);
+-    BOOST_CHECK_EQUAL(ringBuffer->getMinimumGatingSequence(), 7L);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldHandleResetToAndNotWrapUnecessarilySingleProducer)
+-{
+-    assertHandleResetAndNotWrap(RingBuffer< StubEvent >::createSingleProducer(StubEvent::eventFactory(), 4));
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldHandleResetToAndNotWrapUnecessarilyMultiProducer)
+-{
+-    assertHandleResetAndNotWrap(RingBuffer< StubEvent >::createMultiProducer(StubEvent::eventFactory(), 4));
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/RingBufferTestsFixture.cpp b/Disruptor.Tests/RingBufferTestsFixture.cpp
+deleted file mode 100644
+index 7935b21..0000000
+--- a/Disruptor.Tests/RingBufferTestsFixture.cpp
++++ /dev/null
+@@ -1,189 +0,0 @@
+-#include "stdafx.h"
+-#include "RingBufferTestsFixture.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    RingBufferTestsFixture::RingBufferTestsFixture()
+-    {
+-        m_ringBuffer = RingBuffer< StubEvent >::createMultiProducer([] { return StubEvent(-1); }, 32);
+-        m_sequenceBarrier = m_ringBuffer->newBarrier();
+-
+-        auto processor = std::make_shared< NoOpEventProcessor< StubEvent > >(m_ringBuffer);
+-        m_ringBuffer->addGatingSequences({processor->sequence()});
+-    }
+-
+-    std::future< std::vector< StubEvent > > RingBufferTestsFixture::getEvents(std::int64_t initial, std::int64_t toWaitFor)
+-    {
+-        auto barrier = std::make_shared< boost::barrier >(2);
+-        auto dependencyBarrier = m_ringBuffer->newBarrier();
+-
+-        auto testWaiter = std::make_shared< TestWaiter >(barrier, dependencyBarrier, m_ringBuffer, initial, toWaitFor);
+-        auto task = std::async(std::launch::async, [=] { return testWaiter->call(); });
+-
+-        barrier->wait();
+-
+-        return task;
+-    }
+-
+-    void RingBufferTestsFixture::assertHandleResetAndNotWrap(const std::shared_ptr< RingBuffer< StubEvent > >& rb)
+-    {
+-        auto sequence = std::make_shared< Sequence >();
+-        rb->addGatingSequences({sequence});
+-
+-        for (auto i = 0; i < 128; ++i)
+-        {
+-            rb->publish(rb->next());
+-            sequence->incrementAndGet();
+-        }
+-
+-        BOOST_CHECK_EQUAL(rb->cursor(), 127L);
+-
+-        rb->resetTo(31);
+-        sequence->setValue(31);
+-
+-        for (auto i = 0; i < 4; ++i)
+-        {
+-            rb->publish(rb->next());
+-        }
+-
+-        BOOST_CHECK_EQUAL(rb->hasAvailableCapacity(1), false);
+-    }
+-
+-    void RingBufferTestsFixture::assertEmptyRingBuffer(const RingBuffer< boost::any >& ringBuffer)
+-    {
+-        BOOST_CHECK_EQUAL(ringBuffer[0].empty(), true);
+-        BOOST_CHECK_EQUAL(ringBuffer[1].empty(), true);
+-        BOOST_CHECK_EQUAL(ringBuffer[2].empty(), true);
+-        BOOST_CHECK_EQUAL(ringBuffer[3].empty(), true);
+-    }
+-
+-    void RingBufferTestsFixture::NoArgEventTranslator::translateTo(boost::any& eventData, std::int64_t sequence)
+-    {
+-        eventData = static_cast< int >(sequence);
+-    }
+-
+-    void RingBufferTestsFixture::ThreeArgEventTranslator::translateTo(boost::any& eventData, std::int64_t sequence, const std::string& arg0, const std::string& arg1, const std::string& arg2)
+-    {
+-        eventData = arg0 + arg1 + arg2 + "-" + std::to_string(sequence);
+-    }
+-
+-    void RingBufferTestsFixture::TwoArgEventTranslator::translateTo(boost::any& eventData, std::int64_t sequence, const std::string& arg0, const std::string& arg1)
+-    {
+-        eventData = arg0 + arg1 + "-" + std::to_string(sequence);
+-    }
+-
+-    void RingBufferTestsFixture::OneArgEventTranslator::translateTo(boost::any& eventData, std::int64_t sequence, const std::string& arg0)
+-    {
+-        eventData = arg0 + "-" + std::to_string(sequence);
+-    }
+-
+-    RingBufferTestsFixture::TestEventProcessor::TestEventProcessor(const std::shared_ptr< ISequenceBarrier >& sequenceBarrier)
+-        : m_sequenceBarrier(sequenceBarrier)
+-        , m_sequence(std::make_shared< Sequence >())
+-    {
+-    }
+-
+-    std::shared_ptr< ISequence > RingBufferTestsFixture::TestEventProcessor::sequence() const
+-    {
+-        return m_sequence;
+-    }
+-
+-    void RingBufferTestsFixture::TestEventProcessor::halt()
+-    {
+-        m_isRunning = false;
+-    }
+-
+-    void RingBufferTestsFixture::TestEventProcessor::run()
+-    {
+-        m_isRunning = true;
+-        m_sequenceBarrier->waitFor(0L);
+-        m_sequence->setValue(m_sequence->value() + 1);
+-    }
+-
+-    bool RingBufferTestsFixture::TestEventProcessor::isRunning() const
+-    {
+-        return m_isRunning;
+-    }
+-
+-    RingBufferTestsFixture::RingBufferEquals::RingBufferEquals(const std::initializer_list< boost::any >& values)
+-        : m_values(values)
+-    {
+-    }
+-
+-    bool RingBufferTestsFixture::RingBufferEquals::operator==(const RingBuffer< boost::any >& ringBuffer) const
+-    {
+-        auto valid = true;
+-        for (auto i = 0u; i < m_values.size(); ++i)
+-        {
+-            auto value = m_values[i];
+-            valid &= value.empty() || anyEqual(ringBuffer[i], value);
+-        }
+-        return valid;
+-    }
+-
+-    void RingBufferTestsFixture::RingBufferEquals::writeDescriptionTo(std::ostream& stream) const
+-    {
+-        auto firstItem = true;
+-        for (auto&& value : m_values)
+-        {
+-            if (firstItem)
+-                firstItem = false;
+-            else
+-                stream << ", ";
+-
+-            stream << anyToString(value);
+-        }
+-    }
+-
+-    bool RingBufferTestsFixture::RingBufferEquals::anyEqual(const boost::any& lhs, const boost::any& rhs)
+-    {
+-        if (lhs.empty() && rhs.empty())
+-            return true;
+-
+-        if (lhs.empty() || rhs.empty())
+-            return false;
+-
+-        if (lhs.type() != rhs.type())
+-            return false;
+-
+-        if (lhs.type() == typeid(std::string))
+-            return boost::any_cast< std::string >(lhs) == boost::any_cast< std::string >(rhs);
+-
+-        if (lhs.type() == typeid(int))
+-            return boost::any_cast< int >(lhs) == boost::any_cast< int >(rhs);
+-
+-        throw std::runtime_error("comparison of any unimplemented for type");
+-    }
+-
+-    std::string RingBufferTestsFixture::RingBufferEquals::anyToString(const boost::any& value)
+-    {
+-        if (value.empty())
+-            return "";
+-
+-        if (value.type() == typeid(std::string))
+-            return boost::any_cast< std::string >(value);
+-
+-        if (value.type() == typeid(int))
+-            return std::to_string(boost::any_cast< int >(value));
+-
+-        throw std::runtime_error("cannot get string representation of unimplemented any type");
+-    }
+-
+-} // namespace Tests
+-} // namespace Disruptor
+-
+-
+-namespace std
+-{
+-
+-    ostream& operator<<(ostream& stream, const Disruptor::Tests::RingBufferTestsFixture::RingBufferEquals& equals)
+-    {
+-        equals.writeDescriptionTo(stream);
+-        return stream;
+-    }
+-
+-} // namespace std
+diff --git a/Disruptor.Tests/RingBufferTestsFixture.h b/Disruptor.Tests/RingBufferTestsFixture.h
+deleted file mode 100644
+index 107b301..0000000
+--- a/Disruptor.Tests/RingBufferTestsFixture.h
++++ /dev/null
+@@ -1,128 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-#include <future>
+-#include <memory>
+-#include <ostream>
+-#include <vector>
+-
+-#include <boost/any.hpp>
+-#include <boost/test/unit_test.hpp>
+-
+-#include "Disruptor/IEventTranslator.h"
+-#include "Disruptor/IEventTranslatorVararg.h"
+-#include "Disruptor/NoOpEventProcessor.h"
+-#include "Disruptor/RingBuffer.h"
+-
+-#include "Disruptor.Tests/StubEvent.h"
+-#include "Disruptor.Tests/TestWaiter.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    struct RingBufferTestsFixture
+-    {
+-        class NoArgEventTranslator;
+-        class OneArgEventTranslator;
+-        class TestEventProcessor;
+-        class ThreeArgEventTranslator;
+-        class TwoArgEventTranslator;
+-
+-        RingBufferTestsFixture();
+-
+-        std::future< std::vector< StubEvent > > getEvents(std::int64_t initial, std::int64_t toWaitFor);
+-
+-        void assertHandleResetAndNotWrap(const std::shared_ptr< RingBuffer< StubEvent > >& rb);
+-
+-        static void assertEmptyRingBuffer(const RingBuffer< boost::any >& ringBuffer);
+-
+-
+-        class RingBufferEquals
+-        {
+-        public:
+-            RingBufferEquals(const std::initializer_list< boost::any >& values);
+-
+-            bool operator==(const RingBuffer< boost::any >& ringBuffer) const;
+-
+-            void writeDescriptionTo(std::ostream& stream) const;
+-
+-        private:
+-            // http://stackoverflow.com/questions/6029092/compare-boostany-contents
+-            static bool anyEqual(const boost::any& lhs, const boost::any& rhs);
+-
+-            static std::string anyToString(const boost::any& value);
+-
+-            std::vector< boost::any > m_values;
+-        };
+-
+-
+-        std::shared_ptr< RingBuffer< StubEvent > > m_ringBuffer;
+-        std::shared_ptr< ISequenceBarrier > m_sequenceBarrier;
+-
+-        std::function< RingBufferEquals(const boost::any&, const boost::any&) > m_ringBufferWithEvents =
+-            [](const boost::any& l1, const boost::any& l2) { return RingBufferEquals({ l1, l2 }); };
+-
+-        std::function< RingBufferEquals(const boost::any&, const boost::any&, const boost::any&, const boost::any&) > m_ringBufferWithEvents4 =
+-            [](const boost::any& l1, const boost::any& l2, const boost::any& l3, const boost::any& l4) { return RingBufferEquals({ l1, l2, l3, l4 }); };
+-    };
+-
+-
+-    class RingBufferTestsFixture::NoArgEventTranslator : public IEventTranslator< boost::any >
+-    {
+-    public:
+-        void translateTo(boost::any& eventData, std::int64_t sequence) override;
+-    };
+-
+-
+-    class RingBufferTestsFixture::ThreeArgEventTranslator : public IEventTranslatorVararg< boost::any, std::string, std::string, std::string >
+-    {
+-    public:
+-        void translateTo(boost::any& eventData, std::int64_t sequence, const std::string& arg0, const std::string& arg1, const std::string& arg2) override;
+-    };
+-    
+-    
+-    class RingBufferTestsFixture::TwoArgEventTranslator : public IEventTranslatorVararg< boost::any, std::string, std::string >
+-    {
+-    public:
+-        void translateTo(boost::any& eventData, std::int64_t sequence, const std::string& arg0, const std::string& arg1) override;
+-    };
+-    
+-    
+-    class RingBufferTestsFixture::OneArgEventTranslator : public IEventTranslatorVararg< boost::any, std::string >
+-    {
+-    public:
+-        void translateTo(boost::any& eventData, std::int64_t sequence, const std::string& arg0) override;
+-    };
+-    
+-    
+-    class RingBufferTestsFixture::TestEventProcessor : public IEventProcessor
+-    {
+-    public:
+-        explicit TestEventProcessor(const std::shared_ptr< ISequenceBarrier >& sequenceBarrier);
+-
+-        std::shared_ptr< ISequence > sequence() const override;
+-
+-        void halt() override;
+-
+-        void run() override;
+-
+-        bool isRunning() const override;
+-
+-    private:
+-        std::shared_ptr< ISequenceBarrier > m_sequenceBarrier;
+-        std::shared_ptr< ISequence > m_sequence;
+-        bool m_isRunning = false;
+-    };
+-        
+-} // namespace Tests
+-} // namespace Disruptor
+-
+-
+-namespace std
+-{
+-    ostream& operator<<(ostream& stream, const Disruptor::Tests::RingBufferTestsFixture::RingBufferEquals& equals);
+-
+-} // namespace std
+diff --git a/Disruptor.Tests/RingBufferWithMocksTest.cpp b/Disruptor.Tests/RingBufferWithMocksTest.cpp
+deleted file mode 100644
+index 4f3db0d..0000000
+--- a/Disruptor.Tests/RingBufferWithMocksTest.cpp
++++ /dev/null
+@@ -1,73 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "Disruptor/RingBuffer.h"
+-#include "SequencerMock.h"
+-#include "StubEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    struct RingBufferWithMocksFixture
+-    {
+-        RingBufferWithMocksFixture()
+-        {
+-            m_sequencerMock = std::make_shared< testing::NiceMock< SequencerMock< StubEvent > > >();
+-            m_sequencer = m_sequencerMock;
+-
+-            ON_CALL(*m_sequencerMock, bufferSize()).WillByDefault(testing::Return(16));
+-            m_ringBuffer = std::make_shared< RingBuffer< StubEvent > >(StubEvent::eventFactory(), m_sequencer);
+-        }
+-        
+-        std::shared_ptr< RingBuffer< StubEvent > > m_ringBuffer;
+-        std::shared_ptr< ISequencer< StubEvent > > m_sequencer;
+-        std::shared_ptr< SequencerMock< StubEvent > > m_sequencerMock;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+-
+-
+-using namespace Disruptor;
+-using namespace Disruptor::Tests;
+-
+-
+-BOOST_FIXTURE_TEST_SUITE(RingBufferWithMocksTest, RingBufferWithMocksFixture)
+-
+-BOOST_AUTO_TEST_CASE(ShouldDelgateNextAndPublish)
+-{
+-    EXPECT_CALL(*m_sequencerMock, next()).WillOnce(testing::Return(34L));
+-    EXPECT_CALL(*m_sequencerMock, publish(34L)).Times(1);
+-
+-    m_ringBuffer->publish(m_ringBuffer->next());
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldDelgateTryNextAndPublish)
+-{
+-    EXPECT_CALL(*m_sequencerMock, tryNext()).WillOnce(testing::Return(34L));
+-    EXPECT_CALL(*m_sequencerMock, publish(34L)).Times(1);
+-
+-    m_ringBuffer->publish(m_ringBuffer->tryNext());
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldDelgateNextNAndPublish)
+-{
+-    EXPECT_CALL(*m_sequencerMock, next(10)).WillOnce(testing::Return(34L));
+-    EXPECT_CALL(*m_sequencerMock, publish(25L, 34L)).Times(1);
+-
+-    auto hi = m_ringBuffer->next(10);
+-    m_ringBuffer->publish(hi - 9, hi);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldDelgateTryNextNAndPublish)
+-{
+-    EXPECT_CALL(*m_sequencerMock, tryNext(10)).WillOnce(testing::Return(34L));
+-    EXPECT_CALL(*m_sequencerMock, publish(25L, 34L)).Times(1);
+-
+-    auto hi = m_ringBuffer->tryNext(10);
+-    m_ringBuffer->publish(hi - 9, hi);
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/SequenceBarrierMock.h b/Disruptor.Tests/SequenceBarrierMock.h
+deleted file mode 100644
+index 022449f..0000000
+--- a/Disruptor.Tests/SequenceBarrierMock.h
++++ /dev/null
+@@ -1,28 +0,0 @@
+-#pragma once
+-
+-#include <gmock/gmock.h>
+-
+-#include "Disruptor/ISequenceBarrier.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    class SequenceBarrierMock : public ISequenceBarrier
+-    {
+-    public:
+-        MOCK_METHOD1(waitFor, std::int64_t(std::int64_t sequence));
+-        
+-        MOCK_METHOD0(cursor, std::int64_t());
+-
+-        MOCK_METHOD0(isAlerted, bool());
+-        MOCK_METHOD0(alert, void());
+-
+-        MOCK_METHOD0(clearAlert, void());
+-        MOCK_METHOD0(checkAlert, void());
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/SequenceBarrierTests.cpp b/Disruptor.Tests/SequenceBarrierTests.cpp
+deleted file mode 100644
+index 51cd8f4..0000000
+--- a/Disruptor.Tests/SequenceBarrierTests.cpp
++++ /dev/null
+@@ -1,143 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "Disruptor/AlertException.h"
+-#include "Disruptor/IgnoreExceptionHandler.h"
+-#include "Disruptor/Sequence.h"
+-
+-#include "SequenceBarrierTestsFixture.h"
+-
+-
+-using namespace Disruptor;
+-using namespace Disruptor::Tests;
+-
+-
+-BOOST_FIXTURE_TEST_SUITE(SequenceBarrierTests, SequenceBarrierTestsFixture)
+-
+-BOOST_AUTO_TEST_CASE(ShouldWaitForWorkCompleteWhereCompleteWorkThresholdIsAhead)
+-{
+-    const std::int32_t expectedNumberMessages = 10;
+-    const std::int32_t expectedWorkSequence = 9;
+-    fillRingBuffer(expectedNumberMessages);
+-
+-    auto sequence1 = std::make_shared< Sequence >(expectedNumberMessages);
+-    auto sequence2 = std::make_shared< Sequence >(expectedNumberMessages);
+-    auto sequence3 = std::make_shared< Sequence >(expectedNumberMessages);
+-
+-    EXPECT_CALL(*m_eventProcessorMock1, sequence()).WillOnce(testing::Return(sequence1));
+-    EXPECT_CALL(*m_eventProcessorMock2, sequence()).WillOnce(testing::Return(sequence2));
+-    EXPECT_CALL(*m_eventProcessorMock3, sequence()).WillOnce(testing::Return(sequence3));
+-
+-    auto dependencyBarrier = m_ringBuffer->newBarrier({ m_eventProcessorMock1->sequence(),
+-                                                        m_eventProcessorMock2->sequence(),
+-                                                        m_eventProcessorMock3->sequence() });
+-
+-    auto completedWorkSequence = dependencyBarrier->waitFor(expectedWorkSequence);
+-    BOOST_CHECK_GE(completedWorkSequence, expectedWorkSequence);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldWaitForWorkCompleteWhereAllWorkersAreBlockedOnRingBuffer)
+-{
+-    const std::int32_t expectedNumberMessages = 10;
+-    fillRingBuffer(expectedNumberMessages);
+-
+-    std::vector< std::shared_ptr< IEventProcessor > > workers(3);
+-    for (auto i = 0u; i < workers.size(); ++i)
+-    {
+-        workers[i] = std::make_shared< StubEventProcessor >(expectedNumberMessages - 1);
+-    }
+-
+-    auto dependencyBarrier = m_ringBuffer->newBarrier(Util::getSequencesFor(workers));
+-    std::thread([=]
+-    {
+-        auto sequence = m_ringBuffer->next();
+-        (*m_ringBuffer)[sequence].value(static_cast< int >(sequence));
+-        m_ringBuffer->publish(sequence);
+-
+-        for (auto&& stubWorker : workers)
+-        {
+-            stubWorker->sequence()->setValue(sequence);
+-        }
+-    }).detach();
+-
+-    std::int64_t expectedWorkSequence = expectedNumberMessages;
+-    auto completedWorkSequence = dependencyBarrier->waitFor(expectedWorkSequence);
+-    BOOST_CHECK_GE(completedWorkSequence, expectedWorkSequence);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldInterruptDuringBusySpin)
+-{
+-    const std::int32_t expectedNumberMessages = 10;
+-    fillRingBuffer(expectedNumberMessages);
+-
+-    auto signal = std::make_shared< CountdownEvent >(3);
+-    auto sequence1 = std::make_shared< CountDownEventSequence >(8L, signal);
+-    auto sequence2 = std::make_shared< CountDownEventSequence >(8L, signal);
+-    auto sequence3 = std::make_shared< CountDownEventSequence >(8L, signal);
+-
+-    EXPECT_CALL(*m_eventProcessorMock1, sequence()).WillOnce(testing::Return(sequence1));
+-    EXPECT_CALL(*m_eventProcessorMock2, sequence()).WillOnce(testing::Return(sequence2));
+-    EXPECT_CALL(*m_eventProcessorMock3, sequence()).WillOnce(testing::Return(sequence3));
+-
+-    auto sequenceBarrier = m_ringBuffer->newBarrier(Util::getSequencesFor({ m_eventProcessorMock1,
+-                                                                            m_eventProcessorMock2,
+-                                                                            m_eventProcessorMock3 }));
+-
+-    auto alerted = false;
+-    auto future = std::async(std::launch::async, [=, &alerted]()
+-    {
+-        try
+-        {
+-            sequenceBarrier->waitFor(expectedNumberMessages - 1);
+-        }
+-        catch (AlertException&)
+-        {
+-            alerted = true;
+-        }
+-    });
+-
+-    signal->wait(std::chrono::seconds(3));
+-    sequenceBarrier->alert();
+-    future.wait();
+-
+-    BOOST_CHECK_MESSAGE(alerted == true, "Thread was not interrupted");
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldWaitForWorkCompleteWhereCompleteWorkThresholdIsBehind)
+-{
+-    const std::int32_t expectedNumberMessages = 10;
+-    fillRingBuffer(expectedNumberMessages);
+-
+-    std::vector< std::shared_ptr< IEventProcessor > > eventProcessors(3);
+-    for (auto i = 0u; i < eventProcessors.size(); ++i)
+-    {
+-        eventProcessors[i] = std::make_shared< StubEventProcessor >(expectedNumberMessages - 2);
+-    }
+-
+-    auto eventProcessorBarrier = m_ringBuffer->newBarrier(Util::getSequencesFor(eventProcessors));
+-
+-    std::async(std::launch::async, [=]
+-    {
+-        for (auto&& stubWorker : eventProcessors)
+-        {
+-            stubWorker->sequence()->setValue(stubWorker->sequence()->value() + 1);
+-        }
+-    }).wait();
+-
+-    std::int64_t expectedWorkSequence = expectedNumberMessages - 1;
+-    auto completedWorkSequence = eventProcessorBarrier->waitFor(expectedWorkSequence);
+-    BOOST_CHECK_GE(completedWorkSequence, expectedWorkSequence);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldSetAndClearAlertStatus)
+-{
+-    auto sequenceBarrier = m_ringBuffer->newBarrier();
+-    BOOST_CHECK_EQUAL(sequenceBarrier->isAlerted(), false);
+-
+-    sequenceBarrier->alert();
+-    BOOST_CHECK_EQUAL(sequenceBarrier->isAlerted(), true);
+-
+-    sequenceBarrier->clearAlert();
+-    BOOST_CHECK_EQUAL(sequenceBarrier->isAlerted(), false);
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/SequenceBarrierTestsFixture.cpp b/Disruptor.Tests/SequenceBarrierTestsFixture.cpp
+deleted file mode 100644
+index 3c465d1..0000000
+--- a/Disruptor.Tests/SequenceBarrierTestsFixture.cpp
++++ /dev/null
+@@ -1,97 +0,0 @@
+-#include "stdafx.h"
+-#include "SequenceBarrierTestsFixture.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    SequenceBarrierTestsFixture::SequenceBarrierTestsFixture()
+-    {
+-        m_ringBuffer = RingBuffer< StubEvent >::createMultiProducer([] { return StubEvent(-1); }, 64);
+-
+-        m_eventProcessorMock1 = std::make_shared< testing::NiceMock< EventProcessorMock > >();
+-        m_eventProcessorMock2 = std::make_shared< testing::NiceMock< EventProcessorMock > >();
+-        m_eventProcessorMock3 = std::make_shared< testing::NiceMock< EventProcessorMock > >();
+-
+-        m_ringBuffer->addGatingSequences({std::make_shared< NoOpEventProcessor< StubEvent > >(m_ringBuffer)->sequence()});
+-    }
+-
+-    void SequenceBarrierTestsFixture::fillRingBuffer(std::int64_t expectedNumberEvents)
+-    {
+-        for (auto i = 0; i < expectedNumberEvents; i++)
+-        {
+-            auto sequence = m_ringBuffer->next();
+-            auto& event = (*m_ringBuffer)[sequence];
+-            event.value(i);
+-            m_ringBuffer->publish(sequence);
+-        }
+-    }
+-
+-    SequenceBarrierTestsFixture::StubEventProcessor::StubEventProcessor(std::int64_t sequence)
+-    {
+-        m_sequence->setValue(sequence);
+-    }
+-
+-    void SequenceBarrierTestsFixture::StubEventProcessor::run()
+-    {
+-        if (std::atomic_exchange(&m_running, 1) != 0)
+-            DISRUPTOR_THROW_INVALID_OPERATION_EXCEPTION("Already running");
+-    }
+-
+-    std::shared_ptr< ISequence > SequenceBarrierTestsFixture::StubEventProcessor::sequence() const
+-    {
+-        return m_sequence;
+-    }
+-
+-    void SequenceBarrierTestsFixture::StubEventProcessor::halt()
+-    {
+-        m_running = 0;
+-    }
+-
+-    bool SequenceBarrierTestsFixture::StubEventProcessor::isRunning() const
+-    {
+-        return m_running == 1;
+-    }
+-
+-    SequenceBarrierTestsFixture::CountDownEventSequence::CountDownEventSequence(std::int64_t initialValue, const std::shared_ptr< CountdownEvent >& signal)
+-        : m_signal(signal)
+-        , m_sequenceImplementation(std::make_shared< Sequence >(initialValue))
+-    {
+-    }
+-
+-    std::int64_t SequenceBarrierTestsFixture::CountDownEventSequence::value() const
+-    {
+-        if (m_signal->currentCount() > 0)
+-            m_signal->signal();
+-
+-        return m_sequenceImplementation->value();
+-    }
+-
+-    void SequenceBarrierTestsFixture::CountDownEventSequence::setValue(std::int64_t value)
+-    {
+-        m_sequenceImplementation->setValue(value);
+-    }
+-
+-    bool SequenceBarrierTestsFixture::CountDownEventSequence::compareAndSet(std::int64_t expectedSequence, std::int64_t nextSequence)
+-    {
+-        return m_sequenceImplementation->compareAndSet(expectedSequence, nextSequence);
+-    }
+-
+-    std::int64_t SequenceBarrierTestsFixture::CountDownEventSequence::incrementAndGet()
+-    {
+-        return m_sequenceImplementation->incrementAndGet();
+-    }
+-
+-    std::int64_t SequenceBarrierTestsFixture::CountDownEventSequence::addAndGet(std::int64_t value)
+-    {
+-        return m_sequenceImplementation->addAndGet(value);
+-    }
+-
+-    void SequenceBarrierTestsFixture::CountDownEventSequence::writeDescriptionTo(std::ostream& /*stream*/) const
+-    {
+-    }
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/SequenceBarrierTestsFixture.h b/Disruptor.Tests/SequenceBarrierTestsFixture.h
+deleted file mode 100644
+index 7ff6b6e..0000000
+--- a/Disruptor.Tests/SequenceBarrierTestsFixture.h
++++ /dev/null
+@@ -1,78 +0,0 @@
+-#pragma once
+-
+-#include <memory>
+-
+-#include "Disruptor/NoOpEventProcessor.h"
+-#include "Disruptor/RingBuffer.h"
+-
+-#include "Disruptor.TestTools/CountdownEvent.h"
+-
+-#include "Disruptor.Tests/EventProcessorMock.h"
+-#include "Disruptor.Tests/StubEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    struct SequenceBarrierTestsFixture
+-    {
+-        class CountDownEventSequence;
+-        class StubEventProcessor;
+-
+-        SequenceBarrierTestsFixture();
+-
+-        void fillRingBuffer(std::int64_t expectedNumberEvents);
+-
+-
+-        std::shared_ptr< RingBuffer< StubEvent > > m_ringBuffer;
+-        std::shared_ptr< EventProcessorMock > m_eventProcessorMock1;
+-        std::shared_ptr< EventProcessorMock > m_eventProcessorMock2;
+-        std::shared_ptr< EventProcessorMock > m_eventProcessorMock3;
+-    };
+-
+-
+-    class SequenceBarrierTestsFixture::StubEventProcessor : public IEventProcessor
+-    {
+-    public:
+-        explicit StubEventProcessor(std::int64_t sequence);
+-
+-        void run() override;
+-
+-        std::shared_ptr< ISequence > sequence() const override;
+-
+-        void halt() override;
+-
+-        bool isRunning() const override;
+-
+-    private:
+-        std::atomic< std::int32_t > m_running;
+-        std::shared_ptr< Sequence > m_sequence = std::make_shared< Sequence >();
+-    };
+-
+-
+-    class SequenceBarrierTestsFixture::CountDownEventSequence : public ISequence
+-    {
+-    public:
+-        CountDownEventSequence(std::int64_t initialValue, const std::shared_ptr< CountdownEvent >& signal);
+-
+-        std::int64_t value() const override;
+-
+-        void setValue(std::int64_t value) override;
+-
+-        bool compareAndSet(std::int64_t expectedSequence, std::int64_t nextSequence) override;
+-
+-        std::int64_t incrementAndGet() override;
+-
+-        std::int64_t addAndGet(std::int64_t value) override;
+-
+-        void writeDescriptionTo(std::ostream& stream) const override;
+-
+-    private:
+-        std::shared_ptr< CountdownEvent > m_signal;
+-        std::shared_ptr< ISequence > m_sequenceImplementation;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/SequenceReportingCallbackTests.cpp b/Disruptor.Tests/SequenceReportingCallbackTests.cpp
+deleted file mode 100644
+index b3ce044..0000000
+--- a/Disruptor.Tests/SequenceReportingCallbackTests.cpp
++++ /dev/null
+@@ -1,90 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "Disruptor/BatchEventProcessor.h"
+-#include "Disruptor/ISequenceReportingEventHandler.h"
+-#include "Disruptor/RingBuffer.h"
+-
+-#include "Disruptor.TestTools/ManualResetEvent.h"
+-
+-#include "StubEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    struct SequenceReportingCallbackTestsFixture
+-    {
+-        std::shared_ptr< ManualResetEvent > m_callbackSignal = std::make_shared< ManualResetEvent >(false);
+-        std::shared_ptr< ManualResetEvent > m_onEndOfBatchSignal = std::make_shared< ManualResetEvent >(false);
+-    };
+-    
+-    class TestSequenceReportingEventHandler : public ISequenceReportingEventHandler< StubEvent >
+-    {
+-    public:
+-        TestSequenceReportingEventHandler(const std::shared_ptr< ManualResetEvent >& callbackSignal,
+-                                          const std::shared_ptr< ManualResetEvent >& onEndOfBatchSignal)
+-            : m_callbackSignal(callbackSignal)
+-            , m_onEndOfBatchSignal(onEndOfBatchSignal)
+-        {
+-        }
+-
+-        void setSequenceCallback(const std::shared_ptr< ISequence >& sequenceTrackerCallback) override
+-        {
+-            m_sequenceCallback = sequenceTrackerCallback;
+-        }
+-
+-        void onEvent(StubEvent& /*evt*/, std::int64_t sequence, bool endOfBatch) override
+-        {
+-            m_sequenceCallback->setValue(sequence);
+-            m_callbackSignal->set();
+-
+-            if (endOfBatch)
+-            {
+-                m_onEndOfBatchSignal->waitOne();
+-            }
+-        }
+-
+-    private:
+-        std::shared_ptr< ISequence > m_sequenceCallback;
+-        std::shared_ptr< ManualResetEvent > m_callbackSignal;
+-        std::shared_ptr< ManualResetEvent > m_onEndOfBatchSignal;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+-
+-
+-using namespace Disruptor;
+-using namespace Disruptor::Tests;
+-
+-
+-BOOST_FIXTURE_TEST_SUITE(SequenceReportingCallbackTests, SequenceReportingCallbackTestsFixture)
+-
+-BOOST_AUTO_TEST_CASE(ShouldReportProgressByUpdatingSequenceViaCallback)
+-{
+-    auto ringBuffer = RingBuffer< StubEvent >::createMultiProducer([] { return StubEvent(-1); }, 16);
+-    auto sequenceBarrier = ringBuffer->newBarrier();
+-    auto handler = std::make_shared< TestSequenceReportingEventHandler >(m_callbackSignal, m_onEndOfBatchSignal);
+-    auto batchEventProcessor = std::make_shared< BatchEventProcessor< StubEvent > >(ringBuffer, sequenceBarrier, handler);
+-    ringBuffer->addGatingSequences({ batchEventProcessor->sequence() });
+-
+-    std::thread thread([&] { batchEventProcessor->run(); });
+-
+-    BOOST_CHECK_EQUAL(-1L, batchEventProcessor->sequence()->value());
+-    ringBuffer->publish(ringBuffer->next());
+-
+-    m_callbackSignal->waitOne();
+-    BOOST_CHECK_EQUAL(0L, batchEventProcessor->sequence()->value());
+-
+-    m_onEndOfBatchSignal->set();
+-    BOOST_CHECK_EQUAL(0L, batchEventProcessor->sequence()->value());
+-
+-    batchEventProcessor->halt();
+-
+-    if (thread.joinable())
+-        thread.join();
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/SequenceUpdater.cpp b/Disruptor.Tests/SequenceUpdater.cpp
+deleted file mode 100644
+index ff1fb1a..0000000
+--- a/Disruptor.Tests/SequenceUpdater.cpp
++++ /dev/null
+@@ -1,43 +0,0 @@
+-#include "stdafx.h"
+-#include "SequenceUpdater.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    SequenceUpdater::SequenceUpdater(std::int64_t sleepTime, const std::shared_ptr< IWaitStrategy >& waitStrategy)
+-        : m_barrier(2)
+-        , m_sleepTime(static_cast< std::int32_t >(sleepTime))
+-        , m_waitStrategy(waitStrategy)
+-    {
+-    }
+-
+-    void SequenceUpdater::run()
+-    {
+-        try
+-        {
+-            m_barrier.signal();
+-            m_barrier.wait();
+-            if (0 != m_sleepTime)
+-            {
+-                std::this_thread::sleep_for(std::chrono::milliseconds(m_sleepTime));
+-            }
+-            sequence->incrementAndGet();
+-            m_waitStrategy->signalAllWhenBlocking();
+-        }
+-        catch (std::exception& ex)
+-        {
+-            std::cout << ex.what() << std::endl;
+-        }
+-    }
+-
+-    void SequenceUpdater::waitForStartup()
+-    {
+-        m_barrier.signal();
+-        m_barrier.wait();
+-    }
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/SequenceUpdater.h b/Disruptor.Tests/SequenceUpdater.h
+deleted file mode 100644
+index d5f89e6..0000000
+--- a/Disruptor.Tests/SequenceUpdater.h
++++ /dev/null
+@@ -1,34 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-
+-#include "Disruptor/IWaitStrategy.h"
+-#include "Disruptor/Sequence.h"
+-
+-#include "Disruptor.TestTools/CountdownEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    class SequenceUpdater
+-    {
+-    public:
+-        SequenceUpdater(std::int64_t sleepTime, const std::shared_ptr< IWaitStrategy >& waitStrategy);
+-
+-        void run();
+-
+-        void waitForStartup();
+-
+-        std::shared_ptr< Sequence > sequence = std::make_shared< Sequence >();
+-
+-    private:
+-        CountdownEvent m_barrier;
+-        std::int32_t m_sleepTime = 0;
+-        std::shared_ptr< IWaitStrategy > m_waitStrategy;
+-    };
+-    
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/SequencerFixture.h b/Disruptor.Tests/SequencerFixture.h
+deleted file mode 100644
+index 7ddaada..0000000
+--- a/Disruptor.Tests/SequencerFixture.h
++++ /dev/null
+@@ -1,30 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/BlockingWaitStrategy.h"
+-#include "Disruptor/MultiProducerSequencer.h"
+-#include "Disruptor/Sequence.h"
+-#include "Disruptor/SingleProducerSequencer.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    template <class T>
+-    struct SequencerTestFixture
+-    {
+-        SequencerTestFixture()
+-            : m_waitStrategy(std::make_shared< BlockingWaitStrategy >())
+-            , m_sequencer(std::make_shared< T >(m_bufferSize, m_waitStrategy))
+-            , m_gatingSequence(std::make_shared< Sequence >())
+-        {}
+-    
+-        const std::int32_t m_bufferSize = 16;
+-        std::shared_ptr< IWaitStrategy > m_waitStrategy;
+-        std::shared_ptr< T > m_sequencer;
+-        std::shared_ptr< Sequence > m_gatingSequence;
+-    };
+-    
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/SequencerMock.h b/Disruptor.Tests/SequencerMock.h
+deleted file mode 100644
+index 798b33d..0000000
+--- a/Disruptor.Tests/SequencerMock.h
++++ /dev/null
+@@ -1,53 +0,0 @@
+-#pragma once
+-
+-#include <gmock/gmock.h>
+-
+-#include "Disruptor/ISequencer.h"
+-#include "Disruptor.Tests/StubEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    template <class T>
+-    class SequencerMock : public ISequencer< T >
+-    {
+-    public:
+-        MOCK_METHOD1(claim, void(std::int64_t sequence));
+-
+-        MOCK_METHOD1(isAvailable, bool(std::int64_t sequence));
+-        
+-        MOCK_METHOD1(addGatingSequences, void(const std::vector< std::shared_ptr< ISequence > >& gatingSequences));
+-        MOCK_METHOD1(removeGatingSequence, bool(const std::shared_ptr< ISequence >& sequence));
+-
+-        MOCK_METHOD1(newBarrier, std::shared_ptr< ISequenceBarrier >(const std::vector< std::shared_ptr< ISequence > >& sequencesToTrack));
+-        MOCK_METHOD0(getMinimumSequence, std::int64_t());
+-
+-        MOCK_METHOD2_T(newPoller, std::shared_ptr< EventPoller< T > >(const std::shared_ptr< IDataProvider< T > >& provider, const std::vector< std::shared_ptr< ISequence > >& gatingSequences));
+-        
+-        MOCK_CONST_METHOD1(writeDescriptionTo, void(std::ostream& stream));
+-
+-        MOCK_METHOD0(bufferSize, std::int32_t());
+-
+-        MOCK_METHOD1(hasAvailableCapacity, bool(std::int32_t requiredCapacity));
+-
+-        MOCK_METHOD0(getRemainingCapacity, std::int64_t());
+-
+-        MOCK_METHOD0(next, std::int64_t());
+-        MOCK_METHOD1(next, std::int64_t(std::int32_t n));
+-
+-        MOCK_METHOD0(tryNext, std::int64_t());
+-        MOCK_METHOD1(tryNext, std::int64_t(std::int32_t n));
+-
+-        MOCK_METHOD1(publish, void(std::int64_t sequence));
+-        MOCK_METHOD2(publish, void(std::int64_t lo, std::int64_t hi));
+-
+-        MOCK_CONST_METHOD0(cursor, std::int64_t());
+-
+-        MOCK_METHOD2(getHighestPublishedSequence, std::int64_t(std::int64_t nextSequence, std::int64_t availableSequence));
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+\ No newline at end of file
+diff --git a/Disruptor.Tests/SequencerTests.cpp b/Disruptor.Tests/SequencerTests.cpp
+deleted file mode 100644
+index 8ab2c70..0000000
+--- a/Disruptor.Tests/SequencerTests.cpp
++++ /dev/null
+@@ -1,215 +0,0 @@
+-#include "stdafx.h"
+-
+-#include <boost/mpl/vector.hpp>
+-
+-#include "Disruptor.TestTools/ManualResetEvent.h"
+-
+-#include "SequencerFixture.h"
+-#include "WaitStrategyMock.h"
+-
+-
+-using namespace Disruptor;
+-using namespace Disruptor::Tests;
+-
+-
+-typedef boost::mpl::vector< MultiProducerSequencer< int >, SingleProducerSequencer< int > > Sequencers;
+-
+-BOOST_AUTO_TEST_SUITE(SequencerTests)
+-
+-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldStartWithInitialValue, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
+-{
+-    BOOST_CHECK_EQUAL(this->m_sequencer->next(), 0);
+-}
+-
+-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldBatchClaim, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
+-{
+-    BOOST_CHECK_EQUAL(this->m_sequencer->next(4), 3);
+-}
+-
+-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldIndicateHasAvailableCapacity, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
+-{
+-    this->m_sequencer->addGatingSequences({ this->m_gatingSequence });
+-
+-    BOOST_CHECK_EQUAL(this->m_sequencer->hasAvailableCapacity(1), true);
+-    BOOST_CHECK_EQUAL(this->m_sequencer->hasAvailableCapacity(this->m_bufferSize), true);
+-    BOOST_CHECK_EQUAL(this->m_sequencer->hasAvailableCapacity(this->m_bufferSize + 1), false);
+-
+-    this->m_sequencer->publish(this->m_sequencer->next());
+-
+-    BOOST_CHECK_EQUAL(this->m_sequencer->hasAvailableCapacity(this->m_bufferSize - 1), true);
+-    BOOST_CHECK_EQUAL(this->m_sequencer->hasAvailableCapacity(this->m_bufferSize), false);
+-}
+-
+-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldIndicateNoAvailableCapacity, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
+-{
+-    this->m_sequencer->addGatingSequences({ this->m_gatingSequence });
+-
+-    auto sequence = this->m_sequencer->next(this->m_bufferSize);
+-    this->m_sequencer->publish(sequence - (this->m_bufferSize - 1), sequence);
+-
+-    BOOST_CHECK_EQUAL(this->m_sequencer->hasAvailableCapacity(1), false);
+-}
+-
+-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldHoldUpPublisherWhenBufferIsFull, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
+-{
+-    this->m_sequencer->addGatingSequences({ this->m_gatingSequence });
+-
+-    auto sequence = this->m_sequencer->next(this->m_bufferSize);
+-    this->m_sequencer->publish(sequence - (this->m_bufferSize - 1), sequence);
+-
+-    auto waitingSignal = std::make_shared< ManualResetEvent >(false);
+-    auto doneSignal = std::make_shared< ManualResetEvent >(false);
+-
+-    auto expectedFullSequence = Sequence::InitialCursorValue + this->m_sequencer->bufferSize();
+-    BOOST_CHECK_EQUAL(this->m_sequencer->cursor(), expectedFullSequence);
+-
+-    std::thread([=]
+-    {
+-        waitingSignal->set();
+-
+-        auto next = this->m_sequencer->next();
+-        this->m_sequencer->publish(next);
+-
+-        doneSignal->set();
+-    }).detach();
+-
+-    waitingSignal->wait(std::chrono::milliseconds(500));
+-    BOOST_CHECK_EQUAL(this->m_sequencer->cursor(), expectedFullSequence);
+-
+-    this->m_gatingSequence->setValue(Sequence::InitialCursorValue + 1L);
+-
+-    doneSignal->wait(std::chrono::milliseconds(500));
+-    BOOST_CHECK_EQUAL(this->m_sequencer->cursor(), expectedFullSequence + 1L);
+-}
+-
+-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldThrowInsufficientCapacityExceptionWhenSequencerIsFull, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
+-{
+-    this->m_sequencer->addGatingSequences({ this->m_gatingSequence });
+-
+-    for (auto i = 0; i < this->m_bufferSize; ++i)
+-    {
+-        this->m_sequencer->next();
+-    }
+-
+-    BOOST_CHECK_THROW(this->m_sequencer->tryNext(), InsufficientCapacityException);
+-}
+-
+-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldCalculateRemainingCapacity, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
+-{
+-    this->m_sequencer->addGatingSequences({ this->m_gatingSequence });
+-
+-    BOOST_CHECK_EQUAL(this->m_sequencer->getRemainingCapacity(), this->m_bufferSize);
+-    
+-    for (auto i = 1; i < this->m_bufferSize; ++i)
+-    {
+-        this->m_sequencer->next();
+-        BOOST_CHECK_EQUAL(this->m_sequencer->getRemainingCapacity(), this->m_bufferSize - i);
+-    }
+-}
+-
+-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShoundNotBeAvailableUntilPublished, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
+-{
+-    auto next = this->m_sequencer->next(6);
+-
+-    for (auto i = 0; i <= 5; i++)
+-    {
+-        BOOST_CHECK_EQUAL(this->m_sequencer->isAvailable(i), false);
+-    }
+-
+-    this->m_sequencer->publish(next - (6 - 1), next);
+-    
+-    for (auto i = 0; i <= 5; i++)
+-    {
+-        BOOST_CHECK_EQUAL(this->m_sequencer->isAvailable(i), true);
+-    }
+-
+-    BOOST_CHECK_EQUAL(this->m_sequencer->isAvailable(6), false);
+-}
+-
+-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldNotifyWaitStrategyOnPublish, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
+-{
+-    auto waitStrategyMock = std::make_shared< testing::NiceMock< WaitStrategyMock > >();
+-    auto sequencer = std::make_shared< TSequencer >(this->m_bufferSize, waitStrategyMock);
+-
+-    EXPECT_CALL(*waitStrategyMock, signalAllWhenBlocking()).Times(1);
+-
+-    sequencer->publish(sequencer->next());
+-}
+-
+-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldNotifyWaitStrategyOnPublishBatch, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
+-{
+-    auto waitStrategyMock = std::make_shared< testing::NiceMock< WaitStrategyMock > >();
+-    auto sequencer = std::make_shared< TSequencer >(this->m_bufferSize, waitStrategyMock);
+-
+-    EXPECT_CALL(*waitStrategyMock, signalAllWhenBlocking()).Times(1);
+-
+-    auto next = sequencer->next(4);
+-    sequencer->publish(next - (4 - 1), next);
+-}
+-
+-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldWaitOnPublication, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
+-{
+-    auto barrier = this->m_sequencer->newBarrier({});
+-
+-    auto next = this->m_sequencer->next(10);
+-    auto lo = next - (10 - 1);
+-    auto mid = next - 5;
+-
+-    for (auto l = lo; l < mid; ++l)
+-    {
+-       this->m_sequencer->publish(l);
+-    }
+-
+-    BOOST_CHECK_EQUAL(barrier->waitFor(-1), mid - 1);
+-
+-    for (auto l = mid; l <= next; ++l)
+-    {
+-        this->m_sequencer->publish(l);
+-    }
+-
+-    BOOST_CHECK_EQUAL(barrier->waitFor(-1), next);
+-}
+-
+-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldTryNext, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
+-{
+-    this->m_sequencer->addGatingSequences({ this->m_gatingSequence });
+-
+-    for (auto i = 0; i < this->m_bufferSize; i++)
+-    {
+-        BOOST_CHECK_NO_THROW(this->m_sequencer->publish(this->m_sequencer->tryNext()));
+-    }
+- 
+-    BOOST_CHECK_THROW(this->m_sequencer->tryNext(), InsufficientCapacityException);
+-}
+-
+-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldClaimSpecificSequence, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
+-{
+-    std::int64_t sequence = 14;
+-
+-    this->m_sequencer->claim(sequence);
+-    this->m_sequencer->publish(sequence);
+-
+-    BOOST_CHECK_EQUAL(this->m_sequencer->next(), sequence + 1);
+-}
+-
+-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldNotAllowBulkNextLessThanZero, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
+-{
+-    BOOST_CHECK_THROW(this->m_sequencer->next(-1), ArgumentException);
+-}
+-
+-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldNotAllowBulkNextOfZero, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
+-{
+-    BOOST_CHECK_THROW(this->m_sequencer->next(0), ArgumentException);
+-}
+-
+-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldNotAllowBulkTryNextLessThanZero, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
+-{
+-    BOOST_CHECK_THROW(this->m_sequencer->tryNext(-1), ArgumentException);
+-}
+-
+-BOOST_FIXTURE_TEST_CASE_TEMPLATE(ShouldNotAllowBulkTryNextOfZero, TSequencer, Sequencers, SequencerTestFixture< TSequencer >)
+-{
+-    BOOST_CHECK_THROW(this->m_sequencer->tryNext(0), ArgumentException);
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/SleepingEventHandler.cpp b/Disruptor.Tests/SleepingEventHandler.cpp
+deleted file mode 100644
+index 3ba767c..0000000
+--- a/Disruptor.Tests/SleepingEventHandler.cpp
++++ /dev/null
+@@ -1,16 +0,0 @@
+-#include "stdafx.h"
+-#include "SleepingEventHandler.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    void SleepingEventHandler::onEvent(TestEvent& /*data*/, std::int64_t /*sequence*/, bool /*endOfBatch*/)
+-    {
+-        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
+-    }
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/SleepingEventHandler.h b/Disruptor.Tests/SleepingEventHandler.h
+deleted file mode 100644
+index d4fe1c6..0000000
+--- a/Disruptor.Tests/SleepingEventHandler.h
++++ /dev/null
+@@ -1,20 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/IEventHandler.h"
+-
+-#include "Disruptor.Tests/TestEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-    
+-    class SleepingEventHandler : public IEventHandler< TestEvent >
+-    {
+-    public:
+-        void onEvent(TestEvent& data, std::int64_t sequence, bool endOfBatch) override;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/SleepingWaitStrategyTests.cpp b/Disruptor.Tests/SleepingWaitStrategyTests.cpp
+deleted file mode 100644
+index aa93736..0000000
+--- a/Disruptor.Tests/SleepingWaitStrategyTests.cpp
++++ /dev/null
+@@ -1,18 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "Disruptor/SleepingWaitStrategy.h"
+-#include "WaitStrategyTestUtil.h"
+-
+-
+-using namespace Disruptor;
+-using namespace Disruptor::Tests;
+-
+-
+-BOOST_AUTO_TEST_SUITE(SleepingWaitStrategyTests)
+-
+-BOOST_AUTO_TEST_CASE(ShouldWaitForValue)
+-{
+-    assertWaitForWithDelayOf(50, std::make_shared< SleepingWaitStrategy >());
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/SpinWaitWaitStrategyTests.cpp b/Disruptor.Tests/SpinWaitWaitStrategyTests.cpp
+deleted file mode 100644
+index 046bc16..0000000
+--- a/Disruptor.Tests/SpinWaitWaitStrategyTests.cpp
++++ /dev/null
+@@ -1,18 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "Disruptor/SpinWaitWaitStrategy.h"
+-#include "WaitStrategyTestUtil.h"
+-
+-
+-using namespace Disruptor;
+-using namespace Disruptor::Tests;
+-
+-
+-BOOST_AUTO_TEST_SUITE(SpinWaitWaitStrategyTests)
+-
+-BOOST_AUTO_TEST_CASE(ShouldWaitForValue)
+-{
+-    assertWaitForWithDelayOf(50, std::make_shared< SpinWaitWaitStrategy >());
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/StubEvent.cpp b/Disruptor.Tests/StubEvent.cpp
+deleted file mode 100644
+index a4f1819..0000000
+--- a/Disruptor.Tests/StubEvent.cpp
++++ /dev/null
+@@ -1,75 +0,0 @@
+-#include "stdafx.h"
+-#include "StubEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    void StubEvent::TwoTranslator::translateTo(StubEvent& event, std::int64_t /*sequence*/, const std::int32_t& arg0, const std::string& arg1)
+-    {
+-        event.value(arg0);
+-        event.testString(arg1);
+-    }
+-
+-    StubEvent::StubEvent(int i)
+-        : m_value(i)
+-    {
+-    }
+-
+-    int StubEvent::value() const
+-    {
+-        return m_value;
+-    }
+-
+-    void StubEvent::value(int i)
+-    {
+-        m_value = i;
+-    }
+-
+-    std::string StubEvent::testString() const
+-    {
+-        return m_testString;
+-    }
+-
+-    void StubEvent::testString(std::string x)
+-    {
+-        m_testString = x;
+-    }
+-
+-    void StubEvent::copy(const StubEvent& evt)
+-    {
+-        m_value = evt.m_value;
+-    }
+-
+-    bool StubEvent::operator==(const StubEvent& rhs) const
+-    {
+-        return m_value == rhs.m_value;
+-    }
+-
+-    const std::shared_ptr< StubEvent::TwoTranslator >& StubEvent::translator()
+-    {
+-        static auto result(std::make_shared< TwoTranslator >());
+-        return result;
+-    }
+-
+-    const std::function< StubEvent() >& StubEvent::eventFactory()
+-    {
+-        static std::function< StubEvent() > result([] { return StubEvent(-1); });
+-        return result;
+-    }
+-
+-} // namespace Tests
+-} // namespace Disruptor
+-
+-
+-namespace std
+-{
+-
+-    ostream& operator<<(ostream& stream, const Disruptor::Tests::StubEvent& event)
+-    {
+-        return stream << "Value: " << event.value() << ", TestString: " << event.testString();
+-    }
+-
+-} // namespace std
+diff --git a/Disruptor.Tests/StubEvent.h b/Disruptor.Tests/StubEvent.h
+deleted file mode 100644
+index b445098..0000000
+--- a/Disruptor.Tests/StubEvent.h
++++ /dev/null
+@@ -1,69 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-#include <string>
+-
+-#include "Disruptor/IEventTranslatorVararg.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    class StubEvent
+-    {
+-        typedef IEventTranslatorVararg< StubEvent, std::int32_t, std::string > EventTranslatorType;
+-
+-        class TwoTranslator : public EventTranslatorType
+-        {
+-        public:
+-            void translateTo(StubEvent& event, std::int64_t sequence, const std::int32_t& arg0, const std::string& arg1) override;
+-        };
+-
+-    public:
+-        StubEvent()
+-            : m_value(0)
+-            , m_testString()
+-        {}
+-
+-        explicit StubEvent(int i);
+-
+-        void operator=(const StubEvent& other)
+-        {
+-            m_value = other.m_value;
+-            m_testString = other.m_testString;
+-        }
+-
+-        int value() const;
+-        void value(int i);
+-
+-        std::string testString() const;
+-        void testString(std::string x);
+-
+-        void copy(const StubEvent& evt);
+-
+-        bool operator==(const StubEvent& rhs) const;
+-
+-        static const std::shared_ptr< TwoTranslator >& translator();
+-
+-        static const std::function< StubEvent() >& eventFactory();
+-
+-    private:
+-        int m_value;
+-        std::string m_testString;
+-    };
+-    
+-} // namespace Tests
+-} // namespace Disruptor
+-
+-
+-#include <ostream>
+-
+-
+-namespace std
+-{
+-
+-    ostream& operator<<(ostream& stream, const Disruptor::Tests::StubEvent& event);
+-
+-} // namespace std
+diff --git a/Disruptor.Tests/StubExceptionHandler.h b/Disruptor.Tests/StubExceptionHandler.h
+deleted file mode 100644
+index 4a9f8b1..0000000
+--- a/Disruptor.Tests/StubExceptionHandler.h
++++ /dev/null
+@@ -1,47 +0,0 @@
+-#pragma once
+-
+-#include "Disruptor/IExceptionHandler.h"
+-
+-#include "Disruptor.Tests/AtomicReference.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    template <class T>
+-    class StubExceptionHandler : public IExceptionHandler< T >
+-    {
+-    public:
+-        explicit StubExceptionHandler(const std::shared_ptr< AtomicReference< std::exception > >& exceptionHandled)
+-            : m_exceptionHandled(exceptionHandled)
+-        {
+-        }
+-
+-        void handleEventException(const std::exception& ex, std::int64_t /*sequence*/, T& /*evt*/) override
+-        {
+-            m_exceptionHandled->write(ex);
+-        }
+-
+-        void handleOnStartException(const std::exception& ex) override
+-        {
+-            m_exceptionHandled->write(ex);
+-        }
+-
+-        void handleOnShutdownException(const std::exception& ex) override
+-        {
+-            m_exceptionHandled->write(ex);
+-        }
+-
+-        void handleOnTimeoutException(const std::exception& ex, std::int64_t /*sequence*/) override
+-        {
+-            m_exceptionHandled->write(ex);
+-        }
+-
+-    private:
+-        std::shared_ptr< AtomicReference< std::exception > > m_exceptionHandled;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/StubExecutor.cpp b/Disruptor.Tests/StubExecutor.cpp
+deleted file mode 100644
+index 4098f8b..0000000
+--- a/Disruptor.Tests/StubExecutor.cpp
++++ /dev/null
+@@ -1,65 +0,0 @@
+-#include "stdafx.h"
+-#include "StubExecutor.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    std::future< void > StubExecutor::execute(const std::function< void() >& command)
+-    {
+-        ++m_executionCount;
+-
+-        std::future< void > result;
+-
+-        if (!m_ignoreExecutions)
+-        {
+-            std::packaged_task< void() > task(command);
+-            result = task.get_future();
+-
+-            std::lock_guard< decltype(m_mutex) > lock(m_mutex);
+-            m_threads.push_back(boost::thread(std::move(task)));
+-        }
+-
+-        return result;
+-    }
+-
+-    void StubExecutor::joinAllThreads()
+-    {
+-        std::lock_guard< decltype(m_mutex) > lock(m_mutex);
+-
+-        while (!m_threads.empty())
+-        {
+-            boost::thread thread(std::move(m_threads.front()));
+-            m_threads.pop_front();
+-
+-            if (thread.joinable())
+-            {
+-                try
+-                {
+-                    thread.interrupt();
+-                    thread.timed_join(boost::posix_time::milliseconds(5000));
+-                }
+-                catch (std::exception& ex)
+-                {
+-                    std::cout << ex.what() << std::endl;
+-                }
+-            }
+-
+-            BOOST_CHECK_MESSAGE(thread.joinable() == false, "Failed to stop thread: " << thread.get_id());
+-        }
+-    }
+-
+-    void StubExecutor::ignoreExecutions()
+-    {
+-        m_ignoreExecutions = true;
+-    }
+-
+-    std::int32_t StubExecutor::getExecutionCount() const
+-    {
+-        return m_executionCount;
+-    }
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/StubExecutor.h b/Disruptor.Tests/StubExecutor.h
+deleted file mode 100644
+index b965e2c..0000000
+--- a/Disruptor.Tests/StubExecutor.h
++++ /dev/null
+@@ -1,42 +0,0 @@
+-#pragma once
+-
+-#include <atomic>
+-#include <cstdint>
+-#include <deque>
+-
+-#include <boost/thread.hpp>
+-
+-#include "Disruptor/IExecutor.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    class StubExecutor : public IExecutor
+-    {
+-    public:
+-        StubExecutor() 
+-           : m_ignoreExecutions(false)
+-           , m_executionCount(0)
+-        {}
+-
+-        std::future< void > execute(const std::function< void() >& command) override;
+-
+-        void joinAllThreads();
+-
+-        void ignoreExecutions();
+-
+-        std::int32_t getExecutionCount() const;
+-
+-    private:
+-        std::recursive_mutex m_mutex;
+-        std::deque< boost::thread > m_threads;
+-        std::atomic< bool > m_ignoreExecutions;
+-        std::atomic< std::int32_t > m_executionCount;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+-
+diff --git a/Disruptor.Tests/StubPublisher.cpp b/Disruptor.Tests/StubPublisher.cpp
+deleted file mode 100644
+index ef990e6..0000000
+--- a/Disruptor.Tests/StubPublisher.cpp
++++ /dev/null
+@@ -1,40 +0,0 @@
+-
+-#include "stdafx.h"
+-#include "StubPublisher.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    StubPublisher::StubPublisher(const std::shared_ptr< RingBuffer< TestEvent > >& ringBuffer)
+-        : m_running(true)
+-        , m_publicationCount(0)
+-    {
+-        m_ringBuffer = ringBuffer;
+-    }
+-
+-    void StubPublisher::run()
+-    {
+-        while (m_running)
+-        {
+-            auto sequence = m_ringBuffer->next();
+-            m_ringBuffer->publish(sequence);
+-            ++m_publicationCount;
+-        }
+-    }
+-
+-    std::int32_t StubPublisher::getPublicationCount() const
+-    {
+-        return m_publicationCount;
+-    }
+-
+-    void StubPublisher::halt()
+-    {
+-        m_running = false;
+-    }
+-
+-} // namespace Tests
+-} // namespace Disruptor
+-
+diff --git a/Disruptor.Tests/StubPublisher.h b/Disruptor.Tests/StubPublisher.h
+deleted file mode 100644
+index 94e99c8..0000000
+--- a/Disruptor.Tests/StubPublisher.h
++++ /dev/null
+@@ -1,36 +0,0 @@
+-#pragma once
+-
+-#include <atomic>
+-#include <cstdint>
+-#include <memory>
+-
+-#include "Disruptor/RingBuffer.h"
+-
+-#include "Disruptor.Tests/TestEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    class StubPublisher
+-    {
+-    public:
+-        explicit StubPublisher(const std::shared_ptr< RingBuffer< TestEvent > >& ringBuffer);
+-
+-        void run();
+-
+-        std::int32_t getPublicationCount() const;
+-
+-        void halt();
+-
+-    private:
+-        std::atomic< bool > m_running;
+-        std::atomic< std::int32_t > m_publicationCount;
+-
+-        std::shared_ptr< RingBuffer< TestEvent > > m_ringBuffer;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/TestEvent.h b/Disruptor.Tests/TestEvent.h
+deleted file mode 100644
+index 483e53c..0000000
+--- a/Disruptor.Tests/TestEvent.h
++++ /dev/null
+@@ -1,14 +0,0 @@
+-#pragma once
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    class TestEvent
+-    {
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/TestWaiter.cpp b/Disruptor.Tests/TestWaiter.cpp
+deleted file mode 100644
+index e18e040..0000000
+--- a/Disruptor.Tests/TestWaiter.cpp
++++ /dev/null
+@@ -1,38 +0,0 @@
+-#include "stdafx.h"
+-#include "TestWaiter.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    TestWaiter::TestWaiter(const std::shared_ptr< boost::barrier >& barrier,
+-                           const std::shared_ptr< ISequenceBarrier >& sequenceBarrier,
+-                           const std::shared_ptr< RingBuffer< StubEvent > >& ringBuffer,
+-                           std::int64_t initialSequence,
+-                           std::int64_t toWaitForSequence)
+-        : m_barrier(barrier)
+-        , m_sequenceBarrier(sequenceBarrier)
+-        , m_ringBuffer(ringBuffer)
+-        , m_initialSequence(initialSequence)
+-        , m_toWaitForSequence(toWaitForSequence)
+-    {
+-    }
+-
+-    std::vector< StubEvent > TestWaiter::call() const
+-    {
+-        m_barrier->wait();
+-        m_sequenceBarrier->waitFor(m_toWaitForSequence);
+-
+-        std::vector< StubEvent > events;
+-        for (auto l = m_initialSequence; l <= m_toWaitForSequence; ++l)
+-        {
+-            events.push_back((*m_ringBuffer)[l]);
+-        }
+-
+-        return events;
+-    }
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/TestWaiter.h b/Disruptor.Tests/TestWaiter.h
+deleted file mode 100644
+index 45a7a09..0000000
+--- a/Disruptor.Tests/TestWaiter.h
++++ /dev/null
+@@ -1,37 +0,0 @@
+-#pragma once
+-
+-#include <memory>
+-#include <boost/thread/barrier.hpp>
+-
+-#include "Disruptor/ISequenceBarrier.h"
+-#include "Disruptor/RingBuffer.h"
+-
+-#include "Disruptor.Tests/StubEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    class TestWaiter
+-    {
+-    public:
+-        TestWaiter(const std::shared_ptr< boost::barrier >& barrier,
+-                   const std::shared_ptr< ISequenceBarrier >& sequenceBarrier,
+-                   const std::shared_ptr< RingBuffer< StubEvent > >& ringBuffer,
+-                   std::int64_t initialSequence,
+-                   std::int64_t toWaitForSequence);
+-
+-        std::vector< StubEvent > call() const;
+-
+-    private:
+-        std::shared_ptr< boost::barrier > m_barrier;
+-        std::shared_ptr< ISequenceBarrier > m_sequenceBarrier;
+-        std::shared_ptr< RingBuffer< StubEvent > > m_ringBuffer;
+-        std::int64_t m_initialSequence;
+-        std::int64_t m_toWaitForSequence;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/TestWorkHandler.cpp b/Disruptor.Tests/TestWorkHandler.cpp
+deleted file mode 100644
+index da25805..0000000
+--- a/Disruptor.Tests/TestWorkHandler.cpp
++++ /dev/null
+@@ -1,34 +0,0 @@
+-#include "stdafx.h"
+-#include "TestWorkHandler.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    void TestWorkHandler::onEvent(TestEvent& /*evt*/)
+-    {
+-        waitForAndSetFlag(0);
+-    }
+-
+-    void TestWorkHandler::processEvent()
+-    {
+-        waitForAndSetFlag(1);
+-    }
+-
+-    void TestWorkHandler::stopWaiting()
+-    {
+-        m_stopped = true;
+-    }
+-
+-    void TestWorkHandler::waitForAndSetFlag(std::int32_t newValue)
+-    {
+-        while (!m_stopped && std::atomic_exchange(&m_readyToProcessEvent, newValue) == newValue)
+-        {
+-            std::this_thread::yield();
+-        }
+-    }
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/TestWorkHandler.h b/Disruptor.Tests/TestWorkHandler.h
+deleted file mode 100644
+index 5747b93..0000000
+--- a/Disruptor.Tests/TestWorkHandler.h
++++ /dev/null
+@@ -1,38 +0,0 @@
+-#pragma once
+-
+-#include <atomic>
+-#include <cstdint>
+-
+-#include "Disruptor/IWorkHandler.h"
+-
+-#include "Disruptor.Tests/TestEvent.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    class TestWorkHandler : public IWorkHandler< TestEvent >
+-    {
+-    public:
+-        TestWorkHandler() 
+-            : m_readyToProcessEvent(0)
+-            , m_stopped(false)
+-        {}
+-
+-        void onEvent(TestEvent& evt) override;
+-
+-        void processEvent();
+-
+-        void stopWaiting();
+-
+-    private:
+-        void waitForAndSetFlag(std::int32_t newValue);
+-
+-        std::atomic< std::int32_t > m_readyToProcessEvent;
+-        std::atomic< bool > m_stopped;
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/TimeoutBlockingWaitStrategyTests.cpp b/Disruptor.Tests/TimeoutBlockingWaitStrategyTests.cpp
+deleted file mode 100644
+index 9c4f66f..0000000
+--- a/Disruptor.Tests/TimeoutBlockingWaitStrategyTests.cpp
++++ /dev/null
+@@ -1,44 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "Disruptor/Sequence.h"
+-#include "Disruptor/TimeoutBlockingWaitStrategy.h"
+-#include "Disruptor/TimeoutException.h"
+-
+-#include "SequenceBarrierMock.h"
+-
+-
+-using namespace Disruptor;
+-
+-
+-BOOST_AUTO_TEST_SUITE(TimeoutBlockingWaitStrategyTest)
+-
+-BOOST_AUTO_TEST_CASE(ShouldTimeoutWaitFor)
+-{
+-    auto sequenceBarrierMock = std::make_shared< testing::NiceMock< Tests::SequenceBarrierMock > >();
+-
+-    auto theTimeout = std::chrono::milliseconds(500);
+-    auto waitStrategy = std::make_shared< TimeoutBlockingWaitStrategy >(theTimeout);
+-    auto cursor = std::make_shared< Sequence >(5);
+-    const auto& dependent = cursor;
+-
+-    EXPECT_CALL(*sequenceBarrierMock, checkAlert()).Times(testing::AtLeast(1));
+-
+-    auto t0 = ClockConfig::Clock::now();
+-
+-    try
+-    {
+-        waitStrategy->waitFor(6, *cursor, *dependent, *sequenceBarrierMock);
+-        throw std::runtime_error("TimeoutException should have been thrown");
+-    }
+-    catch (TimeoutException&)
+-    {
+-    }
+-
+-    auto t1 = ClockConfig::Clock::now();
+-
+-    auto timeWaiting = t1 - t0;
+-
+-    BOOST_CHECK(timeWaiting >= theTimeout);
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/UtilTests.cpp b/Disruptor.Tests/UtilTests.cpp
+deleted file mode 100644
+index 7d7d4a6..0000000
+--- a/Disruptor.Tests/UtilTests.cpp
++++ /dev/null
+@@ -1,36 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "Disruptor/Sequence.h"
+-#include "Disruptor/Util.h"
+-
+-
+-using namespace Disruptor;
+-
+-
+-BOOST_AUTO_TEST_SUITE(UtilTests)
+-
+-BOOST_AUTO_TEST_CASE(ShouldReturnNextPowerOfTwo)
+-{
+-    auto powerOfTwo = Util::ceilingNextPowerOfTwo(1000);
+-
+-    BOOST_CHECK_EQUAL(1024, powerOfTwo);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldReturnExactPowerOfTwo)
+-{
+-    auto powerOfTwo = Util::ceilingNextPowerOfTwo(1024);
+-
+-    BOOST_CHECK_EQUAL(1024, powerOfTwo);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldReturnMinimumSequence)
+-{
+-    BOOST_CHECK_EQUAL(4L, Util::getMinimumSequence({ std::make_shared< Sequence >(11), std::make_shared< Sequence >(4), std::make_shared< Sequence >(13) }));
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldReturnLongMaxWhenNoEventProcessors)
+-{
+-    BOOST_CHECK_EQUAL(std::numeric_limits< std::int64_t >::max(), Util::getMinimumSequence({ }));
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/WaitStrategyMock.h b/Disruptor.Tests/WaitStrategyMock.h
+deleted file mode 100644
+index 342d307..0000000
+--- a/Disruptor.Tests/WaitStrategyMock.h
++++ /dev/null
+@@ -1,27 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-#include <memory>
+-
+-#include <gmock/gmock.h>
+-
+-#include "Disruptor/IWaitStrategy.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    class WaitStrategyMock : public IWaitStrategy
+-    {
+-    public:
+-        MOCK_METHOD4(waitFor, std::int64_t(std::int64_t sequence, Sequence& cursor, ISequence& dependentSequence, ISequenceBarrier& barrier));
+-
+-        MOCK_METHOD0(signalAllWhenBlocking, void());
+-        
+-        MOCK_CONST_METHOD1(writeDescriptionTo, void(std::ostream& stream));
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/WaitStrategyTestUtil.cpp b/Disruptor.Tests/WaitStrategyTestUtil.cpp
+deleted file mode 100644
+index 0bab733..0000000
+--- a/Disruptor.Tests/WaitStrategyTestUtil.cpp
++++ /dev/null
+@@ -1,29 +0,0 @@
+-#include "stdafx.h"
+-#include "WaitStrategyTestUtil.h"
+-
+-#include "Disruptor/IWaitStrategy.h"
+-#include "Disruptor/Sequence.h"
+-
+-#include "DummySequenceBarrier.h"
+-#include "SequenceUpdater.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-
+-    void assertWaitForWithDelayOf(std::int64_t sleepTimeMillis, const std::shared_ptr< IWaitStrategy >& waitStrategy)
+-    {
+-        auto sequencerUpdater = std::make_shared< SequenceUpdater >(sleepTimeMillis, waitStrategy);
+-        std::thread([=] { sequencerUpdater->run(); }).detach();
+-        sequencerUpdater->waitForStartup();
+-        auto cursor = std::make_shared< Sequence >(0);
+-        auto barrier = std::make_shared< DummySequenceBarrier >();
+-        auto sequence = waitStrategy->waitFor(0, *cursor, *sequencerUpdater->sequence, *barrier);
+-
+-        BOOST_CHECK_EQUAL(sequence, 0L);
+-    }
+-    
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/WaitStrategyTestUtil.h b/Disruptor.Tests/WaitStrategyTestUtil.h
+deleted file mode 100644
+index ecfd00e..0000000
+--- a/Disruptor.Tests/WaitStrategyTestUtil.h
++++ /dev/null
+@@ -1,19 +0,0 @@
+-#pragma once
+-
+-#include <cstdint>
+-#include <memory>
+-
+-
+-namespace Disruptor
+-{
+-
+-    class IWaitStrategy;
+-
+-
+-namespace Tests
+-{
+-
+-    void assertWaitForWithDelayOf(std::int64_t sleepTimeMillis, const std::shared_ptr< IWaitStrategy >& waitStrategy);
+-
+-} // namespace Tests
+-} // namespace Disruptor
+diff --git a/Disruptor.Tests/WorkerPoolTests.cpp b/Disruptor.Tests/WorkerPoolTests.cpp
+deleted file mode 100644
+index 7001770..0000000
+--- a/Disruptor.Tests/WorkerPoolTests.cpp
++++ /dev/null
+@@ -1,110 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "Disruptor/BasicExecutor.h"
+-#include "Disruptor/FatalExceptionHandler.h"
+-#include "Disruptor/RoundRobinThreadAffinedTaskScheduler.h"
+-#include "Disruptor/WorkerPool.h"
+-
+-
+-namespace Disruptor
+-{
+-namespace Tests
+-{
+-    
+-    class AtomicLong
+-    {
+-    public:
+-        AtomicLong() : m_value(0)
+-        {}
+-
+-        AtomicLong(const AtomicLong& other)
+-            : m_value(other.value())
+-        {}
+-
+-        void operator=(const AtomicLong& other)
+-        {
+-            m_value = other.value();
+-        }
+-
+-        std::int64_t value() const
+-        {
+-            return m_value;
+-        }
+-
+-        void increment()
+-        {
+-            ++m_value;
+-        }
+-
+-    private:
+-        std::atomic< std::int64_t > m_value;
+-    };
+-
+-    class AtomicLongWorkHandler : public IWorkHandler< AtomicLong >
+-    {
+-    public:
+-        void onEvent(AtomicLong& evt) override
+-        {
+-            evt.increment();
+-        }
+-    };
+-
+-} // namespace Tests
+-} // namespace Disruptor
+-
+-
+-using namespace Disruptor;
+-using namespace Disruptor::Tests;
+-
+-
+-BOOST_AUTO_TEST_SUITE(WorkerPoolTests)
+-
+-BOOST_AUTO_TEST_CASE(ShouldProcessEachMessageByOnlyOneWorker)
+-{
+-    auto taskScheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
+-    taskScheduler->start(2);
+-
+-    WorkerPool< AtomicLong > pool
+-    (
+-        [] { return AtomicLong(); },
+-        std::make_shared< FatalExceptionHandler< AtomicLong > >(),
+-        { std::make_shared< AtomicLongWorkHandler >(), std::make_shared< AtomicLongWorkHandler >() }
+-    );
+-
+-    auto ringBuffer = pool.start(std::make_shared< BasicExecutor >(taskScheduler));
+-
+-    ringBuffer->next();
+-    ringBuffer->next();
+-    ringBuffer->publish(0);
+-    ringBuffer->publish(1);
+-
+-    std::this_thread::sleep_for(std::chrono::milliseconds(500));
+-
+-    BOOST_CHECK_EQUAL((*ringBuffer)[0].value(), 1L);
+-    BOOST_CHECK_EQUAL((*ringBuffer)[1].value(), 1L);
+-}
+-
+-BOOST_AUTO_TEST_CASE(ShouldProcessOnlyOnceItHasBeenPublished)
+-{
+-    auto taskScheduler = std::make_shared< RoundRobinThreadAffinedTaskScheduler >();
+-    taskScheduler->start(2);
+-
+-    WorkerPool< AtomicLong > pool
+-    (
+-        [] { return AtomicLong(); },
+-        std::make_shared< FatalExceptionHandler< AtomicLong > >(),
+-        { std::make_shared< AtomicLongWorkHandler >(), std::make_shared< AtomicLongWorkHandler >() }
+-    );
+-
+-    auto ringBuffer = pool.start(std::make_shared< BasicExecutor >(taskScheduler));
+-
+-    ringBuffer->next();
+-    ringBuffer->next();
+-
+-    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
+-
+-    BOOST_CHECK_EQUAL((*ringBuffer)[0].value(), 0L);
+-    BOOST_CHECK_EQUAL((*ringBuffer)[1].value(), 0L);
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/YieldingWaitStrategyTests.cpp b/Disruptor.Tests/YieldingWaitStrategyTests.cpp
+deleted file mode 100644
+index eadfaf3..0000000
+--- a/Disruptor.Tests/YieldingWaitStrategyTests.cpp
++++ /dev/null
+@@ -1,18 +0,0 @@
+-#include "stdafx.h"
+-
+-#include "Disruptor/YieldingWaitStrategy.h"
+-#include "WaitStrategyTestUtil.h"
+-
+-
+-using namespace Disruptor;
+-using namespace Disruptor::Tests;
+-
+-
+-BOOST_AUTO_TEST_SUITE(YieldingWaitStrategyTests)
+-
+-BOOST_AUTO_TEST_CASE(ShouldWaitForValue)
+-{
+-    assertWaitForWithDelayOf(50, std::make_shared< YieldingWaitStrategy >());
+-}
+-
+-BOOST_AUTO_TEST_SUITE_END()
+diff --git a/Disruptor.Tests/main.cpp b/Disruptor.Tests/main.cpp
+deleted file mode 100644
+index bacc16a..0000000
+--- a/Disruptor.Tests/main.cpp
++++ /dev/null
+@@ -1,32 +0,0 @@
+-#define BOOST_TEST_MODULE Disruptor.Tests
+-
+-
+-#include <boost/test/unit_test.hpp>
+-#include <boost/test/results_reporter.hpp>
+-
+-#include <gmock/gmock.h>
+-
+-#if _MSC_VER
+-# pragma warning (disable: 4231) // nonstandard extension used : 'extern' before template explicit instantiation
+-#endif
+-
+-struct GlobalFixture
+-{
+-    GlobalFixture()
+-    {
+-        // all passed test names are printed to the output
+-        boost::unit_test::unit_test_log.set_threshold_level(boost::unit_test::log_test_units);
+-        // a very small report is printed to the output (passed tests count / total tests count)
+-        boost::unit_test::results_reporter::set_level(boost::unit_test::SHORT_REPORT);
+-
+-        testing::GTEST_FLAG(throw_on_failure) = true;
+-        testing::InitGoogleMock(&boost::unit_test::framework::master_test_suite().argc, boost::unit_test::framework::master_test_suite().argv);
+-    }
+-
+-    ~GlobalFixture()
+-    {
+-    }
+-};
+-
+-BOOST_GLOBAL_FIXTURE(GlobalFixture);
+-
+diff --git a/Disruptor.Tests/postbuild.bat b/Disruptor.Tests/postbuild.bat
+deleted file mode 100644
+index b04916c..0000000
+--- a/Disruptor.Tests/postbuild.bat
++++ /dev/null
+@@ -1,14 +0,0 @@
+-@setlocal
+-@echo off
+-
+-rem VS post build step command line sample:
+-rem call postbuild.bat $(OutDir) $(Configuration) $(Platform) $(PlatformToolsetVersion)
+-
+-set outdir=%1
+-
+-if not "%TEAMCITY_PROJECT_NAME%" == "" (
+-    echo Running unit tests...
+-    call "%outdir%\disruptor.Tests.exe" --detect_memory_leaks=0 --result_code=no
+-)
+-
+-@endlocal
+diff --git a/Disruptor.Tests/stdafx.cpp b/Disruptor.Tests/stdafx.cpp
+deleted file mode 100644
+index 1f8dac0..0000000
+--- a/Disruptor.Tests/stdafx.cpp
++++ /dev/null
+@@ -1,8 +0,0 @@
+-// stdafx.cpp : source file that includes just the standard includes
+-// disruptorLibTests.pch will be the pre-compiled header
+-// stdafx.obj will contain the pre-compiled type information
+-
+-#include "stdafx.h"
+-
+-// TODO: reference any additional headers you need in STDAFX.H
+-// and not in this file
+diff --git a/Disruptor.Tests/stdafx.h b/Disruptor.Tests/stdafx.h
+deleted file mode 100644
+index fecc537..0000000
+--- a/Disruptor.Tests/stdafx.h
++++ /dev/null
+@@ -1,38 +0,0 @@
+-// stdafx.h : include file for standard system include files,
+-// or project specific include files that are used frequently, but
+-// are changed infrequently
+-//
+-
+-#pragma once
+-
+-#include <boost/config.hpp>
+-
+-// STL
+-#include <algorithm>
+-#include <chrono>
+-#include <cstdint>
+-#include <functional>
+-#include <future>
+-#include <memory>
+-#include <stdexcept>
+-#include <string>
+-#include <thread>
+-#include <typeinfo>
+-#include <unordered_map>
+-#include <vector>
+-
+-// Boost.Test
+-
+-#include "Disruptor/Pragmas.h"
+-
+-DISRUPTOR_PRAGMA_PUSH
+-DISRUPTOR_PRAGMA_IGNORE_ALL
+-DISRUPTOR_PRAGMA_IGNORE_UNUSED_VARIABLES
+-
+-#include <boost/test/results_reporter.hpp>
+-#include <boost/test/unit_test.hpp>
+-
+-DISRUPTOR_PRAGMA_POP
+-
+-// Google Mock
+-#include <gmock/gmock.h>
+diff --git a/Disruptor.Tests/targetver.h b/Disruptor.Tests/targetver.h
+deleted file mode 100644
+index 87c0086..0000000
+--- a/Disruptor.Tests/targetver.h
++++ /dev/null
+@@ -1,8 +0,0 @@
+-#pragma once
+-
+-// Including SDKDDKVer.h defines the highest available Windows platform.
+-
+-// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
+-// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.
+-
+-#include <SDKDDKVer.h>
+diff --git a/Disruptor/CMakeLists.txt b/Disruptor/CMakeLists.txt
+index 6f9bc4f..4e70c90 100644
+--- a/Disruptor/CMakeLists.txt
++++ b/Disruptor/CMakeLists.txt
+@@ -22,6 +22,7 @@ set(Disruptor_sources
+     Sequence.cpp
+     SequenceGroups.cpp
+     SleepingWaitStrategy.cpp
++    SpinCountBackoffWaitStrategy.cpp
+     SpinWait.cpp
+     SpinWaitWaitStrategy.cpp
+     stdafx.cpp
+@@ -100,6 +101,7 @@ set(Disruptor_headers
+     Sequencer.h
+     SingleProducerSequencer.h
+     SleepingWaitStrategy.h
++    SpinCountBackoffWaitStrategy.h
+     SpinWait.h
+     SpinWaitWaitStrategy.h
+     ThreadPerTaskScheduler.h
+diff --git a/Disruptor/SpinCountBackoffWaitStrategy.cpp b/Disruptor/SpinCountBackoffWaitStrategy.cpp
+new file mode 100644
+index 0000000..36a6a4b
+--- /dev/null
++++ b/Disruptor/SpinCountBackoffWaitStrategy.cpp
+@@ -0,0 +1,71 @@
++#include "stdafx.h"
++#include "SpinCountBackoffWaitStrategy.h"
++#include "BlockingWaitStrategy.h"
++
++#include <ostream>
++#include <iostream>
++
++#include "ISequenceBarrier.h"
++#include "Sequence.h"
++
++
++namespace Disruptor
++{
++
++    SpinCountBackoffWaitStrategy::SpinCountBackoffWaitStrategy()
++    {
++        this->SPIN_TRIES = 10000;
++        this->fallbackStrategy = std::make_shared< BlockingWaitStrategy >();
++    }
++
++    SpinCountBackoffWaitStrategy::SpinCountBackoffWaitStrategy(std::uint32_t spinTries,
++                                                               std::shared_ptr<IWaitStrategy> fallbackStrategy)
++    {
++        this->SPIN_TRIES = spinTries;
++        if (spinTries < 1) {
++            this->SPIN_TRIES = 1;
++        }
++
++        this->fallbackStrategy = fallbackStrategy;
++        if (fallbackStrategy == nullptr) {
++            this->fallbackStrategy = std::make_shared< BlockingWaitStrategy >();
++        }
++    }
++
++
++    std::int64_t SpinCountBackoffWaitStrategy::waitFor(std::int64_t sequence,
++                                                       Sequence& cursor,
++                                                       ISequence& dependentSequence,
++                                                       ISequenceBarrier& barrier)
++    {
++        std::int64_t availableSequence;
++        std::uint32_t counter = SPIN_TRIES;
++
++        do {
++            if ((availableSequence = dependentSequence.value()) >= sequence) {
++                return availableSequence;
++            }
++
++            if (0 == --counter) {
++                return fallbackStrategy->waitFor(sequence, cursor, dependentSequence, barrier);
++            }
++            //std::cout << " " <<  counter;
++            barrier.checkAlert();
++            //spinWait.spinOnce();
++
++        } while (true);
++    }
++
++    void SpinCountBackoffWaitStrategy::signalAllWhenBlocking()
++    {
++        fallbackStrategy->signalAllWhenBlocking();
++    }
++
++    void SpinCountBackoffWaitStrategy::writeDescriptionTo(std::ostream& stream) const
++    {
++        stream << "SpinCountBackoffWaitStrategy";
++    }
++
++
++} // namespace Disruptor
++
+diff --git a/Disruptor/SpinCountBackoffWaitStrategy.h b/Disruptor/SpinCountBackoffWaitStrategy.h
+new file mode 100644
+index 0000000..9739551
+--- /dev/null
++++ b/Disruptor/SpinCountBackoffWaitStrategy.h
+@@ -0,0 +1,57 @@
++#pragma once
++
++#include <boost/thread.hpp>
++
++#include "Disruptor/IWaitStrategy.h"
++
++
++namespace Disruptor
++{
++
++    /**
++     * <p>The SpinCountBackoffWait strategy spins for a given number of times then
++     * waits using the configured fallback WaitStrategy.</p>
++     * This combination wait strategy worked well in Java with the fallback being BlockingWaitStrategy,
++     * so that's the default here.
++     *
++     * @author timmer
++     * @date 2/18/2020
++     */
++    class SpinCountBackoffWaitStrategy : public IWaitStrategy
++    {
++
++    public:
++
++        /** Constructor defaulting to 10,000 spins and BlockingWaitStrategy when finished spinning. */
++        SpinCountBackoffWaitStrategy();
++
++        /**
++         * Constructor specifying number of spins and the back up wait strategy it switches to after spinning.
++         * @param spinTries number of spins.
++         * @param fallbackStrategy back up wait strategy.
++         */
++        SpinCountBackoffWaitStrategy(std::uint32_t spinTries, std::shared_ptr<IWaitStrategy> fallbackStrategy);
++
++        /**
++         * \see IWaitStrategy::waitFor
++         */
++        std::int64_t waitFor(std::int64_t sequence,
++                             Sequence& cursor,
++                             ISequence& dependentSequence,
++                             ISequenceBarrier& barrier) override;
++
++        /**
++         * \see IWaitStrategy::signalAllWhenBlocking
++         */
++        void signalAllWhenBlocking() override;
++
++        void writeDescriptionTo(std::ostream& stream) const override;
++
++    private:
++
++        std::uint32_t SPIN_TRIES;
++        std::shared_ptr<IWaitStrategy> fallbackStrategy;
++
++    };
++
++} // namespace Disruptor
