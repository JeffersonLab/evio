<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>evio: evio::EventWriterV4 Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">evio
   &#160;<span id="projectnumber">6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('df/d0c/classevio_1_1_event_writer_v4.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="../../df/df2/classevio_1_1_event_writer_v4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">evio::EventWriterV4 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to write data into a file or buffer in the evio version 4 format.  
 <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d5/d76/_event_writer_v4_8h_source.html">EventWriterV4.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2b4a1dad022c856784e96da451cc7375"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a2b4a1dad022c856784e96da451cc7375">EventWriterV4</a> (std::string &amp;filename, const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;byteOrder=<a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#aa96046df3a55b85a31f2c33e4d903cf1">ByteOrder::nativeOrder</a>(), bool append=false)</td></tr>
<tr class="memdesc:a2b4a1dad022c856784e96da451cc7375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <code><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html" title="Class to write data into a file or buffer in the evio version 4 format.">EventWriterV4</a></code> for writing to a file in the evio 4 format and in the specified byte order.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a2b4a1dad022c856784e96da451cc7375">More...</a><br /></td></tr>
<tr class="separator:a2b4a1dad022c856784e96da451cc7375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905bc3892f25616130a87ca3a6e2b68d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a905bc3892f25616130a87ca3a6e2b68d">EventWriterV4</a> (std::string &amp;filename, const std::string &amp;xmlDictionary, const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;byteOrder=<a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#aa96046df3a55b85a31f2c33e4d903cf1">ByteOrder::nativeOrder</a>(), bool append=false)</td></tr>
<tr class="memdesc:a905bc3892f25616130a87ca3a6e2b68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <code><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html" title="Class to write data into a file or buffer in the evio version 4 format.">EventWriterV4</a></code> for writing to a file in the evio 4 format and in the specified byte order.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a905bc3892f25616130a87ca3a6e2b68d">More...</a><br /></td></tr>
<tr class="separator:a905bc3892f25616130a87ca3a6e2b68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e731b80c9c2253bfc688f9afa43b8ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a2e731b80c9c2253bfc688f9afa43b8ec">EventWriterV4</a> (std::string &amp;baseName, const std::string &amp;directory, const std::string &amp;runType, uint32_t runNumber=1, uint64_t split=0, uint32_t maxBlockSize=<a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a17b6bc167b1261c0c06f0cc655715c95">DEFAULT_BLOCK_SIZE</a>, uint32_t maxEventCount=<a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a62cee800a3d132f0c11e23393c236f7f">DEFAULT_BLOCK_COUNT</a>, const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;byteOrder=<a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#aa96046df3a55b85a31f2c33e4d903cf1">ByteOrder::nativeOrder</a>(), const std::string &amp;xmlDictionary=&quot;&quot;, bool overWriteOK=true, bool append=false, std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt; firstEvent=nullptr, uint32_t streamId=0, uint32_t splitNumber=0, uint32_t splitIncrement=1, uint32_t streamCount=1, size_t bufferSize=<a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#aa0d2dea869028c67fe2fd14a5919579c">DEFAULT_BUFFER_SIZE</a>, std::bitset&lt; 24 &gt; *bitInfo=nullptr)</td></tr>
<tr class="separator:a2e731b80c9c2253bfc688f9afa43b8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2493cca8a8ae2a9bdd004ec4ca0fdc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#abf2493cca8a8ae2a9bdd004ec4ca0fdc">EventWriterV4</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buf, const std::string &amp;xmlDictionary=&quot;&quot;, bool append=false)</td></tr>
<tr class="memdesc:abf2493cca8a8ae2a9bdd004ec4ca0fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <code><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html" title="Class to write data into a file or buffer in the evio version 4 format.">EventWriterV4</a></code> for writing events to a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a>.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#abf2493cca8a8ae2a9bdd004ec4ca0fdc">More...</a><br /></td></tr>
<tr class="separator:abf2493cca8a8ae2a9bdd004ec4ca0fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d47344f6e350fdf431dcceecd3ddd96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a8d47344f6e350fdf431dcceecd3ddd96">EventWriterV4</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buf, int maxBlockSize, int maxEventCount, const std::string &amp;xmlDictionary=&quot;&quot;, std::bitset&lt; 24 &gt; *bitInfo=nullptr, int reserved1=0, int blockNumber=1, bool append=false, std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt; firstEvent=nullptr)</td></tr>
<tr class="memdesc:a8d47344f6e350fdf431dcceecd3ddd96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <code><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html" title="Class to write data into a file or buffer in the evio version 4 format.">EventWriterV4</a></code> for writing events to a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a>.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a8d47344f6e350fdf431dcceecd3ddd96">More...</a><br /></td></tr>
<tr class="separator:a8d47344f6e350fdf431dcceecd3ddd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b07d5885fc446ec0a3ad775a5b093a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a03b07d5885fc446ec0a3ad775a5b093a">isDiskFull</a> () const</td></tr>
<tr class="memdesc:a03b07d5885fc446ec0a3ad775a5b093a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If writing file, is the partition it resides on full? Not full, in this context, means there's enough space to write a full split file + a full record + an extra 10MB as a safety factor.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a03b07d5885fc446ec0a3ad775a5b093a">More...</a><br /></td></tr>
<tr class="separator:a03b07d5885fc446ec0a3ad775a5b093a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3629be1b7550fccf880290db03ddba"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a2a3629be1b7550fccf880290db03ddba">getBytesWrittenToBuffer</a> () const</td></tr>
<tr class="memdesc:a2a3629be1b7550fccf880290db03ddba"><td class="mdescLeft">&#160;</td><td class="mdescRight">If writing to a buffer, get the number of bytes written to it including the ending header.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a2a3629be1b7550fccf880290db03ddba">More...</a><br /></td></tr>
<tr class="separator:a2a3629be1b7550fccf880290db03ddba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9f3811f6ff8a36b8277f349031f743"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a2c9f3811f6ff8a36b8277f349031f743">setBuffer</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buf, std::bitset&lt; 24 &gt; *bitInfo, int blockNumber)</td></tr>
<tr class="memdesc:a2c9f3811f6ff8a36b8277f349031f743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the buffer being written into (initially set in constructor).  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a2c9f3811f6ff8a36b8277f349031f743">More...</a><br /></td></tr>
<tr class="separator:a2c9f3811f6ff8a36b8277f349031f743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d32d1ab29cefe8782188481c311770"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a21d32d1ab29cefe8782188481c311770">setBuffer</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;buf)</td></tr>
<tr class="memdesc:a21d32d1ab29cefe8782188481c311770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the buffer being written into (initially set in constructor).  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a21d32d1ab29cefe8782188481c311770">More...</a><br /></td></tr>
<tr class="separator:a21d32d1ab29cefe8782188481c311770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b8637fd2229a549bac6b6eb99d81a5"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a59b8637fd2229a549bac6b6eb99d81a5">getByteBuffer</a> ()</td></tr>
<tr class="memdesc:a59b8637fd2229a549bac6b6eb99d81a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If writing to a file, return null.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a59b8637fd2229a549bac6b6eb99d81a5">More...</a><br /></td></tr>
<tr class="separator:a59b8637fd2229a549bac6b6eb99d81a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b22f75ba8069135f5676c16039ff875"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a4b22f75ba8069135f5676c16039ff875">isToFile</a> () const</td></tr>
<tr class="memdesc:a4b22f75ba8069135f5676c16039ff875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this object writing to file?  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a4b22f75ba8069135f5676c16039ff875">More...</a><br /></td></tr>
<tr class="separator:a4b22f75ba8069135f5676c16039ff875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e51d7875f3b98e97f0bd09b72ddfed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a82e51d7875f3b98e97f0bd09b72ddfed">isClosed</a> ()</td></tr>
<tr class="memdesc:a82e51d7875f3b98e97f0bd09b72ddfed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a497299886fb4462fa1d4c849acc9f710">close()</a> been called (without reopening by calling <a class="el" href="../../">setBuffer(std::shared_ptr&lt;ByteBuffer&gt;)</a>) ?  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a82e51d7875f3b98e97f0bd09b72ddfed">More...</a><br /></td></tr>
<tr class="separator:a82e51d7875f3b98e97f0bd09b72ddfed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af598c6c8bfabd8900b62b5cea0c2018b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#af598c6c8bfabd8900b62b5cea0c2018b">getCurrentFilename</a> () const</td></tr>
<tr class="memdesc:af598c6c8bfabd8900b62b5cea0c2018b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the current file being written to.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#af598c6c8bfabd8900b62b5cea0c2018b">More...</a><br /></td></tr>
<tr class="separator:af598c6c8bfabd8900b62b5cea0c2018b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55fbf92a394ca80bebeaa8f374a9fe0c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a55fbf92a394ca80bebeaa8f374a9fe0c">getCurrentFilePath</a> () const</td></tr>
<tr class="memdesc:a55fbf92a394ca80bebeaa8f374a9fe0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the full or absolute name or path of the current file being written to.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a55fbf92a394ca80bebeaa8f374a9fe0c">More...</a><br /></td></tr>
<tr class="separator:a55fbf92a394ca80bebeaa8f374a9fe0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2127029f34c77d41fbaa5142c31336d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#af2127029f34c77d41fbaa5142c31336d">getSplitNumber</a> () const</td></tr>
<tr class="memdesc:af2127029f34c77d41fbaa5142c31336d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current split count which is the number of files created by this object.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#af2127029f34c77d41fbaa5142c31336d">More...</a><br /></td></tr>
<tr class="separator:af2127029f34c77d41fbaa5142c31336d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e306e78aafb16378748608e8a8d5e2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a54e306e78aafb16378748608e8a8d5e2">getSplitCount</a> () const</td></tr>
<tr class="memdesc:a54e306e78aafb16378748608e8a8d5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of split files produced by this writer.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a54e306e78aafb16378748608e8a8d5e2">More...</a><br /></td></tr>
<tr class="separator:a54e306e78aafb16378748608e8a8d5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87f296c4b8b9a3a19bf536f841bbc8c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#ab87f296c4b8b9a3a19bf536f841bbc8c">getBlockNumber</a> () const</td></tr>
<tr class="memdesc:ab87f296c4b8b9a3a19bf536f841bbc8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current block number.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#ab87f296c4b8b9a3a19bf536f841bbc8c">More...</a><br /></td></tr>
<tr class="separator:ab87f296c4b8b9a3a19bf536f841bbc8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e2ebea6b986399ac80bc886f40a89c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a36e2ebea6b986399ac80bc886f40a89c">getEventsWritten</a> () const</td></tr>
<tr class="memdesc:a36e2ebea6b986399ac80bc886f40a89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of events written to a file/buffer.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a36e2ebea6b986399ac80bc886f40a89c">More...</a><br /></td></tr>
<tr class="separator:a36e2ebea6b986399ac80bc886f40a89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa274490aa610f017cc059694f8c38c6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#aa274490aa610f017cc059694f8c38c6e">getByteOrder</a> () const</td></tr>
<tr class="memdesc:aa274490aa610f017cc059694f8c38c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the byte order of the buffer/file being written into.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#aa274490aa610f017cc059694f8c38c6e">More...</a><br /></td></tr>
<tr class="separator:aa274490aa610f017cc059694f8c38c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e67ab48bd30fb2c7715728eac29257"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#af1e67ab48bd30fb2c7715728eac29257">setStartingBlockNumber</a> (int startingBlockNumber)</td></tr>
<tr class="memdesc:af1e67ab48bd30fb2c7715728eac29257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number with which to start block numbers.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#af1e67ab48bd30fb2c7715728eac29257">More...</a><br /></td></tr>
<tr class="separator:af1e67ab48bd30fb2c7715728eac29257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0168f51f1b2fb153a255a0fff7b24417"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a0168f51f1b2fb153a255a0fff7b24417">setFirstEvent</a> (std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; node)</td></tr>
<tr class="memdesc:a0168f51f1b2fb153a255a0fff7b24417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an event which will be written to the file/buffer as well as to all split files.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a0168f51f1b2fb153a255a0fff7b24417">More...</a><br /></td></tr>
<tr class="separator:a0168f51f1b2fb153a255a0fff7b24417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b90425e7b02f6c200cab03704834073"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a5b90425e7b02f6c200cab03704834073">setFirstEvent</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; buffer)</td></tr>
<tr class="memdesc:a5b90425e7b02f6c200cab03704834073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an event which will be written to the file/buffer as well as to all split files.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a5b90425e7b02f6c200cab03704834073">More...</a><br /></td></tr>
<tr class="separator:a5b90425e7b02f6c200cab03704834073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff8ab0434a0d9ff0e651fad97a97e4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a2ff8ab0434a0d9ff0e651fad97a97e4d">setFirstEvent</a> (std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt; bank)</td></tr>
<tr class="memdesc:a2ff8ab0434a0d9ff0e651fad97a97e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an event which will be written to the file/buffer as well as to all split files.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a2ff8ab0434a0d9ff0e651fad97a97e4d">More...</a><br /></td></tr>
<tr class="separator:a2ff8ab0434a0d9ff0e651fad97a97e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f1935c2e06346336180b97397b1e3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#ab9f1935c2e06346336180b97397b1e3b">flush</a> ()</td></tr>
<tr class="memdesc:ab9f1935c2e06346336180b97397b1e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method flushes any remaining internally buffered data to file.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#ab9f1935c2e06346336180b97397b1e3b">More...</a><br /></td></tr>
<tr class="separator:ab9f1935c2e06346336180b97397b1e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497299886fb4462fa1d4c849acc9f710"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a497299886fb4462fa1d4c849acc9f710">close</a> ()</td></tr>
<tr class="memdesc:a497299886fb4462fa1d4c849acc9f710"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method flushes any remaining data to file and disables this object.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a497299886fb4462fa1d4c849acc9f710">More...</a><br /></td></tr>
<tr class="separator:a497299886fb4462fa1d4c849acc9f710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f4f904b3129de05f6fe4dbc9ff31c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a52f4f904b3129de05f6fe4dbc9ff31c5">hasRoom</a> (size_t bytes)</td></tr>
<tr class="memdesc:a52f4f904b3129de05f6fe4dbc9ff31c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is there room to write this many bytes to an output buffer as a single event? Will always return true when writing to a file.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a52f4f904b3129de05f6fe4dbc9ff31c5">More...</a><br /></td></tr>
<tr class="separator:a52f4f904b3129de05f6fe4dbc9ff31c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45ed6d74ee62f9c3e489ac8ea06c7c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#aa45ed6d74ee62f9c3e489ac8ea06c7c7">writeEvent</a> (std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; &amp;node, bool force, bool duplicate=true)</td></tr>
<tr class="memdesc:aa45ed6d74ee62f9c3e489ac8ea06c7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an event (bank) to the buffer in evio version 4 format.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#aa45ed6d74ee62f9c3e489ac8ea06c7c7">More...</a><br /></td></tr>
<tr class="separator:aa45ed6d74ee62f9c3e489ac8ea06c7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8cfc0ced1c087fca4cd132be0b6d17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#aad8cfc0ced1c087fca4cd132be0b6d17">writeEventToFile</a> (std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; &amp;node, bool force, bool duplicate)</td></tr>
<tr class="memdesc:aad8cfc0ced1c087fca4cd132be0b6d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an event (bank) into a record and eventually to a file in evio version 4 format.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#aad8cfc0ced1c087fca4cd132be0b6d17">More...</a><br /></td></tr>
<tr class="separator:aad8cfc0ced1c087fca4cd132be0b6d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8848111b6ae3982b5d817072701b77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a4d8848111b6ae3982b5d817072701b77">writeEvent</a> (std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;bankBuffer, bool force=false)</td></tr>
<tr class="memdesc:a4d8848111b6ae3982b5d817072701b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an event (bank) to the buffer in evio version 4 format.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a4d8848111b6ae3982b5d817072701b77">More...</a><br /></td></tr>
<tr class="separator:a4d8848111b6ae3982b5d817072701b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c923dc7e40047a7d5734126c7a41867"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a7c923dc7e40047a7d5734126c7a41867">writeEvent</a> (std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt; bank, bool force=false)</td></tr>
<tr class="memdesc:a7c923dc7e40047a7d5734126c7a41867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an event (bank) to a buffer containing evio version 4 format blocks.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a7c923dc7e40047a7d5734126c7a41867">More...</a><br /></td></tr>
<tr class="separator:a7c923dc7e40047a7d5734126c7a41867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a60f2e6b593beb1b924d441daf1b7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a91a60f2e6b593beb1b924d441daf1b7d">writeEventToFile</a> (std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt; bank, std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; bankBuffer, bool force)</td></tr>
<tr class="memdesc:a91a60f2e6b593beb1b924d441daf1b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an event (bank) into a block and eventually to a file in evio version 4 format.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a91a60f2e6b593beb1b924d441daf1b7d">More...</a><br /></td></tr>
<tr class="separator:a91a60f2e6b593beb1b924d441daf1b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a17b6bc167b1261c0c06f0cc655715c95"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a17b6bc167b1261c0c06f0cc655715c95">DEFAULT_BLOCK_SIZE</a> = 16777216</td></tr>
<tr class="memdesc:a17b6bc167b1261c0c06f0cc655715c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default maximum size, in bytes, for a single block used for writing.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a17b6bc167b1261c0c06f0cc655715c95">More...</a><br /></td></tr>
<tr class="separator:a17b6bc167b1261c0c06f0cc655715c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cee800a3d132f0c11e23393c236f7f"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a62cee800a3d132f0c11e23393c236f7f">DEFAULT_BLOCK_COUNT</a> = 10000</td></tr>
<tr class="memdesc:a62cee800a3d132f0c11e23393c236f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default maximum event count for a single block used for writing.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a62cee800a3d132f0c11e23393c236f7f">More...</a><br /></td></tr>
<tr class="separator:a62cee800a3d132f0c11e23393c236f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d2dea869028c67fe2fd14a5919579c"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#aa0d2dea869028c67fe2fd14a5919579c">DEFAULT_BUFFER_SIZE</a> = <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a17b6bc167b1261c0c06f0cc655715c95">DEFAULT_BLOCK_SIZE</a> + 1024</td></tr>
<tr class="memdesc:aa0d2dea869028c67fe2fd14a5919579c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default byte size of internal buffer.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#aa0d2dea869028c67fe2fd14a5919579c">More...</a><br /></td></tr>
<tr class="separator:aa0d2dea869028c67fe2fd14a5919579c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0f99e38765850c6b751d34d4dbe792a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a0f99e38765850c6b751d34d4dbe792a5">examineFirstBlockHeader</a> ()</td></tr>
<tr class="memdesc:a0f99e38765850c6b751d34d4dbe792a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads part of the first block (physical record) header in order to determine the evio version # and endianness of the file or buffer in question.  <a href="../../df/d0c/classevio_1_1_event_writer_v4.html#a0f99e38765850c6b751d34d4dbe792a5">More...</a><br /></td></tr>
<tr class="separator:a0f99e38765850c6b751d34d4dbe792a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to write data into a file or buffer in the evio version 4 format. </p>
<p>This is included so that CODA DAQ systems can avoid using the cumbersome evio version 6 format. This class is not thread-safe.</p>
<dl class="section author"><dt>Author</dt><dd>Carl Timmer. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>5/14/24. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2b4a1dad022c856784e96da451cc7375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4a1dad022c856784e96da451cc7375">&#9670;&nbsp;</a></span>EventWriterV4() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">evio::EventWriterV4::EventWriterV4 </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>byteOrder</em> = <code><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#aa96046df3a55b85a31f2c33e4d903cf1">ByteOrder::nativeOrder</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>append</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <code><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html" title="Class to write data into a file or buffer in the evio version 4 format.">EventWriterV4</a></code> for writing to a file in the evio 4 format and in the specified byte order. </p>
<p>If the file already exists, its contents will be overwritten unless it is being appended to. If it doesn't exist, it will be created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>name of the file to write to.<br  />
 </td></tr>
    <tr><td class="paramname">append</td><td>if <code>true</code> and the file already exists, all events to be written will be appended to the end of the file. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>the byte order in which to write the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>file cannot be created, or if appending and file is too small to be evio format; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a905bc3892f25616130a87ca3a6e2b68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905bc3892f25616130a87ca3a6e2b68d">&#9670;&nbsp;</a></span>EventWriterV4() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">evio::EventWriterV4::EventWriterV4 </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xmlDictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>byteOrder</em> = <code><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#aa96046df3a55b85a31f2c33e4d903cf1">ByteOrder::nativeOrder</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>append</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an <code><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html" title="Class to write data into a file or buffer in the evio version 4 format.">EventWriterV4</a></code> for writing to a file in the evio 4 format and in the specified byte order. </p>
<p>If the file already exists, its contents will be overwritten unless it is being appended to. If it doesn't exist, it will be created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the file object to write to.<br  />
 </td></tr>
    <tr><td class="paramname">xmlDictionary</td><td>dictionary in xml format or empty if none. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>the byte order in which to write the file. </td></tr>
    <tr><td class="paramname">append</td><td>if <code>true</code> and the file already exists, all events to be written will be appended to the end of the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>file cannot be created, or if appending and file is too small to be evio format; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e731b80c9c2253bfc688f9afa43b8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e731b80c9c2253bfc688f9afa43b8ec">&#9670;&nbsp;</a></span>EventWriterV4() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">evio::EventWriterV4::EventWriterV4 </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>runType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>runNumber</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>split</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxBlockSize</em> = <code><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a17b6bc167b1261c0c06f0cc655715c95">DEFAULT_BLOCK_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxEventCount</em> = <code><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a62cee800a3d132f0c11e23393c236f7f">DEFAULT_BLOCK_COUNT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> &amp;&#160;</td>
          <td class="paramname"><em>byteOrder</em> = <code><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#aa96046df3a55b85a31f2c33e4d903cf1">ByteOrder::nativeOrder</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xmlDictionary</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overWriteOK</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>append</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt;&#160;</td>
          <td class="paramname"><em>firstEvent</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>streamId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>splitNumber</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>splitIncrement</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>streamCount</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em> = <code><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#aa0d2dea869028c67fe2fd14a5919579c">DEFAULT_BUFFER_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::bitset&lt; 24 &gt; *&#160;</td>
          <td class="paramname"><em>bitInfo</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an <code><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html" title="Class to write data into a file or buffer in the evio version 4 format.">EventWriterV4</a></code> for writing events to a file or files in the evio 4 format. If the given file already exists, its contents will be overwritten unless the "overWriteOK" argument is <code>false</code> in which case an exception will be thrown. If the option to "append" these events to an existing file is <code>true</code>, then the write proceeds. If the file doesn't exist, it will be created.</p>
<p>In order to keep files from getting too large, there is an option to continue writing but to multiple files instead of just one. That is, when a file gets to the size given by the "split" arg, it is closed and another is opened, with new writes going to the new file. The trick in this case is to automatically name the new files.</p>
<p>The baseName arg is the base string from which a final file name or names can be created. The baseName may contain up to 3, C-style integer format specifiers using "d" and "x" (such as <b>%03d</b>, or <b>x</b>). These specifiers dictate how the runNumber, streamId and splitNumber arguments are inserted into the filename.</p>
<p>If there are multiple streams of data each writing a file, to avoid ending up with the same file name, they can be differentiated by a stream id. Run number can differentiate data files from different runs of the same experiment. And of course, the split number tracks the number of files automatically created by this <a class="el" href="../../d9/dcd/classevio_1_1_event_writer.html" title="An EventWriter object is used for writing events to a file or to a byte buffer.">EventWriter</a> object and is incremented at each split.</p>
<p>Back to the format specifiers, if more than 3 are found, an exception will be thrown. If no "0" precedes any integer between the "%" and the "d" or "x" of the format specifier, it will be added automatically in order to avoid spaces in the returned string. See the documentation at <a class="el" href="../../d3/d87/classevio_1_1_util.html#a76482198f230e3afadbb65d1e6feedd9">Util::generateFileName</a> to understand exactly how substitutions of runNumber, streamId and splitNumber are done for these specifiers in order to create the split file names.</p>
<p>In addition, the baseName may contain characters of the form <b>$(ENV_VAR)</b> which will be substituted with the value of the associated environmental variable or a blank string if none is found.</p>
<p>Finally, the baseName may contain occurrences of the string "%s" which will be substituted with the value of the runType arg or nothing if the runType is null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseName</td><td>base file name used to generate complete file name (may not be empty) </td></tr>
    <tr><td class="paramname">directory</td><td>directory in which file is to be placed </td></tr>
    <tr><td class="paramname">runType</td><td>name of run type configuration to be used in naming files </td></tr>
    <tr><td class="paramname">runNumber</td><td>number of the CODA run, used in naming files </td></tr>
    <tr><td class="paramname">split</td><td>if &lt; 1, do not split file, write to only one file of unlimited size. Else this is max size in bytes to make a file before closing it and starting writing another. </td></tr>
    <tr><td class="paramname">maxBlockSize</td><td>the max blocksize in bytes to use which must be &gt;= #MIN_BLOCK_SIZE and &lt;= #MAX_BLOCK_SIZE. The size of the block will not be larger than this size unless a single event itself is larger. </td></tr>
    <tr><td class="paramname">maxEventCount</td><td>the max number of events (including dictionary) in a single block which must be &gt;= #MIN_BLOCK_COUNT and &lt;= #MAX_BLOCK_COUNT. </td></tr>
    <tr><td class="paramname">byteOrder</td><td>the byte order in which to write the file. This is ignored if appending to existing file. </td></tr>
    <tr><td class="paramname">xmlDictionary</td><td>dictionary in xml format or empty if none. </td></tr>
    <tr><td class="paramname">overWriteOK</td><td>if <code>false</code> and the file already exists, an exception is thrown rather than overwriting it. </td></tr>
    <tr><td class="paramname">append</td><td>if <code>true</code> append written data to given file. </td></tr>
    <tr><td class="paramname">firstEvent</td><td>the first event written into each file (after any dictionary) including all split files; may be null. Useful for adding common, static info into each split file. </td></tr>
    <tr><td class="paramname">streamId</td><td>streamId number (100 &gt; id &gt; -1) for file name </td></tr>
    <tr><td class="paramname">splitNumber</td><td>number at which to start the split numbers </td></tr>
    <tr><td class="paramname">splitIncrement</td><td>amount to increment split number each time another file is created. </td></tr>
    <tr><td class="paramname">streamCount</td><td>total number of streams in DAQ. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>number of bytes to make the internal buffer which will be storing events before writing them to a file. Must be at least a max block size + 1kB (add a little extra). If not, it is set to that. </td></tr>
    <tr><td class="paramname">bitInfo</td><td>set of bits to include in first block header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if defined dictionary or first event while appending; if splitting file while appending; if appending and file is too small to be evio format; if file name arg is empty; if file could not be opened, positioned, or written to; if file exists but user requested no over-writing or appending. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a0f99e38765850c6b751d34d4dbe792a5">examineFirstBlockHeader()</a>, <a class="el" href="../../d3/d87/classevio_1_1_util.html#a542fb63b5849885087ac24795604b4b6">evio::Util::generateBaseFileName()</a>, <a class="el" href="../../d3/d87/classevio_1_1_util.html#a76482198f230e3afadbb65d1e6feedd9">evio::Util::generateFileName()</a>, and <a class="el" href="../../d9/ddd/classevio_1_1_base_structure.html#adc7c9d3969d7e561016ba76dded03058">evio::BaseStructure::stringsToRawBytes()</a>.</p>

</div>
</div>
<a id="abf2493cca8a8ae2a9bdd004ec4ca0fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2493cca8a8ae2a9bdd004ec4ca0fdc">&#9670;&nbsp;</a></span>EventWriterV4() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">evio::EventWriterV4::EventWriterV4 </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xmlDictionary</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>append</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <code><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html" title="Class to write data into a file or buffer in the evio version 4 format.">EventWriterV4</a></code> for writing events to a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a>. </p>
<p>Uses the default number and size of blocks in buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer to write to. </td></tr>
    <tr><td class="paramname">xmlDictionary</td><td>dictionary in xml format or null if none. </td></tr>
    <tr><td class="paramname">append</td><td>if <code>true</code>, all events to be written will be appended to the end of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if appending and buffer is too small to be evio format; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d47344f6e350fdf431dcceecd3ddd96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d47344f6e350fdf431dcceecd3ddd96">&#9670;&nbsp;</a></span>EventWriterV4() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">evio::EventWriterV4::EventWriterV4 </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxBlockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxEventCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xmlDictionary</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::bitset&lt; 24 &gt; *&#160;</td>
          <td class="paramname"><em>bitInfo</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reserved1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockNumber</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>append</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt;&#160;</td>
          <td class="paramname"><em>firstEvent</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <code><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html" title="Class to write data into a file or buffer in the evio version 4 format.">EventWriterV4</a></code> for writing events to a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer to write to. </td></tr>
    <tr><td class="paramname">maxBlockSize</td><td>the max blocksize to use which must be &gt;= #MIN_BLOCK_SIZE and &lt;= #MAX_BLOCK_SIZE ints. The size of the block will not be larger than this size unless a single event itself is larger. </td></tr>
    <tr><td class="paramname">maxEventCount</td><td>the max number of events (including dictionary) in a single block which must be &gt;= #MIN_BLOCK_COUNT and &lt;= #MAX_BLOCK_COUNT. </td></tr>
    <tr><td class="paramname">xmlDictionary</td><td>dictionary in xml format or null if none. </td></tr>
    <tr><td class="paramname">bitInfo</td><td>set of bits to include in first block header. </td></tr>
    <tr><td class="paramname">reserved1</td><td>set the value of the first "reserved" int in first block header. NOTE: only CODA (i.e. EMU) software should use this. </td></tr>
    <tr><td class="paramname">blockNumber</td><td>number at which to start block number counting. </td></tr>
    <tr><td class="paramname">append</td><td>if <code>true</code>, all events to be written will be appended to the end of the buffer. </td></tr>
    <tr><td class="paramname">firstEvent</td><td>the first event written into the buffer (after any dictionary). May be null. Not useful when writing to a buffer as this event may be written using normal means.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if maxBlockSize or maxEventCount exceed limits; if appending and buffer is too small to be evio format; if defined dictionary while appending; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a497299886fb4462fa1d4c849acc9f710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497299886fb4462fa1d4c849acc9f710">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::EventWriterV4::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method flushes any remaining data to file and disables this object. </p>
<p>May not call this when simultaneously calling writeEvent, flush, setFirstEvent, or getByteBuffer. </p>

</div>
</div>
<a id="a0f99e38765850c6b751d34d4dbe792a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f99e38765850c6b751d34d4dbe792a5">&#9670;&nbsp;</a></span>examineFirstBlockHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evio::EventWriterV4::examineFirstBlockHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads part of the first block (physical record) header in order to determine the evio version # and endianness of the file or buffer in question. </p>
<p>These things do <b>not</b> need to be examined in subsequent block headers.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if error reading file; if not in append mode; if file has bad format; </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#aa11600b2ff36c44d7f2f8e345cfc937d">evio::ByteOrder::ENDIAN_BIG</a>, <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#ae70d8b2df728e3776bb6bb843260bb71">evio::ByteOrder::ENDIAN_LITTLE</a>, <a class="el" href="../../da/de6/classevio_1_1_block_header_v4.html#abc0c1d6d1a27c74236526107da15d131">evio::BlockHeaderV4::hasDictionary()</a>, <a class="el" href="../../d5/d6e/classevio_1_1_i_block_header.html#ac5f22d640a8987649db4fd4c8c699cb7">evio::IBlockHeader::MAGIC_NUMBER</a>, and <a class="el" href="../../d8/d26/_evio_exception_8h.html#a2e2c24f4a58e1cf35ab7fab80e69025a">throwEvioLine</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a2e731b80c9c2253bfc688f9afa43b8ec">EventWriterV4()</a>.</p>

</div>
</div>
<a id="ab9f1935c2e06346336180b97397b1e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f1935c2e06346336180b97397b1e3b">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::EventWriterV4::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method flushes any remaining internally buffered data to file. </p>
<p>Calling <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a497299886fb4462fa1d4c849acc9f710">close()</a> automatically does this so it isn't necessary to call before closing. This method should only be used when writing events at such a low rate that it takes an inordinate amount of time for internally buffered data to be written to the file.</p>
<p>Calling this can kill performance. May not call this when simultaneously calling writeEvent, close, setFirstEvent, or getByteBuffer. </p>

</div>
</div>
<a id="ab87f296c4b8b9a3a19bf536f841bbc8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87f296c4b8b9a3a19bf536f841bbc8c">&#9670;&nbsp;</a></span>getBlockNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::EventWriterV4::getBlockNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current block number. </p>
<p>Warning, this value may be changing. </p><dl class="section return"><dt>Returns</dt><dd>the current block number. </dd></dl>

</div>
</div>
<a id="a59b8637fd2229a549bac6b6eb99d81a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b8637fd2229a549bac6b6eb99d81a5">&#9670;&nbsp;</a></span>getByteBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; evio::EventWriterV4::getByteBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If writing to a file, return null. </p>
<p>If writing to a buffer, get a duplicate of the user-given buffer being written into. The buffer's position will be 0 and its limit will be the size of the valid data. Basically, it's ready to be read from. The returned buffer shares data with the original buffer but has separate limit, position, and mark. Useful if trying to send buffer over the network. Do not call this while simultaneously calling close, flush, setFirstEvent, or writeEvent.</p>
<dl class="section return"><dt>Returns</dt><dd>buffer being written into, made ready for reading; null if writing to file </dd></dl>

<p class="reference">References <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a4b22f75ba8069135f5676c16039ff875">isToFile()</a>.</p>

</div>
</div>
<a id="aa274490aa610f017cc059694f8c38c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa274490aa610f017cc059694f8c38c6e">&#9670;&nbsp;</a></span>getByteOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d7d/classevio_1_1_byte_order.html">ByteOrder</a> evio::EventWriterV4::getByteOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the byte order of the buffer/file being written into. </p>
<dl class="section return"><dt>Returns</dt><dd>byte order of the buffer/file being written into. </dd></dl>

</div>
</div>
<a id="a2a3629be1b7550fccf880290db03ddba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3629be1b7550fccf880290db03ddba">&#9670;&nbsp;</a></span>getBytesWrittenToBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t evio::EventWriterV4::getBytesWrittenToBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If writing to a buffer, get the number of bytes written to it including the ending header. </p>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to buffer </dd></dl>

</div>
</div>
<a id="af598c6c8bfabd8900b62b5cea0c2018b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af598c6c8bfabd8900b62b5cea0c2018b">&#9670;&nbsp;</a></span>getCurrentFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string evio::EventWriterV4::getCurrentFilename </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the current file being written to. </p>
<p>Returns empty string if no file. </p><dl class="section return"><dt>Returns</dt><dd>the name of the current file being written to. </dd></dl>

</div>
</div>
<a id="a55fbf92a394ca80bebeaa8f374a9fe0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55fbf92a394ca80bebeaa8f374a9fe0c">&#9670;&nbsp;</a></span>getCurrentFilePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string evio::EventWriterV4::getCurrentFilePath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the full or absolute name or path of the current file being written to. </p>
<p>Returns empty string if no file. </p><dl class="section return"><dt>Returns</dt><dd>the absolute name or path of the current file being written to. </dd></dl>

</div>
</div>
<a id="a36e2ebea6b986399ac80bc886f40a89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e2ebea6b986399ac80bc886f40a89c">&#9670;&nbsp;</a></span>getEventsWritten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::EventWriterV4::getEventsWritten </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of events written to a file/buffer. </p>
<p>Remember that a particular event may not yet be flushed to the file/buffer. If the file being written to is split, the returned value refers to all split files taken together.</p>
<dl class="section return"><dt>Returns</dt><dd>number of events written to a file/buffer. </dd></dl>

</div>
</div>
<a id="a54e306e78aafb16378748608e8a8d5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e306e78aafb16378748608e8a8d5e2">&#9670;&nbsp;</a></span>getSplitCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::EventWriterV4::getSplitCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of split files produced by this writer. </p>
<dl class="section return"><dt>Returns</dt><dd>number of split files produced by this writer. </dd></dl>

</div>
</div>
<a id="af2127029f34c77d41fbaa5142c31336d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2127029f34c77d41fbaa5142c31336d">&#9670;&nbsp;</a></span>getSplitNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t evio::EventWriterV4::getSplitNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current split count which is the number of files created by this object. </p>
<p>Warning, this value may be changing. </p><dl class="section return"><dt>Returns</dt><dd>the current split count which is the number of files created by this object. </dd></dl>

</div>
</div>
<a id="a52f4f904b3129de05f6fe4dbc9ff31c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f4f904b3129de05f6fe4dbc9ff31c5">&#9670;&nbsp;</a></span>hasRoom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::EventWriterV4::hasRoom </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is there room to write this many bytes to an output buffer as a single event? Will always return true when writing to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>number of bytes to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><div class="fragment"><div class="line"><span class="keyword">true</span> </div>
</div><!-- fragment --> if there still room in the output buffer, else<div class="fragment"><div class="line"><span class="keyword">false</span> </div>
</div><!-- fragment --> . </dd></dl>

<p class="reference">References <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a4b22f75ba8069135f5676c16039ff875">isToFile()</a>.</p>

</div>
</div>
<a id="a82e51d7875f3b98e97f0bd09b72ddfed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e51d7875f3b98e97f0bd09b72ddfed">&#9670;&nbsp;</a></span>isClosed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::EventWriterV4::isClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Has <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a497299886fb4462fa1d4c849acc9f710">close()</a> been called (without reopening by calling <a class="el" href="../../">setBuffer(std::shared_ptr&lt;ByteBuffer&gt;)</a>) ? </p>
<dl class="section return"><dt>Returns</dt><dd><div class="fragment"><div class="line"><span class="keyword">true</span> </div>
</div><!-- fragment --> if this object closed, else<div class="fragment"><div class="line"><span class="keyword">false</span> </div>
</div><!-- fragment --> . </dd></dl>

</div>
</div>
<a id="a03b07d5885fc446ec0a3ad775a5b093a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b07d5885fc446ec0a3ad775a5b093a">&#9670;&nbsp;</a></span>isDiskFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::EventWriterV4::isDiskFull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If writing file, is the partition it resides on full? Not full, in this context, means there's enough space to write a full split file + a full record + an extra 10MB as a safety factor. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the partition the file resides on is full, else false. </dd></dl>

</div>
</div>
<a id="a4b22f75ba8069135f5676c16039ff875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b22f75ba8069135f5676c16039ff875">&#9670;&nbsp;</a></span>isToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::EventWriterV4::isToFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this object writing to file? </p>
<dl class="section return"><dt>Returns</dt><dd><div class="fragment"><div class="line"><span class="keyword">true</span> </div>
</div><!-- fragment --> if writing to file, else<div class="fragment"><div class="line"><span class="keyword">false</span> </div>
</div><!-- fragment --> . </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a59b8637fd2229a549bac6b6eb99d81a5">getByteBuffer()</a>, and <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a52f4f904b3129de05f6fe4dbc9ff31c5">hasRoom()</a>.</p>

</div>
</div>
<a id="a21d32d1ab29cefe8782188481c311770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d32d1ab29cefe8782188481c311770">&#9670;&nbsp;</a></span>setBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::EventWriterV4::setBuffer </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the buffer being written into (initially set in constructor). </p>
<p>This method allows the user to avoid having to create a new <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html" title="Class to write data into a file or buffer in the evio version 4 format.">EventWriterV4</a> each time a bank needs to be written to a different buffer. This does nothing if writing to a file. Not for use if appending.</p>
<p>Do <b>not</b> use this method unless you know what you are doing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer to write to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if this object was not closed prior to resetting the buffer, buffer arg is null, or in appending mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c9f3811f6ff8a36b8277f349031f743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9f3811f6ff8a36b8277f349031f743">&#9670;&nbsp;</a></span>setBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::EventWriterV4::setBuffer </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::bitset&lt; 24 &gt; *&#160;</td>
          <td class="paramname"><em>bitInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the buffer being written into (initially set in constructor). </p>
<p>This method allows the user to avoid having to create a new <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html" title="Class to write data into a file or buffer in the evio version 4 format.">EventWriterV4</a> each time a bank needs to be written to a different buffer. This does nothing if writing to a file. Not for use if appending.</p>
<p>Do <b>not</b> use this method unless you know what you are doing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer to write to. </td></tr>
    <tr><td class="paramname">bitInfo</td><td>set of bits to include in first block header. </td></tr>
    <tr><td class="paramname">blockNumber</td><td>number at which to start block number counting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if this object was not closed prior to resetting the buffer, buffer arg is null, or in appending mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b90425e7b02f6c200cab03704834073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b90425e7b02f6c200cab03704834073">&#9670;&nbsp;</a></span>setFirstEvent() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::EventWriterV4::setFirstEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an event which will be written to the file/buffer as well as to all split files. </p>
<p>It's called the "first event" as it will be the first event written to each split file (after the dictionary) if this method is called early enough or the first event was defined in the constructor.</p>
<p>Since this method is always called after the constructor, the common block will have already been written with a dictionary and firstEvent if either was defined in the constructor. The event given here will be written immediately somewhere in the body of the file, with the forth-coming split files having that event in the first block along with any dictionary.</p>
<p>This means that if the firstEvent is given in the constructor, then the caller may end up with 2 copies of it in a single file (if this method is called once). It's also possible to get 2 copies in a file if this method is called immediately prior to the file splitting.</p>
<p>By its nature this method is not useful for writing to a buffer since it is never split and the event can be written to it as any other.</p>
<p>Data is transferred byte for byte, so data better be in an endian compatible with the output of this writer.</p>
<p>The method <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#aa45ed6d74ee62f9c3e489ac8ea06c7c7">writeEvent</a> calls writeCommonBlock() which, in turn, only gets called when synchronized. So synchronizing this method will make sure firstEvent only gets set while nothing is being written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>buffer containing event to be placed first in each file written including all splits. If null, no more first events are written to any files. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if error writing file </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if event is opposite byte order of internal buffer; if event is bad format; if <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a497299886fb4462fa1d4c849acc9f710" title="This method flushes any remaining data to file and disables this object.">close()</a> already called; if file could not be opened for writing; if file exists but user requested no over-writing; if no room when writing to user-given buffer; </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#aa45ed6d74ee62f9c3e489ac8ea06c7c7">writeEvent()</a>.</p>

</div>
</div>
<a id="a2ff8ab0434a0d9ff0e651fad97a97e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff8ab0434a0d9ff0e651fad97a97e4d">&#9670;&nbsp;</a></span>setFirstEvent() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::EventWriterV4::setFirstEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt;&#160;</td>
          <td class="paramname"><em>bank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an event which will be written to the file/buffer as well as to all split files. </p>
<p>It's called the "first event" as it will be the first event written to each split file (after the dictionary) if this method is called early enough or the first event was defined in the constructor.</p>
<p>Since this method is always called after the constructor, the common block will have already been written with a dictionary and firstEvent if either was defined in the constructor. The event given here will be written immediately somewhere in the body of the file, with the forth-coming split files having that event in the first block along with any dictionary.</p>
<p>This means that if the firstEvent is given in the constructor, then the caller may end up with 2 copies of it in a single file (if this method is called once). It's also possible to get 2 copies in a file if this method is called immediately prior to the file splitting.</p>
<p>By its nature this method is not useful for writing to a buffer since it is never split and the event can be written to it as any other.</p>
<p>Do not call this while simultaneously calling close, flush, writeEvent, or getByteBuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>event to be placed first in each file written including all splits. If null, no more first events are written to any files. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if error writing file </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if event is opposite byte order of internal buffer; if event is bad format; if <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a497299886fb4462fa1d4c849acc9f710" title="This method flushes any remaining data to file and disables this object.">close()</a> already called; if file could not be opened for writing; if file exists but user requested no over-writing; if no room when writing to user-given buffer; </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#aa45ed6d74ee62f9c3e489ac8ea06c7c7">writeEvent()</a>.</p>

</div>
</div>
<a id="a0168f51f1b2fb153a255a0fff7b24417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0168f51f1b2fb153a255a0fff7b24417">&#9670;&nbsp;</a></span>setFirstEvent() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::EventWriterV4::setFirstEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an event which will be written to the file/buffer as well as to all split files. </p>
<p>It's called the "first event" as it will be the first event written to each split file (after the dictionary) if this method is called early enough or the first event was defined in the constructor.</p>
<p>Since this method is always called after the constructor, the common block will have already been written with a dictionary and firstEvent if either was defined in the constructor. The event given here will be written immediately somewhere in the body of the file, with the forth-coming split files having that event in the first block along with any dictionary.</p>
<p>This means that if the firstEvent is given in the constructor, then the caller may end up with 2 copies of it in a single file (if this method is called once). It's also possible to get 2 copies in a file if this method is called immediately prior to the file splitting.</p>
<p>By its nature this method is not useful for writing to a buffer since it is never split and the event can be written to it as any other.</p>
<p>Data is transferred byte for byte, so data better be in an endian compatible with the output of this writer.</p>
<p>Do not call this while simultaneously calling close, flush, writeEvent, or getByteBuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>node representing event to be placed first in each file written including all splits. If null, no more first events are written to any files. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if error writing file </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if event is opposite byte order of internal buffer; if event is bad format; if <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a497299886fb4462fa1d4c849acc9f710" title="This method flushes any remaining data to file and disables this object.">close()</a> already called; if file could not be opened for writing; if file exists but user requested no over-writing; if no room when writing to user-given buffer; </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#aa45ed6d74ee62f9c3e489ac8ea06c7c7">writeEvent()</a>.</p>

</div>
</div>
<a id="af1e67ab48bd30fb2c7715728eac29257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e67ab48bd30fb2c7715728eac29257">&#9670;&nbsp;</a></span>setStartingBlockNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evio::EventWriterV4::setStartingBlockNumber </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startingBlockNumber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number with which to start block numbers. </p>
<p>This method does nothing if events have already been written. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingBlockNumber</td><td>the number with which to start block numbers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d8848111b6ae3982b5d817072701b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8848111b6ae3982b5d817072701b77">&#9670;&nbsp;</a></span>writeEvent() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::EventWriterV4::writeEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bankBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an event (bank) to the buffer in evio version 4 format. </p>
<p>The given event buffer must contain only the event's data (event header and event data) and must <b>not</b> be in complete evio file format. If the internal buffer is full, it will be flushed to the file if writing to a file. Otherwise an exception will be thrown. Do not call this while simultaneously calling close, flush, setFirstEvent, or getByteBuffer.</p>
<p>Be warned that injudicious use of the 2nd arg, the force flag, will <b>kill</b> performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bankBuffer</td><td>the bank (as a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> object) to write. </td></tr>
    <tr><td class="paramname">force</td><td>if writing to disk, force it to write event to the disk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if writing to buffer: true if event was added to record, false if buffer full, or bank and bankBuffer args are both null. If there is an InterruptedException.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if error writing file </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if event is opposite byte order of internal buffer; if <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a497299886fb4462fa1d4c849acc9f710" title="This method flushes any remaining data to file and disables this object.">close()</a> already called; if bad eventBuffer format; if file could not be opened for writing; if file exists but user requested no over-writing; </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#aa45ed6d74ee62f9c3e489ac8ea06c7c7">writeEvent()</a>.</p>

</div>
</div>
<a id="a7c923dc7e40047a7d5734126c7a41867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c923dc7e40047a7d5734126c7a41867">&#9670;&nbsp;</a></span>writeEvent() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::EventWriterV4::writeEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt;&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an event (bank) to a buffer containing evio version 4 format blocks. </p>
<p>Each block has an integral number of events. There are limits to the number of events in each block and the total size of each block. If writing to a file, each full buffer is written - one at a time - and may contain multiple blocks. Dictionary is never written with this method. Do not call this while simultaneously calling close, flush, setFirstEvent, or getByteBuffer.</p>
<p>Be warned that injudicious use of the 2nd arg, the force flag, will <b>kill</b> performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>the bank to write. </td></tr>
    <tr><td class="paramname">force</td><td>if writing to disk, force it to write event to the disk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if writing to buffer: true if event was added to record, false if buffer full, or bank and bankBuffer args are both null. If there is an InterruptedException.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if error writing file </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a497299886fb4462fa1d4c849acc9f710" title="This method flushes any remaining data to file and disables this object.">close()</a> already called; if file could not be opened for writing; if file exists but user requested no over-writing; </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#aa45ed6d74ee62f9c3e489ac8ea06c7c7">writeEvent()</a>.</p>

</div>
</div>
<a id="aa45ed6d74ee62f9c3e489ac8ea06c7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45ed6d74ee62f9c3e489ac8ea06c7c7">&#9670;&nbsp;</a></span>writeEvent() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::EventWriterV4::writeEvent </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>duplicate</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an event (bank) to the buffer in evio version 4 format. </p>
<p>If the internal buffer is full, it will be flushed to the file if writing to a file. Otherwise an exception will be thrown. Do not call this while simultaneously calling close, flush, setFirstEvent, or getByteBuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>object representing the event to write in buffer form </td></tr>
    <tr><td class="paramname">force</td><td>if writing to disk, force it to write event to the disk. </td></tr>
    <tr><td class="paramname">duplicate</td><td>if true, duplicate node's buffer so its position and limit can be changed without issue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if writing to buffer: true if event was added to record, false if buffer full, or bank and bankBuffer args are both null. If there is an InterruptedException.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if error writing file </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if event is opposite byte order of internal buffer; if <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a497299886fb4462fa1d4c849acc9f710" title="This method flushes any remaining data to file and disables this object.">close()</a> already called; if bad eventBuffer format; if file could not be opened for writing; if file exists but user requested no over-writing; </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a0168f51f1b2fb153a255a0fff7b24417">setFirstEvent()</a>, and <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a4d8848111b6ae3982b5d817072701b77">writeEvent()</a>.</p>

</div>
</div>
<a id="a91a60f2e6b593beb1b924d441daf1b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a60f2e6b593beb1b924d441daf1b7d">&#9670;&nbsp;</a></span>writeEventToFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::EventWriterV4::writeEventToFile </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html">EvioBank</a> &gt;&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html">ByteBuffer</a> &gt;&#160;</td>
          <td class="paramname"><em>bankBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an event (bank) into a block and eventually to a file in evio version 4 format. </p>
<p>This method will <b>not</b> work with this object setup to write into a buffer.</p>
<p><b> If splitting files, this method returns false if disk partition is too full to write the complete, next split file. If force arg is true, write anyway. DO NOT mix calling this method with calling <a class="el" href="../../">writeEvent(std::shared_ptr&lt;EvioBank&gt;, std::shared_ptr&lt;ByteBuffer&gt;, bool)</a> (or the methods which call it). Results are unpredictable as it messes up the logic used to quit writing to full disk. </b> </p>
<p>The event to be written may be in one of two forms. The first is as an <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html" title="This holds a CODA Bank structure.">EvioBank</a> object and the second is as a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> containing only the event's data (event header and event data) and must <b>not</b> be in complete evio file format. The first non-null of the bank arguments will be written. Do not call this while simultaneously calling close, flush, setFirstEvent, or getByteBuffer.</p>
<p>Be warned that injudicious use of a true 2nd arg, the force flag, will <b>kill</b> performance.</p>
<p>This method is not used to write the dictionary or the first event (common block). That is only done with the method <a class="el" href="../../">writeCommonBlock</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>the bank (as an <a class="el" href="../../de/de3/classevio_1_1_evio_bank.html" title="This holds a CODA Bank structure.">EvioBank</a> object) to write. </td></tr>
    <tr><td class="paramname">bankBuffer</td><td>the bank (as a <a class="el" href="../../dc/d30/classevio_1_1_byte_buffer.html" title="This class is copied from one of the same name in the Java programming language.">ByteBuffer</a> object) to write. </td></tr>
    <tr><td class="paramname">force</td><td>if writing to disk, force it to write event to the disk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if event was added to block. If splitting files, false if disk partition too full to write the complete, next split file. False if interrupted. If force arg is true, write anyway.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if event is opposite byte order of internal buffer; if bad bankBuffer format; if <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a497299886fb4462fa1d4c849acc9f710" title="This method flushes any remaining data to file and disables this object.">close()</a> already called; if not writing to file; if file could not be opened for writing; if file exists but user requested no over-writing; if error writing file; </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../da/d7d/classevio_1_1_byte_order.html#a23e150c194163000f504efa9b1e53d82">evio::ByteOrder::getName()</a>, and <a class="el" href="../../d3/d87/classevio_1_1_util.html#af57b4b0d9df83781ab62ae2b2f565ea7">evio::Util::printBytes()</a>.</p>

</div>
</div>
<a id="aad8cfc0ced1c087fca4cd132be0b6d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8cfc0ced1c087fca4cd132be0b6d17">&#9670;&nbsp;</a></span>writeEventToFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evio::EventWriterV4::writeEventToFile </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="../../de/dd0/classevio_1_1_evio_node.html">EvioNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>duplicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an event (bank) into a record and eventually to a file in evio version 4 format. </p>
<p>If the internal buffer is full, it will be flushed to the file. Otherwise an exception will be thrown.</p>
<p><b> If splitting files, this method returns false if disk partition is too full to write the complete, next split file. If force arg is true, write anyway. DO NOT mix calling this method with calling <a class="el" href="../../">writeEvent(std::shared_ptr&lt;EvioNode&gt;, bool, bool)</a> (or the methods which call it). Results are unpredictable as it messes up the logic used to quit writing to full disk. </b></p>
<p>The buffer must contain only the event's data (event header and event data) and must <b>not</b> be in complete evio file format. Do not call this while simultaneously calling close, flush, setFirstEvent, or getByteBuffer.</p>
<p>Be warned that injudicious use of a true 2nd arg, the force flag, will <b>kill</b> performance when writing to a file. A true 3rd arg can be used when the backing buffer of the node is accessed by multiple threads simultaneously. This allows that buffer's limit and position to be changed without interfering with the other threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>object representing the event to write in buffer form </td></tr>
    <tr><td class="paramname">force</td><td>if writing to disk, force it to write event to the disk. </td></tr>
    <tr><td class="paramname">duplicate</td><td>if true, duplicate node's buffer so its position and limit can be changed without issue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if event was added to record. If splitting files, false if disk partition too full to write the complete, next split file. False if interrupted. If force arg is true, write anyway.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if error writing file </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d0/d0b/classevio_1_1_evio_exception.html" title="Exception class for Evio software package.">EvioException</a></td><td>if event is opposite byte order of internal buffer; if <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a497299886fb4462fa1d4c849acc9f710" title="This method flushes any remaining data to file and disables this object.">close()</a> already called; if bad eventBuffer format; if file could not be opened for writing; if file exists but user requested no over-writing; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a62cee800a3d132f0c11e23393c236f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62cee800a3d132f0c11e23393c236f7f">&#9670;&nbsp;</a></span>DEFAULT_BLOCK_COUNT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int evio::EventWriterV4::DEFAULT_BLOCK_COUNT = 10000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default maximum event count for a single block used for writing. </p>

</div>
</div>
<a id="a17b6bc167b1261c0c06f0cc655715c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b6bc167b1261c0c06f0cc655715c95">&#9670;&nbsp;</a></span>DEFAULT_BLOCK_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int evio::EventWriterV4::DEFAULT_BLOCK_SIZE = 16777216</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default maximum size, in bytes, for a single block used for writing. </p>
<p>It's set to 16MB (2^24) since that's an efficient number for writing to modern disks. And it is consistent with the java version of this class. It is a soft limit since a single event larger than this limit may need to be written. </p>

</div>
</div>
<a id="aa0d2dea869028c67fe2fd14a5919579c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d2dea869028c67fe2fd14a5919579c">&#9670;&nbsp;</a></span>DEFAULT_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t evio::EventWriterV4::DEFAULT_BUFFER_SIZE = <a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html#a17b6bc167b1261c0c06f0cc655715c95">DEFAULT_BLOCK_SIZE</a> + 1024</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default byte size of internal buffer. </p>
<p>It's enforced to be, at a minimum, DEFAULT_BLOCK_SIZE + a little. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="../../d5/d76/_event_writer_v4_8h_source.html">EventWriterV4.h</a></li>
<li><a class="el" href="../../db/d68/_event_writer_v4_8cpp.html">EventWriterV4.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d9/deb/namespaceevio.html">evio</a></li><li class="navelem"><a class="el" href="../../df/d0c/classevio_1_1_event_writer_v4.html">EventWriterV4</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
